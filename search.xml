<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>实测Android音频的焦点获取和归还</title>
    <url>/2022/02/09/adnroid-audio-focus-change/</url>
    <content><![CDATA[<h1 id="实测Android音频的焦点获取和归还"><a href="#实测Android音频的焦点获取和归还" class="headerlink" title="实测Android音频的焦点获取和归还"></a>实测Android音频的焦点获取和归还</h1><p><img src="https://img-blog.csdnimg.cn/fe17c3d52ca54b74a3a323df14087e3a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Z2Z6buY5Yqg6L29,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近老板想在产品中的短视频后者直播播放的时候对于手机中的音乐播放器进行暂停播放，并且退出视频播放后手机的音乐播放器还能继续播放之前的音乐。</p>
<p>先试试微信，emmm，确实可以。</p>
<p><a href="https://developer.android.com/guide/topics/media-apps/audio-focus?hl=zh-cn" target="_blank" rel="noopener">Android官网：管理音频焦点</a></p>
<h2 id="官网管理音频焦点准则："><a href="#官网管理音频焦点准则：" class="headerlink" title="官网管理音频焦点准则："></a>官网管理音频焦点准则：</h2><ul>
<li>在即将开始播放之前调用 <code>requestAudioFocus()</code>，并验证调用是否返回 <code>AUDIOFOCUS_REQUEST_GRANTED</code>。如果按照本指南中的说明设计应用，则应在媒体会话的 <code>onPlay()</code> 回调中调用 <code>requestAudioFocus()</code>。</li>
<li>在其他应用获得音频焦点时，停止或暂停播放，或降低音量。</li>
<li>播放停止后，放弃音频焦点。</li>
</ul>
<h2 id="不同版本音频焦点的处理方式不太相同："><a href="#不同版本音频焦点的处理方式不太相同：" class="headerlink" title="不同版本音频焦点的处理方式不太相同："></a>不同版本音频焦点的处理方式不太相同：</h2><ul>
<li>从 Android 2.2（API 级别 8）开始，应用通过调用 <code>requestAudioFocus()</code> 和 <code>abandonAudioFocus()</code> 来管理音频焦点。应用还必须为这两个调用注册 <code>AudioManager.OnAudioFocusChangeListener</code>，以便接收回调并管理自己的音量。</li>
<li><p>对于以 Android 5.0（API 级别 21）及更高版本为目标平台的应用，音频应用应使用 <code>AudioAttributes</code> 来描述应用正在播放的音频类型。例如，播放语音的应用应指定 <code>CONTENT_TYPE_SPEECH</code>。</p>
</li>
<li><p>面向 Android 8.0（API 级别 26）或更高版本的应用应使用 <code>requestAudioFocus()</code> 方法，该方法会接受 <code>AudioFocusRequest</code> 参数。<code>AudioFocusRequest</code> 包含有关应用的音频上下文和功能的信息。系统使用这些信息来自动管理音频焦点的得到和失去。</p>
</li>
</ul>
<h2 id="API介绍"><a href="#API介绍" class="headerlink" title="API介绍"></a>API介绍</h2><p>处理音频焦点都是通过AudioManager这个类，如下是获得该类实例的方法：<br> <code>AudioManager am = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);</code></p>
<blockquote>
<p><code>requestAudioFocus()</code>//用于申请音频焦点<br><code>abandonAudioFocus()</code> //用于释放音频焦点<br><code>AudioManager.OnAudioFocusChangeListener</code> 接口，提供了 <code>onAudioFocusChange()</code> 方法来监听音频焦点变化</p>
</blockquote>
<ul>
<li><p><code>requestAudioFocus(OnAudioFocusChangeListener l, int streamType, int durationHint)</code>参数：</p>
<ul>
<li><p><code>AudioManager.OnAudioFocusChangeListener l</code>：<br> 用于监听音频焦点变化，从而可以进行适当的操作，例如暂停播放等。</p>
</li>
<li><p><code>streamType</code> ：<br> 申请音频焦点处理的音频类型，例如，当播放音乐时，可以传入 <code>STREAM_MUSIC</code> ；当播放铃声时，可以传入 <code>STREAM_RING</code> 。表中列出了一些的可选值：</p>
<p> | 类型                | 含义     | 值   |<br> | ——————- | ——– | —- |<br> | STREAM_VOICE_CALL   | 通话     | 0    |<br> | STREAM_SYSTEM       | 系统     | 1    |<br> | STREAM_RING         | 铃声     | 2    |<br> | STREAM_MUSIC        | 音乐     | 3    |<br> | STREAM_ALARM        | 闹铃     | 4    |<br> | STREAM_NOTIFICATION | 系统通知 | 5    |<br> | …                 | …      | …  |</p>
</li>
<li><p><code>durationHint</code> (PS:重要参数)：<br> 可选值有以下五个：<br> (1)  <code>AUDIOFOCUS_GAIN</code>： 此参数表示希望申请一个永久的音频焦点，并且希望上一个持有音频焦点的App停止播放；例如在需要播放音乐时。<br> (2) <code>AUDIOFOCUS_GAIN_TRANSIENT</code>：表示申请一个短暂的音频焦点，并且马上就会被释放，此时希望上一个持有音频焦点的App暂停播放。例如播放一个提醒声音。<br> (3) <code>AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK</code>：效果同 <code>AUDIOFOCUS_GAIN_TRANSIENT</code> ，只是希望上一个持有焦点的App减小其播放声音(但仍可以播放)，此时会混音播放。例如导航播报。<br> (4) <code>AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE</code>： 表示申请一个短暂的音频焦点，并且会希望系统不要播放任何突然的声音（例如通知，提醒等），例如用户在录音。</p>
</li>
<li><p>返回值：<br> <code>AUDIOFOCUS_REQUEST_GRANTED</code> 或者 <code>AUDIOFOCUS_REQUEST_FAILED</code> 。</p>
</li>
</ul>
</li>
<li><p><code>abandonAudioFocus(OnAudioFocusChangeListener l)</code> 参数通上 <code>AudioManager.OnAudioFocusChangeListener</code> .</p>
</li>
<li><p><code>AudioManager.OnAudioFocusChangeListener</code> :当音频焦点发生变化时进行 <code>onAudioFocusChange(int focusChange)</code> 方法的回调；</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> AudioManager.OnAudioFocusChangeListener() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAudioFocusChange</span><span class="params">(<span class="keyword">int</span> focusChange)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (focusChange) &#123;</span><br><span class="line">      <span class="keyword">case</span> AudioManager.AUDIOFOCUS_GAIN:</span><br><span class="line">        <span class="comment">// TBD 继续播放</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> AudioManager.AUDIOFOCUS_LOSS:</span><br><span class="line">        <span class="comment">// TBD 停止播放</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> AudioManager.AUDIOFOCUS_LOSS_TRANSIENT:</span><br><span class="line">        <span class="comment">// TBD 暂停播放</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK:</span><br><span class="line">        <span class="comment">// TBD 混音播放 </span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="实测代码："><a href="#实测代码：" class="headerlink" title="实测代码："></a>实测代码：</h2><p>核心是需要把 <code>AudioManager.AUDIOFOCUS_GAIN</code> 改为 <code>AudioManager.AUDIOFOCUS_GAIN_TRANSIENT</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AudioManager mAudioManager;</span><br><span class="line">    <span class="keyword">private</span> AudioFocusRequest mFocusRequest;</span><br><span class="line">    <span class="keyword">private</span> AudioManager.OnAudioFocusChangeListener mListener;</span><br><span class="line">    <span class="keyword">private</span> AudioAttributes mAttribute;</span><br><span class="line">    <span class="meta">@SuppressLint</span>(<span class="string">"HandlerLeak"</span>)</span><br><span class="line">    <span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(@NonNull Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        mAudioManager = (AudioManager) getSystemService(Context.AUDIO_SERVICE);</span><br><span class="line">        mListener = <span class="keyword">new</span> AudioManager.OnAudioFocusChangeListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAudioFocusChange</span><span class="params">(<span class="keyword">int</span> focusChange)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">switch</span> (focusChange) &#123;</span><br><span class="line">                    <span class="keyword">case</span> AudioManager.AUDIOFOCUS_GAIN:</span><br><span class="line">                       <span class="comment">// TBD 继续播放</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> AudioManager.AUDIOFOCUS_LOSS:</span><br><span class="line">                       <span class="comment">// TBD 停止播放</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> AudioManager.AUDIOFOCUS_LOSS_TRANSIENT:</span><br><span class="line">                        <span class="comment">// TBD 暂停播放</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK:</span><br><span class="line">                        <span class="comment">// TBD 混音播放 </span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//android 版本 5.0</span></span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">            mAttribute = <span class="keyword">new</span> AudioAttributes.Builder()</span><br><span class="line">                    .setUsage(AudioAttributes.USAGE_MEDIA)</span><br><span class="line">                    .setContentType(AudioAttributes.CONTENT_TYPE_MUSIC)</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//android 版本 8.0</span></span><br><span class="line">        <span class="keyword">if</span> (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.O) &#123;</span><br><span class="line">            mFocusRequest = <span class="keyword">new</span> AudioFocusRequest.Builder(AudioManager.AUDIOFOCUS_GAIN_TRANSIENT)</span><br><span class="line">                    .setWillPauseWhenDucked(<span class="keyword">true</span>)</span><br><span class="line">                    .setAcceptsDelayedFocusGain(<span class="keyword">true</span>)</span><br><span class="line">                    .setOnAudioFocusChangeListener(mListener, mHandler)</span><br><span class="line">                    .setAudioAttributes(mAttribute)</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">requestAudioFocus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">					mAudioManager.requestAudioFocus(mFocusRequest);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          mAudioManager.requestAudioFocus(mListener, AudioManager.STREAM_MUSIC, AudioManager.AUDIOFOCUS_GAIN_TRANSIENT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">abandonAudioFocus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">            mAudioManager.abandonAudioFocusRequest(mFocusRequest);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          mAudioManager.abandonAudioFocus(mListener);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://segmentfault.com/a/1190000022234509" target="_blank" rel="noopener">https://segmentfault.com/a/1190000022234509</a></p>
<p><a href="https://www.jianshu.com/p/26ea60c499a7" target="_blank" rel="noopener">https://www.jianshu.com/p/26ea60c499a7</a></p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Audio</tag>
      </tags>
  </entry>
  <entry>
    <title>从硬件角度去理解协程</title>
    <url>/2022/02/07/kotlin_coroutines_understand/</url>
    <content><![CDATA[<p><img src="https://img-blog.csdnimg.cn/1d234942dce746f6a8127e49c6bddb66.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Z2Z6buY5Yqg6L29,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="son"></p>
<p>2022年，虎年虎虎生威~！</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Android</code> 开发者来说 <code>Kotlin</code> 语言已经是很熟悉的了，但 <code>Kotlin</code> 中的 <code>协程</code> 不了解的同学可能还有很多。</p>
<p>阅读网络上大多数文章得到的关于 <code>协程</code> 几个关键词：</p>
<ul>
<li>像是线程；</li>
<li>不是线程；</li>
<li>用户态；</li>
<li>协作式；</li>
</ul>
<p>感觉很懵逼，我就问一个 <code>协程</code> 而已为什么出现这么多奇奇怪该的名词。</p>
<h2 id="协程简介"><a href="#协程简介" class="headerlink" title="协程简介"></a>协程简介</h2><p><a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E7%A8%8B" target="_blank" rel="noopener">维基百科：协程</a></p>
<p><code>协程（英語：coroutine）</code>是计算机程序的一类组件，推广了协作式多任务的子例程，允许执行被挂起与被恢复。 相对子例程而言，协程更为一般和灵活，但在实践中使用没有子例程那样广泛。 协程更适合于用来实现彼此熟悉的程序组件，如协作式多任务、异常处理、事件循环、迭代器、无限列表和管道。</p>
<h2 id="电脑物理硬件"><a href="#电脑物理硬件" class="headerlink" title="电脑物理硬件"></a>电脑物理硬件</h2><p>说 <code>协程</code> 之前我们先聊一下计算机硬件相关的知识。</p>
<h3 id="物理-cpu-数"><a href="#物理-cpu-数" class="headerlink" title="物理 cpu 数"></a>物理 cpu 数</h3><p>指主板上实际插入的 <code>cpu</code> 硬件个数（<code>socket</code>）。（但是这一概念经常被泛泛的说成是 <code>cpu</code> 数，这很容易导致与 <code>core</code> 数，<code>processor</code> 数等概念混淆，所以此处强调是物理 <code>cpu</code> 数）。</p>
<p>由于在主板上引入多个 <code>cpu</code> 插槽需要更复杂的硬件支持（连接不同插槽的 <code>cpu</code> 到内存和其他资源），通常只会在服务器上才这样做。在家用电脑中，一般主板上只会有一个 <code>cpu</code> 插槽。</p>
<h3 id="核数"><a href="#核数" class="headerlink" title="核数"></a>核数</h3><p>一开始，每个物理 <code>cpu</code> 上只有一个核心 <code>a single core</code> ，对操作系统而言，也就是同一时刻只能运行一个进程/线程。 为了提高性能，<code>cpu</code> 厂商开始在单个物理 <code>cpu</code> 上增加核心（实实在在的硬件存在），也就出现了双核心 <code>cpu</code>（<code>dual-core cpu</code>）以及多核心 <code>cpu</code>（<code>multiple cores</code>），这样一个双核心 <code>cpu</code> 就是同一时刻能够运行两个进程/线程的。</p>
<h3 id="超线程技术"><a href="#超线程技术" class="headerlink" title="超线程技术"></a>超线程技术</h3><blockquote>
<p>同时多线程技术（simultaneous multithreading）</p>
</blockquote>
<blockquote>
<p>超线程技术（hyper–threading/HT）</p>
</blockquote>
<p>本质一样，是为了提高单个 <code>core</code> 同一时刻能够执行的多线程数的技术（充分利用单个 <code>core</code> 的计算能力，尽量让其“一刻也不得闲”）。</p>
<p><code>simultaneous multithreading</code> 缩写是 <code>SMT</code>，<code>AMD</code> 和其他 <code>cpu</code> 厂商的称呼。 <code>hyper–threading</code> 是 <code>Intel</code> 的称呼，可以认为 <code>hyper–threading</code> 是 <code>SMT</code> 的一种具体技术实现。</p>
<p><img src="https://img-blog.csdnimg.cn/8071c3c733d5448f9084520e029ed5d3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Z2Z6buY5Yqg6L29,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="AMD-R7"></p>
<p><img src="https://img-blog.csdnimg.cn/c862f543fac74f67b8fb7a4bb0522204.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Z2Z6buY5Yqg6L29,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="Intel-i7"></p>
<p>所以可以这样说：某款采用 <code>SMT</code> 技术的 <code>4核心</code>  <code>AMD cpu</code> 提供了 <code>8线程</code> 同时执行的能力；某款采用 <code>HT</code> 技术的 <code>2 核心</code> <code>Intel cpu</code> 提供了 <code>4 线程</code> 同时执行的能力。</p>
<blockquote>
<p>总的逻辑 <code>cpu</code> 数 = 物理 <code>cpu</code> 数 <em> 每颗物理 <code>cpu</code> 的核心数 </em> 每个核心的超线程数</p>
</blockquote>
<h2 id="线程和协程"><a href="#线程和协程" class="headerlink" title="线程和协程"></a>线程和协程</h2><p>讲 <code>协程</code> 的时候绝对不能不提 <code>线程</code> 。</p>
<p><code>线程</code> 是操作系统能够进行运算的最小单位。</p>
<p>在之前一般情况下 <code>CPU</code> 的每个核心同一时间只能执行一个线程，除了现在比较新的 <code>CPU</code> 拥有上面说的使用 <code>SMT</code> 或者 <code>HT</code> 技术。</p>
<p>但 <code>CPU</code> 的核心数和 <code>线程</code> 的个数没有必然关系。举个很简单的例子，我一段代码可以一直创建<strong>100个线程</strong>。</p>
<p><code>CPU</code> 根本不理解自己执行的指令属于哪个 <code>线程</code>，<code>CPU</code> 也不需要理解这些，它只需只需当前操作系统给它分配的指令就行。</p>
<p>在单核 <code>CPU</code> 时代所有的多线程其实都是多任务，多个任务交替使用 <code>CPU资源</code> 。</p>
<p>有了多核之后，运行在两个线程的任务才实现正真的并行，但电脑的实际核数永远也达不到我们运算需要的任务数量。所以多个任务交替使用 <code>CPU资源</code> 这种情况一直存在，但我们知道 <code>CPP</code> 切换执行线程的上下文都是需要消耗资源的，任务数量越多不一定执行效率更高。对于计算密集型的程序有的建议是设置线程的最佳数量为 <code>CPU</code> 可执行线程数的 <code>1.5倍</code> 或者 <code>1倍+1</code> 。</p>
<p>在这个时候我们想到能不能在异步任务之间切换的时候不切换 <code>CPU</code> 的上下文状态，这样可以减少很多资源的浪费。或者在 <code>CPU</code> 长时间执行 <code>I/O操作</code> 的时候让其他例程先执行，提供资源的利用率。</p>
<p><code>协程</code> 就在这个时候产生了，协作式执行多任务的子例程。</p>
<p>这时候我们已经对 <code>协程</code> 有了初步的了解了，回头想想文章开头4个描述 <code>协程</code> 的说明。</p>
<ul>
<li>像是线程：在部分程序执行的过程中，协程的并发执行就是利用的多线程技术（例如：没有进行改版的 <code>Java程序</code> ）。所以说它像是线程；</li>
<li>不是线程：并发任务的调度不是都通过操作系统级别线程切换执行，而是程序本身支持单个线程的多个并发任务。所以也可以说它不是线程，可以叫它们纤程 <code>Fiber</code> ，或者绿色线程 <code>GreenThread</code> 。正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。</li>
<li>用户态：不是系统级别的线程而且能自主执行异步任务，这种由程序员自己写程序来管理的轻量级线程叫做<strong>用户空间线程</strong>，具有对内核来说不可见的特性。</li>
<li>协作式：要求每个运行中的程序，定位放弃自己的执行权利，让多个任务一起交替执行。<a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E4%BD%9C%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1" target="_blank" rel="noopener">维基百科：协作式多任务</a>；</li>
</ul>
<h2 id="Android中的协程"><a href="#Android中的协程" class="headerlink" title="Android中的协程"></a>Android中的协程</h2><p>上面说的 <code>协程</code> 减少上下文切换，提供效率，那么 <code>Android</code> 的 <code>kotlin</code> 支持协程么?</p>
<p><code>kotlin</code> 官方文档说：本质上，协程是轻量级的线程。</p>
<p>但就目前 <code>Kotlin-JVM</code> 而言来说 <code>协程</code> 它就是线程。其本质上还是一套基于原生 <code>Java Thread API</code> 的封装。</p>
<p>可能后续 <code>Kotlin</code>  的版本会有正真的协程相关的机制来代替线程。</p>
<p>这个时候可能我们可能就有一些疑问，既然 <code>协程</code> 在 <code>Android</code> 平台上依旧是 <code>线程</code> 并没有提示运行效率，<code>Java</code> 中的  <code>Executor</code>  和  <code>Android</code> 中的 <code>AsyncTask</code> 都能提供并发任务，那么 <code>kotlin</code> 的 <code>协程</code> 它有什么用？后面会有一篇文章单独讲解~！</p>
<p>参考资料：</p>
<p><a href="https://www.cnblogs.com/Survivalist/p/11527949.html" target="_blank" rel="noopener">一文读懂什么是进程、线程、协程</a></p>
<p><a href="https://segmentfault.com/a/1190000021548651###" target="_blank" rel="noopener">Kotlin 协程真的比 Java 线程更高效吗?</a></p>
<p><a href="https://rengwuxian.com/kotlin-coroutines-1/" target="_blank" rel="noopener">扔物线：Kotlin的协程用例瞥一眼</a></p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title>【亲测】Shell日期时间和时间戳相互转化</title>
    <url>/2022/01/16/mac_shell_time_transform/</url>
    <content><![CDATA[<p><code>date -d</code> 在Mac上提示以下错误：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">date: option requires an argument -- d</span><br><span class="line">usage: date [-jnRu] [-d dst] [-r seconds] [-t west] [-v[+|-]val[ymwdHMS]] ...</span><br><span class="line">            [-f fmt date | [[[mm]dd]HH]MM[[cc]yy][.ss]] [+format]</span><br></pre></td></tr></table></figure></p>
<p>以下时间戳都是以秒为单位</p>
<ul>
<li><p>自定义日期时间转时间戳</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">/bin/sh</span></span><br><span class="line">help="?"</span><br><span class="line">if [ $# != 1 ] ; then</span><br><span class="line">  echo "参数为空，输入的时间格式为：2022-01-16 15:26:11"</span><br><span class="line">  exit 0</span><br><span class="line">elif [[ $1 = "?" ]]; then</span><br><span class="line">  echo "输入的时间格式为：2022-01-16 15:26:11"</span><br><span class="line">  exit 0</span><br><span class="line">fi</span><br><span class="line">echo "北京时间："$1</span><br><span class="line">echo "时间戳：" $(date -j -f "%Y-%m-%d %H:%M:%S" "$1" +%s)</span><br></pre></td></tr></table></figure>
</li>
<li><p>时间戳转日期</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">/bin/sh</span></span><br><span class="line">echo "北京时间："$(date -r $1)</span><br><span class="line">echo "时间戳："$1</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>时间戳</tag>
      </tags>
  </entry>
  <entry>
    <title>aapt与aapt2--资源id固定和PUBLIC标记</title>
    <url>/2021/07/14/res-aapt-ids-public/</url>
    <content><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20210714200911636.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0dmVuX2tpbmc=,size_16,color_FFFFFF,t_70#pic_center" alt="07-14"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>整片文章是围绕 <code>tinker</code> 的 <code>TinkerResourceIdTask</code> 里的知识点进行扩展的。</p>
<ol>
<li><code>aapt</code> 和 <code>aapt2</code> 的差异（运行环境和运行结果）；</li>
<li>资源 <code>id</code> 的固定；</li>
<li>进行 <code>PUBLIC</code> 的标记；</li>
</ol>
<p><code>aapt</code> 运行环境为 <code>gradle:2.2.0</code> 和 <code>gradle-wrapper:3.4.1</code></p>
<p><code>aapt2</code> 运行环境为 <code>gradle:3.3.2</code> 和 <code>gradle-wrapper:5.6.2</code></p>
<p><a href="https://github.com/stven0king/android-aapt-sample" target="_blank" rel="noopener">android-aapt-sample</a> 项目是我自己的实验样例。有 <code>aapt</code> 和 <code>aapt2</code> 两个分支，分别对应其实现。</p>
<h2 id="AAPT概述"><a href="#AAPT概述" class="headerlink" title="AAPT概述"></a>AAPT概述</h2><p>从 <code>Android Studio 3.0</code> 开始，<code>google</code> 默认开启了 <code>aapt2</code> 作为资源编译的编译器，<code>aapt2</code> 的出现，为资源的增量编译提供了支持。当然使用过程中也会遇到一些问题，我们可以通过在 <strong>gradle.properties</strong> 中配置 <strong>android.enableAapt2=false</strong> 来关闭 <code>aapt2</code>。</p>
<h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p><code>Android</code> 天生为兼容各种各样不同的设备做了相当多的工作，比如屏幕大小、国际化、键盘、像素密度等等，我们能为各种各样特定的场景下使用特定的资源做兼容而不用改动一行代码，假设我们为各种各样不同的场景适配了不同的资源，如何能快速的应用上这些资源呢？<code>Android</code> 为我们提供了 <code>R</code> 这个类，指定了一个资源的索引（<code>id</code>），然后我们只需要告诉系统在不同的业务场景下，使用对应的资源就好了，至于具体是指定资源里面的哪一个具体文件，由系统根据开发者的配置决定。</p>
<p>在这种场景下，假设我们给定的 <code>id</code> 是 <code>x</code> 值，那么当下业务需要使用这个资源的时候，手机的状态就是 <code>y</code> 值，有了(<code>x,y</code>)，在一个表里面就能迅速的定位到资源文件的具体路径了。这个表就是 <code>resources.arsc</code>，它是从 <code>aapt</code> 编译出来的。</p>
<p>其实二进制的资源（比如图片）是不需要编译的，只不过这个“编译”的行为，是为了生成 <code>resources.arsc</code> 以及对 <code>xml</code> 文件进行二进制化等操作，<code>resources.arsc</code> 是上面说的表，<code>xml</code> 的二进制化是为了系统读取上性能更好。<code>AssetManager</code> 在我们调用 <code>R</code> 相关的 <code>id</code> 的时候，就会在这个表里面找到对应的文件，读取出来。</p>
<p><code>Gradle</code> 在编译资源的过程中，就是调用的这些<a href="https://developer.android.com/studio/command-line/aapt2" target="_blank" rel="noopener">aapt2命令</a>，传的参数也在这个文档里都介绍了，只不过对开发者隐藏起了调用细节。</p>
<p><code>aapt2</code> 主要分两步，一步叫 <code>compile</code>，一步叫 <code>link</code>。</p>
<p>创建一个空工程：只写了两个<code>xml</code>，分别是 <code>AndroidManifest.xml</code> 和 <code>activity_main.xml</code>。</p>
<h3 id="Compile"><a href="#Compile" class="headerlink" title="Compile"></a>Compile</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir compiled</span><br><span class="line">aapt2 compile src/main/res/layout/activity_main.xml -o compiled/</span><br></pre></td></tr></table></figure>
<p>在 <code>compiled</code> 文件夹中，生成了<code>layout_activity_main.xml.flat</code> 这个文件，它是 <code>aapt2</code> 特有的，<code>aapt</code> 没有(<code>aapt</code>拷贝的是源文件)，<code>aapt2</code> 用它能进行增量编译。如果我们有很多的文件的话，需要依次调用 <code>compile</code> 才行，其实这里也可以使用 <code>–dir</code> 参数，只不过这个参数就没有增量编译的效果了。也就是说，当传递整个目录时，即使只有一个资源发生了变化，<code>AAPT2</code>也会重新编译目录中的所有文件。</p>
<h3 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h3><p><code>link</code> 的工作量比 <code>compile</code> 要多一点，此处的输入是多个<code>flat</code> 的文件 和 <code>AndroidManifest.xml</code>，外部资源，输出是只包含资源的 <code>apk</code> 和 <code>R.java</code>。命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">aapt2 link -o out.apk \</span><br><span class="line">-I $ANDROID_HOME/platforms/android-28/android.jar \</span><br><span class="line">compiled/layout_activity_main.xml.flat \</span><br><span class="line">--java src/main/java \</span><br><span class="line">--manifest src/main/AndroidManifest.xml</span><br></pre></td></tr></table></figure>
<ul>
<li>第二行 <code>-I</code> 是 <code>import</code> 外部资源，此处主要是 <code>android</code> 命名空间下定义的一些属性，我们平常使用的<code>@android:xxx</code>都是放在这个<code>jar</code> 里面，其实我们也可以提供自己的资源供别人链接;</li>
<li>第三行是输入的 <code>flat</code> 文件，如果有多个，直接在后面拼接即可;</li>
<li>第四行是 <code>R.java</code> 生成的目录;</li>
<li>第五行是指定 <code>AndroidManifest.xml</code>;</li>
</ul>
<p><code>Link</code>完成后会生成<code>out.apk</code>和<code>R.java</code>，<code>out.apk</code>中包含了一个<code>resources.arsc</code>文件。只带资源文件的可以用后缀名<code>.ap_</code>。</p>
<h3 id="查看编译后的资源"><a href="#查看编译后的资源" class="headerlink" title="查看编译后的资源"></a>查看编译后的资源</h3><p>除了是用 <code>Android Studio</code> 去查看 <code>resources.arsc</code>，还可以直接使用 <code>aapt2 dump apk</code> 信息的方式来查看资源相关的<code>ID</code> 和状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">aapt2 dump out.apk</span><br></pre></td></tr></table></figure>
<p>输出的结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Binary APK</span><br><span class="line">Package name=com.geminiwen.hello id=7f</span><br><span class="line">  type layout id=01 entryCount=1</span><br><span class="line">    resource 0x7f010000 layout/activity_main</span><br><span class="line">      () (file) res/layout/activity_main.xml type=XML</span><br></pre></td></tr></table></figure>
<p>可以看到<code>layout/activity_main</code> 对应的 <code>ID</code> 是 <code>0x7f010000</code>。</p>
<h3 id="资源共享"><a href="#资源共享" class="headerlink" title="资源共享"></a>资源共享</h3><p><code>android.jar</code> 只是一个编译用的桩，真正执行的时候，<code>Android OS</code> 提供了一个运行时的库(<code>framework.jar</code>)。<code>android.jar</code>很像一个 <code>apk</code>，只不过它存在的是 <code>class</code> 文件，然后存在一个 <code>AndroidManifest.xml</code> 和 <code>resources.arsc</code>。这就意味着我们也可以对它用<code>aapt2 dump</code>，执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">aapt2 dump $ANDROID_HOME/platforms/android-28/android.jar &gt; test.out</span><br></pre></td></tr></table></figure>
<p>得到很多类似如下的输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">resource 0x010a0000 anim/fade_in PUBLIC</span><br><span class="line">      () (file) res/anim/fade_in.xml type=XML</span><br><span class="line">    resource 0x010a0001 anim/fade_out PUBLIC</span><br><span class="line">      () (file) res/anim/fade_out.xml type=XML</span><br><span class="line">    resource 0x010a0002 anim/slide_in_left PUBLIC</span><br><span class="line">      () (file) res/anim/slide_in_left.xml type=XML</span><br><span class="line">    resource 0x010a0003 anim/slide_out_right PUBLIC</span><br><span class="line">      () (file) res/anim/slide_out_right.xml type=XML</span><br></pre></td></tr></table></figure>
<p>它多了一些<code>PUBLIC</code>的字段，一个 <code>apk</code> 文件里面的资源，如果被加上这个标记的话，就能被其他 <code>apk</code> 所引用，引用方式是<code>@包名:类型/名字</code>，例如：<code>@android:color/red</code>。</p>
<p>如果我们想要提供我们的资源，那么首先为我们的资源打上 <code>PUBLIC</code> 的标记，然后在 <code>xml</code> 中引用你的包名，比如：<a href="mailto:`@com.gemini.app" target="_blank" rel="noopener">`@com.gemini.app</a>:color/red<code>就能引用到你定义的</code>color/red` 了，如果你不指定包名，默认是自己。</p>
<p>至于<code>AAPT2</code> 如何生成 <code>PUBLIC</code>，感兴趣的可以接着阅读本文。</p>
<h2 id="ids-xml概述"><a href="#ids-xml概述" class="headerlink" title="ids.xml概述"></a>ids.xml概述</h2><p><code>ids.xml</code>：为应用的相关资源提供唯一的资源<code>id</code>。<code>id</code>是为了获得<code>xml</code>中的对象需要的参数，也就是 <code>Object = findViewById(R.id.id_name);</code> 中的<code>id_name</code>。</p>
<p>这些值可以在代码中用<code>android.R.id</code>引用到。<br>若在<code>ids.xml</code>中定义了<strong>ID</strong>，则在<code>layout</code>中可如下定义<code>@id/price_edit</code>，否则<code>@+id/price_edit</code>。</p>
<blockquote>
<p>优点</p>
</blockquote>
<ol>
<li>命名方便，我们可以把一些特定的控件先命好名，在使用的时候直接引用<code>id</code>即可，省去了一个命名环节。</li>
<li>优化编译效率:<ul>
<li>添加<code>id</code>后会在<code>R.java</code>中生成;</li>
<li>使用<code>ids.xml</code>统一管理,一次性编译即可多次使用.<br>但使用<code>&quot;@+id/btn_next&quot;</code>的形式,每次文件保存<code>(Ctrl+s</code>)<code>后R.java</code>都会重新检测,如果存在该<code>id</code>则不生成,如果不存在就需要添加该<code>id</code>。故编译效率降低。</li>
</ul>
</li>
</ol>
<p><code>ids.xml</code>文件内容：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"forecast_list"</span> <span class="attr">type</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;item name="app_name" type="string" /&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>也许有人很好奇上面有一行被注释的代码，打开注释会发现编译会报一下错误：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Execution failed <span class="keyword">for</span> task <span class="string">':app:mergeDebugResources'</span>.</span><br><span class="line">&gt; [string/app_name] /Users/tanzx/AndroidStudioProjects/AaptDemo/app/src/main/res/values/strings.xml	[string/app_name] /Users/tanzx/AndroidStudioProjects/AaptDemo/app/src/main/res/values/ids.xml: Error: Duplicate resources</span><br></pre></td></tr></table></figure>
<p>因为<code>app_name</code>对于的资源已经在<code>value</code>中被声明了。</p>
<h2 id="public-xml概述"><a href="#public-xml概述" class="headerlink" title="public.xml概述"></a>public.xml概述</h2><p>官方相关的说明<a href="https://developer.android.com/studio/projects/android-library#PrivateResources" target="_blank" rel="noopener">官网：选择要设为公开的资源</a>。</p>
<blockquote>
<p>原文翻译：库中的所有资源在默认情况下均处于公开状态。如需将所有资源隐式设为私有，您必须至少将一个特定属性定义为公开。资源包括您项目的 <code>res/</code> 目录中的所有文件，例如图像。为了防止库的用户访问仅供内部使用的资源，您应该通过声明一个或多个公开资源的方式来使用这种自动私有标识机制。或者，您也可以通过添加空的 <code>&lt;public /&gt;</code> 标记将所有资源设为私有，此标记不会将任何资源设为公开，而是会将一切（所有资源）都设为私有。</p>
<p>通过将属性隐式设为私有，您不仅可以防止库的用户从内部库资源获得代码补全建议，还可以重命名或移除私有资源，而不会破坏库的客户端。系统会从代码补全中过滤掉私有资源，并且 <a href="https://developer.android.com/studio/write/lint" target="_blank" rel="noopener">Lint</a> 会在您尝试引用私有资源时发出警告。</p>
<p>在构建库时，Android Gradle 插件会获取公开资源定义，并将其提取到 <code>public.txt</code> 文件中，然后系统会将此文件打包到 AAR 文件中。</p>
</blockquote>
<p>实测结果也仅仅是不回代码自动不全，编译器报红。如果进行<code>lint</code>检查，编译都没有警告~！</p>
<p>现在大部分的解释为：文件<strong>RES/value/public.xml</strong>用于将固定资源 <code>ID</code> 分配给 <code>Android</code> 资源。</p>
<p><a href="https://stackoverflow.com/questions/9348614/what-is-the-use-of-the-res-values-public-xml-file-on-android%E3%80%82" target="_blank" rel="noopener">stackoverfloew:What is the use of the res/values/public.xml file on Android?</a></p>
<p><code>public.xml</code>文件内容：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">public</span> <span class="attr">name</span>=<span class="string">"forecast_list"</span> <span class="attr">id</span>=<span class="string">"0x7f040001"</span> <span class="attr">type</span>=<span class="string">"id"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">public</span> <span class="attr">name</span>=<span class="string">"app_name"</span> <span class="attr">id</span>=<span class="string">"0x7f070002"</span> <span class="attr">type</span>=<span class="string">"string"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">public</span> <span class="attr">name</span>=<span class="string">"string3"</span> <span class="attr">id</span>=<span class="string">"0x7f070003"</span> <span class="attr">type</span>=<span class="string">"string"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="资源id固定"><a href="#资源id固定" class="headerlink" title="资源id固定"></a>资源id固定</h2><p>资源id的固定在热修复和插件化中极其重要。在热修复中，构建<code>patch</code>时，需要保持<code>patch</code>包的资源<code>id</code>和基准包的资源<code>id</code>一致；在插件化中，如果插件需要引用宿主的资源，则需要将宿主的资源<code>id</code>进行固定，因此，资源<code>id</code>的固定在这两种场景下是尤为重要的。</p>
<p>在<code>Android Gradle Plugin 3.0.0</code>中，默认开启了<code>aapt2</code>，原先aapt的资源固定方式<code>public.xml</code>也将失效，必须寻找一种新的资源固定的方式，而不是简单的禁用掉<code>aapt</code>2，因此本文来探讨一下<code>aapt和aapt2</code>分别如何进行资源<code>id</code>的固定。</p>
<h3 id="aapt进行id的固定"><a href="#aapt进行id的固定" class="headerlink" title="aapt进行id的固定"></a><code>aapt</code>进行<code>id</code>的固定</h3><blockquote>
<p>项目环境配置（PS：吐槽一下aapt已经被aapt2代替了，aapt相关资料几乎没有，环境搭建太费劲了~！）</p>
<p><code>com.android.tools.build:gradle:2.2.0</code></p>
<p><code>distributionUrl=https\://services.gradle.org/distributions/gradle-3.4.1-all.zip</code></p>
<p><code>compileSdkVersion 24</code></p>
<p><code>buildToolsVersion &#39;24.0.0&#39;</code></p>
</blockquote>
<p>先在<code>value</code>文件下按照上面的<code>ids.xml</code>和<code>public.xml</code>的内容以及文件名，生成对应的文件。</p>
<blockquote>
<p>直接编译结果</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/2021071420103961.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0dmVuX2tpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>通过直接编译之后的<code>R文件</code>的内容，可以看到我们想要的设置的资源<code>id</code>并没有按照我们预期的生成。</p>
<blockquote>
<p>将<code>public.xml</code>文件拷贝到<code>build/intermediates/res/merged</code>对应的目录</p>
</blockquote>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">afterEvaluate &#123;</span><br><span class="line">    <span class="keyword">for</span> (variant <span class="keyword">in</span> android.applicationVariants) &#123;</span><br><span class="line">        <span class="keyword">def</span> scope = variant.getVariantData().getScope()</span><br><span class="line">        String mergeTaskName = scope.getMergeResourcesTask().name</span><br><span class="line">        <span class="keyword">def</span> mergeTask = tasks.getByName(mergeTaskName)</span><br><span class="line">        mergeTask.doLast &#123;</span><br><span class="line">            copy &#123;</span><br><span class="line">                <span class="keyword">int</span> i=<span class="number">0</span></span><br><span class="line">                from(android.sourceSets.main.res.srcDirs) &#123;</span><br><span class="line">                    include <span class="string">'values/public.xml'</span></span><br><span class="line">                    rename <span class="string">'public.xml'</span>, (i++ == <span class="number">0</span>? "public.xml": <span class="string">"public_$&#123;i&#125;.xml"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                into(mergeTask.outputDir)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210714201050847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0dmVuX2tpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>这次我们可以直接看到资源<code>id</code>按照我们需要生成了。</p>
<blockquote>
<p>这是为什么呢？</p>
</blockquote>
<ol>
<li><p><code>android gradle</code>插件<code>1.3</code>以下版本可以直接将<code>public.xml</code>放在源码<code>res</code>目录参与编译;</p>
</li>
<li><p><code>android gradle</code>插件<code>1.3+</code>版本在执行<code>mergeResource</code>任务时忽略了<code>public.xml</code>，所以<code>merge</code>完成后的<code>build</code>目录下的<code>res</code>目录下没有<code>public.xml</code>相关的内容。所以需要在编译时通过脚本将<code>public.xml</code>插入到<code>merge</code>完成后的<code>build</code>目录下的<code>res</code>目录下。之所以这样做可行，是因为<code>aapt</code>本身是支持<code>public.xml</code>的，只是<code>gradle</code>插件在对资源做预处<code>(merge)</code>时对<code>public.xml</code>做了过滤。</p>
</li>
</ol>
<h3 id="aapt2进行id的固定"><a href="#aapt2进行id的固定" class="headerlink" title="aapt2进行id的固定"></a><code>aapt2</code>进行<code>id</code>的固定</h3><p>在<code>aapt2</code>编译（将资源文件编译为二进制格式）后，发现<code>merge</code>的资源都已经经过了预编译，产生了<code>flat</code>文件，这时候将<code>public.xml</code>文件拷贝至该目录就会产生编译错误。</p>
<p>但在<code>aapt2</code>的<strong>链接</strong>阶段中，我们查看相关的<strong>链接选项</strong>：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>--emit-ids path</code></td>
<td>在给定的路径下生成一个文件，该文件包含资源类型的名称及其 ID 映射的列表。它适合与 <code>--stable-ids</code> 搭配使用。</td>
</tr>
<tr>
<td><code>--stable-ids outputfilename.ext</code></td>
<td>使用通过 <code>--emit-ids</code> 生成的文件，该文件包含资源类型的名称以及为其分配的 ID 的列表。此选项可以让已分配的 ID 保持稳定，即使您在链接时删除了资源或添加了新资源也是如此。</td>
</tr>
</tbody>
</table>
<p>发现<code>--emit-ids</code>和<code>--stable-ids</code>命令搭配可以实现<code>id</code>的固定。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">  aaptOptions &#123;</span><br><span class="line">        File publicTxtFile = project.rootProject.file(<span class="string">'public.txt'</span>)</span><br><span class="line">        <span class="comment">//public文件存在，则应用，不存在则生成</span></span><br><span class="line">        <span class="keyword">if</span> (publicTxtFile.exists()) &#123;</span><br><span class="line">            project.logger.error <span class="string">"$&#123;publicTxtFile&#125; exists, apply it."</span></span><br><span class="line">            <span class="comment">//aapt2添加--stable-ids参数应用</span></span><br><span class="line">            aaptOptions.additionalParameters(<span class="string">"--stable-ids"</span>, <span class="string">"$&#123;publicTxtFile&#125;"</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            project.logger.error <span class="string">"$&#123;publicTxtFile&#125; not exists, generate it."</span></span><br><span class="line">            <span class="comment">//aapt2添加--emit-ids参数生成</span></span><br><span class="line">            aaptOptions.additionalParameters(<span class="string">"--emit-ids"</span>, <span class="string">"$&#123;publicTxtFile&#125;"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>第一次编译，先通过<code>--emit-ids</code>在项目的根目录生成<code>public.txt</code>;</li>
<li>再将<code>public.txt</code>里面对于的<code>id</code>改为自己想要固定的<code>id</code>;</li>
<li>再次编译，通过<code>--stable-ids</code>和根目录下的<code>public.txt</code>进行资源<code>id</code>的固定；</li>
</ol>
<blockquote>
<p><code>--emit-ids</code>编译结果</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210714201102544.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0dmVuX2tpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>修改<code>public.txt</code>文件内容再次编译</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210714201112658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0dmVuX2tpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="R-txt转public-txt"><a href="#R-txt转public-txt" class="headerlink" title="R.txt转public.txt"></a>R.txt转public.txt</h4><p>我们一般正常打包生成的中间产物是<code>build/intermediates/symbols/debug/R.txt</code>，需要将其转化为<code>public.txt</code>。</p>
<blockquote>
<p><code>R.txt</code>格式（<code>int</code>  <code>type</code>  <code>name</code>  <code>id</code>）或者（<code>int[]</code>  <code>styleable</code>  <code>name</code>  <code>{id,id,xxxx}</code>）</p>
<p><code>public.txt</code>格式（<code>applicationId:type/name = id</code>）</p>
</blockquote>
<p>所以在转化过程中需要过滤掉<code>R.txt</code>文件中的<code>styleable</code>类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    aaptOptions &#123;</span><br><span class="line">        File rFile = project.rootProject.file(<span class="string">'R.txt'</span>)</span><br><span class="line">        List&lt;String&gt; sortedLines = <span class="keyword">new</span> ArrayList&lt;&gt;()</span><br><span class="line">        <span class="comment">// 一行一行读取</span></span><br><span class="line">        rFile.eachLine &#123;line -&gt;</span><br><span class="line">            <span class="comment">//rLines.add(line)</span></span><br><span class="line">            String[] test = line.split(<span class="string">" "</span>)</span><br><span class="line">            String type = test[<span class="number">1</span>]</span><br><span class="line">            String name = test[<span class="number">2</span>]</span><br><span class="line">            String idValue = test[<span class="number">3</span>]</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"styleable"</span> != type) &#123;</span><br><span class="line">                sortedLines.add(<span class="string">"$&#123;applicationId&#125;:$&#123;type&#125;/$&#123;name&#125; = $&#123;idValue&#125;"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(sortedLines)</span><br><span class="line">        File publicTxtFile = project.rootProject.file(<span class="string">'public.txt'</span>)</span><br><span class="line">        <span class="keyword">if</span> (!publicTxtFile.exists()) &#123;</span><br><span class="line">            publicTxtFile.createNewFile()</span><br><span class="line">            sortedLines?.each &#123;</span><br><span class="line">                publicTxtFile.append(<span class="string">"$&#123;it&#125;\n"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="PUBLIC标记"><a href="#PUBLIC标记" class="headerlink" title="PUBLIC标记"></a>PUBLIC标记</h2><p>在<code>AAPT概述</code>这部分我们讲过如果一个 <code>apk</code> 文件里面的资源，如果被加上<code>PUBLIC</code>标记的话，就能被其他 <code>apk</code> 所引用，引用方式是<code>@包名:类型/名字</code>，例如：<code>@android:color/red</code>。</p>
<p>阅读上面《<code>aapt</code>进行<code>id</code>的固定》到《<code>aapt2</code>进行<code>id</code>的固定》这两部分，我们知道<code>aapt</code>和<code>aapt2</code>进行<code>id</code>固定的方法是不相同的。</p>
<p>其实如果我们用<code>aapt2 dump build/intermediates/res/resources-debug.ap_</code>命令查看生成资源的相关信息。</p>
<p><code>aapt</code>通过<code>public.xml</code>进行<code>id</code>固定的资源信息有<code>PUBLIC</code>标记：</p>
<p><img src="https://img-blog.csdnimg.cn/20210714201123114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0dmVuX2tpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>二使用上面<code>aapt2</code>进行<code>id</code>固定的方式是没有下图中的<code>PUBLIC</code>标记的。</p>
<p>原因还是<code>aapt</code>和<code>aapt2</code>的差异造成的，<code>aapt2</code>的<code>public.txt</code>不等于<code>aapt</code>的<code>public.xml</code>，在<code>aapt2</code>中如果要添加<code>PUBLIC</code>标记，其实还是得另寻其他途径。</p>
<h3 id="回顾思考"><a href="#回顾思考" class="headerlink" title="回顾思考"></a>回顾思考</h3><blockquote>
<p>回顾</p>
</blockquote>
<ol>
<li><code>aapt</code> 进行资源 <code>id</code> 固定和 <code>PUBLIC</code> 标价，是将<code>public.xml</code> 复制到 <code>${mergeResourceTask.outputDir}</code>;</li>
<li><code>aapt2</code> 相比于 <code>aapt</code>  ，做了增量编译的优化。<code>AAPT2</code> 会解析该文件并生成一个扩展名为 <code>.flat</code> 的中间二进制文件。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20210714201138759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0dmVuX2tpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>思考</p>
</blockquote>
<p>能否使用<code>aapt2</code>自己将<code>public.xml</code>编译为<code>public.arsc.flat</code>，并像 <code>aapt</code> 操作一样将其复制到  <code>${mergeResourceTask.outputDir}</code>;</p>
<h3 id="动手实践"><a href="#动手实践" class="headerlink" title="动手实践"></a>动手实践</h3><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    <span class="comment">//将public.txt转化为public.xml，并对public.xml进行aapt2的编译将结果复制到$&#123;ergeResourceTask.outputDir&#125;</span></span><br><span class="line">  <span class="comment">//下面大部分代码是copy自tinker的源码</span></span><br><span class="line">  applicationVariants.all &#123; <span class="keyword">def</span> variant -&gt;</span><br><span class="line">      <span class="keyword">def</span> mergeResourceTask = project.tasks.findByName(<span class="string">"merge$&#123;variant.getName().capitalize()&#125;Resources"</span>)</span><br><span class="line">      <span class="keyword">if</span> (mergeResourceTask) &#123;</span><br><span class="line">          mergeResourceTask.doLast &#123;</span><br><span class="line">              <span class="comment">//目标转换文件，注意public.xml上级目录必须带values目录，否则aapt2执行时会报非法文件路径</span></span><br><span class="line">              File publicXmlFile = <span class="keyword">new</span> File(project.buildDir, <span class="string">"intermediates/res/public/$&#123;variant.getDirName()&#125;/values/public.xml"</span>)</span><br><span class="line">              <span class="comment">//转换public.txt文件为publicXml文件，最后一个参数true标识固定资源id</span></span><br><span class="line">              convertPublicTxtToPublicXml(project.rootProject.file(<span class="string">'public.txt'</span>), publicXmlFile, <span class="literal">false</span>)</span><br><span class="line">              <span class="keyword">def</span> variantData = variant.getMetaClass().getProperty(variant, <span class="string">'variantData'</span>)</span><br><span class="line">              <span class="keyword">def</span> variantScope = variantData.getScope()</span><br><span class="line">              <span class="keyword">def</span> globalScope = variantScope.getGlobalScope()</span><br><span class="line">              <span class="keyword">def</span> androidBuilder = globalScope.getAndroidBuilder()</span><br><span class="line">              <span class="keyword">def</span> targetInfo = androidBuilder.getTargetInfo()</span><br><span class="line">              <span class="keyword">def</span> mBuildToolInfo = targetInfo.getBuildTools()</span><br><span class="line">              Map&lt;BuildToolInfo.PathId, String&gt; mPaths = mBuildToolInfo.getMetaClass().getProperty(mBuildToolInfo, <span class="string">"mPaths"</span>) <span class="keyword">as</span> Map&lt;BuildToolInfo.PathId, String&gt;</span><br><span class="line">                <span class="comment">//通过aapt2 compile命令自己生成public.arsc.flat并输出到$&#123;mergeResourceTask.outputDir&#125;</span></span><br><span class="line">              project.exec(<span class="keyword">new</span> Action&lt;ExecSpec&gt;() &#123;</span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="keyword">void</span> execute(ExecSpec execSpec) &#123;</span><br><span class="line">                      execSpec.executable <span class="string">"$&#123;mPaths.get(BuildToolInfo.PathId.AAPT2)&#125;"</span></span><br><span class="line">                      execSpec.args(<span class="string">"compile"</span>)</span><br><span class="line">                      execSpec.args(<span class="string">"--legacy"</span>)</span><br><span class="line">                      execSpec.args(<span class="string">"-o"</span>)</span><br><span class="line">                      execSpec.args(<span class="string">"$&#123;mergeResourceTask.outputDir&#125;"</span>)</span><br><span class="line">                      execSpec.args(<span class="string">"$&#123;publicXmlFile&#125;"</span>)</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将<code>public.txt</code>文件转化为<code>public.xml</code>文件.</p>
<blockquote>
<ul>
<li><code>public.txt</code>中存在<code>styleable</code>类型资源，<code>public.xml</code>中不存在，因此转换过程中如果遇到<code>styleable</code>类型，需要忽略;</li>
<li><code>vector</code>矢量图资源如果存在内部资源，也需要忽略，在<code>aapt2</code>中，它的名字是以<code>$</code>开头，然后是主资源名，紧跟着__数字递增索引，这些资源外部是无法引用到的，只需要固定<code>id</code>，不需要添加<code>PUBLIC</code>标记，并且<code>$</code>符号在<code>public.xml</code>中是非法的，因此忽略它即可;</li>
<li>由于<code>aapt2</code>有资源<code>id</code>的固定方式，因此转换过程中可直接丢掉<code>id</code>，简单声明即可（PS：这里通过<code>withId</code>参数控制是否需要固定<code>id</code>）;</li>
<li><code>aapt2</code>编译的<code>public.xml</code>文件的上级目录必须是<code>values</code>文件夹，否则编译过程会报非法路径;</li>
</ul>
</blockquote>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 转换publicTxt为publicXml</span></span><br><span class="line"><span class="comment"> * copy tinker:com.tencent.tinker.build.gradle.task.TinkerResourceIdTask#convertPublicTxtToPublicXml</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"GrMethodMayBeStatic"</span>)</span><br><span class="line"><span class="keyword">void</span> convertPublicTxtToPublicXml(File publicTxtFile, File publicXmlFile, <span class="keyword">boolean</span> withId) &#123;</span><br><span class="line">    <span class="keyword">if</span> (publicTxtFile == <span class="literal">null</span> || publicXmlFile == <span class="literal">null</span> || !publicTxtFile.exists() || !publicTxtFile.isFile()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> GradleException(<span class="string">"publicTxtFile $&#123;publicTxtFile&#125; is not exist or not a file"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    GFileUtils.deleteQuietly(publicXmlFile)</span><br><span class="line">    GFileUtils.mkdirs(publicXmlFile.getParentFile())</span><br><span class="line">    GFileUtils.touch(publicXmlFile)</span><br><span class="line"></span><br><span class="line">    project.logger.info <span class="string">"convert publicTxtFile $&#123;publicTxtFile&#125; to publicXmlFile $&#123;publicXmlFile&#125;"</span></span><br><span class="line"></span><br><span class="line">    publicXmlFile.append(<span class="string">"&lt;!-- AUTO-GENERATED FILE.  DO NOT MODIFY --&gt;"</span>)</span><br><span class="line">    publicXmlFile.append(<span class="string">"\n"</span>)</span><br><span class="line">    publicXmlFile.append(<span class="string">"&lt;resources&gt;"</span>)</span><br><span class="line">    publicXmlFile.append(<span class="string">"\n"</span>)</span><br><span class="line">    Pattern linePattern = Pattern.compile(<span class="string">".*?:(.*?)/(.*?)\\s+=\\s+(.*?)"</span>)</span><br><span class="line"></span><br><span class="line">    publicTxtFile.eachLine &#123;<span class="keyword">def</span> line -&gt;</span><br><span class="line">        Matcher matcher = linePattern.matcher(line)</span><br><span class="line">        <span class="keyword">if</span> (matcher.matches() &amp;&amp; matcher.groupCount() == <span class="number">3</span>) &#123;</span><br><span class="line">            String resType = matcher.group(<span class="number">1</span>)</span><br><span class="line">            String resName = matcher.group(<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> (resName.startsWith(<span class="string">'$'</span>)) &#123;</span><br><span class="line">                project.logger.info <span class="string">"ignore to public res $&#123;resName&#125; because it's a nested resource"</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resType.equalsIgnoreCase(<span class="string">"styleable"</span>)) &#123;</span><br><span class="line">                project.logger.info <span class="string">"ignore to public res $&#123;resName&#125; because it's a styleable resource"</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (withId) &#123;</span><br><span class="line">                    publicXmlFile.append(<span class="string">"\t&lt;public type=\"$&#123;resType&#125;\" name=\"$&#123;resName&#125;\" id=\"$&#123;matcher.group(3)&#125;\" /&gt;\n"</span>)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    publicXmlFile.append(<span class="string">"\t&lt;public type=\"$&#123;resType&#125;\" name=\"$&#123;resName&#125;\" /&gt;\n"</span>)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    publicXmlFile.append(<span class="string">"&lt;/resources&gt;"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上思考和动手实践的过程，我们不仅解决了<code>aapt2</code>进行<code>PUBLIC</code>标记的问题，还找到了一种新的<code>aapt2</code>进行<code>id</code>固定的方法。</p>
<p>可能遇到的报错：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">no signature of method com.android.build.gradle.internal.variant.applicationvariantdata.getscope() is applicable <span class="keyword">for</span> argument types: () values: []</span><br></pre></td></tr></table></figure>
<p>解决方法为修改<code>gradle</code> 版本为 <code>gradle:3.3.2</code> 和 <code>gradle-wrapper:5.6.2</code> ，毕竟 <code>tinker</code> 也不支持最新版的 <code>gradle</code> .</p>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://github.com/Tencent/tinker.git" target="_blank" rel="noopener">Github:tinker</a></p>
<p><a href="https://www.cnblogs.com/linghu-java/p/9548039.html" target="_blank" rel="noopener">android public.xml 用法</a></p>
<p><a href="https://ljd1996.github.io/2019/08/21/Android-Gradle%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener">Android-Gradle笔记</a></p>
<p><a href="https://fucknmb.com/2017/11/15/aapt2%E9%80%82%E9%85%8D%E4%B9%8B%E8%B5%84%E6%BA%90id%E5%9B%BA%E5%AE%9A/" target="_blank" rel="noopener">aapt2 适配之资源 id 固定</a></p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>aapt</tag>
      </tags>
  </entry>
  <entry>
    <title>将构建配置从 Groovy 迁移到 KTS</title>
    <url>/2021/06/28/gradle-kotlin-dsl/</url>
    <content><![CDATA[<h1 id="将构建配置从-Groovy-迁移到-KTS"><a href="#将构建配置从-Groovy-迁移到-KTS" class="headerlink" title="将构建配置从 Groovy 迁移到 KTS"></a>将构建配置从 Groovy 迁移到 KTS</h1><p><img src="https://img-blog.csdnimg.cn/img_convert/86211657b18d27817f8b26ffd277be43.png#pic_center" alt="icon.jpg"><br>@<a href="文章目录">TOC</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为<code>Android</code>开发习惯了面向对象编程，习惯了<code>IDEA</code>提供的各种辅助开发快捷功能。</p>
<p>那么带有陌生的常规语法的<code>Groovy</code>脚本对于我来说一向敬而远之。</p>
<p><code>Kotlin DSL</code>的出现感觉是为了我们量身定做的，因为采用 Kotlin 编写的代码可读性更高，并且 Kotlin 提供了更好的编译时检查和 IDE 支持。</p>
<p>&lt;hr style=” border:solid; width:100px; height:1px;” color=#000000 size=1”&gt;</p>
<blockquote>
<p>名词概念解释</p>
</blockquote>
<ul>
<li><p><strong>Gradle</strong>: 自动化构建工具. 平行产品: <code>Maven</code>.</p>
</li>
<li><p><strong>Groovy</strong>: 语言, 编译后变为<code>JVM byte code</code>, 兼容<code>Java</code>平台.</p>
</li>
<li><p><strong>DSL</strong>: <code>Domain Specific Language</code>, 领域特定语言.</p>
</li>
<li><p><strong>Groovy DSL</strong>: <code>Gradle</code>的API是Java的,<code>Groovy DSL</code>是在其之上的脚本语言. <code>Groovy DS</code>脚本文件后缀: <code>.gradle</code>.</p>
</li>
<li><p><strong>KTS</strong>：是指 Kotlin 脚本，这是 Gradle 在构建配置文件中使用的一种 <a href="https://kotlinlang.org/docs/tutorials/command-line.html#run-scripts" target="_blank" rel="noopener">Kotlin 语言形式</a>。Kotlin 脚本是<a href="https://kotlinlang.org/docs/tutorials/command-line.html#using-the-command-line-to-run-scripts" target="_blank" rel="noopener">可从命令行运行</a>的 Kotlin 代码。</p>
</li>
<li><p><strong>Kotlin DSL</strong>：主要是指 <a href="https://developer.android.com/reference/tools/gradle-api?hl=zh-cn" target="_blank" rel="noopener">Android Gradle 插件 Kotlin DSL</a>，有时也指<a href="https://guides.gradle.org/migrating-build-logic-from-groovy-to-kotlin/" target="_blank" rel="noopener">底层 Gradle Kotlin DSL</a>。</p>
</li>
</ul>
<p>在讨论从 Groovy 迁移时，术语“KTS”和“Kotlin DSL”可以互换使用。换句话说，“将 Android 项目从 Groovy 转换为 KTS”与“将 Android 项目从 Groovy 转换为 Kotlin DSL”实际上是一个意思。</p>
<h2 id="Groovy和KTS对比"><a href="#Groovy和KTS对比" class="headerlink" title="Groovy和KTS对比"></a>Groovy和KTS对比</h2><table>
<thead>
<tr>
<th>类型</th>
<th><strong>Kotlin</strong></th>
<th><strong>Groovy</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>自动代码补全</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>是否类型安全</td>
<td>是</td>
<td>不是</td>
</tr>
<tr>
<td>源码导航</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>重构</td>
<td>自动关联</td>
<td>手动修改</td>
</tr>
</tbody>
</table>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h3><ul>
<li>可以使用<code>Kotlin</code>, 开发者可能对这个语言更熟悉更喜欢.</li>
<li><code>IDE</code>支持更好, 自动补全提示, 重构,<code>imports</code>等.</li>
<li>类型安全: <code>Kotlin</code>是静态类型.</li>
<li>不用一次性迁移完: 两种语言的脚本可以共存, 也可以互相调用.</li>
</ul>
<h3 id="缺点和已知问题："><a href="#缺点和已知问题：" class="headerlink" title="缺点和已知问题："></a>缺点和已知问题：</h3><ul>
<li><p>目前，采用 <code>KTS</code> 的构建速度可能比采用 <code>Groovy</code> 慢（自测小demo耗时增加约40%(约8s)）。</p>
</li>
<li><p><code>Project Structure</code> 编辑器不会展开在 <code>buildSrc</code> 文件夹中定义的用于库名称或版本的常量。</p>
</li>
<li><code>KTS</code> 文件目前在项目视图中<a href="https://issuetracker.google.com/119757694?hl=zh-cn" target="_blank" rel="noopener">不提供文本提示</a>。</li>
</ul>
<h2 id="Android构建配置从Groovy迁移KTS"><a href="#Android构建配置从Groovy迁移KTS" class="headerlink" title="Android构建配置从Groovy迁移KTS"></a>Android构建配置从Groovy迁移KTS</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol>
<li><p><code>Groovy</code> 字符串可以用单引号 <code>&#39;string&#39;</code> 或双引号 <code>&quot;string&quot;</code> 引用，而 <code>Kotlin</code> 需要双引号 <code>&quot;string&quot;</code>。</p>
</li>
<li><p><code>Groovy</code> 允许在调用函数时省略括号，而 <code>Kotlin</code> 总是需要括号。</p>
</li>
<li><p><code>Gradle Groovy DSL</code> 允许在分配属性时省略 <code>=</code> 赋值运算符，而 <code>Kotlin</code> 始终需要赋值运算符。</p>
</li>
</ol>
<p>所以在<code>KTS</code>中需要统一做到：</p>
<ul>
<li>使用双引号统一引号.</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/4bced2be902c8a5f512472cdfc41d0e2.png#pic_center" alt="groovy-kts-diff1.png"></p>
<ul>
<li>消除函数调用和属性赋值的歧义（分别使用括号和赋值运算符）。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/3a47c02e5057af5f8630107889029901.png#pic_center" alt="groovy-kts-diff2.png"></p>
<h3 id="脚本文件名"><a href="#脚本文件名" class="headerlink" title="脚本文件名"></a>脚本文件名</h3><p><strong>Groovy DSL</strong> 脚本文件使用 <code>.gradle</code> 文件扩展名。</p>
<p><strong>Kotlin DSL</strong> 脚本文件使用 <code>.gradle.kt</code>s 文件扩展名。</p>
<h3 id="一次迁移一个文件"><a href="#一次迁移一个文件" class="headerlink" title="一次迁移一个文件"></a>一次迁移一个文件</h3><p>由于您可以在项目中结合使用 <code>Groovy build</code> 文件和 <code>KTS build</code> 文件，因此将项目转换为 <code>KTS</code> 的一个简单方法是先选择一个简单的 <code>build</code> 文件（例如 <code>settings.gradle</code>），将其重命名为 <code>settings.gradle.kts</code>，然后将其内容转换为 <code>KTS</code>。之后，确保您的项目在迁移每个 <code>build</code> 文件之后仍然可以编译。</p>
<h3 id="自定义Task"><a href="#自定义Task" class="headerlink" title="自定义Task"></a>自定义Task</h3><p>由于<code>Koltin</code> 是静态类型语言，<code>Groovy</code>是动态语言，前者是类型安全的，他们的性质区别很明显的体现在了 task 的创建和配置上。详情可以参考<a href="https://guides.gradle.org/migrating-build-logic-from-groovy-to-kotlin/#configuring-tasks" target="_blank" rel="noopener">Gradle官方迁移教程</a></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// groovy</span></span><br><span class="line">task clean(type: Delete) &#123;</span><br><span class="line">    delete rootProject.buildDir</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// kotiln-dsl</span></span><br><span class="line">tasks.register(<span class="string">"clean"</span>, Delete::<span class="class"><span class="keyword">class</span>) </span>&#123;</span><br><span class="line">    delete(rootProject.buildDir)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> clean <span class="keyword">by</span> tasks.creating(Delete::<span class="class"><span class="keyword">class</span>) </span>&#123;</span><br><span class="line">    delete(rootProject.buildDir)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingTask</span> : <span class="type">DefaultTask</span></span>() &#123;</span><br><span class="line">    <span class="keyword">var</span> msg: String? = <span class="literal">null</span></span><br><span class="line">    <span class="meta">@TaskAction</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">greet</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"GreetingTask:<span class="variable">$msg</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> msg <span class="keyword">by</span> tasks.creating(GreetingTask::<span class="class"><span class="keyword">class</span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">val</span> testTask: Task <span class="keyword">by</span> tasks.creating &#123;</span><br><span class="line">   doLast &#123;</span><br><span class="line">       println(<span class="string">"testTask:Run"</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> testTask2: Task = task(<span class="string">"test2"</span>) &#123;</span><br><span class="line">    doLast &#123; </span><br><span class="line">      println(<span class="string">"Hello, World!"</span>) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> testTask3: Task = tasks.create(<span class="string">"test3"</span>) &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println(<span class="string">"testTask:Run"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用-plugins-代码块"><a href="#使用-plugins-代码块" class="headerlink" title="使用 plugins 代码块"></a>使用 <code>plugins</code> 代码块</h3><p>如果您在<code>build</code> 文件中使用 <code>plugins</code> 代码块，<code>IDE</code> 将能够获知相关上下文信息，即使在构建失败时也是如此。<code>IDE</code> 可使用这些信息执行代码补全并提供其他实用建议，从而帮助您解决 <code>KTS</code> 文件中存在的问题。</p>
<p>在您的代码中，将命令式 <code>apply plugin</code> 替换为声明式 <code>plugins</code> 代码块。<code>Groovy</code> 中的以下代码…</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'com.android.application'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'kotlin-android'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'kotlin-kapt'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'androidx.navigation.safeargs.kotlin'</span></span><br></pre></td></tr></table></figure>
<p>在 KTS 中变为以下代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id(<span class="string">"com.android.application"</span>)</span><br><span class="line">    id(<span class="string">"kotlin-android"</span>)</span><br><span class="line">    id(<span class="string">"kotlin-kapt"</span>)</span><br><span class="line">    id(<span class="string">"androidx.navigation.safeargs.kotlin"</span>)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>如需详细了解 <code>plugins</code> 代码块，请参阅 <a href="https://docs.gradle.org/nightly/userguide/migrating_from_groovy_to_kotlin_dsl.html#applying_plugins" target="_blank" rel="noopener">Gradle 的迁移指南</a>。</p>
<p><strong>注意</strong>：<code>plugins</code> 代码块仅解析 Gradle 插件门户中提供的插件或使用 <a href="https://docs.gradle.org/current/userguide/plugins.html#sec:plugin_management" target="_blank" rel="noopener"><code>pluginManagement</code></a> 代码块指定的自定义存储库中提供的插件。如果插件来自插件门户中不存在的 <code>buildScript</code> 依赖项，那么这些插件在 Kotlin 中就必须使用 <code>apply</code> 才能应用。例如：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">apply(plugin = <span class="string">"kotlin-android"</span>)</span><br><span class="line">apply &#123;</span><br><span class="line">    from(<span class="string">"<span class="subst">$&#123;rootDir.path&#125;</span>/config.gradle"</span>)</span><br><span class="line">    from(<span class="string">"<span class="subst">$&#123;rootDir.path&#125;</span>/version.gradle.kts"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如需了解详情，请参阅 <a href="https://docs.gradle.org/current/userguide/plugins.html#sec:applying_plugins_buildscript" target="_blank" rel="noopener">Gradle 文档</a>。</p>
<blockquote>
<p>强烈建议您<code>plugins {}</code>优先使用块而不是<code>apply()</code>函数。</p>
<p>有两个关键的最佳实践可以更轻松地在 <code>Kotlin DSL</code> 的静态上下文中工作：</p>
<ul>
<li>使用<code>plugins {}</code>块</li>
<li>将本地构建逻辑放在构建的<strong>buildSrc</strong>目录中</li>
</ul>
<p>该<a href="https://docs.gradle.org/current/userguide/plugins.html#sec:plugins_block" target="_blank" rel="noopener">plugins {}块</a>是关于保持您的构建脚本声明性，以便充分利用<code>Kotlin DSL</code>。</p>
<p>使用<a href="https://docs.gradle.org/current/userguide/organizing_gradle_projects.html#sec:build_sources" target="_blank" rel="noopener"><em>buildSrc</em>项目</a>是关于将您的构建逻辑组织成共享的本地插件和约定，这些插件和约定易于测试并提供良好的 IDE 支持。</p>
</blockquote>
<h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><blockquote>
<p>常见依赖</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// groovy</span></span><br><span class="line">implementation project(<span class="string">':library'</span>)</span><br><span class="line">implementation <span class="string">'com.xxxx:xxxx:8.8.1'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// kotlin</span></span><br><span class="line">implementation(project(<span class="string">":library"</span>))</span><br><span class="line">implementation(<span class="string">"com.xxxx:xxx:8.8.1"</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>freeTree</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// groovy</span></span><br><span class="line">implementation fileTree(include: <span class="string">'*.jar'</span>, dir: <span class="string">'libs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//kotlin</span></span><br><span class="line">implementation(fileTree(mapOf(<span class="string">"include"</span> to listOf(<span class="string">"*.jar"</span>), <span class="string">"dir"</span> to <span class="string">"libs"</span>)))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>特别类型库依赖</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//groovy</span></span><br><span class="line">implementation(name: <span class="string">'splibrary'</span>, ext: <span class="string">'aar'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//kotlin</span></span><br><span class="line">implementation (group=<span class="string">""</span>,name=<span class="string">"splibrary"</span>,ext = <span class="string">"aar"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="构建变体"><a href="#构建变体" class="headerlink" title="构建变体"></a>构建变体</h3><h4 id="显式和隐式-buildTypes"><a href="#显式和隐式-buildTypes" class="headerlink" title="显式和隐式 buildTypes"></a>显式和隐式 <code>buildTypes</code></h4><p>在 Kotlin DSL 中，某些 <code>buildTypes</code>（如 <code>debug</code> 和 <code>release,</code>）是隐式提供的。但是，其他 <code>buildTypes</code> 则必须手动创建。</p>
<p>例如，在 Groovy 中，您可能有 <code>debug</code>、<code>release</code> 和 <code>staging</code> <code>buildTypes</code>：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">buildTypes</span><br><span class="line">  debug &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  release &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  staging &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>在 KTS 中，仅 <code>debug</code> 和 <code>release</code> <code>buildTypes</code> 是隐式提供的，而 <code>staging</code> 则必须由您手动创建：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">buildTypes</span><br><span class="line">  getByName(<span class="string">"debug"</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  getByName(<span class="string">"release"</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  create(<span class="string">"staging"</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h4><p><code>Grovvy</code>编写：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">productFlavors &#123;</span><br><span class="line">        demo &#123;</span><br><span class="line">            dimension <span class="string">"app"</span></span><br><span class="line">        &#125;</span><br><span class="line">        full &#123;</span><br><span class="line">            dimension <span class="string">"app"</span></span><br><span class="line">            multiDexEnabled <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            signingConfig signingConfigs.signConfig</span><br><span class="line">            minifyEnabled <span class="literal">true</span></span><br><span class="line">            debuggable <span class="literal">false</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        debug &#123;</span><br><span class="line">            minifyEnabled <span class="literal">false</span></span><br><span class="line">            debuggable <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">signingConfigs &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            storeFile file(<span class="string">"myreleasekey.keystore"</span>)</span><br><span class="line">            storePassword <span class="string">"password"</span></span><br><span class="line">            keyAlias <span class="string">"MyReleaseKey"</span></span><br><span class="line">            keyPassword <span class="string">"password"</span></span><br><span class="line">        &#125;</span><br><span class="line">        debug &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>kotlin-KTL</code>编写：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">productFlavors &#123;</span><br><span class="line">    create(<span class="string">"demo"</span>) &#123;</span><br><span class="line">        dimension = <span class="string">"app"</span></span><br><span class="line">    &#125;</span><br><span class="line">    create(<span class="string">"full"</span>) &#123;</span><br><span class="line">        dimension = <span class="string">"app"</span></span><br><span class="line">        multiDexEnabled = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buildTypes &#123;</span><br><span class="line">        getByName(<span class="string">"release"</span>) &#123;</span><br><span class="line">            signingConfig = signingConfigs.getByName(<span class="string">"release"</span>)</span><br><span class="line">            isMinifyEnabled = <span class="literal">true</span></span><br><span class="line">            isDebuggable = <span class="literal">false</span></span><br><span class="line">            proguardFiles(getDefaultProguardFile(<span class="string">"proguard-android.txtt"</span>), <span class="string">"proguard-rules.pro"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        getByName(<span class="string">"debug"</span>) &#123;</span><br><span class="line">            isMinifyEnabled = <span class="literal">false</span></span><br><span class="line">            isDebuggable = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">signingConfigs &#123;</span><br><span class="line">        create(<span class="string">"release"</span>) &#123;</span><br><span class="line">            storeFile = file(<span class="string">"myreleasekey.keystore"</span>)</span><br><span class="line">            storePassword = <span class="string">"password"</span></span><br><span class="line">            keyAlias = <span class="string">"MyReleaseKey"</span></span><br><span class="line">            keyPassword = <span class="string">"password"</span></span><br><span class="line">        &#125;</span><br><span class="line">        getByName(<span class="string">"debug"</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="访问配置"><a href="#访问配置" class="headerlink" title="访问配置"></a>访问配置</h3><h4 id="gradle-properties"><a href="#gradle-properties" class="headerlink" title="gradle.properties"></a>gradle.properties</h4><p>我们通常会把签名信息、版本信息等配置写在<code>gradle.properties</code>中，在kotlin-dsl中我们可以通过一下方式访问：</p>
<ol>
<li><code>rootProject.extra.properties</code></li>
<li><code>project.extra.properties</code></li>
<li><code>rootProject.properties</code></li>
<li><code>properties</code></li>
<li><code>System.getProperties()</code></li>
</ol>
<blockquote>
<p><code>System.getProperties()</code>使用的限制比较多</p>
</blockquote>
<ul>
<li>参数名必须按照<code>systemProp.xxx</code>格式(例如：<code>systemProp.kotlinVersion=1.3.72</code>);</li>
<li>与当前执行的task有关（<code>&gt; Configure project :buildSrc</code>和<code>&gt; Configure project :</code>的结果不同，后者无法获取的<code>gradle.properties</code>中的数据）;</li>
</ul>
<h4 id="local-properties"><a href="#local-properties" class="headerlink" title="local.properties"></a>local.properties</h4><p>获取工程的<code>local.properties</code>文件</p>
<blockquote>
<p><code>gradleLocalProperties(rootDir)</code></p>
</blockquote>
<blockquote>
<p><code>gradleLocalProperties(projectDir)</code></p>
</blockquote>
<h4 id="获取系统环境变量的值"><a href="#获取系统环境变量的值" class="headerlink" title="获取系统环境变量的值"></a>获取系统环境变量的值</h4><p><code>val JAVA_HOME:String = System.getenv(&quot;JAVA_HOME&quot;) ?: &quot;default_value&quot;</code></p>
<h3 id="关于Ext"><a href="#关于Ext" class="headerlink" title="关于Ext"></a>关于Ext</h3><p>Google 官方推荐的一个 Gradle 配置<a href="https://developer.android.com/studio/build/gradle-tips?hl=zh-cn#configure-project-wide-properties" target="_blank" rel="noopener">最佳实践</a>是在项目最外层 build.gradle 文件的<code>ext</code>代码块中定义项目范围的属性，然后在所有模块间共享这些属性，比如我们通常会这样存放依赖的版本号。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// build.gradle</span></span><br><span class="line"></span><br><span class="line">ext &#123;</span><br><span class="line">    compileSdkVersion = <span class="number">28</span></span><br><span class="line">    buildToolsVersion = <span class="string">"28.0.3"</span></span><br><span class="line">    supportLibVersion = <span class="string">"28.0.0"</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是由于缺乏IDE的辅助(跳转查看、全局重构等都不支持)，实际使用体验欠佳。</p>
<p>在<code>KTL</code>中用<code>extra</code>来代替<code>Groovy</code>中的<code>ext</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The extra object can be used for custom properties and makes them available to all</span></span><br><span class="line"><span class="comment">// modules in the project.</span></span><br><span class="line"><span class="comment">// The following are only a few examples of the types of properties you can define.</span></span><br><span class="line">extra[<span class="string">"compileSdkVersion"</span>] = <span class="number">28</span></span><br><span class="line"><span class="comment">// You can also create properties to specify versions for dependencies.</span></span><br><span class="line"><span class="comment">// Having consistent versions between modules can avoid conflicts with behavior.</span></span><br><span class="line">extra[<span class="string">"supportLibVersion"</span>] = <span class="string">"28.0.0"</span></span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    <span class="comment">// Use the following syntax to access properties you defined at the project level:</span></span><br><span class="line">    <span class="comment">// rootProject.extra["property_name"]</span></span><br><span class="line">    compileSdkVersion(rootProject.extra[<span class="string">"sdkVersion"</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Alternatively, you can access properties using a type safe delegate:</span></span><br><span class="line">    <span class="keyword">val</span> sdkVersion: <span class="built_in">Int</span> <span class="keyword">by</span> rootProject.extra</span><br><span class="line">    ...</span><br><span class="line">    compileSdkVersion(sdkVersion)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation(<span class="string">"com.android.support:appcompat-v7:<span class="subst">$&#123;rootProject.ext.supportLibVersion&#125;</span>"</span>)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p> <code>build.gralde</code>中的<code>ext</code>数据是可以在<code>build.gradle.kts</code>中使用<code>extra</code>进行访问的。</p>
</blockquote>
<h3 id="修改生成apk名称和BuildConfig中添加apk支持的cpu架构"><a href="#修改生成apk名称和BuildConfig中添加apk支持的cpu架构" class="headerlink" title="修改生成apk名称和BuildConfig中添加apk支持的cpu架构"></a>修改生成apk名称和BuildConfig中添加apk支持的cpu架构</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> abiCodes = mapOf(<span class="string">"armeabi-v7a"</span> to <span class="number">1</span>, <span class="string">"x86"</span> to <span class="number">2</span>, <span class="string">"x86_64"</span> to <span class="number">3</span>)</span><br><span class="line">android.applicationVariants.all &#123;</span><br><span class="line">    <span class="keyword">val</span> buildType = <span class="keyword">this</span>.buildType.name</span><br><span class="line">    <span class="keyword">val</span> variant = <span class="keyword">this</span></span><br><span class="line">    outputs.all &#123;</span><br><span class="line">        <span class="keyword">val</span> name =</span><br><span class="line">            <span class="keyword">this</span>.filters.find &#123; it.filterType == com.android.build.api.variant.FilterConfiguration.FilterType.ABI.name &#125;?.identifier</span><br><span class="line">        <span class="keyword">val</span> baseAbiCode = abiCodes[name]</span><br><span class="line">        <span class="keyword">if</span> (baseAbiCode != <span class="literal">null</span>) &#123;</span><br><span class="line">          	<span class="comment">//写入cpu架构信息</span></span><br><span class="line">            variant.buildConfigField(<span class="string">"String"</span>, <span class="string">"CUP_ABI"</span>, <span class="string">"\"<span class="subst">$&#123;name&#125;</span>\""</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">is</span> com.android.build.gradle.<span class="keyword">internal</span>.api.ApkVariantOutputImpl) &#123;</span><br><span class="line">            <span class="comment">//修改apk名称</span></span><br><span class="line">            <span class="keyword">if</span> (buildType == <span class="string">"release"</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.outputFileName = <span class="string">"KotlinDSL_<span class="subst">$&#123;name&#125;</span>_<span class="subst">$&#123;buildType&#125;</span>.apk"</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (buildType == <span class="string">"debug"</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.outputFileName = <span class="string">"KotlinDSL_V<span class="subst">$&#123;variant.versionName&#125;</span>_<span class="subst">$&#123;name&#125;</span>_<span class="subst">$&#123;buildType&#125;</span>.apk"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="buildSrc"><a href="#buildSrc" class="headerlink" title="buildSrc"></a>buildSrc</h2><p>我们在使用<code>Groovy</code>语言构建的时候，往往会抽取一个<code>version_config.gradle</code>来作为全局的变量控制，而<code>ext</code>扩展函数则是必须要使用到的，而在我们的<code>Gradle Kotlin DSL</code>中，如果想要使用全局控制，则需要建议使用<code>buildSrc</code>。</p>
<p>复杂的构建逻辑通常很适合作为自定义任务或二进制插件进行封装。自定义任务和插件实现不应存在于构建脚本中。<code>buildSrc</code>则不需要在多个独立项目之间共享代码，就可以非常方便地使用该代码了。</p>
<p><code>buildSrc</code>被视为构建目录。编译器发现目录后，<code>Gradle</code>会自动编译并测试此代码，并将其放入构建脚本的类路径中。</p>
<blockquote>
<ol>
<li>先创建<code>buildSrc</code>目录；</li>
<li>在该目录下创建<code>build.gradle.kts</code>文件；</li>
<li>创建一个<code>buildSrc/src/main/koltin</code>目录；</li>
<li>在该目录下创建<code>Dependencies.kt</code>文件作为版本管理类；</li>
</ol>
</blockquote>
<p>需要注意的是<code>buildSrc</code>的<code>build.gradle.kts</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    `kotlin-dsl`</span><br><span class="line">&#125;</span><br><span class="line">repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">apply &#123;</span><br><span class="line">    plugin(<span class="string">"kotlin"</span>)</span><br><span class="line">&#125;</span><br><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        gradlePluginPortal()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath(kotlin(<span class="string">"gradle-plugin"</span>, <span class="string">"1.3.72"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//dependencies &#123;</span></span><br><span class="line"><span class="comment">//    implementation(gradleKotlinDsl())</span></span><br><span class="line"><span class="comment">//    implementation(kotlin("stdlib", "1.3.72"))</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">repositories &#123;</span><br><span class="line">    gradlePluginPortal()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不同版本之间<code>buildSrc</code>下的<code>build.gradle</code>文件执行顺序：</p>
<blockquote>
<p><code>gradle-wrapper.properties:5.6.4</code></p>
<p> <code>com.android.tools.build:gradle:3.2.0</code></p>
</blockquote>
<ol>
<li><code>BuildSrc:build.gradle</code></li>
<li><code>setting.gradle</code></li>
<li><code>Project:build.gradle</code></li>
<li><code>Moudle:build.gradle</code></li>
</ol>
<blockquote>
<p><code>gradle-wrapper.properties:6.5</code> </p>
<p><code>com.android.tools.build:gradle:4.1.1</code></p>
</blockquote>
<ol>
<li><code>setting.gradle</code></li>
<li><code>BuildSrc:build.gradle</code></li>
<li><code>Project:build.gradle</code></li>
<li><code>Moudle:build.gradle</code></li>
</ol>
<p>所以在非<code>buildSrc</code>目录下的<code>build.gradle.kts</code>文件中我们使用<code>Dependencies.kt</code>需要注意其加载顺序。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://developer.android.com/studio/build/migrate-to-kts?hl=zh-cn" target="_blank" rel="noopener">Android官网-将构建配置从 Groovy 迁移到 KTS</a></p>
<p><a href="https://guides.gradle.org/migrating-build-logic-from-groovy-to-kotlin/" target="_blank" rel="noopener">Migrating build logic from Groovy to Kotlin</a></p>
<p><a href="https://github.com/gradle/kotlin-dsl-samples" target="_blank" rel="noopener">GitHub:kotlin-dsl-samples</a></p>
<p><a href="https://github.com/gradle/kotlin-dsl-samples/tree/master/samples/hello-android" target="_blank" rel="noopener">GitHub:kotlin-dsl-samples/samples/hello-android</a></p>
<p><a href="https://medium.com/android-dev-hacks/kotlin-dsl-gradle-scripts-in-android-made-easy-b8e2991e2ba" target="_blank" rel="noopener">Kotlin DSL: Gradle scripts in Android made easy</a></p>
<p><a href="https://docs.gradle.org/current/userguide/organizing_gradle_projects.html#sec:build_sources" target="_blank" rel="noopener">buildSrc官方文档</a></p>
<p><a href="https://medium.com/swlh/gradles-kotlin-dsl-buildsrc-4434100a07d7" target="_blank" rel="noopener">Gradle’s Kotlin DSL BuildSrc</a></p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Groovy</tag>
        <tag>kotlin</tag>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>ViewPager2+Fragment操作笔记</title>
    <url>/2021/05/14/android-widget-viewpager2/</url>
    <content><![CDATA[<h1 id="ViewPager2-Fragment操作笔记"><a href="#ViewPager2-Fragment操作笔记" class="headerlink" title="ViewPager2+Fragment操作笔记"></a>ViewPager2+Fragment操作笔记</h1><p><img src="https://img-blog.csdnimg.cn/img_convert/883382632cde26ae934f5a628e278ead.png#pic_center" alt="心情好"></p>
<h2 id="ViewPager2简介"><a href="#ViewPager2简介" class="headerlink" title="ViewPager2简介"></a>ViewPager2简介</h2><p><a href="https://developer.android.com/jetpack/androidx/releases/viewpager2" target="_blank" rel="noopener">ViewPager2官网介绍</a></p>
<p><a href="https://github.com/android/views-widgets-samples/tree/main/ViewPager2" target="_blank" rel="noopener">ViewPager2官网Samples</a></p>
<p>距离<code>ViewPager2</code>正式版的发布已经一年多了，目前<code>ViewPager</code>早已停止更新，官方鼓励使用ViewPager2替代。 <code>ViewPager2</code>底层基于<code>RecyclerView</code>实现，因此可以获得<code>RecyclerView</code>带来的诸多收益：</p>
<ul>
<li>抛弃传统的<code>PagerAdapter</code>，统一了<code>Adapter</code>的<code>API</code>；</li>
<li>横向、竖向布局都可以实现自由滑动；</li>
<li>支持<code>DiffUitl</code>，可以实现局部刷新；</li>
<li>支持<code>RTL</code>（right-to-left），对于一些有出海需求的APP非常有用；</li>
<li>支持<code>ItemDecorator</code>，搭配<code>PageTransformer</code>实现炫酷的跳转动画；</li>
</ul>
<p><code>ViewPager2</code>更多的是配合<code>Fragment</code>的使用，这需要借助于<code>FragmentStateAdapter</code>。</p>
<p>他们偶尔会搭配<code>TabLayout</code>一起使用，相关代码直接阅读或者运行 <a href="https://github.com/android/views-widgets-samples/tree/main/ViewPager2" target="_blank" rel="noopener">ViewPager2官网Samples</a> 即可，这里不做重复的讲解。</p>
<p>下面主要讲一下在使用过程中遇到的问题~！</p>
<h2 id="实际操作效果"><a href="#实际操作效果" class="headerlink" title="实际操作效果"></a>实际操作效果</h2><p>上滑吸顶+标题页面左右滑动+横滑和竖滑列表+标题页面数据和数量更新</p>
<blockquote>
<p>上滑吸顶<br><code>CoordinatorLayout</code>+<code>AppBarLayout</code>+<code>CollapsingToolbarLayout</code><br>左右滑动<br><code>ViewPager2</code>+<code>TabLayout</code>+<code>Fragment</code><br>横滑和竖滑列表<br><code>RecycleView</code>+<code>NestedScrollableHost</code><br>标题页面数据和数量<br><code>TabLayoutMediator</code>+声明周期检测+缓存优化</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/img_convert/d092f1350385f7da3a65aa5c841452b5.gif#pic_center" alt="viewpage2_tabLayout_nestedscroll.gif"></p>
<h2 id="RecycleView和Viewpage2的滑动冲突"><a href="#RecycleView和Viewpage2的滑动冲突" class="headerlink" title="RecycleView和Viewpage2的滑动冲突"></a>RecycleView和Viewpage2的滑动冲突</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Tanzhenxing</span></span><br><span class="line"><span class="comment"> * Date: 2021/4/7 7:04 下午</span></span><br><span class="line"><span class="comment"> * Description:解决 [RecyclerView] 嵌套到 [androidx.viewpager2.widget.ViewPager2] 左右滑动冲突</span></span><br><span class="line"><span class="comment"> * 目前只解决了左右滑动冲突</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecyclerViewAtViewPager2</span> : <span class="type">RecyclerView &#123;</span></span></span><br><span class="line">    <span class="keyword">constructor</span>(context: Context) : <span class="keyword">this</span>(context, <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">constructor</span>(context: Context, attrs: AttributeSet?) : <span class="keyword">this</span>(context, attrs, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">constructor</span>(context: Context, attrs: AttributeSet?, defStyleAttr: <span class="built_in">Int</span>) : <span class="keyword">super</span>(context, attrs, defStyleAttr)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> x1 = <span class="number">0</span>f</span><br><span class="line">    <span class="keyword">var</span> x2 = <span class="number">0</span>f</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dispatchTouchEvent</span><span class="params">(event: <span class="type">MotionEvent</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(event!!.action == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            x1 = event.x</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(event.action == MotionEvent.ACTION_MOVE) &#123;</span><br><span class="line">            x2 = event.x</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.action == MotionEvent.ACTION_CANCEL</span><br><span class="line">            || event.action == MotionEvent.ACTION_UP) &#123;</span><br><span class="line">            x2 = <span class="number">0</span>f</span><br><span class="line">            x1 = <span class="number">0</span>f</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> xOffset= x2-x1</span><br><span class="line">        <span class="keyword">if</span> (layoutManager <span class="keyword">is</span> LinearLayoutManager) &#123;</span><br><span class="line">            <span class="keyword">val</span> linearLayoutManager = layoutManager <span class="keyword">as</span> LinearLayoutManager</span><br><span class="line">            <span class="keyword">if</span> (linearLayoutManager.orientation == HORIZONTAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((xOffset &lt;= <span class="number">0</span> &amp;&amp; canScrollHorizontally(<span class="number">1</span>))</span><br><span class="line">                    || (xOffset &gt;= <span class="number">0</span> &amp;&amp; canScrollHorizontally(<span class="number">-1</span>))) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.parent?.requestDisallowInterceptTouchEvent(<span class="literal">true</span>)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.parent?.requestDisallowInterceptTouchEvent(<span class="literal">false</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> 2021/4/8 目前没有实现上下滑动和 [androidx.viewpager2.widget.ViewPager2]上下滑动的冲突</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            handleDefaultScroll()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">handleDefaultScroll</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> canScrollHorizontally = canScrollHorizontally(<span class="number">-1</span>) || canScrollHorizontally(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">val</span> canScrollVertically = canScrollVertically(<span class="number">-1</span>) || canScrollVertically(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> (canScrollHorizontally || canScrollVertically) &#123;</span><br><span class="line">            <span class="keyword">this</span>.parent?.requestDisallowInterceptTouchEvent(<span class="literal">true</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.parent?.requestDisallowInterceptTouchEvent(<span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ViewPager2中Fragment的懒加载"><a href="#ViewPager2中Fragment的懒加载" class="headerlink" title="ViewPager2中Fragment的懒加载"></a>ViewPager2中Fragment的懒加载</h2><h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><p>一般我们使用<code>Fragment</code>对页面进行数据懒加载的时候都是通过<code>onHiddenChanged</code>方法判断显示和隐藏，在<strong>第一次展现</strong>出来的时候再进行接口调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">onHiddenChanged</span><span class="params">(<span class="keyword">boolean</span> hidden)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.onHiddenChanged(hidden);</span><br><span class="line">  <span class="keyword">if</span> (!hidden) &#123;</span><br><span class="line">    onUserVisible();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    onUserGone();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但在<code>ViewPager2</code>中，<code>Fragment</code>的<code>setUserVisibleHint</code>和<code>onHiddenChanged</code>方法都是不执行的。</p>
<ul>
<li><code>ViewPager</code>展现第一个页面，然后切后台的日志：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">04</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">45</span>:<span class="number">10.992</span> D/tanzhenxing:<span class="number">11</span>(<span class="number">22006</span>): onCreate</span><br><span class="line"><span class="number">04</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">45</span>:<span class="number">10.992</span> D/tanzhenxing:<span class="number">11</span>(<span class="number">22006</span>): onCreateView:</span><br><span class="line"><span class="number">04</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">45</span>:<span class="number">11.004</span> D/tanzhenxing:<span class="number">11</span>(<span class="number">22006</span>): onActivityCreated</span><br><span class="line"><span class="number">04</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">45</span>:<span class="number">11.004</span> D/tanzhenxing:<span class="number">11</span>(<span class="number">22006</span>): onViewStateRestored: <span class="number">184310198</span></span><br><span class="line"><span class="number">04</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">45</span>:<span class="number">11.004</span> D/tanzhenxing:<span class="number">11</span>(<span class="number">22006</span>): onStart</span><br><span class="line"><span class="number">04</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">45</span>:<span class="number">11.004</span> D/tanzhenxing:<span class="number">11</span>(<span class="number">22006</span>): onResume</span><br><span class="line"><span class="number">04</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">45</span>:<span class="number">18.739</span> D/tanzhenxing:<span class="number">11</span>(<span class="number">22006</span>): onPause</span><br><span class="line"><span class="number">04</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">45</span>:<span class="number">18.779</span> D/tanzhenxing:<span class="number">11</span>(<span class="number">22006</span>): onStop</span><br></pre></td></tr></table></figure>
<p>然后在切回前台的日志：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">04</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">53</span>:<span class="number">40.749</span> D/tanzhenxing:<span class="number">11</span>(<span class="number">22006</span>): onStart</span><br><span class="line"><span class="number">04</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">53</span>:<span class="number">40.752</span> D/tanzhenxing:<span class="number">11</span>(<span class="number">22006</span>): onResume</span><br></pre></td></tr></table></figure>
<ul>
<li><code>ViewPager</code>展现第一个页面，然后手动滑动到第二个页面日志：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">04</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">44.168</span> D/tanzhenxing:<span class="number">12</span>(<span class="number">22006</span>): onCreate</span><br><span class="line"><span class="number">04</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">44.168</span> D/tanzhenxing:<span class="number">12</span>(<span class="number">22006</span>): onCreateView:</span><br><span class="line"><span class="number">04</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">44.178</span> D/tanzhenxing:<span class="number">12</span>(<span class="number">22006</span>): onActivityCreated</span><br><span class="line"><span class="number">04</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">44.178</span> D/tanzhenxing:<span class="number">12</span>(<span class="number">22006</span>): onViewStateRestored: <span class="number">47009644</span></span><br><span class="line"><span class="number">04</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">44.178</span> D/tanzhenxing:<span class="number">12</span>(<span class="number">22006</span>): onStart</span><br><span class="line"><span class="number">04</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">44.553</span> D/tanzhenxing:<span class="number">11</span>(<span class="number">22006</span>): onPause</span><br><span class="line"><span class="number">04</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">54</span>:<span class="number">44.554</span> D/tanzhenxing:<span class="number">12</span>(<span class="number">22006</span>): onResume</span><br></pre></td></tr></table></figure>
<p>这样看起来我们是可以利用<code>Fragment</code>声明周期中的<code>onStart</code>和<code>onResume</code>方法做懒加载。</p>
<h3 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h3><p>只要讲数据请求写在 <code>onCreateView</code> 或者<code>onStart</code>中就能进行接口的离屏请求。</p>
<h2 id="FragmentStateAdapter"><a href="#FragmentStateAdapter" class="headerlink" title="FragmentStateAdapter"></a>FragmentStateAdapter</h2><p><code>ViewPager2</code>继承自<code>RecyclerView</code>，大概率<code>FragmentStateAdapter</code>继承自<code>RecyclerView.Adapter</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FragmentStateAdapter</span> <span class="title">extends</span> </span></span><br><span class="line">  RecyclerView.Adapter&lt;FragmentViewHolder&gt; implements StatefulAdapter &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="onCreateViewHolder"><a href="#onCreateViewHolder" class="headerlink" title="onCreateViewHolder"></a>onCreateViewHolder</h3><p><code>onCreateViewHolder</code>是<code>RecycleVeiw</code>用于创建<code>ViewHolder</code>的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> FragmentViewHolder <span class="title">onCreateViewHolder</span><span class="params">(@NonNull ViewGroup parent, <span class="keyword">int</span> viewType)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> FragmentViewHolder.create(parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>FragmentViewHolder</code>的主要作用是通过<code>FrameLayout</code>为<code>Fragment</code>提供用作容器的<code>container</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> FragmentViewHolder <span class="title">create</span><span class="params">(@NonNull</span></span></span><br><span class="line"><span class="function"><span class="params">ViewGroup parent)</span> </span>&#123;</span><br><span class="line">    FrameLayout container = <span class="keyword">new</span> FrameLayout(parent.getContext());</span><br><span class="line">    container.setLayoutParams(<span class="keyword">new</span> ViewGroup.LayoutParams(</span><br><span class="line">            ViewGroup.LayoutParams.MATCH_PARENT,</span><br><span class="line">            ViewGroup.LayoutParams.MATCH_PARENT));</span><br><span class="line">    container.setId(ViewCompat.generateViewId());</span><br><span class="line">    container.setSaveEnabled(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FragmentViewHolder(container);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="onBindViewHolder"><a href="#onBindViewHolder" class="headerlink" title="onBindViewHolder"></a>onBindViewHolder</h3><p><code>onBindViewHolder</code>是<code>RecycleVeiw</code>用于数据绑定的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(<span class="keyword">final</span> @NonNull FragmentViewHolder holder, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**部分代码省略 */</span></span><br><span class="line">	  ensureFragment(position);</span><br><span class="line">    <span class="comment">/**部分代码省略 */</span></span><br><span class="line">  	gcFragments();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ensureFragment(position)</code>，其内部会最终回调用<code>createFragment</code>创建当前<code>Fragment</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureFragment</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> itemId = getItemId(position);</span><br><span class="line">  <span class="keyword">if</span> (!mFragments.containsKey(itemId)) &#123;</span><br><span class="line">    <span class="comment">// TODO(133419201): check if a Fragment provided here is a new Fragment</span></span><br><span class="line">    Fragment newFragment = createFragment(position);</span><br><span class="line">    newFragment.setInitialSavedState(mSavedStates.get(itemId));</span><br><span class="line">    mFragments.put(itemId, newFragment);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>mFragments</code>缓存创建的<code>Fragment</code>，供后面<code>placeFramentInViewholder</code>使用; <code>gcFragments</code>回收已经不再使用的的<code>Fragment</code>（<strong>对应的item已经删除</strong>），节省内存开销。</p>
<h3 id="onViewAttachedToWindow"><a href="#onViewAttachedToWindow" class="headerlink" title="onViewAttachedToWindow"></a>onViewAttachedToWindow</h3><p><code>onViewAttachedToWindow</code>是<code>ViewHolder</code>出现在页面中回调。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public final void onViewAttachedToWindow(@NonNull final FragmentViewHolder holder) &#123;</span><br><span class="line">    //将FragmentViewHolder的container与当前Fragment绑定</span><br><span class="line">	  placeFragmentInViewHolder(holder);</span><br><span class="line">  	gcFragments();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="FragmentStateAdapter使用"><a href="#FragmentStateAdapter使用" class="headerlink" title="FragmentStateAdapter使用"></a>FragmentStateAdapter使用</h3><ul>
<li><code>Fragment</code>对象容器;</li>
<li>生产<code>fragment</code>识别的<code>id</code>；</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFragmentStateAdapter</span></span>(<span class="keyword">val</span> <span class="keyword">data</span>: List&lt;<span class="built_in">Int</span>&gt;, fragment: Fragment) : FragmentStateAdapter(fragment)&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> fragments = mutableMapOf&lt;<span class="built_in">Int</span>, Fragment&gt;()</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">createFragment</span><span class="params">(position: <span class="type">Int</span>)</span></span>: Fragment &#123;</span><br><span class="line">        <span class="keyword">val</span> value = <span class="keyword">data</span>[position]</span><br><span class="line">        <span class="keyword">val</span> fragment = fragments[value]</span><br><span class="line">        <span class="keyword">if</span> (fragment != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> fragment</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> cardFragment =</span><br><span class="line">            NestedAllRecyclerViewFragment.create(value)</span><br><span class="line">        fragments[value] = cardFragment</span><br><span class="line">        <span class="keyword">return</span> cardFragment</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据数据生成唯一id</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如果不重写，那么在调用[notifyDataSetChanged]更新的时候</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 会抛出```new IllegalStateException("Fragment already added")```异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemId</span><span class="params">(position: <span class="type">Int</span>)</span></span>: <span class="built_in">Long</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">data</span>[position].toLong()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来判断当前id对应的fragment是否添加过</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">containsItem</span><span class="params">(itemId: <span class="type">Long</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">data</span>.forEach &#123;</span><br><span class="line">            <span class="keyword">if</span> (it.toLong() == itemId) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemCount</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">data</span>.size</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在进行</p>
<h3 id="获取Fragment实例"><a href="#获取Fragment实例" class="headerlink" title="获取Fragment实例"></a>获取Fragment实例</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getCurrentFragment</span><span class="params">(position: <span class="type">Int</span>)</span></span>: Fragment? =</span><br><span class="line">        fragment.childFragmentManager.findFragmentByTag(<span class="string">"f<span class="variable">$position</span>"</span>)</span><br></pre></td></tr></table></figure>
<p>源码分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FragmentStateAdapter</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">Adapter</span>&lt;<span class="title">FragmentViewHolder</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">StatefulAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**部分代码省略 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">placeFragmentInViewHolder</span><span class="params">(@NonNull</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> FragmentViewHolder holder)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**部分代码省略 */</span></span><br><span class="line">        <span class="keyword">if</span> (!shouldDelayFragmentTransactions()) &#123;</span><br><span class="line">            scheduleViewAttach(fragment, container);</span><br><span class="line">            mFragmentManager.beginTransaction()</span><br><span class="line">                            .add(fragment, <span class="string">"f"</span> + holder.getItemId())</span><br><span class="line">                            .setMaxLifecycle(fragment, STARTED).commitNow();</span><br><span class="line">            mFragmentMaxLifecycleEnforcer.updateFragmentMaxLifecycle(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**部分代码省略 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**部分代码省略 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getItemId</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> position;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给<code>Fragment</code>添加的<code>TAG</code>是<code>&quot;f&quot; + holder.getItemId()</code>。</p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><ul>
<li>初始化时遇到的崩溃；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Fragment HomeFragment&#123;b793d14 (e67290fe-<span class="number">7</span>ab1-<span class="number">4</span>b2b-b98c-<span class="number">4e08</span>d146644c)&#125; has not been attached yet.</span><br><span class="line">com.xxx.xxx.xxx.adapter.HomeFragmentStateAdapter.&lt;init&gt;(SourceFile:<span class="number">29</span>)</span><br></pre></td></tr></table></figure>
<p>在开发过程中遇到问题，需要在构造<code>FragmentStateAdapter</code>的时候对<code>Fragment</code>的状态做判断<code>isAdded()</code>。</p>
<ul>
<li>更新数据的时候遇到的崩溃：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Fragment already added</span><br></pre></td></tr></table></figure>
<p>重写<code>getItemId</code>方法，该方法返回的值与数据有关而不是与数据在列表中的索引有关。因为它代表着<code>Fragment</code>的唯一性，是否可以复用。</p>
<h2 id="ViewPager2滑动监听"><a href="#ViewPager2滑动监听" class="headerlink" title="ViewPager2滑动监听"></a>ViewPager2滑动监听</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OnPageChangeCallback</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当前页面开始滑动时</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageScrolled</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">float</span> positionOffset,@Px <span class="keyword">int</span> positionOffsetPixels)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当页面被选中时</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageSelected</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当前页面滑动状态变动时</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageScrollStateChanged</span><span class="params">(@ScrollState <span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pageChangeCallback = <span class="keyword">object</span> : ViewPager2.OnPageChangeCallback() &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPageSelected</span><span class="params">(position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//需要注意的是postion需要做大于0的判断</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="TabLayout-TabLayoutMediator"><a href="#TabLayout-TabLayoutMediator" class="headerlink" title="TabLayout+TabLayoutMediator"></a>TabLayout+TabLayoutMediator</h2><p>方便实现<code>TAB</code>和<code>ViewPager</code>滑动或跳转的关联。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">'com.google.android.material:material:1.2.0'</span></span><br></pre></td></tr></table></figure>
<p>建议<code>material</code>的版本号大约<code>1.0.0</code>，否则实现<code>TAB</code>的自定义布局宽度展现些问题。</p>
<p>使用：<a href="https://github.com/android/views-widgets-samples/tree/main/ViewPager2" target="_blank" rel="noopener">ViewPager2官网Samples</a></p>
<h2 id="DiffUtil-局部更新"><a href="#DiffUtil-局部更新" class="headerlink" title="DiffUtil 局部更新"></a>DiffUtil 局部更新</h2><p><a href="https://ishare.58corp.com/articleDetail?id=41897" target="_blank" rel="noopener">DiffUtil和它的差量算法</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了<code>ViewPager2</code>配合<code>Fragment</code>的使用方法以及在使用过程中需要注意的问题，顺带提到了<strong>TabLayout</strong>、<strong>OnPageChangeCallback</strong>、<strong>DiffUtil</strong>等。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>ViewPager2</tag>
        <tag>Fragment</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程池实现原理和源码分析</title>
    <url>/2021/02/19/java-thread-poll-1/</url>
    <content><![CDATA[<h1 id="Java线程池实现原理和源码分析"><a href="#Java线程池实现原理和源码分析" class="headerlink" title="Java线程池实现原理和源码分析"></a>Java线程池实现原理和源码分析</h1><p><img src="https://img-blog.csdnimg.cn/img_convert/dc61b582844cf193af46b8f90f480960.png#pic_center" alt=""></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文章是从2019年11月下旬开始打开写的，一直拖到2020年的年尾才开始写，直到2021年年初才写完。</p>
<p>时间太快也太慢~！</p>
<p>依稀记得2019年10月份的时候某东从创业公司离职打算面试找工作，他问我线程池你会么？然后给我他发了一篇我2017年写的笔记《Java并发编程之线程池必用知识点》，他说就这么点？我当时想线程池也差不多就这么多吧~！</p>
<p>2019年11月9号我和某东一起从大望路做815公交去燕郊。当时只是因为我正在学习一部分多线程相关的知识点，刚好公交车上没啥事情我俩就唠了唠。当时他问了我一些线程池的问题，我觉得在平时的工作线程池知道该怎么用就行顶多优化一下核心线程数量。主要讨论的还是多线程并发和锁的相关问题。</p>
<p>年底工作一般比较忙也就很少进行自我学习了，隔了一周想起了某东问我的问题“线程池中线程是怎么产生的，任务是怎么等待执行？”。</p>
<p>自己也不是很清楚这块的逻辑，临时把这个TODO项纪录了下来，想以后有时间了研究一下。结果这个以后跨越了2019年和2020年直接来到了2021年。</p>
<p>原谅我的啰里啰嗦，关键这个篇文章时间跨度太长了，给我的印象太深了。不得不说道说道，下面开始进去正题~！</p>
<p><code>JDK1.8</code>的源码来分析Java线程池的核心设计与实现。</p>
<p>本文参考了<a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html" target="_blank" rel="noopener">Java线程池实现原理及其在美团业务中的实践</a>这篇文章中的部分内容。</p>
<p><a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html" target="_blank" rel="noopener">Java线程池实现原理及其在美团业务中的实践</a>这篇文章写的非常好，除过本文内容之外这篇文章还讲述了的关于<strong>线程池的背景</strong>，<strong>线程池在业务中的实践</strong>和<strong>动态化线程池</strong>等，所以想了解线程池关于这些类容的可以阅读<a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html" target="_blank" rel="noopener">Java线程池实现原理及其在美团业务中的实践</a>这篇文章。</p>
<p>如果读者为做服务端开发的同学那么强烈建议阅读<a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html" target="_blank" rel="noopener">Java线程池实现原理及其在美团业务中的实践</a>。</p>
<h1 id="外观"><a href="#外观" class="headerlink" title="外观"></a>外观</h1><p><strong>外观</strong>主要是我们平常使用线程池的时候所看到的一些点。</p>
<ul>
<li>继承关系；</li>
<li>构造函数；</li>
<li>构造函数中的参数；</li>
<li>构造函数中的阻塞队列；</li>
<li>线程池的创建；</li>
<li>构造函数中的拒绝策略；</li>
</ul>
<h2 id="线程池继承关系"><a href="#线程池继承关系" class="headerlink" title="线程池继承关系"></a>线程池继承关系</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/a664410799a9e282b2235609a652ef21.png#pic_center =240x300" alt="ThreadPoolExecutor-uml.png"></p>
<p><code>ThreadPoolExecutor</code>实现的顶层接口是<code>Executor</code>，在接口<code>Executor</code>中用户无需关注如何创建线程，如何调度线程来执行任务，用户只需提供<code>Runnable</code>对象，将任务的运行逻辑提交到执行器<code>Executor</code>中，由<code>Executor</code>框架完成线程的调配和任务的执行部分。</p>
<p><code>ExecutorService</code>接口增加了一些能力：</p>
<ol>
<li>扩充执行任务的能力，补充可以为一个或一批异步任务生成<code>Future</code>的方法；</li>
<li>提供了管控线程池的方法，比如停止线程池的运行。</li>
</ol>
<p><code>AbstractExecutorService</code>则是上层的抽象类，将执行任务的流程串联了起来，保证下层的实现只需关注一个执行任务的方法即可。</p>
<p>最下层的实现类<code>ThreadPoolExecutor</code>实现最复杂的运行部分:</p>
<ol>
<li><p>可以自动创建、管理和复用指定数量的一组线程，适用方只需提交任务即可</p>
</li>
<li><p>线程安全，<code>ThreadPoolExecutor</code>内部有状态、核心线程数、非核心线程等属性，广泛使用了<strong>CAS</strong>和<strong>AQS</strong>锁机制避免并发带来的冲突问题</p>
</li>
<li><p>提供了核心线程、缓冲阻塞队列、非核心线程、抛弃策略的概念，可以根据实际应用场景进行组合使用</p>
</li>
<li><p>提供了<code>beforeExecute</code> 和<code>afterExecute()</code>可以支持对线程池的功能进行扩展</p>
</li>
</ol>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>corePoolSize</strong>：线程池的核心线程数，一般情况下不管有没有任务都会一直在线程池中一直存活，只有在 <code>ThreadPoolExecutor</code>中的方法<code>allowCoreThreadTimeOut(boolean value)</code>设置为<code>true</code>时，闲置的核心线程会存在超时机制，如果在指定时间没有新任务来时，核心线程也会被终止，而这个时间间隔由第3个属性 <code>keepAliveTime</code>指定。</li>
<li><strong>maximumPoolSize</strong>：线程池所能容纳的最大线程数，当活动的线程数达到这个值后，后续的新任务将会被阻塞。</li>
<li><strong>keepAliveTime</strong>：控制线程闲置时的超时时长，超过则终止该线程。一般情况下用于非核心线程，只有在 <code>ThreadPoolExecutor</code>中的方法<code>allowCoreThreadTimeOut(boolean value)</code>设置为<code>true</code>时，也作用于核心线程。</li>
<li><strong>unit</strong>：用于指定<code>keepAliveTime</code>参数的时间单位，<code>TimeUnit</code>是个<code>enum</code>枚举类型，常用的有：<code>TimeUnit.HOURS(小时)</code>、<code>TimeUnit.MINUTES(分钟)</code>、<code>TimeUnit.SECONDS(秒)</code>和 <code>TimeUnit.MILLISECONDS(毫秒)</code>等。</li>
<li><strong>workQueue</strong>：线程池的任务队列，通过线程池的<code>execute(Runnable command)</code>方法会将任务<code>Runnable</code>存储在队列中。</li>
<li><strong>threadFactory</strong>：线程工厂，它是一个接口，用来为线程池创建新线程的。</li>
<li><strong>handler</strong>：拒绝策略，所谓拒绝策略，是指将任务添加到线程池中时，线程池拒绝该任务所采取的相应策略。</li>
</ul>
<h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 任务阻塞队列 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue; </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非公平的互斥锁（可重入锁）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程集合一个Worker对应一个线程，没有核心线程的说话，只有核心线程数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配合mainLock通过Condition能够更加精细的控制多线程的休眠与唤醒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition termination = mainLock.newCondition();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程池中线程数量曾经达到过的最大值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 已完成任务数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> completedTaskCount;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ThreadFactory对象，用于创建线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拒绝策略的处理句柄</span></span><br><span class="line"><span class="comment"> * 现在默认提供了CallerRunsPolicy、AbortPolicy、DiscardOldestPolicy、DiscardPolicy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程池维护线程（超过核心线程数）所允许的空闲时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> keepAliveTime;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 允许线程池中的核心线程超时进行销毁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> allowCoreThreadTimeOut;  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程池维护线程的最小数量，哪怕是空闲的  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程池维护的最大线程数量，线程数超过这个数量之后新提交的任务就需要进入阻塞队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> maximumPoolSize;</span><br></pre></td></tr></table></figure>
<h2 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h2><p><code>Executors</code>提供获取几种常用的线程池的方法：</p>
<ul>
<li><strong>缓存程线程池</strong></li>
</ul>
<blockquote>
<p><code>newCachedThreadPool</code>是一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。调用 <code>execute()</code> 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。因此，长时间保持空闲的线程池不会使用任何资源。注意，可以使用 <code>ThreadPoolExecutor</code> 构造方法创建具有类似属性但细节不同（例如超时参数）的线程池。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>单线程线程池</strong></li>
</ul>
<blockquote>
<p><code>newSingleThreadExecutor</code> 创建是一个单线程池，也就是该线程池只有一个线程在工作，所有的任务是串行执行的，如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它，此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">    (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>固定大小线程池</strong></li>
</ul>
<blockquote>
<p><code>newFixedThreadPool</code> 创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小，线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>单线程线程池</strong></li>
</ul>
<blockquote>
<p><code>newScheduledThreadPool</code> 创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static ScheduledExecutorService newScheduledThreadPool(</span><br><span class="line">    int corePoolSize, ThreadFactory threadFactory) &#123;</span><br><span class="line">  return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);</span><br><span class="line">&#125;</span><br><span class="line">public ScheduledThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                   ThreadFactory threadFactory) &#123;</span><br><span class="line">  super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,</span><br><span class="line">      new DelayedWorkQueue(), threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看出来上面的方法一共使用了<code>DelayedWorkQueue</code>、<code>LinkedBlockingQueue</code> 和 <code>SynchronousQueue</code>。这个就是线程核心之一的阻塞队列。</p>
<h2 id="任务阻塞队列"><a href="#任务阻塞队列" class="headerlink" title="任务阻塞队列"></a>任务阻塞队列</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/468012bde8d6b6b85e366776d6dc9894.png#pic_center" alt="BlockingQueue.png"></p>
<p><strong>它一般分为直接提交队列、有界任务队列、无界任务队列、优先任务队列；</strong></p>
<h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><p>1、<strong>直接提交队列</strong>：设置为<code>SynchronousQueue</code>队列，<code>SynchronousQueue</code>是一个特殊的<code>BlockingQueue</code>，它没有容量，每执行一个插入操作就会阻塞，需要再执行一个删除操作才会被唤醒，反之每一个删除操作也都要等待对应的插入操作。</p>
<p>使用<code>SynchronousQueue</code>队列，提交的任务不会被保存，总是会马上提交执行。如果用于执行任务的线程数量小于<code>maximumPoolSize</code>，则尝试创建新的进程，如果达到<code>maximumPoolSize</code>设置的最大值，则根据你设置的<code>handler</code>执行拒绝策略。因此这种方式你提交的任务不会被缓存起来，而是会被马上执行，在这种情况下，你需要对你程序的并发量有个准确的评估，才能设置合适的<code>maximumPoolSize</code>数量，否则很容易就会执行拒绝策略；</p>
<h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p>2、<strong>有界的任务队列</strong>：有界的任务队列可以使用<code>ArrayBlockingQueue</code>实现，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pool = new ThreadPoolExecutor(1, 2, 1000, TimeUnit.MILLISECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(10),Executors.defaultThreadFactory(),new ThreadPoolExecutor.AbortPolicy());</span><br></pre></td></tr></table></figure>
<p>使用<code>ArrayBlockingQueue</code>有界任务队列，若有新的任务需要执行时，线程池会创建新的线程，直到创建的线程数量达到<code>corePoolSize</code>时，则会将新的任务加入到等待队列中。若等待队列已满，即超过<code>ArrayBlockingQueue</code>初始化的容量，则继续创建线程，直到线程数量达到<code>maximumPoolSize</code>设置的最大线程数量，若大于<code>maximumPoolSize</code>，则执行拒绝策略。在这种情况下，线程数量的上限与有界任务队列的状态有直接关系，如果有界队列初始容量较大或者没有达到超负荷的状态，线程数将一直维持在<code>corePoolSiz</code>e以下，反之当任务队列已满时，则会以<code>maximumPoolSize</code>为最大线程数上限。</p>
<h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p>3、<strong>无界的任务队列</strong>：无界任务队列可以使用<code>LinkedBlockingQueue</code>实现，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pool = new ThreadPoolExecutor(1, 2, 1000, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(),Executors.defaultThreadFactory(),new ThreadPoolExecutor.AbortPolicy());</span><br></pre></td></tr></table></figure>
<p>使用无界任务队列，线程池的任务队列可以无限制的添加新的任务，而线程池创建的最大线程数量就是你<code>corePoolSize</code>设置的数量，也就是说在这种情况下<code>maximumPoolSize</code>这个参数是无效的，哪怕你的任务队列中缓存了很多未执行的任务，当线程池的线程数达到<code>corePoolSize</code>后，就不会再增加了；若后续有新的任务加入，则直接进入队列等待，当使用这种任务队列模式时，一定要注意你任务提交与处理之间的协调与控制，不然会出现队列中的任务由于无法及时处理导致一直增长，直到最后资源耗尽的问题。</p>
<h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><p>4<strong>、优先任务队列：</strong>优先任务队列通过<code>PriorityBlockingQueue</code>实现：</p>
<p>任务会按优先级重新排列执行，且线程池的线程数一直为<code>corePoolSize</code>，也就是只有一个。</p>
<p><code>PriorityBlockingQueue</code>其实是一个特殊的无界队列，它其中无论添加了多少个任务，线程池创建的线程数也不会超过<code>corePoolSize</code>的数量，只不过其他队列一般是按照先进先出的规则处理任务，而<code>PriorityBlockingQueue</code>队列可以自定义规则根据任务的优先级顺序先后执行。</p>
<p>其实<code>LinkedBlockingQueue</code>也是可以设置界限的，它默认的界限是<code>Integer.MAX_VALUE</code>。同时也支持也支持构造的时候设置队列大小。</p>
<h2 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当<code>Executor</code>已经关闭，即执行了<code>executorService.shutdown()</code>方法后，或者<code>Executor</code>将有限边界用于最大线程和工作队列容量，且已经饱和时。使用方法<code>execute()</code>提交的新任务将被拒绝.<br>在以上述情况下，<code>execute</code>方法将调用其<code>RejectedExecutionHandler</code>的 <code>RejectedExecutionHandler.rejectedExecution(java.lang.Runnable, java.util.concurrent.ThreadPoolExecutor)</code>方法。</p>
<h3 id="AbortPolicy-默认的拒绝策略"><a href="#AbortPolicy-默认的拒绝策略" class="headerlink" title="AbortPolicy 默认的拒绝策略"></a>AbortPolicy 默认的拒绝策略</h3><p>也称为终止策略，遭到拒绝将抛出运行时<code>RejectedExecutionException</code>。业务方能通过捕获异常及时得到对本次任务提交的结果反馈。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AbortPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AbortPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Task "</span> + r.toString() +</span><br><span class="line">                                         <span class="string">" rejected from "</span> +</span><br><span class="line">                                         e.toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CallerRunsPolicy"><a href="#CallerRunsPolicy" class="headerlink" title="CallerRunsPolicy"></a>CallerRunsPolicy</h3><p>拥有自主反馈控制，让提交者执行提交任务，能够减缓新任务的提交速度。这种情况是需要让所有的任务都执行完毕。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallerRunsPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CallerRunsPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">            r.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DiscardPolicy"><a href="#DiscardPolicy" class="headerlink" title="DiscardPolicy"></a>DiscardPolicy</h3><p>拒绝任务的处理程序，静默丢弃任务。使用此策略，我们可能无法感知系统的异常状态。慎用~！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DiscardOldestPolicy"><a href="#DiscardOldestPolicy" class="headerlink" title="DiscardOldestPolicy"></a>DiscardOldestPolicy</h3><p>丢弃队列中最前面的任务，然后重新提交被拒绝的任务。是否要使用此策略需要看业务是否需要新老的替换，慎用~！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardOldestPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardOldestPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">            e.getQueue().poll();</span><br><span class="line">            e.execute(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h1><p>前面讲了<strong>线程池的外观</strong>，接下来讲述它的<strong>内核</strong>。</p>
<p>线程池在内部实际上构建了一个<strong>生产者消费者模型</strong>，将<code>线程</code>和<code>任务</code>两者解耦，并不直接关联，从而良好的缓冲任务，复用线程。</p>
<p>线程池的运行主要分成两部分：任务管理、线程管理。</p>
<p>任务管理部分充当生产者的角色，当任务提交后，线程池会判断该任务后续的流转：</p>
<ol>
<li>直接申请线程执行该任务；</li>
<li>缓冲到队列中等待线程执行；</li>
<li>拒绝该任务。</li>
</ol>
<p>线程管理部分是消费者，它们被统一维护在线程池内，根据任务请求进行线程的分配，当线程执行完任务后则会继续获取新的任务去执行，最终当线程获取不到任务的时候，线程就会被回收。</p>
<p>接下来，我们会按照以下三个部分去详细讲解线程池运行机制：</p>
<ol>
<li>线程池如何维护自身状态。</li>
<li>线程池如何管理任务。</li>
<li>线程池如何管理线程。</li>
</ol>
<h2 id="线程池的生命周期"><a href="#线程池的生命周期" class="headerlink" title="线程池的生命周期"></a>线程池的生命周期</h2><p>线程池运行的状态，并不是用户显式设置的，而是伴随着线程池的运行，由内部来维护。</p>
<p>线程池内部使用一个变量维护两个值：运行状态(<code>runState</code>)和线程数量 (<code>workerCount</code>)。</p>
<p>在具体实现中，线程池将运行状态(<code>runState</code>)、线程数量 (<code>workerCount</code>)两个关键参数的维护放在了一起:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br></pre></td></tr></table></figure>
<p><code>ctl</code>这个<code>AtomicInteger</code>类型，是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段.</p>
<p>它同时包含两部分的信息：线程池的运行状态 (<code>runState</code>) 和线程池内有效线程的数量 (<code>workerCount</code>)，高<strong>3位</strong>保存<code>runState</code>，低<strong>29</strong>位保存<code>workerCount</code>，两个变量之间互不干扰。</p>
<blockquote>
<p>用一个变量去存储两个值，可避免在做相关决策时，出现不一致的情况，不必为了维护两者的一致，而占用锁资源。通过阅读线程池源代码也可以发现，经常出现要同时判断线程池运行状态和线程数量的情况。线程池也提供了若干方法去供用户获得线程池当前的运行状态、线程个数。这里都使用的是位运算的方式，相比于基本运算，速度也会快很多(PS:这种用法在许多源代码中都可以看到)。</p>
</blockquote>
<p>关于内部封装的获取生命周期状态、获取线程池线程数量的计算方法如以下代码所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;<span class="comment">//32-3</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;<span class="comment">//低29位都为1，高位都为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;<span class="comment">//111</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;<span class="comment">//000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;<span class="comment">//001</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;<span class="comment">//010</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;<span class="comment">//011</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Packing and unpacking ctl</span></span><br><span class="line"><span class="comment">//计算当前运行状态，取高三位</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="comment">//计算当前线程数量，取低29位</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="comment">//通过状态和线程数生成ctl</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure>
<p><code>ThreadPoolExecutor</code>的运行状态有5种，分别为：</p>
<table>
<thead>
<tr>
<th style="text-align:center">运行状态</th>
<th>状态描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">RUNNING</td>
<td>能接受新提交的任务，并且也能处理阻塞队列中的任务</td>
</tr>
<tr>
<td style="text-align:center">SHUTDOWN</td>
<td>不能接受新提交的任务，但却可以继续处理阻塞队列中的任务</td>
</tr>
<tr>
<td style="text-align:center">STOP</td>
<td>不能接受新任务，也不能处理队列中的任务同时会中断正在处理的任务线程</td>
</tr>
<tr>
<td style="text-align:center">TIDYING</td>
<td>所有的任务都已经终止，workCount（有效线程数）为0</td>
</tr>
<tr>
<td style="text-align:center">TERMINATED</td>
<td>在terminated方法执行完之后进入该状态</td>
</tr>
</tbody>
</table>
<p><img src="https://img-blog.csdnimg.cn/img_convert/04cb57348838a44aa491d0d300a720a4.png#pic_center" alt="线程池声明周期.jpg"></p>
<h2 id="任务调度机制"><a href="#任务调度机制" class="headerlink" title="任务调度机制"></a>任务调度机制</h2><p>任务调度是线程池的主要入口，当用户提交了一个任务，接下来这个任务将如何执行都是由这个阶段决定的。了解这部分就相当于了解了线程池的核心运行机制。</p>
<p>首先，所有任务的调度都是由<code>execute</code>方法完成的，这部分完成的工作是：检查现在线程池的<strong>运行状态</strong>、<strong>运行线程数</strong>、<strong>运行策略</strong>，决定接下来执行的流程，是直接<strong>申请线程执行</strong>，或是<strong>缓冲到队列中执行</strong>，亦或是<strong>直接拒绝该任务</strong>。其执行过程如下：</p>
<ol>
<li>首先检测线程池运行状态，如果不是<code>RUNNING</code>，则直接拒绝，线程池要保证在<code>RUNNING</code>的状态下执行任务。</li>
<li>如果<code>workerCount &lt; corePoolSize</code>，则创建并启动一个线程来执行新提交的任务。</li>
<li>如果<code>workerCount &gt;= corePoolSize</code>，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。</li>
<li>如果<code>workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize</code>，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。</li>
<li>如果<code>workerCount &gt;= maximumPoolSize</code>，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/img_convert/7ec699190187108a2d80121090d2f4ef.png#pic_center" alt="任务调度流程图.png"></p>
<p>接下来进入源代码分析时间~！</p>
<h2 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AbstractExecutorService.java</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ThreadPoolExecutor.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  <span class="keyword">int</span> c = ctl.get();<span class="comment">//获取ctl</span></span><br><span class="line">  <span class="comment">//检查当前核心线程数，是否小于核心线程数的大小限制</span></span><br><span class="line">  <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">    <span class="comment">//没有达到核心线程数的大小限制，那么添家核心线程执行该任务</span></span><br><span class="line">    <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//如果添加失败，刷新ctl值</span></span><br><span class="line">    c = ctl.get();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//再次检查线程池的运行状态，将任务添加到等待队列中</span></span><br><span class="line">  <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">    <span class="keyword">int</span> recheck = ctl.get();<span class="comment">//刷新ctl值</span></span><br><span class="line">    <span class="comment">//如果当前线程池的装不是运行状态，那么移除刚才添加的任务</span></span><br><span class="line">    <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">      reject(command);<span class="comment">//移除成功后，使用拒绝策略处理该任务；</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)<span class="comment">//当前工作线程数为0</span></span><br><span class="line">      <span class="comment">//线程池正在运行，或者移除任务失败。</span></span><br><span class="line">      <span class="comment">//添加一个非核心线程，并不指定该线程的运行任务。</span></span><br><span class="line">      <span class="comment">//等线程创建完成之后，会从等待队列中获取任务执行。</span></span><br><span class="line">      addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">//逻辑到这里说明线程池已经不是RUNNING状态，或者等待队列已满，需要创建一个新的非核心线程执行该任务；</span></span><br><span class="line">  <span class="comment">//如果创建失败，那么非核心线程已满，使用拒绝策略处理该任务；</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">    reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="添加工作线程和执行任务"><a href="#添加工作线程和执行任务" class="headerlink" title="添加工作线程和执行任务"></a>添加工作线程和执行任务</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class">  <span class="title">Worker</span>(<span class="title">Runnable</span> <span class="title">firstTask</span>) </span>&#123;</span><br><span class="line">    setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">    <span class="keyword">this</span>.firstTask = firstTask;<span class="comment">//初始化的任务，可以为null</span></span><br><span class="line">    <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);<span class="comment">//Worker持有的线程</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**部分代码省略*/</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	runWorker(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>添加工作线程和执行任务</strong>：总体就是创建<code>Worker</code>，并且为它找到匹配的<code>Runnable</code>。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/83f919cb70bf439b9f113f967f181b85.png#pic_center" alt="addwork.png"></p>
<h3 id="添加工作线程"><a href="#添加工作线程" class="headerlink" title="添加工作线程"></a>添加工作线程</h3><p>增加线程是通过线程池中的<code>addWorker</code>方法，该方法的功能就是增加一个线程，该方法不考虑线程池是在哪个阶段增加的该线程，这个分配线程的策略是在上个步骤完成的，该步骤仅仅完成增加线程，并使它运行，最后返回是否成功这个结果。</p>
<p><code>addWorker</code>方法有两个参数：<code>firstTask</code>、<code>core</code>。</p>
<p><code>firstTask</code>参数用于指定新增的线程执行的第一个任务，该参数可以为空；</p>
<p><code>core</code>参数为<code>true</code>表示在新增线程时会判断当前活动线程数是否少于<code>corePoolSize</code>，<code>false</code>表示新增线程前需要判断当前活动线程数是否少于<code>maximumPoolSize</code>。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/15bfac21e604754038a95ead5fd19e76.png#pic_center" alt="addwork2.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:<span class="comment">//break和continue的跳出标签</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();<span class="comment">//获取ctl的值</span></span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);<span class="comment">//获取当前线程池的状态；</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1、如果当前的线程池状态不是RUNNING</span></span><br><span class="line"><span class="comment">         * 2、当前线程池是RUNNING而且没有添加新任务，而且等待队列不为空。这种情况下是需要创建执行线程的。</span></span><br><span class="line"><span class="comment">         * 所以满足1，但不满足2就创建执行线程失败，返回false。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">/**进入内层循环 */</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);<span class="comment">//获取当前执行线程的数量</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 1、工作线程数量大于或等于计数器的最大阈值，那么创建执行线程失败，返回false。</span></span><br><span class="line"><span class="comment">             * 2、如果当前创建的核心线程，那么工作线程数大于corePoolSize的话，创建执行线程失败，返回false。</span></span><br><span class="line"><span class="comment">             * 3、如果当前创建的是非核心线程，那么工作线程数大于maximumPoolSize的话，创建执行线程失败，返回false。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//用CAS操作让线程数加1，如果成功跳出整个循环</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)<span class="comment">//线程状态前后不一样，重新执行外循环</span></span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">            <span class="comment">//如果CAS操作由于工作线程数的增加失败，那么重新进行内循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**就现在，线程数已经增加了。但是真正的线程对象还没有创建出来。*/</span></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();<span class="comment">//加锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 再次检查线程池的运行状态</span></span><br><span class="line"><span class="comment">                 * 1、如果是RUNNING状态，那么可以创建；</span></span><br><span class="line"><span class="comment">                 * 2、如果是SHUTDOWN状态，但没有执行线程，可以创建（创建后执行等待队列中的任务）</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="comment">//检测该线程是否已经开启</span></span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    workers.add(w);<span class="comment">//将改工作线程添加到集合中</span></span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)<span class="comment">//更新线程池的运行时的最大线程数</span></span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;<span class="comment">//标识工作线程添加成功</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;<span class="comment">//释放锁</span></span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;<span class="comment">//如果工作线程添加成功，那么开启线程</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//如果工作线程添加失败，那么进行失败处理</span></span><br><span class="line">        <span class="comment">//将已经增加的线程数减少，将添加到集合的工作线程删除</span></span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h3><p>在<strong>添加工作线程</strong>部分我们看到了，添加成功之后会开启线程执行任务。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/c983921d315a5083bf356e2f8a67a09f.png#pic_center" alt="runwork.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//解锁，允许中断</span></span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果当前的工作线程已经有执行任务，或者可以从等待队列中获取到执行任务</span></span><br><span class="line">        <span class="comment">//getTask获取任务时候会进行阻塞</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            w.lock();<span class="comment">//开始执行，上锁</span></span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="comment">//判断线程是否需要中断</span></span><br><span class="line">            <span class="comment">//如果线程池状态是否为STOP\TIDYING\TERMINATED,同时当前线程没有被中断那么将当前线程进行中断</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                    (Thread.interrupted() &amp;&amp;</span><br><span class="line">                    runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;<span class="comment">//异常处理</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;<span class="comment">//工作线程的当前任务置空</span></span><br><span class="line">                w.completedTasks++;<span class="comment">//当前工作线程执行完成的线程数+1</span></span><br><span class="line">                w.unlock();<span class="comment">//执行完成解锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;<span class="comment">//完成了所有任务，正常退出</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;<span class="comment">//执行工作线程的退出操作</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="工作线程获取任务"><a href="#工作线程获取任务" class="headerlink" title="工作线程获取任务"></a>工作线程获取任务</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/15ab456774deee5a09f037c61f6da916.png#pic_center" alt="getTask.jpg"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();<span class="comment">//获取ctl的值</span></span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);<span class="comment">//获取线程池状态</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1、rs为STOP\TIDYING\TERMINATED，标识无法继续执行任务</span></span><br><span class="line"><span class="comment">         * 2、等待队列中没有任务可以被执行</span></span><br><span class="line"><span class="comment">         * 工作线程数量减一</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);<span class="comment">//获取工作线程数量</span></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="comment">//如果允许核心线程超时，或者当前工作线程数量大于核心线程数量。标识需要进行超时检测</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1、如果当前工作线程数是否大于线程池可允许的最大工作线程数（maximumPoolSize可以动态设置）</span></span><br><span class="line"><span class="comment">         * ，或者当前需要进行超时控制并且上次从等待队列中获取执行任务发生了超时。</span></span><br><span class="line"><span class="comment">         * 2、如果当前不是唯一的线程，并且等待队列中没有需要执行的任务。</span></span><br><span class="line"><span class="comment">         * 这两种情况下一起存在就表示，工作线程发生了超时需要回收，所以对线程数进行-1；</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))<span class="comment">//线程数量减少成功，否则重新执行本次循环</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//如果设置有超时，那么设定超时时间。否则进行无限的阻塞等待执行任务</span></span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="keyword">true</span>;<span class="comment">//获取超时,设置标记</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="工作线程的退出"><a href="#工作线程的退出" class="headerlink" title="工作线程的退出"></a>工作线程的退出</h2><p>线程池中线程的销毁依赖<strong>JVM自动</strong>的回收，线程池做的工作是根据当前线程池的状态维护一定数量的线程引用，防止这部分线程被JVM回收，当线程池决定哪些线程需要回收时，只需要将其引用消除即可。<code>Worker</code>被创建出来后，就会不断地进行轮询，然后获取任务去执行，核心线程可以无限等待获取任务，非核心线程要限时获取任务。当<code>Worker</code>无法获取到任务，也就是获取的任务为空时，循环会结束，<code>Worker</code>会主动消除自身在线程池内的引用。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/2f2a67e167362a69c5ae28e20fa6af88.png#pic_center" alt="processWorkerExit.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//completedAbruptly为true，标识该工作线程执行出现了异常，将工作线程数减一</span></span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn't adjusted</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">    <span class="comment">//否则标识该工作线程为正常结束，这种情况下getTask方法中已经对工作线程进行了减一</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();<span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        completedTaskCount += w.completedTasks;<span class="comment">//更新线程池的，线程执行完成数量</span></span><br><span class="line">        workers.remove(w);<span class="comment">//工作线程容器移除该工作线程</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();<span class="comment">//解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//尝试结束线程池</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;<span class="comment">//如果当前线程池的运行状态是RUNNING\SHUTDOWN</span></span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;<span class="comment">//如果该工作线程为正常结束</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 判断当前需要的最少的核心线程数(如果允许核心线程超时，那么最小的核心线程数为0，否则为corePoolSize)</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="comment">//如果允许核心线程超时，而且等待队列不为空，那么工作线程的最小值为1，否则为0。</span></span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//当前工作线程数，是否满足最先的核心线程数</span></span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="comment">//如果满足那么直接return</span></span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果是异常结束，或者当前线程数不满足最小的核心线程数，那么添加一个非核心线程</span></span><br><span class="line">        <span class="comment">//核心线程和非核心线程没有什么不同，只是在创建的时候判断逻辑不同</span></span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="特需"><a href="#特需" class="headerlink" title="特需"></a>特需</h1><h2 id="线程池的监控"><a href="#线程池的监控" class="headerlink" title="线程池的监控"></a>线程池的监控</h2><p>通过线程池提供的参数进行监控。线程池里有一些属性在监控线程池的时候可以使用</p>
<ul>
<li><code>getTaskCount</code>：线程池已经执行的和未执行的任务总数；</li>
<li><code>getCompletedTaskCount</code>：线程池已完成的任务数量，该值小于等于<code>taskCount</code>；</li>
<li><code>getLargestPoolSize</code>：线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过，也就是达到了<code>maximumPoolSize</code>；</li>
<li><code>getPoolSize</code>：线程池当前的线程数量；</li>
<li><code>getActiveCount</code>：当前线程池中正在执行任务的线程数量。</li>
</ul>
<h2 id="动态调整线程池的大小"><a href="#动态调整线程池的大小" class="headerlink" title="动态调整线程池的大小"></a>动态调整线程池的大小</h2><p><code>JDK</code>允许线程池使用方通过<code>ThreadPoolExecutor</code>的实例来动态设置线程池的核心策略，以<code>setCorePoolSize</code>为方法例;</p>
<blockquote>
<p>在运行期线程池使用方调用此方法设置<code>corePoolSize</code>之后，线程池会直接覆盖原来的<code>corePoolSize</code>值，并且基于当前值和原始值的比较结果采取不同的处理策略。</p>
<p>对于当前值小于当前工作线程数的情况，说明有多余的<code>worker</code>线程，此时会向当前<code>idle</code>的<code>worker</code>线程发起中断请求以实现回收，多余的<code>worker</code>在下次<code>idel</code>的时候也会被回收；对于当前值大于原始值且当前队列中有待执行任务，则线程池会创建新的<code>worker</code>线程来执行队列任务（PS:<code>idel</code>状态为<code>worker</code>线程释放锁之后的状态，因为它在运行期间都是上锁的）。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/img_convert/a37f0ff31615cf75d0a67061b26429d7.png#pic_center" alt="setCorePoolSize.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCorePoolSize</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">//计算增量</span></span><br><span class="line">    <span class="keyword">int</span> delta = corePoolSize - <span class="keyword">this</span>.corePoolSize;</span><br><span class="line">    <span class="comment">//覆盖原有的corePoolSize</span></span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="comment">//如果当前的工作线程数量大于线程池的最大可运行核心线程数量，那么进行中断工作线程处理</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(ctl.get()) &gt; corePoolSize)</span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (delta &gt; <span class="number">0</span>) &#123;<span class="comment">//如果增量大于0</span></span><br><span class="line">        <span class="comment">// We don't really know how many new threads are "needed".</span></span><br><span class="line">        <span class="comment">// As a heuristic, prestart enough new workers (up to new</span></span><br><span class="line">        <span class="comment">// core size) to handle the current number of tasks in</span></span><br><span class="line">        <span class="comment">// queue, but stop if queue becomes empty while doing so.</span></span><br><span class="line">        <span class="comment">//等待队列非空，获取等待任务和增量的最小值</span></span><br><span class="line">        <span class="keyword">int</span> k = Math.min(delta, workQueue.size());</span><br><span class="line">        <span class="comment">//循环创建核心工作线程执行等待队列中的任务</span></span><br><span class="line">        <span class="keyword">while</span> (k-- &gt; <span class="number">0</span> &amp;&amp; addWorker(<span class="keyword">null</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (workQueue.isEmpty())</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    interruptIdleWorkers(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();<span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//遍历工作线程的集合</span></span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">            Thread t = w.thread;</span><br><span class="line">            <span class="comment">//如果当前线程没有被中断，而且能获取到锁，那么尝试进行中断，最后释放锁</span></span><br><span class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//是否仅仅中断一个工作线程</span></span><br><span class="line">            <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;<span class="comment">//释放锁</span></span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="优雅的关闭线程池"><a href="#优雅的关闭线程池" class="headerlink" title="优雅的关闭线程池"></a>优雅的关闭线程池</h2><p>从《线程池声明周期》图上还可以看到，当我们执行 <code>ThreadPoolExecutor#shutdown</code> 方法将会使线程池状态从 <strong>RUNNING</strong> 转变为 <strong>SHUTDOWN</strong>。而调用 <code>ThreadPoolExecutor#shutdownNow</code> 之后线程池状态将会从 <strong>RUNNING</strong> 转变为 <strong>STOP</strong>。</p>
<h3 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h3><blockquote>
<p>停止接收新任务，原来的任务继续执行</p>
</blockquote>
<ol>
<li>停止接收新的submit的任务；</li>
<li>已经提交的任务（包括正在跑的和队列中等待的）,会继续执行完成；</li>
<li>等到第2步完成后，才真正停止；</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();<span class="comment">// 检查权限</span></span><br><span class="line">        advanceRunState(SHUTDOWN);<span class="comment">// 设置线程池状态</span></span><br><span class="line">        interruptIdleWorkers();<span class="comment">// 中断空闲线程</span></span><br><span class="line">        <span class="comment">// 钩子函数，主要用于清理一些资源</span></span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>shutdown</code> 方法首先加锁，其次先检查系统安装状态。接着就会将线程池状态变为 <strong>SHUTDOWN</strong>，在这之后线程池不再接受提交的新任务。此时如果还继续往线程池提交任务，将会使用线程池拒绝策略响应，默认情况下将会使用 <code>ThreadPoolExecutor.AbortPolicy</code>，抛出 <code>RejectedExecutionException</code> 异常。</p>
<p><code>interruptIdleWorkers</code> 方法在<a href="">动态调整线程池大小</a>部分有源码讲述，它只会中断空闲的线程，不会中断正在执行任务的的线程。空闲的线程将会阻塞在线程池的阻塞队列上。</p>
<h3 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow"></a>shutdownNow</h3><blockquote>
<p>停止接收新任务，原来的任务停止执行</p>
</blockquote>
<ol>
<li>跟 <code>shutdown()</code>一样，先停止接收新<code>submit</code>的任务；</li>
<li>忽略队列里等待的任务；</li>
<li>尝试将正在执行的任务<code>interrupt</code>中断；</li>
<li>返回未执行的任务列表；</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();<span class="comment">// 检查状态</span></span><br><span class="line">        advanceRunState(STOP);<span class="comment">// 将线程池状态变为 STOP</span></span><br><span class="line">        interruptWorkers();<span class="comment">// 中断所有线程，包括工作线程以及空闲线程</span></span><br><span class="line">        tasks = drainQueue();<span class="comment">// 丢弃工作队列中存量任务</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers)</span><br><span class="line">            <span class="comment">//如果工作线程已经开始，那么调用interrupt进行中断</span></span><br><span class="line">            w.interruptIfStarted();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Runnable&gt; <span class="title">drainQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BlockingQueue&lt;Runnable&gt; q = workQueue;</span><br><span class="line">    ArrayList&lt;Runnable&gt; taskList = <span class="keyword">new</span> ArrayList&lt;Runnable&gt;();</span><br><span class="line">    <span class="comment">//从此队列中删除所有可用的元素，并将它们添加到给定的集合中。</span></span><br><span class="line">    q.drainTo(taskList);</span><br><span class="line">    <span class="comment">//如果队列是DelayQueue或其他类型的队列，而poll或drainTo可能无法删除某些元素，则会将它们逐个删除。</span></span><br><span class="line">    <span class="keyword">if</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Runnable r : q.toArray(<span class="keyword">new</span> Runnable[<span class="number">0</span>])) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q.remove(r))</span><br><span class="line">                taskList.add(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> taskList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>shutdownNow</code>试图终止线程的方法是通过调用 <code>Thread.interrupt()</code> 方法来实现的，这种方法的作用有限，如果线程中没有<code>sleep</code> 、<code>wait</code>、<code>Condition</code>、定时锁等应用, <code>interrupt()</code> 方法是无法中断当前的线程的。所以，<code>shutdownNow()</code>并不代表线程池就一定立即就能退出，它也可能必须要等待所有正在执行的任务都执行完成了才能退出。但是大多数时候是能立即退出的。</p>
<blockquote>
<p>线程中断机制： <code>thread#interrupt</code> 只是设置一个中断标志，不会立即中断正常的线程。如果想让中断立即生效，必须在线程 内调用 <code>Thread.interrupted()</code> 判断线程的中断状态。 对于阻塞的线程，调用中断时，线程将会立刻退出阻塞状态并抛出 <code>InterruptedException</code> 异常。所以对于阻塞线程需要正确处理 <code>InterruptedException</code> 异常。</p>
</blockquote>
<h3 id="awaitTermination"><a href="#awaitTermination" class="headerlink" title="awaitTermination"></a>awaitTermination</h3><p>线程池 <code>shutdown</code> 与 <code>shutdownNow</code> 方法都不会主动等待执行任务的结束，如果需要等到线程池任务执行结束，需要调用 <code>awaitTermination</code> 主动等待任务调用结束。</p>
<ul>
<li>等所有已提交的任务（包括正在跑的和队列中等待的）执行完；</li>
<li>等超时时间到了；</li>
<li>线程被中断，抛出<code>InterruptedException</code>;</li>
</ul>
<p>如果线程池任务执行结束，<code>awaitTermination</code> 方法将会返回 <code>true</code>，否则当等待时间超过指定时间后将会返回 <code>false</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关闭线程池的钩子函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">(ExecutorService executorService)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一步：使新任务无法提交</span></span><br><span class="line">    executorService.shutdown();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 第二步：等待未完成任务结束</span></span><br><span class="line">        <span class="keyword">if</span>(!executorService.awaitTermination(<span class="number">60</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">             <span class="comment">// 第三步：取消当前执行的任务</span></span><br><span class="line">            executorService.shutdownNow();</span><br><span class="line">            <span class="comment">// 第四步：等待任务取消的响应</span></span><br><span class="line">            <span class="keyword">if</span>(!executorService.awaitTermination(<span class="number">60</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                System.err.println(<span class="string">"Thread pool did not terminate"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException ie) &#123;</span><br><span class="line">        <span class="comment">// 第五步：出现异常后，重新取消当前执行的任务</span></span><br><span class="line">        executorService.shutdownNow();</span><br><span class="line">        Thread.currentThread().interrupt(); <span class="comment">// 设置本线程中断状态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>感觉内容好多，写不完啊~！</p>
<p>说的线程池就不得不说多线程并发操作，<code>同步</code>，<code>异步</code>，<code>CSA</code>，<code>AQS</code>，<code>公平锁和非公平锁</code>，<code>可重入锁和非可重入锁</code>等各种并发控制需要的知识点。</p>
<p>平常工作中使用比较少，自己有没有系统的知识体系结构。导致好多学过之后忘掉，然后又学习又忘记。</p>
<p>希望我以后有机会能逐步进行学习和分享。</p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>Qigsaw源码之Gradle插件解析</title>
    <url>/2021/01/25/qigsaw-plugin/</url>
    <content><![CDATA[<p><img src="https://img-blog.csdnimg.cn/img_convert/5cdbb1b0ba4f46bbe9d8ef0f167ae337.png#pic_center" alt="hi,2021"></p>
<p><a href="https://developer.android.com/platform/technology/app-bundle" target="_blank" rel="noopener">Android App Bundle</a>为<code>Qigsaw</code>的前置依赖知识点。</p>
<p><a href="https://developer.android.com/platform/technology/app-bundle" target="_blank" rel="noopener">Android App Bundle</a> 是<code>Android</code>新推出的一种官方发布格式<code>.aab</code>，可让您以更高效的方式开发和发布应用。借助 <code>Android App Bundle</code>，您可以更轻松地以更小的应用提供优质的使用体验，从而提升安装成功率并减少卸载量。转换过程轻松便捷。您无需重构代码即可开始获享较小应用的优势。改用这种格式后，您可以体验模块化应用开发和可自定义功能交付，并从中受益（PS：必须依赖于<code>GooglePlay</code>）。</p>
<p><code>qigsaw</code>基于<code>AAB</code>实现，同时完全仿照<code>AAB</code>提供的<code>play core library</code>接口加载插件，开发查阅官方文档即可开始开发。如果有国际化需求的公司可以在国内版和国际版上无缝切换。同时<code>Qigsaw</code>实现<code>0 hook</code>，仅有少量私有 API 访问，保证其兼容性和稳定性。</p>
<p><a href="https://github.com/stven0king/Qigsaw" target="_blank" rel="noopener">Github:Qigsaw</a></p>
<p>本篇文章主要讲述<code>Qigsaw</code>相关的<code>plugin</code>。</p>
<h2 id="Qigsaw插件"><a href="#Qigsaw插件" class="headerlink" title="Qigsaw插件"></a>Qigsaw插件</h2><p>主工程进行进行<code>apply plugin: &#39;com.iqiyi.qigsaw.application&#39;</code>插件的依赖；</p>
<p><code>feature</code>工程进行以下依赖：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'com.android.dynamic-feature'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'com.iqiyi.qigsaw.dynamicfeature'</span></span><br></pre></td></tr></table></figure>
<p><code>gradle.properties</code>文件中配置<code>QIGSAW_BUILD=true</code>，才会有<code>feature</code>包的一些信息生成。</p>
<blockquote>
<p>com.iqiyi.qigsaw.application</p>
</blockquote>
<p><code>com.iqiyi.qigsaw.application.properties</code>文件内容为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">implementation-<span class="class"><span class="keyword">class</span></span>=com.iqiyi.qigsaw.buildtool.gradle.QigsawAppBasePlugin</span><br></pre></td></tr></table></figure>
<p><code>QigsawAppBasePlugin</code>默认会注册一个 <code>SplitComponentTransform</code>，在开启<code>QIGSAW_BUILD=true</code>之后还会注册<code>SplitResourcesLoaderTransform</code>。通过 <code>Transform</code>实现对插件内容的<code>AOP</code>。</p>
<p><code>QigsawAppBasePlugin</code>除过注册两个<code>Transform</code>之外，为主要的是处理插件和基础包信息生成<code>Qigsaw</code>产物。</p>
<blockquote>
<p>com.iqiyi.qigsaw.dynamicfeature</p>
</blockquote>
<p><code>com.iqiyi.qigsaw.dynamicfeature.properties</code>文件内容为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">implementation-<span class="class"><span class="keyword">class</span></span>=com.iqiyi.qigsaw.buildtool.gradle.QigsawDynamicFeaturePlugin</span><br></pre></td></tr></table></figure>
<p><code>QigsawDynamicFeaturePlugin</code>在开启<code>QIGSAW_BUILD=true</code>之后会注册<code>SplitResourcesLoaderTransform</code>以及<code>SplitLibraryLoaderTransform</code>实现对插件内容的<code>AOP</code>。</p>
<h3 id="SplitResourcesLoaderTransform"><a href="#SplitResourcesLoaderTransform" class="headerlink" title="SplitResourcesLoaderTransform"></a>SplitResourcesLoaderTransform</h3><p>主要是向<code>Activity</code>、<code>Service</code>和<code>Receiver</code>类中的<code>getResources</code>注入<code>SplitInstallHelper.loadResources(this, super.getResources())</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SplitComponentWeaver</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链接目标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String CLASS_WOVEN = <span class="string">"com/google/android/play/core/splitinstall/SplitInstallHelper"</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链接方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String METHOD_WOVEN = <span class="string">"loadResources"</span></span><br><span class="line">    <span class="keyword">byte</span>[] weave(InputStream inputStream)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相关注入类为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SplitResourcesLoaderInjector</span> </span>&#123;</span><br><span class="line">    WaitableExecutor waitableExecutor</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 预埋的 Activity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Set&lt;String&gt; activities</span><br><span class="line">    Set&lt;String&gt; services</span><br><span class="line">    Set&lt;String&gt; receivers</span><br><span class="line">    SplitActivityWeaver activityWeaver</span><br><span class="line">    SplitServiceWeaver serviceWeaver</span><br><span class="line">    SplitReceiverWeaver receiverWeaver</span><br><span class="line">    <span class="comment">/**部分代码省略**/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中基础包和插件的区别主要是注册的目标不同：</p>
<blockquote>
<p>基础包只是读取<code>build.gradle</code>文件中的<code>qigsawSplit.baseContainerActivities</code>配置的<code>Activity</code>。</p>
</blockquote>
<blockquote>
<p>而插件需要读取<code>AndroidManifest.xml</code>文件中的<code>Activity</code>、<code>Service</code>和<code>Receiver</code>。</p>
</blockquote>
<p><code>SplitInstallHelper.loadResources(this, super.getResources());</code>的作用是将所有插件资源路径添加到<code>AssetManager</code>中，这样各个插件就可以访问所有的资源，关键实现代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Method <span class="title">getAddAssetPathMethod</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (addAssetPathMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">        addAssetPathMethod = HiddenApiReflection.findMethod(AssetManager.class, <span class="string">"addAssetPath"</span>, String.class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> addAssetPathMethod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SplitComponentTransform"><a href="#SplitComponentTransform" class="headerlink" title="SplitComponentTransform"></a>SplitComponentTransform</h3><p>该<code>Transform</code>主要进行了两个操作 ：</p>
<ul>
<li>读取各个插件<code>apk</code>的<code>Manifest</code>文件，创建<code>ComponentInfo</code>类并将将各个插件<code>apk</code>的<code>Application</code>,<code>Activity</code>,<code>Service</code>,<code>Recevier</code>记录在该类的字段中，字段名称<strong>以工程名+组件</strong>类型命名，值为各个插件<code>apk</code>包含的组件，如过包含多个用逗号隔开。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.iqiyi.android.qigsaw.core.extension.ComponentInfo</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComponentInfo</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String native_ACTIVITIES = <span class="string">"com.iqiyi.qigsaw.sample.ccode.NativeSampleActivity"</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String java_ACTIVITIES = <span class="string">"com.iqiyi.qigsaw.sample.java.JavaSampleActivity"</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String java_APPLICATION = <span class="string">"com.iqiyi.qigsaw.sample.java.JavaSampleApplication"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>为每个<code>provider</code>创建代理类 类名为<code>String providerClassName=providerName+&quot;Decorated&quot;+splitName</code>，其中<code>providerName</code>为原始<code>provider</code>类名，<code>splitName</code>为插件<code>apk</code>对应的名称，并且该类继承<code>SplitContentProvider</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaContentProvider_Decorated_java</span> <span class="keyword">extends</span> <span class="title">SplitContentProvider</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e30da5460cdeb47dafd2ad5eaf28a291.png#pic_center" alt="provider_deccorated.png"></p>
<p>为啥这么做呢?</p>
<p>因为在<code>app</code>启动时<code>provider</code>的执行时机是比较靠前的，<br><code>Application-&gt;attachBaseContext ==&gt;ContentProvider-&gt;onCreate ==&gt;Application-&gt;onCreate ==&gt;Activity-&gt;onCreate</code>在这个过程中我们的插件apk并没有加载进来，一定会报<code>ClassNotFound</code>。所以我们将插件<code>apk</code>的<code>provider</code>生成一个代理类，然后替换掉，如果插件没有加载进来，代理类什么也不执行就可以了。很好的解决了我们的问题。</p>
<h3 id="SplitLibraryLoaderTransform"><a href="#SplitLibraryLoaderTransform" class="headerlink" title="SplitLibraryLoaderTransform"></a>SplitLibraryLoaderTransform</h3><p><code>SplitLibraryLoaderTransform</code>类进行的操作是向<code>dynamic-feature</code>构建<code>apk</code>的过程中，创建以 <code>&quot;com.iqiyi.android.qigsaw.core.splitlib.&quot; + project.name + &quot;SplitLibraryLoader&quot;</code>的类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.iqiyi.android.qigsaw.core.splitlib.assetsSplitLibraryLoader</span></span><br><span class="line"><span class="comment">// com.iqiyi.android.qigsaw.core.splitlib.javaSplitLibraryLoader</span></span><br><span class="line"><span class="comment">// com.iqiyi.android.qigsaw.core.splitlib.nativeSplitLibraryLoader</span></span><br><span class="line"><span class="keyword">package</span> com.iqiyi.android.qigsaw.core.splitlib;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">javaSplitLibraryLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadSplitLibrary</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.loadLibrary(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类的作用是啥呢？</p>
<p>下面我们来解释一下，你会发现很有趣的。</p>
<ul>
<li><code>Qigsaw</code>是基于对于<code>com.google.android.play.core</code>对外暴露的方法，进行了自定义实现。因为<code>aab</code>目前只能对<code>google play</code>上发布应用起作用，所以开发者重新实现了一套<code>com.google.android.play.core</code>包名的第三方库，这样就可以做到在国内市场，与国外应用市场无缝迁移。</li>
<li><code>Qigsaw</code>提供两种加载方式加载插件<code>apk</code>，单<code>Classloader</code>和多<code>Classloader</code>模式，单<code>Classloader</code>涉及私有<code>api</code>访问，而多<code>Classloader</code>不涉及私有<code>api</code>访问。</li>
</ul>
<p>该类的存在就是为了解决多<code>Classloader</code>模式下的<strong>so加载</strong>问题<br><code>System.loadLibrary(str);</code>该方法会使用调用方的classloader从中获取so信息并加载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//java.lang.System.java</span></span><br><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadLibrary</span><span class="params">(String libname)</span> </span>&#123;</span><br><span class="line">  Runtime.getRuntime().loadLibrary0(Reflection.getCallerClass(), libname);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于多<code>Classloader</code>模式下，每个插件都要各自的<code>Classloader</code>,<code>so</code>与<code>dex</code>都在各自的<code>Classloader</code>中记录，所以在多<code>Classloader</code>模式下， <code>System.loadLibrary</code>应由插件<code>apk</code>各自的<code>Classloader</code>调用。具体实现可参考<code>SplitLibraryLoaderHelper</code>类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.iqiyi.android.qigsaw.core.splitload.SplitLibraryLoaderHelper.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">loadSplitLibrary0</span><span class="params">(ClassLoader classLoader, String splitName, String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class&lt;?&gt; splitLoaderCl = classLoader.loadClass(<span class="string">"com.iqiyi.android.qigsaw.core.splitlib."</span> + splitName + <span class="string">"SplitLibraryLoader"</span>);</span><br><span class="line">        Object splitLoader = splitLoaderCl.newInstance();</span><br><span class="line">        Method method = HiddenApiReflection.findMethod(splitLoaderCl, <span class="string">"loadSplitLibrary"</span>, String.class);</span><br><span class="line">        method.invoke(splitLoader, name);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ignored) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Qigsaw编译解析"><a href="#Qigsaw编译解析" class="headerlink" title="Qigsaw编译解析"></a>Qigsaw编译解析</h2><h3 id="Qigsaw打包流程"><a href="#Qigsaw打包流程" class="headerlink" title="Qigsaw打包流程"></a>Qigsaw打包流程</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/4d922d7aa1f5ba0954ccf43743ca65ce.png#pic_center" alt="qigsaw_plugin_flow_chart.png"></p>
<h3 id="copySplitManifestDebug"><a href="#copySplitManifestDebug" class="headerlink" title="copySplitManifestDebug"></a>copySplitManifestDebug</h3><p>实现<code>feature</code>包下生成的<code>AndroidManifest.xml</code>文件的拷贝。</p>
<p>目标文件和地址：<code>featureName/build/intermediates/merged_manifests/debug/AndroidManifest.xml</code>。</p>
<p>拷贝后的地址：<code>app/build/intermediates/qigsaw/split-outputs/manifests/debug</code>。</p>
<p>拷贝后的文件名：<code>$featureName.xml</code></p>
<h3 id="ProcessTaskDependenciesBetweenBaseAndSplitsWithQigsaw"><a href="#ProcessTaskDependenciesBetweenBaseAndSplitsWithQigsaw" class="headerlink" title="ProcessTaskDependenciesBetweenBaseAndSplitsWithQigsaw"></a>ProcessTaskDependenciesBetweenBaseAndSplitsWithQigsaw</h3><p>触发<strong>copySplitManifestDebug</strong>任务，将<code>feature包</code>生成的产物和数据输出到<code>qigsawProcessDebugManifest</code>任务中。</p>
<h3 id="extractTargetFilesFromOldApk"><a href="#extractTargetFilesFromOldApk" class="headerlink" title="extractTargetFilesFromOldApk"></a>extractTargetFilesFromOldApk</h3><p>将<code>app_debug.apk</code>解压 将<code>assets/</code>目录下所有内容释放到<code>app/build/intermediates/qigsaw/old-apk/target-files/xxx</code>中</p>
<h3 id="qigsawProcessDebugManifest"><a href="#qigsawProcessDebugManifest" class="headerlink" title="qigsawProcessDebugManifest"></a>qigsawProcessDebugManifest</h3><p><code>SplitComponentTransform</code>创建的<code>$ContentProviderName_Decorated_$featureName</code>继承<code>SplitContentProvider</code>代替原有的<code>Provider</code>。</p>
<p>因为<code>Provider</code> 在应用启动的时候就需要加载，避免这个时候<code>feature</code>包没有下载下来，先加载一个代理的<code>Provider</code>。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/dbbbea28377246fd42fa062e276d8523.png#pic_center" alt="provider.png"></p>
<h3 id="generateDebugQigsawConfig"><a href="#generateDebugQigsawConfig" class="headerlink" title="generateDebugQigsawConfig"></a>generateDebugQigsawConfig</h3><p>生成以下文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Keep</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">QigsawConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_SPLIT_INFO_VERSION = <span class="string">"1.0.0_1.0.0"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] DYNAMIC_FEATURES = &#123;<span class="string">"java"</span>, <span class="string">"assets"</span>, <span class="string">"native"</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QIGSAW_ID = <span class="string">"1.0.0_c40ab5d"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> QIGSAW_MODE = Boolean.parseBoolean(<span class="string">"true"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String VERSION_NAME = <span class="string">"1.0.0"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>QIGSAW_ID</code>回先获取基础包的<code>id</code>，如果没有那么为当前的<code>QigsawId</code>。</p>
<h3 id="processSplitApkDebug"><a href="#processSplitApkDebug" class="headerlink" title="processSplitApkDebug"></a>processSplitApkDebug</h3><p>每个<code>feature</code>都需要执行的任务，分别处理自己的的<code>apk</code>并生成对应的<code>json</code>文件。</p>
<ul>
<li><p>将<code>feature</code>包的<code>apk</code>文件解压到<code>app/build/intermediates/qigsaw/split-outputs/unzip/debug/$featureName</code>文件；</p>
</li>
<li><p>遍历解压<code>apk</code>中的<code>lib</code>文件目录，找到支持的<strong>ABI</strong>;</p>
</li>
<li><p>如果有<code>lib</code>文件有<code>so</code>文件，那么在该目录生成一个<code>AndroidManifest.xml</code>文件；</p>
<ul>
<li><p>将<code>lib</code>文件和生成的<code>AndroidManifest.xml</code>压缩为<code>protoAbiApk</code>;</p>
</li>
<li><p>利用<code>aapt2</code>工具将 <code>protoAbiApk</code>到 <code>binaryAbiApk</code>中;</p>
</li>
<li><p>将<code>binaryAbiApk</code>进行签名生成<code>app/build/intermediates/qigsaw/split-outputs/apks/debug/$feature-$abi.apk</code>;</p>
</li>
<li><p>生成<code>SplitInfo.SplitApkData</code>数据；</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"abi"</span>: <span class="string">"x86"</span>,</span><br><span class="line">  <span class="attr">"url"</span>: <span class="string">"assets://qigsaw/native-x86.zip"</span>,</span><br><span class="line">  <span class="attr">"md5"</span>: <span class="string">"03a29962b87c6ed2a7961b6dbe45f532"</span>,</span><br><span class="line">  <span class="attr">"size"</span>: <span class="number">8539</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>遍历解压<code>apk</code>中<strong>除过lib</strong>之前的文件目录，压缩为<code>$fearure-master-unsigned.apk</code>。签名生成<code>app/build/intermediates/qigsaw/split-outputs/apks/debug/$feature-master.apk</code>;</p>
</li>
<li><p>生成<code>SplitInfo.SplitApkData</code>数据；</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"abi"</span>: <span class="string">"master"</span>,</span><br><span class="line">  <span class="attr">"url"</span>: <span class="string">"assets://qigsaw/native-master.zip"</span>,</span><br><span class="line">  <span class="attr">"md5"</span>: <span class="string">"3b89066aeaf7d2c2a59b4f3a10fef345"</span>,</span><br><span class="line">  <span class="attr">"size"</span>: <span class="number">12824</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>更具<code>lib</code>文件下的数据生成<code>SplitInfo.SplitLibData</code>数据；</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"abi"</span>: <span class="string">"arm64-v8a"</span>,</span><br><span class="line">  <span class="attr">"jniLibs"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"libhello-jni.so"</span>,</span><br><span class="line">      <span class="attr">"md5"</span>: <span class="string">"2938d8b40825e82715422dbdba479e4f"</span>,</span><br><span class="line">      <span class="attr">"size"</span>: <span class="number">5896</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后生成每个<code>feature</code>的<code>SplitInfo</code>数据，写入<code>/app/build/intermediates/qigsaw/split-outputs/split-info/debug/$featureName.json</code>文件；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SplitInfo</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">GroovyObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String splitName;<span class="comment">//feature包名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> builtIn;<span class="comment">//!onDemand||!releaseSplitApk(releaseSplitApk是gradle中配置项)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> onDemand;<span class="comment">//取自AndroidManifest.xml中的onDemand</span></span><br><span class="line">    <span class="keyword">private</span> String applicationName;<span class="comment">//feature应用名</span></span><br><span class="line">    <span class="keyword">private</span> String version;<span class="comment">//feature包中的versionname@versioncode</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> minSdkVersion;<span class="comment">//feature最低版本</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> dexNumber;<span class="comment">//feature包中的dex数量</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; dependencies;<span class="comment">//feature包的依赖；</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; workProcesses;<span class="comment">//feature包AndroidManifest.xml中的Activity、Service、Receiver、provider配置的进程；</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;SplitInfo.SplitApkData&gt; apkData;<span class="comment">//SplitInfo.SplitApkData数据</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;SplitInfo.SplitLibData&gt; libData;<span class="comment">//SplitInfo.SplitLibData数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="qigsawAssembleDebug"><a href="#qigsawAssembleDebug" class="headerlink" title="qigsawAssembleDebug"></a>qigsawAssembleDebug</h3><ul>
<li>将<code>build/intermediates/qigsaw/split-outputs/split-info/debug</code>中的每个<code>feature</code>包生成的<code>json</code>合并；</li>
<li>将<strong>合并之后</strong>的文件与基础包中的<code>Qigsaw</code>配置文件进行对比，生成新的<code>增量Qigsaw</code>配置文件；<ul>
<li>对比规则是<code>verisonName</code>相等的时候对比<code>split.version</code>，有一个不同就表示有更新;</li>
<li>如果有更新，那么<code>QigsawId</code>为基础包的<code>QigsawId</code>，并分析和修改<code>split</code>信息；<ul>
<li>修改<code>split</code>信息的时候，相同的<code>splitName</code>对比<code>split.version</code>。如果相同那么<code>split</code>使用基础包的<code>split</code>信息，如果<strong>不同</strong>那么该<code>split</code>的<code>builtIn=false</code>，<code>onDemand=true</code>。并将有更新的<code>split</code>做记录（<code>updatesplits</code>字段值）。此时<code>updateMode</code>值为<strong>VERSION_CHANGED=1</strong>；</li>
<li>没有任何修改，那么<code>updateMode</code>值为<strong>VERSION_NO_CHANGED=2</strong>；</li>
<li>如果没有基础包，那么<code>updateMode</code>值为<strong>DEFAULT=0</strong>；</li>
</ul>
</li>
</ul>
</li>
<li>分别判断如果<code>feature</code>包的<code>builtIn</code>是<strong>false</strong>；<ul>
<li>判断是否有上传服务，如有有那么上传<code>feature</code>包。上传成功后将对应的<code>url</code>地址修改为可下载的<code>http</code>地址。如果地址为空，或者不是<code>http</code>开头会跑异常。</li>
<li>如果没有实现上传服务那么<code>builtIn</code>置为<strong>true</strong>；</li>
</ul>
</li>
<li>格式化<code>split</code>内容，写到<code>build/intermediates/qigsaw/split-details/debug</code>文件目录下。</li>
<li>将<code>updateMode</code>值写到<code>build/intermediates/qigsaw/split-details/debug/_update_record_.json</code>文件。</li>
<li>如果<code>updateMode</code>值为<strong>VERSION_NO_CHANGED</strong>，那么将<code>intermediates/qigsaw/old-apk/target-files/debug/assets/qigsaw/qigsaw_*.json</code>文件拷贝到<code>app/build/intermediates/merged_assets/debug/out/qigsaw/qigsaw_*.json</code>;<ul>
<li>否则将<code>app/build/intermediates/qigsaw/split-details/debug/qigsaw_*.json</code>文件拷贝到<code>app/build/intermediates/merged_assets/debug/out/qigsaw/qigsaw_*.json</code>;</li>
</ul>
</li>
<li>向<code>app/build/intermediates/qigsaw/split-details/debug/base.app.cpu.abilist.properties</code>写入支持的<code>abi</code>，并将其拷贝到<code>app/build/intermediates/merged_assets/debug/out/</code>下面；</li>
<li>遍历<code>feature</code>生成的<code>splitinfo</code>信息，如果<code>builtIn</code>是<strong>true</strong>;<ul>
<li>如果<code>updateMode</code>值为<strong>DEFAULT=0</strong>，将将<code>app/build/intermediates/qigsaw/split-outputs/apks/debug/*.apk</code>拷贝到<code>app/build/intermediates/merged_assets/debug/out/qigsaw/*.zip</code>；</li>
<li>如果<code>updateMode</code>值为<strong>DEFAULT!=0</strong>，判断该<code>feature</code>是否是在<code>updateSplits</code>中;<ul>
<li>如果是那么将<code>app/build/intermediates/qigsaw/split-outputs/apks/debug/*.apk</code>拷贝到<code>app/build/intermediates/merged_assets/debug/out/qigsaw/*.zip</code>；</li>
<li>如果不是将<code>app/build/intermediates/qigsaw/old-apk/target-files/debug/assets/qigsaw/*.zip</code>拷贝到<code>app/build/intermediates/merged_assets/debug/out/qigsaw/*.zip</code>；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="产物"><a href="#产物" class="headerlink" title="产物"></a>产物</h3><p><code>Qigsaw</code>配置文件</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"qigsawId"</span>: <span class="string">"1.0.0_c40ab5d"</span>,</span><br><span class="line">  <span class="attr">"appVersionName"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"updateSplits"</span>: [</span><br><span class="line">    <span class="string">"java"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"splits"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"splitName"</span>: <span class="string">"java"</span>,</span><br><span class="line">      <span class="attr">"builtIn"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">"onDemand"</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">"applicationName"</span>: <span class="string">"com.iqiyi.qigsaw.sample.java.JavaSampleApplication"</span>,</span><br><span class="line">      <span class="attr">"version"</span>: <span class="string">"1.1@1"</span>,</span><br><span class="line">      <span class="attr">"minSdkVersion"</span>: <span class="number">14</span>,</span><br><span class="line">      <span class="attr">"dexNumber"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"workProcesses"</span>: [</span><br><span class="line">        <span class="string">""</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"apkData"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"abi"</span>: <span class="string">"master"</span>,</span><br><span class="line">          <span class="attr">"url"</span>: <span class="string">"assets://qigsaw/java-master.zip"</span>,</span><br><span class="line">          <span class="attr">"md5"</span>: <span class="string">"658bc419a9d3c7812a36e61f6c5be4c4"</span>,</span><br><span class="line">          <span class="attr">"size"</span>: <span class="number">12822</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"splitName"</span>: <span class="string">"native"</span>,</span><br><span class="line">      <span class="attr">"builtIn"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">"onDemand"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">"version"</span>: <span class="string">"1.0@1"</span>,</span><br><span class="line">      <span class="attr">"minSdkVersion"</span>: <span class="number">14</span>,</span><br><span class="line">      <span class="attr">"dexNumber"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"apkData"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"abi"</span>: <span class="string">"arm64-v8a"</span>,</span><br><span class="line">          <span class="attr">"url"</span>: <span class="string">"assets://qigsaw/native-arm64-v8a.zip"</span>,</span><br><span class="line">          <span class="attr">"md5"</span>: <span class="string">"b01ad63db38a4ec5fad3284c573a02d3"</span>,</span><br><span class="line">          <span class="attr">"size"</span>: <span class="number">8545</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"abi"</span>: <span class="string">"master"</span>,</span><br><span class="line">          <span class="attr">"url"</span>: <span class="string">"assets://qigsaw/native-master.zip"</span>,</span><br><span class="line">          <span class="attr">"md5"</span>: <span class="string">"3c41745a16a31e967cde8247009463f1"</span>,</span><br><span class="line">          <span class="attr">"size"</span>: <span class="number">12824</span></span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"libData"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"abi"</span>: <span class="string">"arm64-v8a"</span>,</span><br><span class="line">          <span class="attr">"jniLibs"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">"name"</span>: <span class="string">"libhello-jni.so"</span>,</span><br><span class="line">              <span class="attr">"md5"</span>: <span class="string">"2938d8b40825e82715422dbdba479e4f"</span>,</span><br><span class="line">              <span class="attr">"size"</span>: <span class="number">5896</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Qigsaw</code>加载的压缩包</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/4aae1c3a10d593b721822c4c78332351.png#pic_center" alt="app-debug.png"></p>
<h3 id="下期研究知识点"><a href="#下期研究知识点" class="headerlink" title="下期研究知识点"></a>下期研究知识点</h3><ul>
<li>混淆相关使用操作；</li>
<li><code>Tinker</code>热修改相关使用操作；</li>
</ul>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Qigsaw</tag>
      </tags>
  </entry>
  <entry>
    <title>Android8.0隐式广播和自定义签名权限</title>
    <url>/2021/01/23/broadcast-8.0/</url>
    <content><![CDATA[<p><img src="https://img-blog.csdnimg.cn/img_convert/6346ddc0ece7034f9b69d509ed67751e.png#pic_center" alt="我思故我在"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>记录一下今天同事给我分享的比较有意思的Bug，在已有的已经在<code>AndroidManifest.xml</code>中注册的广播在部分手机上无法通过<code>Action</code>隐式启动。上网搜搜资料自己写了个Demo，Mark一下~！~！</p>
<p><a href="https://developer.android.com/about/versions/oreo/background" target="_blank" rel="noopener">Android官网：Oreo后台执行限制</a></p>
<p>我们这里主要看对于广播的影响，摘抄一段官网上的介绍：</p>
<h2 id="广播限制"><a href="#广播限制" class="headerlink" title="广播限制"></a>广播限制</h2><p>如果应用注册为接收广播，则在每次发送广播时，应用的接收器都会消耗资源。 如果多个应用注册为接收基于系统事件的广播，则会引发问题：触发广播的系统事件会导致所有应用快速地连续消耗资源，从而降低用户体验。 为了缓解这一问题，<code>Android 7.0</code>（API 级别 24）对广播施加了一些限制，如<a href="https://developer.android.com/topic/performance/background-optimization" target="_blank" rel="noopener">后台优化</a>中所述。 <code>Android 8.0</code>（API 级别 26）让这些限制更为严格。</p>
<ul>
<li>适配 <code>Android 8.0</code> 或更高版本的应用无法继续在其清单中为隐式广播注册广播接收器。 <em>隐式广播</em>是一种不专门针对该应用的广播。 例如，<code>ACTION_PACKAGE_REPLACED</code> 就是一种隐式广播，因为该广播将被发送给所有已注册侦听器，让后者知道设备上的某些软件包已被替换。 不过，<code>ACTION_MY_PACKAGE_REPLACED</code> 不是隐式广播，因为不管已为该广播注册侦听器的其他应用有多少，它都会只被发送给软件包已被替换的应用。</li>
<li>应用可以继续在它们的清单中注册显式广播。</li>
<li>应用可以在运行时使用 <code>Context.registerReceiver()</code> 为任意广播（不管是隐式还是显式）注册接收器。</li>
<li>需要<a href="https://developer.android.com/guide/topics/manifest/permission-element#plevel" target="_blank" rel="noopener">签名权限</a>的广播不受此限制所限，因为这些广播只会发送到使用相同证书签名的应用，而不是发送到设备上的所有应用。</li>
</ul>
<p>在许多情况下，之前注册隐式广播的应用使用 <code>JobScheduler</code> 作业可以获得类似的功能。 例如，一款社交照片应用可能需要不时地执行数据清理，并且倾向于在设备连接到充电器时执行此操作。 之前，应用已经在清单中为 <code>ACTION_POWER_CONNECTED</code> 注册了一个接收器；当应用接收到该广播时，它会检查清理是否必要。 为了迁移到 <code>Android 8.0</code> 或更高版本，应用将该接收器从其清单中移除。 应用将清理作业安排在设备处于空闲状态和充电时运行。</p>
<p><strong>请注意：</strong>很多隐式广播当前已不受此限制所限。 应用可以继续在其清单中为这些广播注册接收器，不管应用适配哪个 API 级别。 有关已豁免广播的列表，请参阅<a href="https://developer.android.com/guide/components/broadcast-exceptions" target="_blank" rel="noopener">隐式广播例外</a>。 </p>
<p>更具上面的描述，我们可以得到一下几点：</p>
<ol>
<li>适配<code>Android 8.0</code>或更高版本的应用无法继续在其清单中为隐式广播注册广播接收器；</li>
<li>应用可以继续在它们的清单中注册显式广播；</li>
<li>推荐运行时使用<code>Context.registerReceiver()</code>注册广播；</li>
<li>需要<strong>签名权限</strong>的广播不受此约束；</li>
</ol>
<h2 id="自定义权限"><a href="#自定义权限" class="headerlink" title="自定义权限"></a>自定义权限</h2><p><a href="https://developer.android.com/guide/topics/manifest/permission-element#plevel" target="_blank" rel="noopener">Android官网：permission</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">permission</span> <span class="attr">android:description</span>=<span class="string">"string resource"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:icon</span>=<span class="string">"drawable resource"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">"string resource"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"string"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:permissionGroup</span>=<span class="string">"string"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:protectionLevel</span>=<span class="string">[</span>"<span class="attr">normal</span>" | "<span class="attr">dangerous</span>" |"<span class="attr">signature</span>" | <span class="attr">...</span>] /&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="android-protectionLevel"><a href="#android-protectionLevel" class="headerlink" title="android:protectionLevel"></a>android:protectionLevel</h3><p>说明权限中隐含的潜在风险，并指示系统在确定是否将权限授予请求授权的应用时应遵循的流程。</p>
<p>每个保护级别都包含基本权限类型以及零个或多个标记。例如，<code>dangerous</code>保护级别没有标记。相反，保护级别 <code>signature|privileged</code>是<code>signature</code>基本权限类型和<code>privileged</code>标记的组合。</p>
<p>下表列出了所有基本权限类型。如需查看标记列表，请参阅 <a href="https://developer.android.com/reference/android/R.attr#protectionLevel" target="_blank" rel="noopener">protectionLevel</a>。</p>
<table>
<thead>
<tr>
<th style="text-align:left">值</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>normal</code></td>
<td style="text-align:left">默认值。具有较低风险的权限，此类权限允许请求授权的应用访问隔离的应用级功能，对其他应用、系统或用户的风险非常小。系统会自动向在安装时请求授权的应用授予此类权限，无需征得用户的明确许可（但用户始终可以选择在安装之前查看这些权限）。</td>
</tr>
<tr>
<td style="text-align:left"><code>dangerous</code></td>
<td style="text-align:left">具有较高风险的权限，此类权限允许请求授权的应用访问用户私人数据或获取可对用户造成不利影响的设备控制权。由于此类权限会带来潜在风险，因此系统可能不会自动向请求授权的应用授予此类权限。例如，应用请求的任何危险权限都可能会向用户显示并且获得确认才会继续执行操作，或者系统会采取一些其他方法来避免用户自动允许使用此类功能。</td>
</tr>
<tr>
<td style="text-align:left"><code>signature</code></td>
<td style="text-align:left">只有在请求授权的应用使用与声明权限的应用相同的证书进行签名时系统才会授予的权限。如果证书匹配，则系统会在不通知用户或征得用户明确许可的情况下自动授予权限。</td>
</tr>
<tr>
<td style="text-align:left"><code>signatureOrSystem</code></td>
<td style="text-align:left"><code>signature\privileged</code> 的旧同义词。在<strong>API级别23</strong>中已弃用。系统仅向位于<code>Android</code>系统映像的专用文件夹中的应用或使用与声明权限的应用相同的证书进行签名的应用授予的权限。不要使用此选项，因为 <code>signature</code> 保护级别应足以满足大多数需求，无论应用安装在何处，该保护级别都能正常发挥作用。<code>signatureOrSystem</code>权限适用于以下特殊情况：多个供应商将应用内置到一个系统映像中，并且需要明确共享特定功能，因为这些功能是一起构建的。</td>
</tr>
</tbody>
</table>
<h3 id="自定义签名权限并使用"><a href="#自定义签名权限并使用" class="headerlink" title="自定义签名权限并使用"></a>自定义签名权限并使用</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">permission</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:protectionLevel</span>=<span class="string">"signature"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"com.xx.xx.receiver"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"com.xx.xx.receiver"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>我写个Demo测试一下，测试机<code>MI 8</code>，系统为<code>Android 10</code>。</p>
<p>声明两个<code>Broadcast</code>,一个带权限，一个不带权限。<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomReceiver</span> : <span class="type">BroadcastReceiver</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onReceive</span><span class="params">(context: <span class="type">Context</span>?, intent: <span class="type">Intent</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(intent != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> param = intent.getStringExtra(<span class="string">"message"</span>)</span><br><span class="line">            <span class="keyword">var</span> result:String?</span><br><span class="line">            result = String.format(<span class="string">"get the receiver for %s"</span>, param)</span><br><span class="line">            XToast.show(result)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomReceiver2</span> : <span class="type">CustomReceiver</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--带签名权限的广播--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">receiver</span> <span class="attr">android:name</span>=<span class="string">".main.receiver.CustomReceiver"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:permission</span>=<span class="string">"com.xx.xx.receiver"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.xx.xx.message"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--普通的广播--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">receiver</span> <span class="attr">android:name</span>=<span class="string">".main.receiver.CustomReceiver2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.xx.xx.message2"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li><blockquote>
<p>发送权限隐式广播-不加权限</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> intent = Intent(<span class="string">"com.xx.xx.message"</span> + num++)</span><br><span class="line">intent.putExtra(<span class="string">"message"</span>,<span class="string">"custom test"</span> + num++)</span><br><span class="line">sendBroadcast(intent)</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
<p>结果：吐司无法展现。<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">15:59:23.420#1635#1758#W#BroadcastQueue #Background execution not allowed: receiving Intent &#123; act=com.xx.xx.message flg=0x10 (has extras) &#125; to com.xx.xx.demo/.main.receiver.CustomReceiver</span><br></pre></td></tr></table></figure></p>
<ol start="2">
<li><blockquote>
<p>发送权限隐式广播-加权限</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> intent = Intent(<span class="string">"com.xx.xx.message"</span>)</span><br><span class="line">intent.putExtra(<span class="string">"message"</span>,<span class="string">"custom test"</span>)</span><br><span class="line">sendOrderedBroadcast(intent, <span class="string">"com.xx.xx.receiver"</span>)</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
<p>结果：吐司展现。</p>
<ol start="3">
<li><blockquote>
<p>发送权限隐式广播-加权限-错误</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> intent = Intent(<span class="string">"com.xx.xx.message"</span>)</span><br><span class="line">intent.putExtra(<span class="string">"message"</span>,<span class="string">"custom test"</span>)</span><br><span class="line">sendOrderedBroadcast(intent, <span class="string">"com.xx.xx.receiver.error"</span>)</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
<p>结果：吐司无法展现。<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">15:44:54.514#1696#1774#W#BroadcastQueue #Permission Denial: receiving Intent &#123; act=com.xx.xx.message flg=0x1000010 (has extras) &#125; to com.xx.xx.ztemplate/.main.receiver.CustomReceiver requires com.xx.xx.receiver.error due to sender com.xx.xx.demo (uid 10547)</span><br></pre></td></tr></table></figure></p>
<ol start="4">
<li><blockquote>
<p>发送隐式广播</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> intent = Intent(<span class="string">"com.xx.xx.message2"</span>)</span><br><span class="line">intent.putExtra(<span class="string">"message"</span>,<span class="string">"custom test"</span>)</span><br><span class="line">sendBroadcast(intent)</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
<p>结果：吐司无法展现。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">15:59:23.420#1635#1758#W#BroadcastQueue #Background execution not allowed: receiving Intent &#123; act=com.xx.xx.message flg=0x10 (has extras) &#125; to com.xx.xx.demo/.main.receiver.CustomReceiver</span><br></pre></td></tr></table></figure>
<ol start="5">
<li><blockquote>
<p>发送隐式广播-添加package</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> intent = Intent(<span class="string">"com.xx.xx.message2"</span>)</span><br><span class="line">intent.`<span class="keyword">package</span>` = <span class="string">"com.xx.xx.demo"</span></span><br><span class="line">intent.putExtra(<span class="string">"message"</span>,<span class="string">"custom test"</span>)</span><br><span class="line">sendBroadcast(intent)</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
<p>结果：吐司展现。</p>
<ol start="6">
<li><blockquote>
<p>发送隐式广播-setClass(等同于添加component)</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> intent = Intent(<span class="string">"com.xx.xx.message2"</span>)</span><br><span class="line">intent.setClass(<span class="keyword">this</span>, CustomReceiver2::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">intent.putExtra(<span class="string">"message"</span>,<span class="string">"custom test"</span>)</span><br><span class="line">sendBroadcast(intent)</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
<p>结果：吐司展现。</p>
<p>其实第<code>5</code>和第<code>6</code>个case已经不算隐式广播了，他们都为<code>Intent</code>设置了<code>package</code>指明了当前的环境。</p>
<h2 id="错误分析"><a href="#错误分析" class="headerlink" title="错误分析"></a>错误分析</h2><blockquote>
<p> <code>BroadcastQueue #Permission Denial:</code></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/img_convert/c161a43371831e84fbe2db7c36a2f342.png#pic_center" alt="BroadcastQueue-permission-denial.png"></p>
<p>这里提示权限有问题，需要添加或修改权限。</p>
<blockquote>
<p><code>BroadcastQueue #Background execution not allowed:</code></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/img_convert/16522b7278dc8b09f5b84e9cf029c5ed.png#pic_center" alt="BroadcastQueue-not-allow.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//android.content.Intent.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_RECEIVER_INCLUDE_BACKGROUND = <span class="number">0x01000000</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_RECEIVER_EXCLUDE_BACKGROUND = <span class="number">0x00800000</span>;</span><br></pre></td></tr></table></figure>
<p>这个代码块有一个<code>||</code>操作，我们不想让其进入到改逻辑需要使前面判断为<code>false</code>，后面判断为<code>false</code>。</p>
<p>判断<code>r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_EXCLUDE_BACKGROUND</code> 中携带了<code>FLAG_RECEIVER_EXCLUDE_BACKGROUND</code>标志位。我们一般都不会携带，所以前面逻辑为<code>false</code>。</p>
<p>后面逻辑有三个<code>&amp;&amp;</code>操作，那么只需要让其中一个为<code>false</code>即可。</p>
<ol start="2">
<li><p><code>r.intent.getComponent() == null</code>， 会进入此逻辑（设置<strong>component</strong>）。</p>
</li>
<li><p><code>r.intent.getPackage() == null</code>，会进入此逻辑（设置<strong>component</strong>）。</p>
</li>
<li><p><code>r.intent.getFlags() &amp; Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND) == 0</code> 不能带有<code>FLAG_RECEIVER_INCLUDE_BACKGROUND</code>这个标志位，否则会进入此逻辑（设置<strong>FLAG_RECEIVER_INCLUDE_BACKGROUND</strong>）。</p>
</li>
<li>如果启动广播的时候携带了权限，那么如果不是签名权限会进入此逻辑(设置<strong>签名权限</strong>)。</li>
</ol>
<p>其实<code>1</code>和<code>2</code>我们上面已经测试过了（第<code>5</code>个和第<code>6</code>个case）；</p>
<p><code>3</code>设置<code>Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND</code>，但改常量是<code>hide</code>无法通过<code>Intent</code>访问。我们只能写<code>0x01000000</code>，但不建议这么做；</p>
<p><code>4</code>其实就是文档中说明的<strong>签名权限</strong>不受<code>Android 8.0</code>后台执行优化的控制；</p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android8.0</tag>
        <tag>签名权限</tag>
      </tags>
  </entry>
  <entry>
    <title>修改AAR和Jar中class文件</title>
    <url>/2021/01/22/javassist-dev/</url>
    <content><![CDATA[<p><img src="https://img-blog.csdnimg.cn/img_convert/cb84db57e4f6bbcf2c70c0bf9740d8ed.png#pic_center" alt="hi，2021"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近帮助同事解决了一个比较棘手的问题，一路采坑的过程比较有意思。在此记录下来。（PS：主要原因是项目比较大，我们只有整个<code>Android</code>项目部分业务侧代码的开发权限。所以解决问题的一些解决问题的常规手段无法使用。）</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>需求：<code>Web</code>页面中<code>H5</code>和<code>native</code>交互，保存<code>base64图片</code>。</p>
<p>问题：使用现有的已经封装好的<code>Hybrid</code>协议，在最后集成测试发现部分手机无法保存成功。</p>
<ul>
<li>调试发现<code>H5</code>中使用原有的协议格式调用新协议，无法触发业务侧<code>native</code>注册的新协议的日志和断点。</li>
</ul>
<ol>
<li>怀疑原有的协议格式问题，当H5使用原有协议格式调用线上已经存在的新协议发现<code>native</code>可以端调用成功，此问题排除；</li>
<li>怀疑新协议中的参数问题，H5去掉新协议中的参数发现可以调用到<code>native</code>新协议实现。猜测可能是协议参数导致出的问题；<ol>
<li>通过断点找到触发协议调用的地方，也就是<code>H5</code>和<code>native</code>数据通信的地方。发现目前<code>Hybrid</code>协议使用的是<code>native</code>端复写<code>onJsPrompt</code>方法，拦截<code>JavaScript</code>的<code>prompt()</code>方法。</li>
<li>将新协议参数改回来，再次调用。断点在<code>native</code>端复写<code>onJsPrompt</code>方法中发现传输的数据被截断，数据解析失败无法进行下一个转发到业务测。</li>
</ol>
</li>
</ol>
<h3 id="问题点"><a href="#问题点" class="headerlink" title="问题点"></a>问题点</h3><p>项目中原有的<code>Hybrid协议</code>使用的<code>复写prompt方法</code>作为通信的桥梁，现在遇到了<strong>发大洪水（较大的数据）</strong>出现了阻碍问题。</p>
<h2 id="解决方案选择"><a href="#解决方案选择" class="headerlink" title="解决方案选择"></a>解决方案选择</h2><ol>
<li><p>让<code>H5</code>将<code>base64</code>格式的图片改为<code>http</code>格式图片；</p>
<blockquote>
<p>图片本就是<code>H5</code>绘制出来的，再上传之后客户端再下载交互体验太差；</p>
</blockquote>
</li>
<li>我们业务侧实现自已一套的<code>Hybrid</code>协议；</li>
<li><p>让项目的基础架构部修改现有的<code>Hybrid</code>协议；</p>
<blockquote>
<p>晚上发现的bug，明天就需要封测。24小时之内想要完成跨部门的基础架构的改动，很难实现。</p>
</blockquote>
</li>
</ol>
<p>最后我们选择的是第二种方案，自己实现一套<code>Hybrid</code>协议。</p>
<h2 id="解决方案实现"><a href="#解决方案实现" class="headerlink" title="解决方案实现"></a>解决方案实现</h2><ol>
<li>拿到<code>WebView</code> 调用<code>addJavascriptInterface</code>方法给<code>H5</code>环境下添加<code>JS</code>对象。</li>
<li>开发<code>JS</code>工具让其能按照老协议格式，调用到新的<code>JS</code>通信方法。</li>
<li>将拿到的数据解析抛给原来在<code>onJsPrompt</code>方法中处理数据的包装类对象。</li>
</ol>
<p>如果所有的项目代码我们都能改动，那么这个解决方案也就没有难点。难点在于我们现在只有这个<code>H5</code>页面的最外层的一个壳<code>Activity</code>，而且封装的<code>WebView</code>没有为对外暴露我们想要的方法。所以方案的第三步执行产生了问题。</p>
<p>针对这个问题我们有两个解决方案：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/60faeadb5a7c3cbbe60255c0198cc86d.png#pic_center" alt="Hybrid-Base64-project.jpg"></p>
<ol>
<li>本次通过注入<code>JS</code>对象的<code>Hybrid</code>通信协议和项目原有的<code>Hybrid</code>协议做两套逻辑；</li>
<li>通过多次<code>hook</code>黑科技调用到原有其他类中的<code>dispatch</code>方法；</li>
</ol>
<p>如果仅仅是这样也就没有本篇文章了。</p>
<p>好了，啰嗦了这么久了终于开始进入正题了。不知道还有几个同学打算继续看下去。</p>
<p>我们可以拿到项目中所有的<code>AAR</code>文件，想着是否能通过修改源代码使之提供我们想要的<code>API</code>，然后通过升级 <code>AAR</code>版本解决问题。好了本文的重点已经出来了<strong>修改AAR中class文件</strong>。</p>
<h2 id="修改AAR中class文件"><a href="#修改AAR中class文件" class="headerlink" title="修改AAR中class文件"></a>修改AAR中class文件</h2><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><blockquote>
<p>先把<code>AAR</code>中的想要修改的<code>class</code>删除，重新打包为新的<code>AAR</code>。项目依赖新版本<code>AAR</code>，然后在项目对应的包下创建一个相同的类。</p>
<ol>
<li>将原有的<code>class</code>文件内容反编译之后拷贝到新建的类中，直接运行。</li>
<li>将原有的<code>class</code>文件内容反编译之后拷贝到新建的类中。最后重新编译生成的<code>class</code>再添加到<code>AAR</code>中重新打包生成新的<code>AAR</code>。</li>
</ol>
</blockquote>
<p>如果类被混淆过的，那么这个方案基本废掉了。因为反编译出的<code>class</code>的内容里面存在大量包和类名相同的情况，这个再编译期间无法确认本次调用时使用的类还是包。</p>
<p>举个例子，混淆之后经常看到下面的结构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.xx.a</span><br><span class="line">com.xx.a.a</span><br></pre></td></tr></table></figure>
<p>在写下面代码的时候会提示类<code>a</code>下没有类<code>a</code>，而不是去包<code>a</code>下找类<code>a</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a ma = <span class="keyword">new</span> com.xx.a.a();</span><br></pre></td></tr></table></figure>
<h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/8c9a841fee6b7bb598bdac9ec03a5377.png#pic_center" alt="aop-asm.JPEG"></p>
<p>根据上图就可以看出这个方案是进行切面编程。我们仅仅需要在某个类中添加一两个方法，去解决访问受限的问题。考虑到当前这个问题的难易程度我们选择<code>Javassist</code>。因为<code>Javassist</code>源代码级<code>API</code>比<code>ASM</code>中实际的字节码操作更容易使用，无需深入了解<code>JVM</code>规范也能使用。</p>
<p><code>Javassist</code> <a href="http://www.javassist.org/html/" target="_blank" rel="noopener">官方文档</a></p>
<p><code>jar</code>包下载地址 <a href="https://github.com/jboss-javassist/javassist" target="_blank" rel="noopener">Github:javassist</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需要添加的方法</span></span><br><span class="line"><span class="comment">//public void executeJSCmd(String var1) &#123;</span></span><br><span class="line"><span class="comment">//    if (this.mActionDispatcher != null) &#123;</span></span><br><span class="line"><span class="comment">//        Message var2 = this.mActionHandler.obtainMessage(0);</span></span><br><span class="line"><span class="comment">//        var2.obj = var1;</span></span><br><span class="line"><span class="comment">//        this.mActionHandler.sendMessage(var2);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//需要操作的class的类名：com.xxx.android.web.webview.BaseWebChromeClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NotFoundException, CannotCompileException, IOException </span>&#123;</span><br><span class="line">        ClassPool classPool = ClassPool.getDefault();</span><br><span class="line">        <span class="comment">// 必须将class文件放在这个工程编译后的class文件中，路径也对应起来</span></span><br><span class="line">        CtClass ctClass = classPool.get(<span class="string">"com.xxx.android.web.webview.BaseWebChromeClient"</span>);</span><br><span class="line">        CtMethod newmethod = CtNewMethod.make(<span class="string">"public void executeJSCmd(String message) &#123; if (this.mActionDispatcher != null) &#123; android.os.Message msg = this.mActionHandler.obtainMessage(0); msg.obj = message; this.mActionHandler.sendMessage(msg); &#125; &#125;"</span>,ctClass);</span><br><span class="line">        ctClass.addMethod(newmethod);</span><br><span class="line">        ctClass.writeFile();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，比如我们添加的方法中涉及到了其他的类需要写全路径<code>android.os.Message</code>，而且这个类相关的<code>jar</code>包也必须添加到运行环境中（也可以将这个类的class文件放着这个工程编译后的class文件目录中），否则执行时候会报一下的错误。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread "main" javassist.CannotCompileException: [source error] no such class: android.os.Message</span><br><span class="line">	at javassist.CtNewMethod.make(CtNewMethod.java:<span class="number">78</span>)</span><br><span class="line">	at javassist.CtNewMethod.make(CtNewMethod.java:<span class="number">44</span>)</span><br><span class="line">	at com.test.pattern.Test.main(Test.java:<span class="number">13</span>)</span><br></pre></td></tr></table></figure>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>替换或者删除<code>jar</code>中的<code>class</code>的时候最好不要解压然后再使用命名打包，我自己在<code>Max</code>电脑上使用命令打<code>jar</code>包的时候会有一个<code>.DS_Store</code>文件。我使用的<code>BetterZip</code><strong>压缩&amp;解压</strong>工具，在不解压的情况下进行<code>jar</code>包中的<code>class</code>的<strong>添加和删除</strong>操作非常方便。</p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>AAR</tag>
        <tag>jar</tag>
        <tag>class</tag>
        <tag>javassist</tag>
      </tags>
  </entry>
  <entry>
    <title>Android中R文件ID值</title>
    <url>/2021/01/11/android-r-id/</url>
    <content><![CDATA[<h1 id="Android中R文件ID值"><a href="#Android中R文件ID值" class="headerlink" title="Android中R文件ID值"></a>Android中R文件ID值</h1><p><img src="https://img-blog.csdnimg.cn/img_convert/017dd03576db45793220ffc5655369da.png#pic_center" alt=""></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前端时间在学习 <code>Qigsaw</code> 相关的源码，思考到一个问题。动态加载的<code>feature</code> 包里的 <code>资源id</code> 是否会与主包中的 <code>资源id</code> 冲突。因为主包的 <code>apk</code> 文件不一定是和加载的<code>feature</code> 包是一起打包生成的，<code>feature</code> 包是可以进行升级的。查看 <code>Qigsaw</code>编译脚本对 <code>old.apk</code> 进行增量编译 <code>feature</code> 的时候也没有发现对 <code>R文件</code> 做特殊的处理。</p>
<p>那么 <code>Android</code> 怎么保证两次编译出的 <code>feature</code> 包中的 <code>资源id</code> 不与主包中的冲突呢？我们带着问题阅读文章进行答案的探索（<code>Android</code>中资源属于一个大模块，我们本地只讨论其中与<code>R文件</code>相关的部分）。</p>
<blockquote>
<ul>
<li>不同的 <code>android-gradle</code> 版本可能对 <code>R文件</code> 的格式以及生成目录会略作修改，本文只选了两个版本做参考。</li>
<li>同步的反编译工具反编译出来的结果不仅相关，我们主要以 <code>AndroidStudio</code> 结果为主。</li>
</ul>
</blockquote>
<h2 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h2><h3 id="在代码中访问资源"><a href="#在代码中访问资源" class="headerlink" title="在代码中访问资源"></a>在代码中访问资源</h3><p>您可以以方法参数的形式传递资源 ID，进而在代码中使用资源。例如，您可以设置一个 <code>ImageView</code>，从而借助 <code>setImageResource()</code> 使用 <code>res/drawable/myimage.png</code> 资源：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ImageView imageView = (ImageView) findViewById(R.id.myimageview);</span><br><span class="line">imageView.setImageResource(R.drawable.myimage);</span><br></pre></td></tr></table></figure>
<p>您还可利用 <code>Resources</code> 中的方法检索个别资源，并且您可通过 <code>getResources()</code> 获得该资源的实例。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>以下是在代码中引用资源的语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&lt;package_name&gt;.]R.&lt;resource_type&gt;.&lt;resource_name&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><em><code>&lt;package_name&gt;</code></em> 是资源所在包的名称（如果引用的资源来自您自己的资源包，则不需要）。</li>
<li><em><code>&lt;resource_type&gt;</code></em> 是资源类型的 <code>R</code> 子类。</li>
<li><em><code>&lt;resource_name&gt;</code></em> 是不带扩展名的资源文件名，或 XML 元素中的 <code>android:name</code> 属性值（若资源是简单值）。</li>
</ul>
<p>其实到这里我们已经解决了我们阅读本文的目的。</p>
<p>主包的 <code>资源文件ID</code> 和 <code>feature</code> 包的 <code>资源文件ID</code> 值是由于 <code>&lt;package_name&gt;</code> 不一致导致最后 <code>ID</code> 值不会相同。</p>
<p>有时间的小伙伴可以继续往下阅读，后面更精彩。</p>
<h2 id="R文件"><a href="#R文件" class="headerlink" title="R文件"></a>R文件</h2><blockquote>
<p>主工程R文件结构</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b34f2d9feb43e10e61b869541333f0ca.png#pic_center" alt="R.png"></p>
<blockquote>
<p>插件的R文件结构</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/img_convert/87d98b315d092e922acaf45e7bfe0e8f.png#pic_center" alt="Qigsaw-feature-R.png"></p>
<p>R文件中每个<code>资源ID值</code>一共4个字段，由三部分组成：<code>PackageId+TypeId+EntryId</code></p>
<ul>
<li><code>PackageId</code>：是包的<code>Id</code>值，<code>Android</code> 中如果第三方应用的话，这个默认值是 <code>0x70</code> ，系统应用的话就是 <code>0x01</code> ，插件的话那么就是给插件分配的<code>id值</code>，占用一个字节。</li>
<li><code>TypeId</code>: 是资源的类型<code>Id</code>值，一般 <code>Android</code> 中有这几个类型：<code>attr</code>，<code>drawable</code>，<code>layout</code>，<code>anim</code>，<code>raw</code>，<code>dimen</code>，<code>string</code>，<code>bool</code>，<code>style</code>，<code>integer</code>，<code>array</code>，<code>color</code>，<code>id</code>，<code>menu</code> 等。【应用程序所有模块中的资源类型名称，按照字母排序之后。值是从1开支逐渐递增的，而且顺序不能改变（每个模块下的<code>R文件</code>的相同资源类型<code>id值</code>相同)。比如：<code>anim=0x01</code>占用1个字节，那么在这个编译出的所有R文件中<code>anim</code> 的值都是 <code>0x01</code>】</li>
<li><code>EntryId</code>:是在具体的类型下资源实例的<code>id</code>值，从0开始，依次递增，他占用四个字节。</li>
</ul>
<h3 id="Lib库的R文件"><a href="#Lib库的R文件" class="headerlink" title="Lib库的R文件"></a>Lib库的R文件</h3><blockquote>
<p><code>com.android.tools.build:gradle:3.2.0</code></p>
<p><code>releasePath</code> :<code>/build/generated/not_namespaced_r_class_sources_release_generateReleaseRFile/out/R.java</code> (<code>Debug包与其对应</code>)</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/img_convert/f9915699b98300df2d399a40dab7cec2.png#pic_center" alt="3.2.0-module-lib-r.png"></p>
<blockquote>
<p><code>com.android.tools.build:gradle:3.4.1</code></p>
<p><code>debugPath</code> :<code>/build/intermediates/complile_only_not_namespaced_r_class_jar_debug_generateDebugRFile/R.jar</code> (<code>Release包与其对应</code>)</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/img_convert/fc6a8feaf6b508c61764b461bf56721b.png#pic_center" alt="3.4.1-module-lib-r.png"></p>
<p>我们可以看到 <code>Lib</code> 中的 <code>R</code> 文件都是 <code>public static</code> 不是常量。 这和我们刚开始查看的 <code>主工程</code> 以及 <code>插件</code> 的 <code>R文件</code> 相比缺少了 <code>final</code> 关键词的修饰。</p>
<blockquote>
<p><code>Lib</code> 库中资源<code>id</code> 的使用为引用类型；</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/img_convert/572f73aa94dd43fe228d6cf17c8a511d.png#pic_center" alt="module-lib-r-source-layout.png"></p>
<p>（PS:至于<code>资源ID</code>为什么不是常量，使用为引用类型，我们继续往后看~！）</p>
<h3 id="AAR中的R文件"><a href="#AAR中的R文件" class="headerlink" title="AAR中的R文件"></a>AAR中的R文件</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/937bf55d2dbe0a47ab2d4f5eefc9a9f4.png#pic_center" alt="AAR-R.png"></p>
<p>我们可以看到打包了的 <code>Lib/Module</code> 为 <code>arr包</code> 之后，我们是找不到 <code>R.java</code> 文件的。只有一个 <code>R.txt</code>。</p>
<blockquote>
<p><code>aar</code> 依赖库中资源<code>id</code> 的使用为引用类型；</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/img_convert/f56b1f4531d5d582e386c2ecabda14c7.png#pic_center" alt="module-lib-r-jar-layout.png"></p>
<h3 id="依赖库R文件的生成"><a href="#依赖库R文件的生成" class="headerlink" title="依赖库R文件的生成"></a>依赖库R文件的生成</h3><ul>
<li>源码依赖的 <code>Lib</code> 库的 <code>R</code> 文件中的 <code>ID</code> 不是常量；</li>
<li><code>aar</code> 依赖的 <code>Lib</code> 库的<code>R</code> 文件是 <code>.txt</code> 文件；</li>
<li>源码依赖的 <code>Lib</code> 库和 <code>aar</code> 依赖的 <code>Lib</code> 库中的 <code>资源ID</code> 的使用都是引用类型；</li>
</ul>
<p>源码依赖的 <code>Lib</code> 库和 <code>aar</code> 依赖的 <code>Lib</code> 库中的 <code>R</code> 文件的相关产物都是由于：如果依赖库的 <code>R</code> 文件中的 <code>资源ID</code> 在打包之前设置为常量，那么不同依赖库以及主工程的 <code>R</code> 文件必然会产生冲突。所有项目中的 <code>R文件以及其资源ID</code> 都是所有的代码合并之后重新赋值的或者生成的。</p>
<ul>
<li>源码依赖的 <code>Lib</code> 库的 <code>R</code> 文件会重新在 <code>app</code> 模块的 <code>build</code> 目录中重新生成一个相同的<code>R</code> 文件只不过 <code>资源ID</code> 前面添加了 <code>final</code> 关键词变成了常量；</li>
<li><code>aar</code> 依赖的 <code>Lib</code> 库的<code>R</code> 文件会更具 <code>.txt</code> 文件中的内容，在 <code>app</code> 模块的 <code>build</code> 目录中重新生成一个<code>R</code> 文件而且 <code>资源ID</code> 是添加了 <code>final</code> 关键词的常量；</li>
<li>其 <code>R</code> 文件的生成目录和 <code>主app</code> 的 <code>R</code> 文件是相同的；</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/92362b2dfc7bb649abc8e3c9d7b9c051.png#pic_center" alt="APP_R_JAVA.png"></p>
<p>这个目录在<code>com.android.tools.build:gradle:3.4.1</code>和<code>com.android.tools.build:gradle:3.2.0</code> 版本下都是相同的。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/5e6c3d1eaf4d0558b8877b2e918b2fcd.png#pic_center" alt="APP_CLASS_R_ID.png"></p>
<ul>
<li><code>AAR的class文件</code> 在主工程编译时，不会再次进行编译，也就是说<strong>AAR的class文件原封不动的打包进apk</strong>。</li>
<li>主工程的代码编译时在<code>R</code> 文件生成之后的，所以主工程的资源引用值都是<strong>常量且内联为常量值</strong>。</li>
</ul>
<p>其实这一点也和之前 <code>R</code> 文件结构中的知识点对应起来。<code>R文件</code> 是在编译主工程的时候进行合并、排序、赋值的。在这之后又返过来生成 <code>R.java</code> 文件，给 <code>资源ID</code> 赋予已经生成好的常量值。</p>
<h3 id="R文件的数量"><a href="#R文件的数量" class="headerlink" title="R文件的数量"></a>R文件的数量</h3><p>每个 <code>aar</code> 或者 <code>lib库</code> 都会有一个 <code>R文件</code>，那么一个项目的 <code>R文件</code> 数量为：</p>
<blockquote>
<p><strong>app中R文件数量=依赖的module/aar数量 + 1(自身的R文件)</strong></p>
<p><strong>module的R文件数 = 依赖的module/aar数量 + 1(自身的R文件)</strong></p>
</blockquote>
<h2 id="后续疑问"><a href="#后续疑问" class="headerlink" title="后续疑问"></a>后续疑问</h2><p>我们大概了解的 <code>R</code> 文件的生成和使用。但通过本篇文章的了解我们也许会有更多的疑问？</p>
<ul>
<li>为什么要有那么多 <code>R.java</code> 文件，而且不同模块的的资源名称还有重复值？</li>
<li>资源名称重复的时候会报异常，但这里的部分模块的<code>资源名称</code>明显有相同的为什么没有报异常？</li>
<li>在编译的时候如果遇到资源重复，那么到底该使用哪个资源，有优先级规则是什么？</li>
<li>为什么 <code>aar</code> 或者 <code>lib库</code> 中使用资源的 <code>class</code> 没有进行 <code>ID值</code> 的内联？</li>
<li><code>R文件</code> 可以混淆么，有什么好处或者什么坑？</li>
</ul>
<h2 id="官网参考资料"><a href="#官网参考资料" class="headerlink" title="官网参考资料"></a>官网参考资料</h2><p><a href="https://developer.android.com/studio/write/add-resources.html" target="_blank" rel="noopener">添加应用资源</a></p>
<p><a href="https://developer.android.com/guide/topics/resources/providing-resources?hl=zh-cn" target="_blank" rel="noopener">应用资源概览</a></p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>R文件</tag>
      </tags>
  </entry>
  <entry>
    <title>DiffUtil和它的差量算法</title>
    <url>/2020/10/20/diffutil-source/</url>
    <content><![CDATA[<h1 id="DiffUtil和它的差量算法"><a href="#DiffUtil和它的差量算法" class="headerlink" title="DiffUtil和它的差量算法"></a>DiffUtil和它的差量算法</h1><p><img src="https://img-blog.csdnimg.cn/20201016193724905.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0dmVuX2tpbmc=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学习<code>Myers&#39;Diff</code> 算法是从 <code>DiffUtils</code> 源代码开始的，但<code>DiffUtil和它的差量算法</code>这篇却是文章是在写完 <a href="https://dandanlove.blog.csdn.net/article/details/108979400" target="_blank" rel="noopener">Myers‘Diff之贪婪算法</a> 和 <a href="https://dandanlove.blog.csdn.net/article/details/108996040" target="_blank" rel="noopener">Myers‘Diff之线性空间细化</a> 这两篇算法文章之后着手的。比较先需要学会算法才能理解代码实现并更好的进行使用。</p>
<h2 id="DiffUtil介绍"><a href="#DiffUtil介绍" class="headerlink" title="DiffUtil介绍"></a>DiffUtil介绍</h2><p>在正式分析<code>DiffUtil</code>之前，我们先来对<code>DiffUtil</code>有一个大概的了解–<code>DiffUtil</code>到底是什么东西。</p>
<blockquote>
<p>类的路径：<code>androidx.recyclerview.widget.DiffUtil.java</code></p>
</blockquote>
<p>大家在开发关于列表页面的时候可能会遇到下面的情况：</p>
<blockquote>
<p>在一次操作里面可能会同时出现<code>remove</code>、<code>add</code>、<code>change</code>三种操作。像这种情况，我们不能调用<code>notifyItemRemoved</code>、<code>notifyItemInserted</code>或者<code>notifyItemChanged</code>方法。为了视图立即刷新，我们只能通过调用<code>notifyDataSetChanged</code>方法来实现。但<code>notifyDataSetChanged</code> 刷新是全部刷新没有动画效果。</p>
</blockquote>
<p>那么有一种能通过对比知道两个列表的数据的差异，然后进行<code>remove</code>、<code>add</code>或<code>change</code>么？</p>
<p><strong>Google</strong>提供的<code>DiffUtil</code>是一个实用程序类，它计算两个列表之间的差异，并输出将第一个列表转换为第二个列表的更新操作列表。</p>
<h2 id="DiffUtil-DiffResult"><a href="#DiffUtil-DiffResult" class="headerlink" title="DiffUtil.DiffResult"></a>DiffUtil.DiffResult</h2><blockquote>
<p>DiffUtil在计算两个列表之间的差异时使用的Callback类。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line">	<span class="comment">//旧数据集的长度；</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getOldListSize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//新数据集的长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getNewListSize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//判断是否是同一个item；</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">areItemsTheSame</span><span class="params">(<span class="keyword">int</span> oldItemPosition, <span class="keyword">int</span> newItemPosition)</span></span>;</span><br><span class="line">    <span class="comment">//如果item相同，此方法用于判断是否同一个 Item 的内容也相同</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">areContentsTheSame</span><span class="params">(<span class="keyword">int</span> oldItemPosition, <span class="keyword">int</span> newItemPosition)</span></span>;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="comment">//如果item相同，内容不同，用 payLoad 记录这个 ViewHolder 中，具体需要更新那个View</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getChangePayload</span><span class="params">(<span class="keyword">int</span> oldItemPosition, <span class="keyword">int</span> newItemPosition)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="DiffUtil-DiffResult-1"><a href="#DiffUtil-DiffResult-1" class="headerlink" title="DiffUtil.DiffResult"></a>DiffUtil.DiffResult</h2><p>此类包含有关<code>DiffUtil＃calculateDiff</code>调用的结果的信息。可以通过<code>dispatchUpdatesTo</code>使用<code>DiffResult</code>中的更新，也可以通过<code>dispatchUpdatesTo</code>直接将结果流式传输到<code>RecyclerView.Adapter</code>。</p>
<h2 id="DiffUtil使用"><a href="#DiffUtil使用" class="headerlink" title="DiffUtil使用"></a>DiffUtil使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecyclerItemCallback</span> <span class="keyword">extends</span> <span class="title">DiffUtil</span>.<span class="title">Callback</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Bean&gt; mOldDataList;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Bean&gt; mNewDataList;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RecyclerItemCallback</span><span class="params">(List&lt;Bean&gt; oldDataList, List&lt;Bean&gt; newDataList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mOldDataList = oldDataList;</span><br><span class="line">        <span class="keyword">this</span>.mNewDataList = newDataList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOldListSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mOldDataList.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNewListSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mNewDataList.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">areItemsTheSame</span><span class="params">(<span class="keyword">int</span> oldItemPosition, <span class="keyword">int</span> newItemPosition)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(mNewDataList.get(newItemPosition).getId(), mOldDataList.get(oldItemPosition).getId());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">areContentsTheSame</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> i1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(mOldDataList.get(i).getContent(), mNewDataList.get(i1).getContent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">refreshData</span><span class="params">(List&lt;Bean&gt; oldDataList,List&lt;Bean&gt; newDataList)</span> </span>&#123;</span><br><span class="line">    RecyclerItemCallback recyclerItemCallback = <span class="keyword">new</span> RecyclerItemCallback(oldDataList, newDataList);</span><br><span class="line">    DiffUtil.DiffResult diffResult = DiffUtil.calculateDiff(recyclerItemCallback, <span class="keyword">false</span>);</span><br><span class="line">    diffResult.dispatchUpdatesTo(mRecyclerAdapter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="DiffUtil中Myers算法代码"><a href="#DiffUtil中Myers算法代码" class="headerlink" title="DiffUtil中Myers算法代码"></a>DiffUtil中Myers算法代码</h2><blockquote>
<p>再次提醒一下代码阅读需要先了解 <a href="https://dandanlove.blog.csdn.net/article/details/108979400" target="_blank" rel="noopener">Myers‘Diff之贪婪算法</a> 和 <a href="https://dandanlove.blog.csdn.net/article/details/108996040" target="_blank" rel="noopener">Myers‘Diff之线性空间细化</a>  这两篇文章中的算法知识。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiffUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">//部分代码省略</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DiffResult <span class="title">calculateDiff</span><span class="params">(@NonNull Callback cb, <span class="keyword">boolean</span> detectMoves)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> oldSize = cb.getOldListSize();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> newSize = cb.getNewListSize();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> List&lt;Snake&gt; snakes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// instead of a recursive implementation, we keep our own stack to avoid potential stack</span></span><br><span class="line">        <span class="comment">// overflow exceptions</span></span><br><span class="line">        <span class="keyword">final</span> List&lt;Range&gt; stack = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        stack.add(<span class="keyword">new</span> Range(<span class="number">0</span>, oldSize, <span class="number">0</span>, newSize));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> max = oldSize + newSize + Math.abs(oldSize - newSize);</span><br><span class="line">        <span class="comment">// allocate forward and backward k-lines. K lines are diagonal lines in the matrix. (see the</span></span><br><span class="line">        <span class="comment">// paper for details)</span></span><br><span class="line">        <span class="comment">// These arrays lines keep the max reachable position for each k-line.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] forward = <span class="keyword">new</span> <span class="keyword">int</span>[max * <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] backward = <span class="keyword">new</span> <span class="keyword">int</span>[max * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We pool the ranges to avoid allocations for each recursive call.</span></span><br><span class="line">        <span class="keyword">final</span> List&lt;Range&gt; rangePool = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">final</span> Range range = stack.remove(stack.size() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">final</span> Snake snake = diffPartial(cb, range.oldListStart, range.oldListEnd,</span><br><span class="line">                    range.newListStart, range.newListEnd, forward, backward, max);</span><br><span class="line">            <span class="keyword">if</span> (snake != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (snake.size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    snakes.add(snake);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// offset the snake to convert its coordinates from the Range's area to global</span></span><br><span class="line">                <span class="comment">//使路径点的偏移以将其坐标从范围区域转换为全局</span></span><br><span class="line">                snake.x += range.oldListStart;</span><br><span class="line">                snake.y += range.newListStart;</span><br><span class="line">                <span class="comment">//拆分左上角和右下角进行递归</span></span><br><span class="line">                <span class="comment">// add new ranges for left and right</span></span><br><span class="line">                <span class="keyword">final</span> Range left = rangePool.isEmpty() ? <span class="keyword">new</span> Range() : rangePool.remove(</span><br><span class="line">                        rangePool.size() - <span class="number">1</span>);</span><br><span class="line">                <span class="comment">//起点为上一次的起点</span></span><br><span class="line">                left.oldListStart = range.oldListStart;</span><br><span class="line">                left.newListStart = range.newListStart;</span><br><span class="line">                <span class="comment">//如果是逆向得到的中间路径，那么左上角的终点为该中间路径的起点</span></span><br><span class="line">                <span class="keyword">if</span> (snake.reverse) &#123;</span><br><span class="line">                    left.oldListEnd = snake.x;</span><br><span class="line">                    left.newListEnd = snake.y;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (snake.removal) &#123;<span class="comment">//中间路径是向右操作，那么终点的x需要退一</span></span><br><span class="line">                        left.oldListEnd = snake.x - <span class="number">1</span>;</span><br><span class="line">                        left.newListEnd = snake.y;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;<span class="comment">//中间路径是向下操作，那么终点的y需要退一</span></span><br><span class="line">                        left.oldListEnd = snake.x;</span><br><span class="line">                        left.newListEnd = snake.y - <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                stack.add(left);</span><br><span class="line">                <span class="comment">// re-use range for right</span></span><br><span class="line">                <span class="comment">//noinspection UnnecessaryLocalVariable</span></span><br><span class="line">                <span class="keyword">final</span> Range right = range;<span class="comment">//右下角终点和之前的终点相同</span></span><br><span class="line">                <span class="keyword">if</span> (snake.reverse) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (snake.removal) &#123;<span class="comment">//中间路径是向右操作，那么起点的x需要进一</span></span><br><span class="line">                        right.oldListStart = snake.x + snake.size + <span class="number">1</span>;</span><br><span class="line">                        right.newListStart = snake.y + snake.size;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;<span class="comment">//中间路径是向下操作，那么起点的y需要进一</span></span><br><span class="line">                        right.oldListStart = snake.x + snake.size;</span><br><span class="line">                        right.newListStart = snake.y + snake.size + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果是逆向得到的中间路径，那么右下角的起点为该中间路径的终点</span></span><br><span class="line">                    right.oldListStart = snake.x + snake.size;</span><br><span class="line">                    right.newListStart = snake.y + snake.size;</span><br><span class="line">                &#125;</span><br><span class="line">                stack.add(right);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                rangePool.add(range);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// sort snakes</span></span><br><span class="line">        Collections.sort(snakes, SNAKE_COMPARATOR);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DiffResult(cb, snakes, forward, backward, detectMoves);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//diffPartial方法主要是来寻找一条snake，它的核心也就是Myers算法。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Snake <span class="title">diffPartial</span><span class="params">(Callback cb, <span class="keyword">int</span> startOld, <span class="keyword">int</span> endOld,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> startNew, <span class="keyword">int</span> endNew, <span class="keyword">int</span>[] forward, <span class="keyword">int</span>[] backward, <span class="keyword">int</span> kOffset)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> oldSize = endOld - startOld;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> newSize = endNew - startNew;</span><br><span class="line">        <span class="keyword">if</span> (endOld - startOld &lt; <span class="number">1</span> || endNew - startNew &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//差异增量</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> delta = oldSize - newSize;</span><br><span class="line">        <span class="comment">//最双向最长路径</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> dLimit = (oldSize + newSize + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//进行初始化设置</span></span><br><span class="line">        Arrays.fill(forward, kOffset - dLimit - <span class="number">1</span>, kOffset + dLimit + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        Arrays.fill(backward, kOffset - dLimit - <span class="number">1</span> + delta, kOffset + dLimit + <span class="number">1</span> + delta, oldSize);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 差异量为奇数</span></span><br><span class="line"><span class="comment">         * 每个差异-水平删除或垂直插入-都是从一千行移到其相邻行。</span></span><br><span class="line"><span class="comment">         * 由于增量是正向和反向算法中心之间的差异，因此我们知道需要检查中间snack的d值。</span></span><br><span class="line"><span class="comment">         * 对于奇数增量，我们必须寻找差异为d的前向路径与差异为d-1的反向路径重叠。</span></span><br><span class="line"><span class="comment">         * 类似地，对于偶数增量，重叠将是当正向和反向路径具有相同数量的差异时</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> checkInFwd = delta % <span class="number">2</span> != <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt;= dLimit; d++) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 这一循环是从(0,0)出发找到移动d步能达到的最远点</span></span><br><span class="line"><span class="comment">             * 引理：d和k同奇同偶，所以每次k都递增2</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = -d; k &lt;= d; k += <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">// find forward path</span></span><br><span class="line">                <span class="comment">// we can reach k from k - 1 or k + 1. Check which one is further in the graph</span></span><br><span class="line">                <span class="comment">//找到前进路径</span></span><br><span class="line">                <span class="comment">//我们可以从k-1或k + 1到达k。检查图中的哪个更远 </span></span><br><span class="line">                <span class="keyword">int</span> x;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">boolean</span> removal;<span class="comment">//向下</span></span><br><span class="line">                <span class="comment">//bool down = ( k == -d || ( k != d &amp;&amp; V[ k - 1 ] &lt; V[ k + 1 ] ) );</span></span><br><span class="line">                <span class="keyword">if</span> (k == -d || (k != d &amp;&amp; forward[kOffset + k - <span class="number">1</span>] &lt; forward[kOffset + k + <span class="number">1</span>])) &#123;</span><br><span class="line">                    x = forward[kOffset + k + <span class="number">1</span>];</span><br><span class="line">                    removal = <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    x = forward[kOffset + k - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    removal = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// set y based on x</span></span><br><span class="line">                <span class="comment">//k = x - y</span></span><br><span class="line">                <span class="keyword">int</span> y = x - k;</span><br><span class="line">                <span class="comment">// move diagonal as long as items match</span></span><br><span class="line">                <span class="comment">//只要item匹配就移动对角线</span></span><br><span class="line">                <span class="keyword">while</span> (x &lt; oldSize &amp;&amp; y &lt; newSize</span><br><span class="line">                        &amp;&amp; cb.areItemsTheSame(startOld + x, startNew + y)) &#123;</span><br><span class="line">                    x++;</span><br><span class="line">                    y++;</span><br><span class="line">                &#125;</span><br><span class="line">                forward[kOffset + k] = x;</span><br><span class="line">                <span class="comment">//如果delta为奇数，那么相连通的节点一定是向前移动的节点，也就是执行forward操作所触发的节点</span></span><br><span class="line">                <span class="comment">//if delta is odd and ( k &gt;= delta - ( d - 1 ) and k &lt;= delta + ( d - 1 ) )</span></span><br><span class="line">                <span class="keyword">if</span> (checkInFwd &amp;&amp; k &gt;= delta - d + <span class="number">1</span> &amp;&amp; k &lt;= delta + d - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">//if overlap with reverse[ d - 1 ] on line k</span></span><br><span class="line">                    <span class="comment">//forward'x &gt;= backward'x，如果在k线上正向查找能到到的位置的x坐标比反向查找达到的y坐标小</span></span><br><span class="line">                </span><br><span class="line">                    <span class="keyword">if</span> (forward[kOffset + k] &gt;= backward[kOffset + k]) &#123;</span><br><span class="line">                        Snake outSnake = <span class="keyword">new</span> Snake();</span><br><span class="line">                        outSnake.x = backward[kOffset + k];</span><br><span class="line">                        outSnake.y = outSnake.x - k;</span><br><span class="line">                        outSnake.size = forward[kOffset + k] - backward[kOffset + k];</span><br><span class="line">                        outSnake.removal = removal;</span><br><span class="line">                        outSnake.reverse = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span> outSnake;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 这一循环是从(m,n)出发找到移动d步能达到的最远点</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = -d; k &lt;= d; k += <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">// find reverse path at k + delta, in reverse</span></span><br><span class="line">                <span class="comment">//以k + delta,找到反向路径。backwardK相当于反向转化之后的正向的k</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> backwardK = k + delta;</span><br><span class="line">                <span class="keyword">int</span> x;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">boolean</span> removal;</span><br><span class="line">                <span class="comment">//与k线类似</span></span><br><span class="line">                <span class="comment">//bool down = ( k == -d || ( k != d &amp;&amp; V[ k - 1 ] &lt; V[ k + 1 ] ) );</span></span><br><span class="line">                <span class="keyword">if</span> (backwardK == d + delta || (backwardK != -d + delta </span><br><span class="line">                        &amp;&amp; backward[kOffset + backwardK - <span class="number">1</span>] &lt; backward[kOffset + backwardK + <span class="number">1</span>])) &#123;</span><br><span class="line">                    x = backward[kOffset + backwardK - <span class="number">1</span>];</span><br><span class="line">                    removal = <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    x = backward[kOffset + backwardK + <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">                    removal = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// set y based on x</span></span><br><span class="line">                <span class="keyword">int</span> y = x - backwardK;</span><br><span class="line">                <span class="comment">// move diagonal as long as items match</span></span><br><span class="line">                <span class="comment">//只要item匹配就移动对角线</span></span><br><span class="line">                <span class="keyword">while</span> (x &gt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span></span><br><span class="line">                        &amp;&amp; cb.areItemsTheSame(startOld + x - <span class="number">1</span>, startNew + y - <span class="number">1</span>)) &#123;</span><br><span class="line">                    x--;</span><br><span class="line">                    y--;</span><br><span class="line">                &#125;</span><br><span class="line">                backward[kOffset + backwardK] = x;</span><br><span class="line">                <span class="comment">//如果delta为偶数，那么相连通的节点一定是反向移动的节点，也就是执行backward操作所触发的节点</span></span><br><span class="line">                <span class="comment">//if delta is even and ( k &gt;= -d - delta and k &lt;= d - delta )</span></span><br><span class="line">                <span class="keyword">if</span> (!checkInFwd &amp;&amp; k + delta &gt;= -d &amp;&amp; k + delta &lt;= d) &#123;</span><br><span class="line">                    <span class="comment">//if overlap with forward[ d ] on line k</span></span><br><span class="line">                    <span class="comment">//forward'x &gt;= backward'x，判断正向反向是否连通了</span></span><br><span class="line">                    <span class="keyword">if</span> (forward[kOffset + backwardK] &gt;= backward[kOffset + backwardK]) &#123;</span><br><span class="line">                        Snake outSnake = <span class="keyword">new</span> Snake();</span><br><span class="line">                        outSnake.x = backward[kOffset + backwardK];</span><br><span class="line">                        outSnake.y = outSnake.x - backwardK;</span><br><span class="line">                        outSnake.size =</span><br><span class="line">                                forward[kOffset + backwardK] - backward[kOffset + backwardK];</span><br><span class="line">                        outSnake.removal = removal;</span><br><span class="line">                        outSnake.reverse = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">return</span> outSnake;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"DiffUtil hit an unexpected case while trying to calculate"</span></span><br><span class="line">                + <span class="string">" the optimal path. Please make sure your data is not changing during the"</span></span><br><span class="line">                + <span class="string">" diff calculation."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//部分代码省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考链接：<br><a href="https://github.com/google/diff-match-patch" target="_blank" rel="noopener">代码:diff-match-patch</a><br><a href="http://xmailserver.org/diff2.pdf" target="_blank" rel="noopener">diff2论文</a><br><a href="https://www.codeproject.com/Articles/42279/Investigating-Myers-diff-algorithm-Part-1-of-2" target="_blank" rel="noopener">Myers diff alogrithm:part 1</a><br><a href="https://www.codeproject.com/Articles/42280/Investigating-Myers-Diff-Algorithm-Part-2-of-2" target="_blank" rel="noopener">Myers diff alogrithm:part 2</a></p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Arithmetic</category>
      </categories>
      <tags>
        <tag>Diff</tag>
      </tags>
  </entry>
  <entry>
    <title>Myers'Diff之线性空间细化</title>
    <url>/2020/10/20/myers-diff-od/</url>
    <content><![CDATA[<h1 id="Myers’diff"><a href="#Myers’diff" class="headerlink" title="Myers’diff"></a>Myers’diff</h1><p><img src="https://img-blog.csdnimg.cn/20201012201130708.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0dmVuX2tpbmc=,size_16,color_FFFFFF,t_70#pic_center" alt="美图"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在学习完上一篇文章<a href="https://dandanlove.blog.csdn.net/article/details/108979400" target="_blank" rel="noopener">Myers’Diff之贪婪算法</a> 之后，我对<code>Android</code>源码中的<code>DiffUtil</code>类进行了阅读发现其算法的实现和文章中的方式并不尽相同，而是在其基础之上再次进行的优化。所以本篇文章是以上一篇<a href="https://dandanlove.blog.csdn.net/article/details/108979400" target="_blank" rel="noopener">Myers’Diff之贪婪算法</a> 文章内容基础之上对它的变体进行再次研究的过程。</p>
<p>上一篇文章<a href="https://dandanlove.blog.csdn.net/article/details/108979400" target="_blank" rel="noopener">Myers’Diff之贪婪算法</a> 讲述<code>diff</code>怎么从一个抽象的问题转化为数学问题，并对一些名词做了专有的定义（为解决问题的过程提供辅助），<code>Myers&#39;Diff之贪婪算法</code>讲述了利用辅助的<code>k线</code>进行迭代求解，整改过程并不考虑时间和空间的消耗。所以这篇文章主要是在其基础之上进行时间和空间复杂度的优化。</p>
<h2 id="逆向算法"><a href="#逆向算法" class="headerlink" title="逆向算法"></a>逆向算法</h2><p><code>Myers&#39;Diff之贪婪算反</code> 是从<code>(0,0)</code>到<code>(N,M)</code>进行移动的，它的反向工作是从<code>(N,M)</code>到<code>(0,0)</code>。</p>
<p><img src="https://img-blog.csdnimg.cn/20201010143343944.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0dmVuX2tpbmc=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>从该图可以看出，该解决方案不同于通过向前工作而生成的解决方案，但是其<code>LCS</code>和<code>SES</code>的长度相同。 但这是完全正确的，因为通常可以有许多等效的解决方案，并且该算法只是选择找到的第一个解决方案。</p>
<h4 id="Delta"><a href="#Delta" class="headerlink" title="Delta"></a>Delta</h4><blockquote>
<p>因为序列<code>A</code>和<code>B</code>的长度可以不同，所以正向和反向算法的<code>k线</code>可以不同。 将此差异作为变量<code>delta = N-M</code>隔离是有用的。在示例中，<code>N = 7</code>和<code>M = 6</code>给出了<code>delta =1</code>。这是从<code>前k行</code>到<code>后k行</code>的偏移量。 您可以说正向路径以<code>k = 0</code>为中心，反向路径以<code>k = delta</code>为中心。</p>
</blockquote>
<h4 id="Middle-Snake"><a href="#Middle-Snake" class="headerlink" title="Middle Snake"></a>Middle Snake</h4><p>可以对<code>D</code>的连续值同时运行<code>正向</code>和<code>反向</code>算法。在<code>D</code>的某个值处，两条路径将在<code>k线</code>上重叠。 本文证明这些路径之一是解决方案的一部分。 由于它将位于中间的某个地方，因此称为中间路径。</p>
<p>该示例的中间路径在此图中以粉红色显示：</p>
<p><img src="https://img-blog.csdnimg.cn/20201010150112608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0dmVuX2tpbmc=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>这很有用，因为它将问题分为两部分，然后可以分别递归解决。<br>这在空间上是线性的，因为只有最后的V向量必须存储，给出<code>O（D）</code>。对于时间，此线性算法仍为<code>O（（N + M）D）</code>。</p>
<p>这也有助于找到中间路径，其D必须是正向和反向算法D的一半。这意味着随着D的增加，所需时间接近基本算法的一半。</p>
<p>伪代码：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> d = <span class="number">0</span> to ( N + M + <span class="number">1</span> ) / <span class="number">2</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> k = -d to d step <span class="number">2</span></span><br><span class="line">  &#123;</span><br><span class="line">    calculate the furthest reaching forward <span class="keyword">and</span> reverse paths</span><br><span class="line">    <span class="keyword">if</span> there is an overlap, we have a middle snake</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Odd-and-Even-Deltas"><a href="#Odd-and-Even-Deltas" class="headerlink" title="Odd and Even Deltas"></a>Odd and Even Deltas</h4><p>每个差异<code>水平删除</code>或<code>垂直插入</code>都是从<code>k行</code>移到其相邻行。由于增量是正向和反向算法中心之间的差异，因此我们知道需要检查中间路径的<code>d</code>值。</p>
<p>对于奇数增量，我们必须寻找差异为<code>d</code>的前向路径与差异为<code>d-1</code>的反向路径重叠。<br>下图显示，对于<code>delta = 3</code>，当<code>正向d</code>为<code></code>2而<code>反向d</code>为<code>1</code>时发生重叠：</p>
<p><img src="https://img-blog.csdnimg.cn/20201010150752794.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0dmVuX2tpbmc=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>类似地，对于偶数增量，当正向和反向路径的差异数相同时，就会出现重叠。<br>下图显示，对于<code>delta = 2</code>，当<code>正向</code>和<code>反向</code> 的 <code>d</code>均为<code>2</code>时，发生重叠：</p>
<p><img src="https://img-blog.csdnimg.cn/20201010150901753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0dmVuX2tpbmc=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>因此，这是查找中间路径的完整伪代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">delta = N - M</span><br><span class="line"><span class="keyword">for</span> d = <span class="number">0</span> to ( N + M + <span class="number">1</span> ) / <span class="number">2</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> k = -d to d step <span class="number">2</span></span><br><span class="line">  &#123;</span><br><span class="line">    calculate the furthest reaching forward path on line k</span><br><span class="line">    <span class="keyword">if</span> delta is odd <span class="keyword">and</span> ( k &gt;= delta - ( d - <span class="number">1</span> ) <span class="keyword">and</span> k &lt;= delta + ( d - <span class="number">1</span> ) )</span><br><span class="line">      <span class="keyword">if</span> overlap with reverse[ d - <span class="number">1</span> ] on line k</span><br><span class="line">        =&gt; found middle snake <span class="keyword">and</span> SES of length <span class="number">2</span>D - <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> k = -d to d step <span class="number">2</span></span><br><span class="line">  &#123;</span><br><span class="line">    calculate the furthest reaching reverse path on line k</span><br><span class="line">    <span class="keyword">if</span> delta is even <span class="keyword">and</span> ( k &gt;= -d - delta <span class="keyword">and</span> k &lt;= d - delta )</span><br><span class="line">      <span class="keyword">if</span> overlap with forward[ d ] on line k</span><br><span class="line">        =&gt; found middle snake <span class="keyword">and</span> SES of length <span class="number">2</span>D</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>(N+M+1) / 2</code> 从两端同时出发，意味着外循环次数<strong>大于等于</strong>最长路径的二分之一；</li>
<li>如果<code>delta</code> 是偶数那么中间路径在向前的方向中出现；</li>
<li>如果<code>delta</code> 是偶数那么中间路径在向后的方向中出现；</li>
</ul>
<h3 id="递归解决"><a href="#递归解决" class="headerlink" title="递归解决"></a>递归解决</h3><p>我们需要以递归方法包装中间路径算法。基本上，我们需要找到一条中间的路径，然后求解保留在<strong>左上角</strong>和<strong>右下角</strong>的矩形。</p>
<p>伪代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Compare( A, N, B, M )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( M == <span class="number">0</span> &amp;&amp; N &gt; <span class="number">0</span> ) add N deletions to SES</span><br><span class="line">  <span class="keyword">if</span> ( N == <span class="number">0</span> &amp;&amp; M &gt; <span class="number">0</span> ) add M insertions to SES</span><br><span class="line">  <span class="keyword">if</span> ( N == <span class="number">0</span> || M == <span class="number">0</span> ) <span class="keyword">return</span>  </span><br><span class="line">  calculate middle snake</span><br><span class="line">  suppose it is from ( x, y ) to ( u, v ) with total differences D</span><br><span class="line">  <span class="keyword">if</span> ( D &gt; <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    Compare( A[ <span class="number">1</span> .. x ], x, B[ <span class="number">1</span> .. y ], y ) <span class="comment">// top left</span></span><br><span class="line">    Add middle snake to results</span><br><span class="line">    Compare( A[ u + <span class="number">1</span> .. N ], N - u, B[ v + <span class="number">1</span> .. M ], M - v ) <span class="comment">// bottom right</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( D == <span class="number">1</span> ) <span class="comment">// must be forward snake</span></span><br><span class="line">  &#123;</span><br><span class="line">    Add d = <span class="number">0</span> diagonal to results</span><br><span class="line">    Add middle snake to results</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( D == <span class="number">0</span> ) <span class="comment">// must be reverse snake</span></span><br><span class="line">  &#123;</span><br><span class="line">    Add middle snake to results</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我将在稍后解释几个边缘情况。</p>
<h4 id="Edge-case"><a href="#Edge-case" class="headerlink" title="Edge case"></a>Edge case</h4><p>上面的伪代码需要考虑两个边界case，<code>d=0</code>和<code>d=1</code>。</p>
<p>如果中间路径算法找到<code>D = 0</code>的解，则两个序列相同。这意味着增量为零，即为偶数。因此，中间路径是一条正好匹配（对角线）的反向路径。因此，我们要做的就是将这条路径添加到结果中。</p>
<p><img src="https://img-blog.csdnimg.cn/20201010155143841.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0dmVuX2tpbmc=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>如果中间的路径算法找到<code>D = 1</code>的解，那么就存在一个插入或删除。这意味着<code>delta</code>是<code>1</code>或<code>-1</code>，这是奇数，因此中间的路径是前向路径。 对于这种情况，我们可以通过计算<code>d = 0</code>对角线并将其与中间路径一起添加到结果中来完成解决方案。</p>
<p><img src="https://img-blog.csdnimg.cn/20201010155245225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0dmVuX2tpbmc=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="总结对比"><a href="#总结对比" class="headerlink" title="总结对比"></a>总结对比</h2><p>这次的优化还是以递归方法进行的，与<a href="https://dandanlove.blog.csdn.net/article/details/108979400" target="_blank" rel="noopener">Myers’Diff之贪婪算法</a> 的递归不同的是。这次的递归我们需要找到一条中间的路径，然后进行<strong>左上角</strong>和<strong>右下角</strong>的矩形拆分，将拆分之后的矩形再进行递归。<code>O((M+N)lg(􏰎􏰏M+N)+D2)</code> 为最坏的情况。时间约为 <code>O(N + M)D)</code> 其<code>D</code>必须是<strong>正向和反向算法</strong> <code>D</code>的一半。这意味着随着<code>D</code>的增加，所需时间接近基本算法的一半。</p>
<p>算法实践：<a href="https://dandanlove.blog.csdn.net/article/details/109123553" target="_blank" rel="noopener">DiffUtil和它的差量算法</a></p>
<p>参考链接：<br><a href="https://github.com/google/diff-match-patch" target="_blank" rel="noopener">代码:diff-match-patch</a><br><a href="http://xmailserver.org/diff2.pdf" target="_blank" rel="noopener">diff2论文</a><br><a href="https://www.codeproject.com/Articles/42279/Investigating-Myers-diff-algorithm-Part-1-of-2" target="_blank" rel="noopener">Myers diff alogrithm:part 1</a><br><a href="https://www.codeproject.com/Articles/42280/Investigating-Myers-Diff-Algorithm-Part-2-of-2" target="_blank" rel="noopener">Myers diff alogrithm:part 2</a></p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Arithmetic</category>
      </categories>
      <tags>
        <tag>Diff</tag>
      </tags>
  </entry>
  <entry>
    <title>Myers‘Diff之贪婪算法</title>
    <url>/2020/10/20/myers-diff-greedy/</url>
    <content><![CDATA[<h1 id="Myers’Diff"><a href="#Myers’Diff" class="headerlink" title="Myers’Diff"></a>Myers’Diff</h1><p><img src="https://img-blog.csdnimg.cn/20201012200724264.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0dmVuX2tpbmc=,size_16,color_FFFFFF,t_70#pic_center" alt="美图"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>写这篇文章已经拖了很久了，因为一直在准备后续的 <a href="https://dandanlove.blog.csdn.net/article/details/108996040" target="_blank" rel="noopener">Myers‘Diff之线性空间细化</a> 。最初不知道是什么时候发现 <code>DiffUtil</code> 对比列表 <code>item</code> 数据进行局部刷新，<code>git</code> 文件对比都用到了这个算法。上个月刚好再一次看到了就想深入了解一下。但发现发现国内的博客和帖子，对这个算法的讲述内容比较少，每篇文章都讲述了作者自己认为重要的内容，所以有一个点搞不懂的话没法整体性的进行理解。刚开始我自己就有一个点没想清楚想了好几天，我觉得程序员不能怕算法，书读百遍其义自现，阅读算法代码也是如此，平时多思考偶尔的一点灵光出现会减少你死磕算法浪费的时间。</p>
<h2 id="Myer差分算法"><a href="#Myer差分算法" class="headerlink" title="Myer差分算法"></a>Myer差分算法</h2><p>举一个最常见的例子，我们使用 <code>git</code> 进行提交时，通常会查看这次提交做了哪些改动，这里我们先简单定义一下什么是 <code>diff</code> ：<code>diff</code> 就是目标文本和源文本之间的区别，也就是将源文本变成目标文本所需要的操作。<code>Myers算法</code> 由 <code>Eugene W.Myers</code> 在 <code>1986</code> 年发表在 <code>《 Algorithmica》</code> 杂志上。的一篇<a href="http://xmailserver.org/diff2.pdf" target="_blank" rel="noopener">论文</a>中提出，是一个能在大部分情况产生<strong>最短的直观的diff</strong> 的一个算法。</p>
<p><img src="https://img-blog.csdnimg.cn/20201009164930993.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0dmVuX2tpbmc=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>寻找最短的直观的diff</strong> 是一个非常模糊的问题，首先，我们需要把这个问题抽象为一个具体的数学问题，然后再来寻找算法解决。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li><p>File A and File B</p>
<blockquote>
<p>The diff algorithm takes two files as input. The first, usually older, one is file A, and the second one is file B. The algorithm generates instructions to turn file A into file B.(diff算法将两个文件作为输入。第一个通常是较旧的文件是文件A，第二个是文件B。算法生成指令以将文件A转换为文件B。)</p>
</blockquote>
</li>
<li><p>Shortest Edit Script ( SES )</p>
<blockquote>
<p>The algorithm finds the Shortest Edit Script that converts file A into file B. The SES contains only two types of commands: deletions from file A and insertions in file B.(该算法找到将文件A转换为文件B的最短编辑脚本。SES仅包含两种类型的命令：从文件A删除和在文件B中插入。)</p>
</blockquote>
</li>
<li><p>Longest Common Subsequence ( LCS )</p>
<blockquote>
<p>Finding the SES is equivalent to finding the Longest Common Subsequence of the two files. The LCS is the longest list of characters that can be generated from both files by removing some characters. The LCS is distinct from the Longest Common Substring, which has to be contiguous.(查找SES等同于找到两个文件的最长公共子序列。 LCS是可以通过删除某些字符从两个文件生成的最长字符列表。 LCS与最长公共子字符串不同，后者必须是连续的。)</p>
</blockquote>
</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>本文使用与本文相同的示例。文件<code>A</code>包含 <code>ABCABBA</code>，文件<code>B</code>包含<code>CBABAC</code>。这些被表示为两个字符数组：<code>A []</code>和<code>B []</code>。<br><code>A []</code>的长度为<code>N</code>，<code>B []</code>的长度为<code>M</code>。</p>
<p>我们就可以求解从<code>A数组</code>变成<code>B数组</code>的问题，转换成为求解从<code>A字符串</code>变成<code>B字符串</code>的问题（将抽象问题具现）。</p>
<p><img src="https://img-blog.csdnimg.cn/20201009170750344.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0dmVuX2tpbmc=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><code>数组A</code>沿<code>x轴</code>放在顶部。<code>数组B</code>沿<code>y轴</code>向下放置。</p>
<p>PS:文章中的图都是由<a href="https://www.codeproject.com/KB/recipes/DiffTutorial_2/DiffTutorial_bin.zip" target="_blank" rel="noopener">DiffTutorial</a>软件制作而成，该应用程序是一种学习辅助工具。它显示算法各个阶段的图形表示。</p>
<p>解决方案：从<code>左上角（0，0）</code>到<code>右下角（7，6）</code>的最短路径。 您始终可以水平或垂直移动一个字符。水平<code>（右）</code>移动表示从<code>文件A</code>中删除，垂直<code>（向下）</code>移动表示在<code>文件B</code>中插入。如果存在匹配的字符，则还可以对角移动，以匹配结束。 解决方案是包含最多对角线的迹线。 <code>LCS</code>是轨迹中的对角线，<code>SES</code>是轨迹中的水平和垂直移动。例如，<code>LCS</code>的长度为4个字符，<code>SES</code>的长度为5个差异。</p>
<blockquote>
<p>snake: 一条snake代表走一步。例如从(0,0)-&gt;(0,1) / (0,0)-&gt;(1,0) / (0,1)-&gt;(0,2)-&gt;(2,4) 这分别为三条snake，走对角线不计入步数。</p>
</blockquote>
<blockquote>
<p>k line: k lines表示长的对角线，其中每个k = x - y。假设一个点m(m,n),那么它所在的k line值为m - n。</p>
</blockquote>
<blockquote>
<p>d contour: 每条有效路径(能从(0,0)到(m,n)的路径都称为有效路径)的步数。形象点，一条path有多个snake组成，这里d contours表示snake的个数。</p>
</blockquote>
<h2 id="贪婪算法"><a href="#贪婪算法" class="headerlink" title="贪婪算法"></a>贪婪算法</h2><p>该算法是迭代的。它计算连续 <code>d</code> 的每条 <code>k</code> 线上最远的到达路径。当路径到达右下角时，将找到解决方案。</p>
<blockquote>
<p>这里面有很重要的几点：</p>
<ol>
<li>路径的终点必然在<code>k</code>线上。迭代进行，所以<code>k</code>线的上一步操作是<code>k+1</code>向下移动或者<code>k-1</code>向右移动；</li>
<li>计算连续的<code>d</code>每条<code>k</code>线上最远的到达路径（偶数<code>d</code>的端点在偶数<code>k</code>线，奇数类似）；</li>
<li>路径到达右下角结束；</li>
</ol>
<p>其中1和2都是在论文中进行了证明~！</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20201009192930777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0dmVuX2tpbmc=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li><code>k line</code>：棕色线是k的奇数值的k条线。黄线是k的偶数值的k线。 </li>
<li><code>snake</code>：深蓝色的线条是蛇。红蛇显示溶液痕迹。 </li>
<li><code>d contours</code>：淡蓝色的线是差异轮廓。例如，标记为“ 2”的直线上的三个端点全部具有2个水平或垂直移动。</li>
</ul>
<h3 id="外循环次数"><a href="#外循环次数" class="headerlink" title="外循环次数"></a>外循环次数</h3><p>从（x、y）组成的矩形<code>左上角</code>，到<code>右下角</code>。最长的路径莫过于所有对角线都不经过。也就是只走<code>X</code>和<code>Y</code>的长度即<code>最大长度=N+M</code>。<br><figure class="highlight plain"><figcaption><span>( int d </span></figcaption><table><tr><td class="code"><pre><span class="line">### 内循环的次数</span><br><span class="line">在此循环内，我们必须为每条`k线`找到最远的到达路径。对于给定的`d`，只能到达的`k线`位于`[-d .. + d]`范围内。当所有移动都向下时，`k = -d` 是可能的；当所有移动都在右侧时，`k = + d` 是可能的。</span><br><span class="line">```for ( int k = -d ; k &lt;= d ; k += 2 )</span><br></pre></td></tr></table></figure></p>
<p>看到这里也许就有人产生疑问，为什么是<code>k+=2</code>。</p>
<blockquote>
<p>这块有一个优化，文章前面说过<code>偶数</code>d<code>的端点在偶数</code>k<code>线，奇数类似</code>。<br>解释：移动奇数步长（前进或者后退都行）最终位置一定在奇数的<code>k线</code>上，偶数步长的最终位置一定在偶数的<code>k线</code>上。<br>PS：这里让我纠结了好长时间，最后一下几点思考让我想的更加清楚：</p>
<ol>
<li>从<code>零</code>开始一步一步在<code>k线</code>上进行移动，一定是从<code>零</code>开始。</li>
<li>这里的计算不是偶数加偶数得到的还是偶数，奇数加奇数得到的数是奇数或者偶数（这里是计算多个<code>+1或-1</code>）。</li>
<li>无论偶数还是奇数<code>+1或-1</code>之后都会改变自己的奇偶性，所以<code>d</code>次操作之后的奇偶性由<code>d</code>的奇偶进行决定。由因为起点为偶数<code>零</code>，所以说<code>偶数</code>d<code>的端点在偶数</code>k<code>线，奇数类似</code>。</li>
</ol>
</blockquote>
<h3 id="举例说明（d-3）"><a href="#举例说明（d-3）" class="headerlink" title="举例说明（d=3）"></a>举例说明（d=3）</h3><p>从<code>d = 3</code>的示例进行研究，这意味着<code>k</code>的取值范围是<code>[-3，-1，1，3]</code>。为了帮助您，我将示例中的<code>snake</code>的端点转录到下表中：<br><img src="https://img-blog.csdnimg.cn/20201010102738607.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0dmVuX2tpbmc=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p>k = -3：这种情况下，只有当k = -2，d = 2时，向下移动一步(k = -4, d = 2这种情况不存在)。所以，我们可以这么来走，从(2,4)点开始向下走到(2,5),由于(2,5)和(3,6)之间存在一个对角线，可以走到(3,6)。所以着整个snake是：(2,4) -&gt; (2,5) -&gt; (3,6)。</p>
</blockquote>
<blockquote>
<p>k = -1：当k = -1时，有两种情况需要来讨论：分别是k = 0，d = 2向下走；k = -2 ，d = 2向右走。</p>
<ul>
<li>当k = 0，d = 2时，是(2,2)点。所以当从(2,2)点向下走一步，到达(2,3),由于(2,3)没有对角线连接，所以整个snake是：(2,2) -&gt; (2,3)。</li>
<li>当k = -2 ，d = 2时，是(2,4)点。所以当从(2,4)点向右走一步，到达(3,4)，由于(3,4)与(4,5)存在对角线，所以整个snake是：(2,4) -&gt; (3,4) -&gt; (4,5)。</li>
</ul>
<p>在整个过程中，存在两条snake，我们选择是沿着k line走的最远的snake，所以选择第二条snake。</p>
</blockquote>
<blockquote>
<p>k = 1：当k = 1时，存在两种可能性，分别是从k = 0向右走一步，或者k = 2向下走一步，我们分别来讨论一下。</p>
<ul>
<li>当k = 0，d = 2时，是(2,2)点。所以当从(2,2)向右走一步，到达(3,2),由于(3,2)与(5,4)存在对角线，所以整个snake是：(2,2) -&gt;(3,2) -&gt;(5,4)。</li>
<li>当k = 2，d = 2时，是(3,1)点。所以当从(3,1)向下走一步，到达(3,2)。所以这个snake是：(3,1) -&gt;(3,2) -&gt;(5,4)。</li>
</ul>
<p>在整个过程中，存在两条snake，我们选择起点x值较大的snake，所以是：(3,1) -&gt;(3,2) -&gt;(5,4)。</p>
</blockquote>
<blockquote>
<p>k = 3：这种情况下，(k = 4， d = 2)是不可能的，所以我们必须在(k = 2，d = 2)时向右移动一步。当k = 2, d = 2时， 是(3,1)点。所以从(3,1)点向右移动一步是(4,1)点。所以整个snake是：(3,1) -&gt; (4,1) -&gt; (5,2).</p>
</blockquote>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p>我们有两个循环，我们需要一个数据结构。<br>请注意，<code>d（n）</code>的解仅取决于<code>d（n-1）</code>的解。还请记住，对于<code>d</code>的偶数值，我们在偶数<code>k行</code>上找到端点，而这些端点仅取决于全部在奇数k行上的先前端点。对于<code>d</code>的奇数值也是如此。<br>我们使用称为<code>V</code>的数组，其中<code>k</code>为索引，终点的<code>x</code>位置为值。我们不需要存储<code>y</code>位置，因为我们可以根据<code>x</code>和<code>k</code>来计算它：<code>y = x-k</code>。同样，对于给定的<code>d</code>，<code>k</code>在<code>[-d .. d]</code>范围内。</p>
<figure class="highlight plain"><figcaption><span>down </span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">如果`k = -d`，我们一定是向下移动了；如果`k = d`，我们一定是向右移动了。</span><br><span class="line">对于正常的中间情况，我们选择从`x`值较大的任何相邻行开始。这保证了我们到达`k`线上尽可能远的点。</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">V[ 1 ] = 0;</span><br><span class="line">for ( int d = 0 ; d &lt;= N + M ; d++ )//外循环，进行多少次代表有多少个snake和V数组</span><br><span class="line">&#123;</span><br><span class="line">  for ( int k = -d ; k &lt;= d ; k += 2 )//内循环</span><br><span class="line">  &#123;</span><br><span class="line">    // down or right?</span><br><span class="line">    bool down = ( k == -d || ( k != d &amp;&amp; V[ k - 1 ] &lt; V[ k + 1 ] ) );</span><br><span class="line">    int kPrev = down ? k + 1 : k - 1;//如果向下，那么上一步应该是k+1</span><br><span class="line">    // start point，上一个点</span><br><span class="line">    int xStart = V[ kPrev ];//v[k]=x</span><br><span class="line">    int yStart = xStart - kPrev;//y=x-k</span><br><span class="line">    // mid point，下一个点</span><br><span class="line">    int xMid = down ? xStart : xStart + 1;</span><br><span class="line">    int yMid = xMid - k;</span><br><span class="line">    // end point</span><br><span class="line">    int xEnd = xMid;</span><br><span class="line">    int yEnd = yMid;</span><br><span class="line">    // follow diagonal</span><br><span class="line">    int snake = 0;//是否有对角线继续往重点走</span><br><span class="line">    while ( xEnd &lt; N &amp;&amp; yEnd &lt; M &amp;&amp; A[ xEnd ] == B[ yEnd ] ) </span><br><span class="line">    &#123; </span><br><span class="line">    	xEnd++; yEnd++; snake++; </span><br><span class="line">   	&#125;</span><br><span class="line">    // save end point</span><br><span class="line">    V[ k ] = xEnd;</span><br><span class="line">    // check for solution</span><br><span class="line">    if ( xEnd &gt;= N &amp;&amp; yEnd &gt;= M ) /* solution has been found */</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码寻找一条到达终点的<code>snake</code>。因为<code>V数组</code>里面存储的是在<code>k line</code>最新端点的坐标，所以为了寻找到所有的<code>snake</code>，我们在<code>d</code>的每次循环完毕之后，从<code>d(Solution)遍历到0</code>。如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">IList&lt;V&gt; Vs; <span class="comment">// saved V's indexed on d</span></span><br><span class="line">IList&lt;Snake&gt; snakes; <span class="comment">// list to hold solution</span></span><br><span class="line"><span class="comment">//从后往前推，最后一条snake是到达终点必须经过的路线。</span></span><br><span class="line">POINT p = <span class="keyword">new</span> POINT( N, M ); <span class="comment">// start at the end</span></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> d = vs.Count - <span class="number">1</span> ; p.X &gt; <span class="number">0</span> || p.Y &gt; <span class="number">0</span> ; d-- )</span><br><span class="line">&#123;</span><br><span class="line">  var V = Vs[ d ];<span class="comment">//内循环产生的数据</span></span><br><span class="line">  <span class="keyword">int</span> k = p.X - p.Y;<span class="comment">//本次循环的起点的k线</span></span><br><span class="line">  <span class="comment">// end point is in V</span></span><br><span class="line">  <span class="keyword">int</span> xEnd = V[ k ];</span><br><span class="line">  <span class="keyword">int</span> yEnd = x - k;</span><br><span class="line">  <span class="comment">// down or right?</span></span><br><span class="line">  <span class="keyword">bool</span> down = ( k == -d || ( k != d &amp;&amp; V[ k - <span class="number">1</span> ] &lt; V[ k + <span class="number">1</span> ] ) );</span><br><span class="line">  <span class="keyword">int</span> kPrev = down ? k + <span class="number">1</span> : k - <span class="number">1</span>;<span class="comment">//上一个snake的k线</span></span><br><span class="line">  <span class="comment">// start point</span></span><br><span class="line">  <span class="keyword">int</span> xStart = V[ kPrev ];</span><br><span class="line">  <span class="keyword">int</span> yStart = xStart - kPrev;</span><br><span class="line">  <span class="comment">// mid point</span></span><br><span class="line">  <span class="keyword">int</span> xMid = down ? xStart : xStart + <span class="number">1</span>;<span class="comment">//中间点</span></span><br><span class="line">  <span class="keyword">int</span> yMid = xMid - k;</span><br><span class="line">  snakes.Insert( <span class="number">0</span>, <span class="keyword">new</span> Snake( <span class="comment">/* start, mid and end points */</span> ) );</span><br><span class="line">  p.X = xStart;</span><br><span class="line">  p.Y = yStart;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度: 期望为<code>O(M+N+D^2)</code>，最坏情况为为<code>O((M+N)D)</code> 。</p>
<p>有兴趣的可以继续阅读下一篇文章 <a href="https://dandanlove.blog.csdn.net/article/details/108996040" target="_blank" rel="noopener">Myers‘Diff之线性空间细化</a> 。</p>
<p>算法实践：<a href="https://dandanlove.blog.csdn.net/article/details/109123553" target="_blank" rel="noopener">DiffUtil和它的差量算法</a></p>
<p>参考链接：<br><a href="https://github.com/google/diff-match-patch" target="_blank" rel="noopener">代码:diff-match-patch</a><br><a href="http://xmailserver.org/diff2.pdf" target="_blank" rel="noopener">diff2论文</a><br><a href="https://www.codeproject.com/Articles/42279/Investigating-Myers-diff-algorithm-Part-1-of-2" target="_blank" rel="noopener">Myers diff alogrithm:part 1</a><br><a href="https://www.codeproject.com/Articles/42280/Investigating-Myers-Diff-Algorithm-Part-2-of-2" target="_blank" rel="noopener">Myers diff alogrithm:part 2</a></p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Arithmetic</category>
      </categories>
      <tags>
        <tag>Diff</tag>
      </tags>
  </entry>
  <entry>
    <title>App Startup 源码分析</title>
    <url>/2020/07/07/startup-runtime/</url>
    <content><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20200707194954333.jpeg" alt="startup"></p>
<p>上篇文章 <a href="https://dandanlove.blog.csdn.net/article/details/107188633" target="_blank" rel="noopener">非侵入试获取Context进行SDK初始化</a> 讲述了通过<code>ContentProvider</code> 进行 <code>SDK</code> 的初始化，文章末尾引出了 <code>App Startup</code> 。如果一个 <code>app</code> 依赖了很多需要初始化的 <code>sdk</code> ，如果都放在一个 <code>ContentProvider</code> 中会导致此 <code>ContentProvider</code> 代码数量增加。而如果每个sdk都采用同样的方式将会带来性能问题。<code>App Startup</code>可以有效解决这个问题。</p>
<p><a href="https://developer.android.google.cn/topic/libraries/app-startup" target="_blank" rel="noopener">Jetpack StartUp官网</a> </p>
<h2 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h2><p>使用 <code>startup</code> 在你的 <code>Android App</code> 或者 <code>Android Library</code> ，需要在你 <code>build.gradle</code> 添加下边依赖。</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    implementation <span class="string">"androidx.startup:startup-runtime:1.0.0-alpha01"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="接入"><a href="#接入" class="headerlink" title="接入"></a>接入</h2><p><code>Apps</code> 和 <code>Library</code> 通常依赖于应用程序启动时立即初始化组件。</p>
<p>我们可以通过使用 <code>ContentProvider</code> 初始化每个依赖关系来满足此需求，但是  <code>ContentProvider</code> 的实例化成本很高，并且可能不必要地减慢启动顺序。此外，  <code>ContentProvider</code>  的初始化是无序的。</p>
<p><code>App Startup</code> 提供了一种更高效的方法，可在应用程序启动时初始化组件并显式定义其依赖关系。</p>
<h3 id="实现初始化组件"><a href="#实现初始化组件" class="headerlink" title="实现初始化组件"></a>实现初始化组件</h3><p>我们定义的每一个初始化组件必现实现 <a href="https://developer.android.google.cn/reference/kotlin/androidx/startup/Initializer" target="_blank" rel="noopener">Initializer</a> 接口，这个接口定义了两个方法 ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Initializer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function">T <span class="title">create</span><span class="params">(@NonNull Context paramContext)</span></span>;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    List&lt;Class&lt;? extends Initializer&lt;?&gt;&gt;&gt; dependencies();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>create()</code> ，这个方法会包含组件初始话的所有的操作，最终会返回一个实例 <code>T</code>；</li>
<li><code>dependencies()</code>，这个方法返回一组实现了 <code>Initializer&lt;T&gt;</code> 的类，这些都是当前组件初始化需要依赖的其他组件。可以使用此方法来控制应用程序在启动时运行初始化程序的顺序。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Initializes WorkManager.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkManagerInitializer</span> <span class="keyword">extends</span> <span class="title">Initializer</span>&lt;<span class="title">WorkManager</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WorkManager <span class="title">create</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        Configuration configuration = Configuration.Builder().build();</span><br><span class="line">        WorkManager.initialize(context, configuration);</span><br><span class="line">        <span class="keyword">return</span> WorkManager.getInstance(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Class&lt;Initializer&lt;?&gt;&gt;&gt; dependencies() &#123;</span><br><span class="line">        <span class="comment">// No dependencies on other libraries.</span></span><br><span class="line">        <span class="keyword">return</span> emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>WorkManagerInitializer</code> 组件的初始化不需要依赖其他的组件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Initializes ExampleLogger.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleLoggerInitializer</span> <span class="keyword">extends</span> <span class="title">Initializer</span>&lt;<span class="title">ExampleLogger</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExampleLogger <span class="title">create</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// WorkManager.getInstance() is non-null only after</span></span><br><span class="line">        <span class="comment">// WorkManager is initialized.</span></span><br><span class="line">        <span class="keyword">return</span> ExampleLogger(WorkManager.getInstance(context));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Class&lt;Initializer&lt;?&gt;&gt;&gt; dependencies() &#123;</span><br><span class="line">        <span class="comment">// Defines a dependency on WorkManagerInitializer so it can be</span></span><br><span class="line">        <span class="comment">// initialized after WorkManager is initialized.</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(WorkManagerInitializer.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ExampleLoggerInitializer</code> 组件的初始化需要依赖 <code>WorkManagerInitializer</code> 组件。</p>
<h3 id="设置AndroidManifest条目"><a href="#设置AndroidManifest条目" class="headerlink" title="设置AndroidManifest条目"></a>设置AndroidManifest条目</h3><p><code>InitializationProvider</code> 是被 <code>App Startup</code> 包含一组特殊的 <code>Content Provider</code> 。使用它能发现和调用组件的初始化。</p>
<p><code>InitializationProvider</code>  可以通过在 <code>AndroidManifest</code> 中配置的 <code>&lt;meta-data&gt;</code> 发现初始化组件。</p>
<p><code>App Startup</code> 通过调用 <code>dependencies()</code> 方法我们能发现其他的初始化组件。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"androidx.startup.InitializationProvider"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:authorities</span>=<span class="string">"$&#123;applicationId&#125;.androidx-startup"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:node</span>=<span class="string">"merge"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- This entry makes ExampleLoggerInitializer discoverable. --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span>  <span class="attr">android:name</span>=<span class="string">"com.example.ExampleLoggerInitializer"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:value</span>=<span class="string">"androidx.startup"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们不需要在 <code>AndroidManifest.xml</code> 中添加 <code>WorkManagerInitializer</code>，因为 <code>ExampleLoggerInitializer</code> 是依赖于 <code>WorkManagerInitializer</code> 。</p>
<h3 id="手动初始化组件"><a href="#手动初始化组件" class="headerlink" title="手动初始化组件"></a>手动初始化组件</h3><p>当您使用 <code>App Startup</code>时，<code>InitializationProvider</code>对象使用名为 <code>AppInitializer</code>的实体在应用程序启动时自动发现并运行组件初始化程序。</p>
<p>但如果不想应用程序启动的时候进行组件初始化，那么可以进行手动初始化。这称为延迟初始化，它可以帮助最小化启动成本。</p>
<p>您必须首先对要手动初始化的所有组件禁用自动初始化。</p>
<h4 id="禁用单个组件的自动初始化"><a href="#禁用单个组件的自动初始化" class="headerlink" title="禁用单个组件的自动初始化"></a>禁用单个组件的自动初始化</h4><p>要禁用单个组件的自动初始化，请从清单中删除该组件的初始化程序的 <code>&lt;meta-data&gt;</code> 条目。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"androidx.startup.InitializationProvider"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:authorities</span>=<span class="string">"$&#123;applicationId&#125;.androidx-startup"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:node</span>=<span class="string">"merge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">"com.example.ExampleLoggerInitializer"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">tools:node</span>=<span class="string">"remove"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>您可以在条目中使用 <code>tools:node=&quot;remove&quot;</code>而不是简单地删除条目，以确保合并工具还从所有其他合并清单文件中删除了条目。</p>
<p><strong>禁用组件的自动初始化，也会禁用该组件的依赖项的自动初始化。</strong></p>
<h4 id="禁用所有组件的自动初始化"><a href="#禁用所有组件的自动初始化" class="headerlink" title="禁用所有组件的自动初始化"></a>禁用所有组件的自动初始化</h4><p>要禁用所有自动初始化，请从清单中删除 <code>InitializationProvider</code> 的整个条目：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"androidx.startup.InitializationProvider"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:authorities</span>=<span class="string">"$&#123;applicationId&#125;.androidx-startup"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:node</span>=<span class="string">"remove"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="手动调用组件初始化程序"><a href="#手动调用组件初始化程序" class="headerlink" title="手动调用组件初始化程序"></a>手动调用组件初始化程序</h4><p>如果为组件禁用了自动初始化，则可以使用 <code>AppInitializer</code> 手动初始化该组件及其依赖项。</p>
<p>例如，以下代码调用 <code>AppInitializer</code> 并手动初始化 <code>ExampleLogger</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AppInitializer.getInstance(context)</span><br><span class="line">    .initializeComponent(ExampleLoggerInitializer.class);</span><br></pre></td></tr></table></figure>
<p>由于 <code>WorkManager</code> 是 <code>ExampleLogger</code> 的依赖项，因此 <code>App Startup</code> 也将初始化 <code>WorkManager</code> 。</p>
<h3 id="运行Lint检查"><a href="#运行Lint检查" class="headerlink" title="运行Lint检查"></a>运行Lint检查</h3><p><code>App Startup</code> 库包含一组 <code>lint</code> 规则，可用于检查是否已正确定义了组件初始化程序。您可以通过从命令行运行 <code>./gradlew：app：lintDebug</code> 来执行这些 <code>lint</code> 检查。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p><img src="/Users/tanzx/Note/Android/第三方库/startup-runtime/startup-runtime-source-files.png" alt="startup-runtime-source-files"></p>
<p>先看一下源码的 <code>aar</code> 结构。</p>
<h3 id="lint-jar"><a href="#lint-jar" class="headerlink" title="lint.jar"></a>lint.jar</h3><p>提供 <code>App Startup</code> 进行语义检查，本次不做分析。</p>
<h3 id="Androidmanifest-xml"><a href="#Androidmanifest-xml" class="headerlink" title="Androidmanifest.xml"></a>Androidmanifest.xml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">"androidx.startup"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-sdk</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:minSdkVersion</span>=<span class="string">"14"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:targetSdkVersion</span>=<span class="string">"29"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">"androidx.startup.InitializationProvider"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:authorities</span>=<span class="string">"$&#123;applicationId&#125;.androidx-startup"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">tools:node</span>=<span class="string">"merge"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到该库兼容最小的 <code>Android</code> 版本为 <code>14</code>，该库当前适配的版本为 <code>19</code> 。</p>
<p>另一个就是自己注册的 <code>InitializationProvider</code> 。</p>
<h3 id="InitializationProvider"><a href="#InitializationProvider" class="headerlink" title="InitializationProvider"></a>InitializationProvider</h3><p><code>App Startup</code> 的开始就是 <code>InitializationProvider</code> 的启动，我们从 <code>InitializationProvider</code> 这个进行分析就可以。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializationProvider</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Context context = getContext();</span><br><span class="line">        <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">            AppInitializer.getInstance(context).discoverAndInitialize();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StartupException(<span class="string">"Context cannot be null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***其他代码省略***/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们可以到 <code>InitializationProvider</code> 内部最终还是调用的 <code>AppInitializer</code> 进行初始化，这里只不过是利用了 <code>ContentProvider</code> 的自动启动而已。</p>
<h3 id="AppInitializer"><a href="#AppInitializer" class="headerlink" title="AppInitializer"></a>AppInitializer</h3><p>这个类算不算是 <code>App Startup</code> 这个库的核心我不是很清楚。</p>
<ul>
<li>他是整个库的代码核心；</li>
<li>他不是核心因为实现真的很简单，<code>App Startup</code> 这个库再我看来<code>InitializationProvider</code> 更有可取之处 ；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AppInitializer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SECTION_NAME = <span class="string">"Startup"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AppInitializer sInstance;<span class="comment">//单例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object sLock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Object&gt; mInitialized;<span class="comment">//组件只有一次初始化</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">final</span> Context mContext;<span class="comment">//application的上下文环境</span></span><br><span class="line">    AppInitializer(<span class="meta">@NonNull</span> Context context) &#123;</span><br><span class="line">        <span class="keyword">this</span>.mContext = context.getApplicationContext();</span><br><span class="line">        <span class="keyword">this</span>.mInitialized = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AppInitializer <span class="title">getInstance</span><span class="params">(@NonNull Context context)</span> </span>&#123;<span class="comment">//DCL单例</span></span><br><span class="line">        <span class="keyword">synchronized</span> (sLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>)</span><br><span class="line">                sInstance = <span class="keyword">new</span> AppInitializer(context);</span><br><span class="line">            <span class="keyword">return</span> sInstance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">initializeComponent</span><span class="params">(@NonNull Class&lt;? extends Initializer&lt;T&gt;&gt; component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> doInitialize(component, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//进行组件初始化</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">doInitialize</span><span class="params">(@NonNull Class&lt;? extends Initializer&lt;?&gt;&gt; component, @NonNull Set&lt;Class&lt;?&gt;&gt; initializing)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//防止多线程并发</span></span><br><span class="line">        <span class="keyword">synchronized</span> (sLock) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> isTracingEnabled = Trace.isEnabled();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Object result;</span><br><span class="line">                <span class="keyword">if</span> (isTracingEnabled)</span><br><span class="line">                    Trace.beginSection(component.getSimpleName());</span><br><span class="line">								<span class="comment">//首先判断该组件是正在进行初始化，如果是那么抛异常</span></span><br><span class="line">                <span class="keyword">if</span> (initializing.contains(component)) &#123;</span><br><span class="line">                    String message = String.format(<span class="string">"Cannot initialize %s. Cycle detected."</span>, <span class="keyword">new</span> Object[] &#123; component</span><br><span class="line">                            .getName() &#125;);</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(message);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//首先判断该组件是否进行过初始化，如果已经初始化那么直接返回</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">this</span>.mInitialized.containsKey(component)) &#123;</span><br><span class="line">                    initializing.add(component);<span class="comment">//加入正在初始化的容器做记录</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Object instance = component.getDeclaredConstructor(<span class="keyword">new</span> Class[<span class="number">0</span>]).newInstance(<span class="keyword">new</span> Object[<span class="number">0</span>]);<span class="comment">//反射进行构造</span></span><br><span class="line">                        Initializer&lt;?&gt; initializer = (Initializer)instance;</span><br><span class="line">                        List&lt;Class&lt;? extends Initializer&lt;?&gt;&gt;&gt; dependencies = initializer.dependencies();<span class="comment">//获取依赖的初始化组件</span></span><br><span class="line">                        <span class="keyword">if</span> (!dependencies.isEmpty())<span class="comment">//如果依赖不为空，那么先初始化依赖组件</span></span><br><span class="line">                            <span class="keyword">for</span> (Class&lt;? extends Initializer&lt;?&gt;&gt; clazz : dependencies) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (!<span class="keyword">this</span>.mInitialized.containsKey(clazz))</span><br><span class="line">                                    doInitialize(clazz, initializing);</span><br><span class="line">                            &#125;</span><br><span class="line">                        <span class="comment">//调用create获取组件初始化之后的实例</span></span><br><span class="line">                        result = initializer.create(<span class="keyword">this</span>.mContext);</span><br><span class="line">                        initializing.remove(component);<span class="comment">//从正在初始化的容器中移除</span></span><br><span class="line">                        <span class="keyword">this</span>.mInitialized.put(component, result);<span class="comment">//加入已经初始化的容器做记录</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> StartupException(throwable);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result = <span class="keyword">this</span>.mInitialized.get(component);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> (T)result;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                Trace.endSection();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//获取InitializationProvider中注册的组件进行初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">discoverAndInitialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Trace.beginSection(<span class="string">"Startup"</span>);</span><br><span class="line">            ComponentName provider = <span class="keyword">new</span> ComponentName(<span class="keyword">this</span>.mContext.getPackageName(), InitializationProvider.class.getName());</span><br><span class="line">            ProviderInfo providerInfo = <span class="keyword">this</span>.mContext.getPackageManager().getProviderInfo(provider, <span class="number">128</span>);</span><br><span class="line">            Bundle metadata = providerInfo.metaData;</span><br><span class="line">            String startup = <span class="keyword">this</span>.mContext.getString(R.string.androidx_startup);</span><br><span class="line">            <span class="keyword">if</span> (metadata != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Set&lt;Class&lt;?&gt;&gt; initializing = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">                Set&lt;String&gt; keys = metadata.keySet();</span><br><span class="line">                <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">                    String value = metadata.getString(key, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (startup.equals(value)) &#123;</span><br><span class="line">                        Class&lt;?&gt; clazz = Class.forName(key);</span><br><span class="line">                        <span class="keyword">if</span> (Initializer.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line">                            Class&lt;? extends Initializer&lt;?&gt;&gt; component = (Class)clazz;</span><br><span class="line">                            doInitialize(component, initializing);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (android.content.pm.PackageManager.NameNotFoundException|ClassNotFoundException exception) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StartupException(exception);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Trace.endSection();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="App-Startup总结"><a href="#App-Startup总结" class="headerlink" title="App Startup总结"></a>App Startup总结</h2><p>优点：</p>
<ul>
<li>解决了多个 <code>sdk</code> 初始化导致 <code>Application</code>  文件和 <code>Mainfest</code> 文件需要频繁改动，维护困难的问题。</li>
<li>方便了 <code>sdk</code> 开发者在内部处理 <code>sdk</code> 的初始化问题，并且可以和调用者共享一个 <code>ContentProvider</code>。</li>
<li>处理了 <code>sdk</code> 之间的依赖关系，有效解耦，方便协同开发；</li>
</ul>
<p>缺点：</p>
<ul>
<li><code>ContentProvider</code> 的启动和反射构造 <code>Initializer</code> 在低版本系统中会有一定的性能损耗。</li>
<li><p>目前有些 <code>sdk</code> 的集成使用的就是 <code>ContentProvider</code> 这种无侵入试，多个 <code>ContentProvider</code> 此时有些浪费。</p>
</li>
<li><p>导致类文件增多，特别是有大量需要初始化的 <code>sdk</code> 存在时。</p>
</li>
<li>可能目前的版本还不是正式版，所以对 <strong>多线程</strong> 和 <strong>多进程</strong> 的考虑比较少。</li>
</ul>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>App Startup</tag>
      </tags>
  </entry>
  <entry>
    <title>非侵入试获取Context进行SDK初始化</title>
    <url>/2020/07/07/context-provider-sdk/</url>
    <content><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20200707194057310.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0dmVuX2tpbmc=,size_16,color_FFFFFF,t_70#pic_center" alt="Context"></p>
<h1 id="非侵入试获取Context进行SDK初始化"><a href="#非侵入试获取Context进行SDK初始化" class="headerlink" title="非侵入试获取Context进行SDK初始化"></a>非侵入试获取Context进行SDK初始化</h1><p>当我们在使用第三方<strong>SDK</strong>，或者自己进行<strong>SDK</strong>封装时，如果需要需要用到 <code>Context</code> 进行初始化时，一般做法就是将初始化方法暴露给调用方，让调用方在初始化<strong>SDK</strong>时，传入上下文环境。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">publi <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        MultiDex.install(getApplication());</span><br><span class="line">        <span class="keyword">if</span> (Config.Debug)) &#123;</span><br><span class="line">            ARouter.openLog();</span><br><span class="line">            ARouter.openDebug();</span><br><span class="line">        &#125;</span><br><span class="line">        ARouter.init(<span class="keyword">this</span>);</span><br><span class="line">        SkinSdk.init(<span class="keyword">this</span>);</span><br><span class="line">        PaySDK.install(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上的 <code>SDK</code> 初始化代码是不是感觉很难维护。有没有一种直接拿来用而不需要进行 <strong>显式</strong> 初始化的SDK集成方式呢？</p>
<p>我们知道 <code>ContentProvider</code> 的生命周期，它是在 <code>Application.attach</code> 之后 <code>Application.onCreate</code> 之前进行 <code>installProvider</code> 。不需要我们 <strong>显式</strong> 通过代码启动。、</p>
<p>所以他满足了我们一般初始化 <strong>SDK</strong> 的条件：</p>
<ul>
<li>拥有 <code>Context[Application]</code> 的上下文环境；</li>
<li>可以进行自动启动；</li>
</ul>
<p>如果大家平时注意观察会发现我们平时使用的一些<strong>SDK</strong>也是不需要显示初始化的，而他们都是使用自定义的 <code>ContentProvider</code> 这种方式。</p>
<h2 id="picasso-初始化"><a href="#picasso-初始化" class="headerlink" title="picasso 初始化"></a><a href="https://github.com/square/picasso" target="_blank" rel="noopener">picasso</a> 初始化</h2><p>相关知识可以阅读 <a href="https://editor.csdn.net/md/?articleId=103770389" target="_blank" rel="noopener">Picasso源码分析和对比</a> 这篇文章。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestrictTo</span>(LIBRARY)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PicassoProvider</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123;</span><br><span class="line">  <span class="meta">@SuppressLint</span>(<span class="string">"StaticFieldLeak"</span>) <span class="keyword">static</span> Context context;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    context = getContext();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/***部分代码省略***/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无侵入试的 <code>Context</code> 获取，依靠 <code>ContentProvider</code> 通过注册在 <code>AndroidManifest.xml</code> 实现自动启。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">"com.squareup.picasso"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-sdk</span> <span class="attr">android:minSdkVersion</span>=<span class="string">"14"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">"com.squareup.picasso.PicassoProvider"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:authorities</span>=<span class="string">"$&#123;applicationId&#125;.com.squareup.picasso"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>picasso</code> 的初始化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Picasso</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Picasso <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Picasso.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (PicassoProvider.context == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"context == null"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Builder(PicassoProvider.context).build();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="InstantRun"><a href="#InstantRun" class="headerlink" title="InstantRun"></a>InstantRun</h2><p>相关知识可以阅读 <a href="https://editor.csdn.net/md/?articleId=80365174" target="_blank" rel="noopener">InstantRun从2.0到3.0，历史解毒</a> 这篇文章。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span> <span class="attr">android:theme</span>=<span class="string">"@style/AppTheme"</span> </span></span><br><span class="line"><span class="tag">             <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span> </span></span><br><span class="line"><span class="tag">             <span class="attr">android:icon</span>=<span class="string">"@mipmap/ic_launcher"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">android:name</span>=<span class="string">"com.example.tzx.changeskin.MyApplication"</span> </span></span><br><span class="line"><span class="tag">             <span class="attr">android:debuggable</span>=<span class="string">"true"</span> </span></span><br><span class="line"><span class="tag">             <span class="attr">android:testOnly</span>=<span class="string">"true"</span> </span></span><br><span class="line"><span class="tag">             <span class="attr">android:allowBackup</span>=<span class="string">"true"</span> </span></span><br><span class="line"><span class="tag">             <span class="attr">android:supportsRtl</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">"com.example.tzx.changeskin.InstantRunActivity"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">provider</span> <span class="attr">android:name</span>=<span class="string">"com.android.tools.ir.server.InstantRunContentProvider"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">android:multiprocess</span>=<span class="string">"true"</span>          <span class="attr">android:authorities</span>=<span class="string">"com.example.tzx.changeskin.com.android.tools.ir.server.InstantRunContentProvider"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>InstantRunContentProvider</code> 源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InstantRunContentProvider</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isMainProcess()) &#123;</span><br><span class="line">            Log.i(Logging.LOG_TAG, <span class="string">"starting instant run server: is main process"</span>);</span><br><span class="line">            Server.create(getContext());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Log.i(Logging.LOG_TAG, <span class="string">"not starting instant run server: not main process"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isMainProcess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isMainProcess = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (AppInfo.applicationId == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> foundPackage = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> pid = Process.myPid();</span><br><span class="line">        <span class="keyword">for</span> (RunningAppProcessInfo processInfo : ((ActivityManager) getContext().getSystemService(<span class="string">"activity"</span>)).getRunningAppProcesses()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (AppInfo.applicationId.equals(processInfo.processName)) &#123;</span><br><span class="line">                foundPackage = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (processInfo.pid == pid) &#123;</span><br><span class="line">                    isMainProcess = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isMainProcess || foundPackage) &#123;</span><br><span class="line">            <span class="keyword">return</span> isMainProcess;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.w(Logging.LOG_TAG, <span class="string">"considering this process main process:no process with this package found?!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Leakcanary"><a href="#Leakcanary" class="headerlink" title="Leakcanary"></a>Leakcanary</h2><p>进行 <code>LeakCanary</code> 集成的 <code>apk</code> 文件中的 <code>AndroidManifest.xml</code> 会自动添加一下的配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">		<span class="attr">android:name</span>=<span class="string">"leakcanary.internal.AppWatcherInstaller$MainProcess"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:authorities</span>=<span class="string">"com.tzx.androidcode.leakcanary-installer"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>AppWatcherInstaller$MainProcess</code> 源码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">AppWatcherInstaller</span> : <span class="type">ContentProvider</span></span>() &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * [MainProcess] automatically sets up the LeakCanary code that runs in the main app process.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">MainProcess</span> : <span class="type">AppWatcherInstaller</span></span>()</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * When using the `leakcanary-android-process` artifact instead of `leakcanary-android`,</span></span><br><span class="line"><span class="comment">   * [LeakCanaryProcess] automatically sets up the LeakCanary code</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">LeakCanaryProcess</span> : <span class="type">AppWatcherInstaller</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">      <span class="keyword">super</span>.onCreate()</span><br><span class="line">      AppWatcher.config = AppWatcher.config.copy(enabled = <span class="literal">false</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> application = context!!.applicationContext <span class="keyword">as</span> Application</span><br><span class="line">    InternalAppWatcher.install(application)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/***部分代码省略***/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="App-Startup"><a href="#App-Startup" class="headerlink" title="App Startup"></a>App Startup</h2><p><a href="https://developer.android.google.cn/topic/libraries/app-startup" target="_blank" rel="noopener">Jetpack StartUp官网</a> </p>
<p>我们可以通过使用 <code>ContentProvider</code> 初始化每个依赖关系来满足此需求，但是  <code>ContentProvider</code> 的实例化成本很高，并且可能不必要地减慢启动顺序。此外，  <code>ContentProvider</code>  的初始化是无序的。</p>
<p><code>App Startup</code> 提供了一种更高效的方法，可在应用程序启动时初始化组件并显式定义其依赖关系。</p>
<p><a href="https://dandanlove.blog.csdn.net/article/details/107188896" target="_blank" rel="noopener">App Startup 源码分析</a></p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Context</tag>
      </tags>
  </entry>
  <entry>
    <title>Android内存泄漏检测工具使用手册</title>
    <url>/2020/06/05/android-memory-leak-analyze-tool/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>性能优化除过我们平时自己设计和开发之外就得考虑使用工具进行检测。<code>Android</code> 关于能够定位和剖析问题的内存工具有很多，但不是每个工具所有场景都能覆盖到。</p>
<ul>
<li><code>DDMS</code></li>
<li><code>LeakCanary</code></li>
<li><code>haha/shark</code></li>
<li><code>Android Profile</code></li>
<li><code>MAT</code></li>
<li><code>Jhat</code></li>
<li><code>dumpsys meminfo</code></li>
<li><code>APT</code></li>
<li><code>LeakInspector</code></li>
<li><code>Chrome Devtool</code></li>
<li><code>GC Log</code> </li>
</ul>
<p>现在对平时能发现问题，而且使用简单的一些工具的使用进行整理，并且对这个 <code>LeakCanaryTestActivity</code> 页面进行内存泄漏的分析。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeakCanaryTestActivity</span> <span class="keyword">extends</span> <span class="title">BaseActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Test test;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        test = <span class="keyword">new</span> Test(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.context = context;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">private</span> Context context;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LeakCanary"><a href="#LeakCanary" class="headerlink" title="LeakCanary"></a>LeakCanary</h2><p><a href="https://square.github.io/leakcanary/" target="_blank" rel="noopener">LeakCanary 官网</a></p>
<p><code>LeakCanary</code> 的原理很简单: 在 <code>Activity</code> 或 <code>Fragment</code> 被销毁后, 将他们的引用包装成一个 <code>WeakReference</code>, 然后将这个 <code>WeakReference</code> 关联到一个 <code>ReferenceQueue</code> 。查看<code>ReferenceQueue</code>中是否含有 <code>Activity</code> 或 <code>Fragment</code> 的引用。如果没有 <strong>触发GC</strong> 后再次查看。还是没有的话就说明回收成功, 否则可能发生了泄露. 这时候开始 <code>dump</code> 内存的信息,并分析泄露的引用链。</p>
<h3 id="在Android中接入LeakCanary"><a href="#在Android中接入LeakCanary" class="headerlink" title="在Android中接入LeakCanary"></a>在Android中接入LeakCanary</h3><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  debugImplementation <span class="string">'com.squareup.leakcanary:leakcanary-android:2.3'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>LeakCanary2.0</code> 之前我们接入的时候需要在 <code>Application.onCreate</code> 方法中显式调用 <code>LeakCanary.install(this);</code> 开启 <code>LeakCanary</code> 的内存监控。</p>
<p><code>LeakCanary2.0</code> 开始通过自己注册的 <code>provider</code> 自己开启 <code>LeakCanary</code> 的内存监控。我们平时开发用的 <code>Instant Run</code> 运行过程中也使用的是这种静默方式进行启动。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span> <span class="attr">android:name</span>=<span class="string">"com.android.tools.ir.server.InstantRunContentProvider"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:multiprocess</span>=<span class="string">"true"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">android:authorities</span>=<span class="string">"com.tzx.androidcode.com.android.tools.ir.server.InstantRunContentProvider"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="LeakCanary内存泄漏分析"><a href="#LeakCanary内存泄漏分析" class="headerlink" title="LeakCanary内存泄漏分析"></a>LeakCanary内存泄漏分析</h3><p>在进行 <code>debug</code> 或者 <code>UI自动化</code> 测试的时候，我们会在通知栏看到有关内存泄漏的提示。查看详情后我们能看到相关的内存泄漏具体位置，存在泄露的成员变量都用波浪线进行的标识。</p>
<p><img src="https://img-blog.csdnimg.cn/20200605194330839.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0dmVuX2tpbmc=,size_16,color_FFFFFF,t_70#pic_center" alt="LeakCanary-user"></p>
<h3 id="内存泄漏上报到服务端"><a href="#内存泄漏上报到服务端" class="headerlink" title="内存泄漏上报到服务端"></a>内存泄漏上报到服务端</h3><p><code>LeakCanary</code> 升级到 <code>2.0</code> 的  <code>beta</code> 和 <code>final</code> 版本之后 <a href="https://square.github.io/leakcanary/shark/" target="_blank" rel="noopener">shark 官网</a> 文档提供的的内存泄漏上报方式对应的 <code>API</code> 已经过时，我们需要实现新的接口将 <code>LeakCanary</code> 捕获的内存泄漏进行上报。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">class LeakUploader : OnHeapAnalyzedListener &#123;</span><br><span class="line">  <span class="function">override fun <span class="title">onHeapAnalyzed</span><span class="params">(heapAnalysis: HeapAnalysis)</span> </span>&#123;</span><br><span class="line">    TODO(<span class="string">"Upload heap analysis to server"</span>)</span><br><span class="line">    <span class="comment">//HeapAnalysis的toString和2.0之前的版本的LeakCanary.leakInfo获得的信息类似</span></span><br><span class="line">    println(heapAnalysis)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class MyApplication : Application() &#123;</span><br><span class="line">  <span class="function">override fun <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate()</span><br><span class="line">    LeakCanary.config = LeakCanary.config.copy(</span><br><span class="line">        onHeapAnalyzedListener = LeakUploader()</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Shark"><a href="#Shark" class="headerlink" title="Shark"></a>Shark</h2><p><a href="https://square.github.io/leakcanary/shark/" target="_blank" rel="noopener">shark 官网</a></p>
<p><code>Shark</code>是为 <code>LeakCanary 2</code> 提供支持的堆分析器，它是<code>Kotlin</code>独立堆分析库，可在低内存占用情况下高速运行（PS：<code>LeakCanary 2</code> 之前的堆分析库是 <code>haha</code> ，<a href="https://github.com/square/haha" target="_blank" rel="noopener">haha Git地址</a>）。</p>
<p>此处说的 <code>LeakCanary 2</code> 为 <code>beta</code> 和 <code>final</code> 版本，<code>alpha</code> 版依旧是用的 <code>haha</code> 只不过是用 <code>kotlin</code> 写的。</p>
<p><code>Shark</code> 在为 <code>LeakCanary 2</code> 提供支持的同事也提供 <strong>Shark CLI</strong> 支持。</p>
<p><code>Shark</code> 命令行界面（<code>CLI</code>）使您可以直接从计算机分析堆。它可以转储安装在已连接的 <code>Android</code> 设备上的应用程序的堆，对其进行分析，甚至剥离所有敏感数据（例如PII，密码或加密密钥）的堆转储，这在共享堆转储时非常有用。</p>
<h3 id="Shark分析当前应用的内存泄漏情况"><a href="#Shark分析当前应用的内存泄漏情况" class="headerlink" title="Shark分析当前应用的内存泄漏情况"></a>Shark分析当前应用的内存泄漏情况</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shark-cli --device 设备id --process 包名 analyze</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200605194413812.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0dmVuX2tpbmc=,size_16,color_FFFFFF,t_70#pic_center" alt="shark-cli-analyze"></p>
<p>同时支持混淆后的内存泄漏分析，利用<code>mapping</code>文件进行可读性还原。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shark-cli -d 设备id -p 包名 -m 混淆文件 analyze</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200605194453407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0dmVuX2tpbmc=,size_16,color_FFFFFF,t_70#pic_center" alt="shark-cli-analyze-mapping"></p>
<h3 id="Shark分析hprof文件"><a href="#Shark分析hprof文件" class="headerlink" title="Shark分析hprof文件"></a>Shark分析hprof文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shark-cli -h 生成的hprof文件 analyze</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200605194524639.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0dmVuX2tpbmc=,size_16,color_FFFFFF,t_70#pic_center" alt="shark-cli-analyze-hprof"></p>
<h2 id="Android-Profile"><a href="#Android-Profile" class="headerlink" title="Android Profile"></a>Android Profile</h2><p><strong>Android Profiler</strong>分为三大模块： <strong>cpu</strong>、<strong>内存</strong> 、<strong>网络</strong>。</p>
<p><a href="https://developer.android.com/studio/profile/memory-profiler?hl=zh-cn" target="_blank" rel="noopener">官网：使用 Memory Profiler 查看 Java 堆和内存分配</a></p>
<p><code>Memory Profiler</code> 是<code>Android Profiler</code>中的一个组件，它可以帮助您识别内存泄漏和内存溢出，从而导致存根、冻结甚至应用程序崩溃。它显示了应用程序内存使用的实时图，让您捕获堆转储、强制垃圾收集和跟踪内存分配。</p>
<h3 id="捕获堆转储进行分析"><a href="#捕获堆转储进行分析" class="headerlink" title="捕获堆转储进行分析"></a>捕获堆转储进行分析</h3><p><img src="https://img-blog.csdnimg.cn/20200605194608555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0dmVuX2tpbmc=,size_16,color_FFFFFF,t_70#pic_center" alt="profiler-docs"></p>
<p>在列表的顶部，您可以使用右下拉菜单在列表之间切换:</p>
<ul>
<li><code>Arrange by class</code>： 根据类名分配。</li>
<li><code>Arrange by package</code>：根据包名分配。</li>
<li><code>Arrange by callstack</code>: 根据调用堆栈排序。</li>
</ul>
<p>查看堆转储后的信息：</p>
<ul>
<li>您的应用程序分配了哪些类型的对象，以及每个对象的数量;</li>
<li>每个对象使用多少内存;</li>
<li>每个对象的引用被保留在你的代码中;</li>
<li>调用堆栈，用于分配对象的位置（只有在记录分配时捕获堆转储）;</li>
</ul>
<h2 id="MAT安装"><a href="#MAT安装" class="headerlink" title="MAT安装"></a>MAT安装</h2><p>打开 <code>Eclipse-&gt;help-&gt;Eclipse Marketplce</code>，搜索<code>Memory Analyze</code>进行安装，安装完成后重启 <code>Eclipse</code>。</p>
<p><img src="https://img-blog.csdnimg.cn/20200605194648980.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0dmVuX2tpbmc=,size_16,color_FFFFFF,t_70#pic_center" alt="marketplace-memory-analyze"></p>
<h2 id="MAT使用"><a href="#MAT使用" class="headerlink" title="MAT使用"></a>MAT使用</h2><p>将<code>dump heap</code> 生成的 <code>hprof</code> 文件转化为<strong>MAT</strong>能处理的<code>hprof</code> 文件。</p>
<p>执行 <code>android.os.Debug.dumpHprofData(hprofPath)</code>  生成 <code>hprof</code> 文件，<strong>执行之前记得进行GC</strong>。</p>
<p><code>hprof-conv</code> 位于 <code>sdk/platform-tools/hprof-conv</code> 。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hprof-conv memory-android.hprof memory-mat.hprof</span><br></pre></td></tr></table></figure>
<h3 id="MAT处理导入hprof文件"><a href="#MAT处理导入hprof文件" class="headerlink" title="MAT处理导入hprof文件"></a>MAT处理导入hprof文件</h3><p><img src="https://img-blog.csdnimg.cn/20200605194746623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0dmVuX2tpbmc=,size_16,color_FFFFFF,t_70#pic_center" alt="mat-overview"></p>
<p><code>Action</code> 有一下几个视图：</p>
<table>
<thead>
<tr>
<th>视图</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Histogram</td>
<td>列举内存中对象存在的个数和大小，以及对于的名称</td>
</tr>
<tr>
<td>Dominator Tree</td>
<td>站在对象的角度查看他们的内存情况</td>
</tr>
<tr>
<td>Top Consumers</td>
<td>该视图会显示可能的内存泄漏点</td>
</tr>
<tr>
<td>Duplicate Classes</td>
<td>检测由多个类加载器加载的类</td>
</tr>
</tbody>
</table>
<h3 id="寻找内存泄漏的类"><a href="#寻找内存泄漏的类" class="headerlink" title="寻找内存泄漏的类"></a>寻找内存泄漏的类</h3><p>根据内存中类的对象实例数量，判断该类对象是否被泄露。</p>
<p><img src="https://img-blog.csdnimg.cn/20200605195109947.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0dmVuX2tpbmc=,size_16,color_FFFFFF,t_70#pic_center" alt="mat-histogram"></p>
<p>我们可以利用提供的多种检索方式进行目标类的检索，我这里用包名作为检索要素。</p>
<blockquote>
<p><strong>Shallow Size</strong></p>
</blockquote>
<ul>
<li>对象自身占用的内存大小，不包括它引用的对象。</li>
<li>针对非数组类型的对象，它的大小就是对象与它所有的成员变量大小的总和。当然这里面还会包括一些<code>java</code>语言特性的数据存储单元。</li>
<li>针对数组类型的对象，它的大小是数组元素对象的大小总和。</li>
</ul>
<blockquote>
<p><strong>Retained Size</strong></p>
</blockquote>
<p><code>Retained Size</code>  = <code>当前对象大小</code> + <code>当前对象可直接或间接引用到的对象的大小总和</code>。(间接引用的含义：A-&gt;B-&gt;C, C就是间接引用。如果<code>B</code> 和 <code>C</code> 没有被其他对象引用，那么 <code>RetainedSize-A = ShallowSize(A + B + C)</code> 它和 <a href="https://en.wikipedia.org/wiki/Dominator_(graph_theory" target="_blank" rel="noopener">Dominator</a>) 比较相似)<br>换句话说，<code>Retained Size</code>就是当前对象被<code>GC</code>后，从<code>Heap</code>上总共能释放掉的内存。<br>不过，释放的时候还要排除被<code>GC Roots</code>直接或间接引用的对象。他们暂时不会被被当做<code>Garbage</code>。</p>
<p>从上图可以看出 <code>MainActivity</code> 、<code>LeakCanaryTestActivity</code> 和 <code>LeakCanaryTestActivity$a</code> 都有一个实例没有被回收。</p>
<h3 id="分析被泄露的类的引用关系"><a href="#分析被泄露的类的引用关系" class="headerlink" title="分析被泄露的类的引用关系"></a>分析被泄露的类的引用关系</h3><p>选择没有回收的类，进行 <code>list objects -&gt; with incoming references</code> 操作得到被引用的对象。</p>
<p><img src="https://img-blog.csdnimg.cn/20200605195136445.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0dmVuX2tpbmc=,size_16,color_FFFFFF,t_70#pic_center" alt="mat-histogram-list-object"></p>
<blockquote>
<p><code>with outgoing references</code> : 该对象内部引用了那些其他对象；</p>
<p><code>with incoming references</code> : 该对象被谁进行了引用；</p>
</blockquote>
<p>得到被引用的类之后，进行 <code>Path To GC Roots -&gt; exclude all phantom/weak/soft etc. references</code>  操作，得到所有引用类型的引用。</p>
<p><img src="https://img-blog.csdnimg.cn/20200605195159729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0dmVuX2tpbmc=,size_16,color_FFFFFF,t_70#pic_center" alt="mat-histogram-list-gcroot"></p>
<blockquote>
<p><code>StrongReference</code>(强引用)：通常我们编写的代码都是 <code>StrongReference</code>，于此对应的是强可达性，只有去掉强可达，对象才被回收。</p>
</blockquote>
<blockquote>
<p><code>SoftReference</code>(软引用)：只要有足够的内存，就一直保持对象，直到发现内存吃紧且没有<code>StrongReference</code>时才回收对象。一般可用来实现缓存,需要获取对象时，可以调用get方法。</p>
</blockquote>
<blockquote>
<p><code>WeakReference</code>(弱引用)：随时可能会被垃圾回收器回收，不一定要等到虚拟机内存不足时才强制回收。要获取对象时，同样可以调用<code>get</code>方法。</p>
</blockquote>
<blockquote>
<p><code>PhantomReference</code>(虚引用)：根本不会在内存中保持任何对象，你只能使用<code>PhantomReference</code>本身。一般用于在进入<code>finalize()</code>方法后进行特殊的清理过程。</p>
</blockquote>
<h3 id="找到最终的泄漏的地方"><a href="#找到最终的泄漏的地方" class="headerlink" title="找到最终的泄漏的地方"></a>找到最终的泄漏的地方</h3><p><img src="https://img-blog.csdnimg.cn/20200605195226342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0dmVuX2tpbmc=,size_16,color_FFFFFF,t_70#pic_center" alt="mat-histogram-list-gcroot-result"></p>
<p>从这个图中我们可以可以得到：</p>
<ol>
<li><code>LeakCanaryTestActivity</code> 的一个实例被它的内部类 <code>LeakCanaryTestActivity$Test</code> 的成员变量 <code>context</code> 所持有；</li>
<li><code>LeakCanaryTestActivity$Test</code> 的一个实例又被 <code>LeakCanaryTestActivity</code> 的成员变量 <code>test</code> 所持有。</li>
</ol>
<h3 id="Merge对比分析"><a href="#Merge对比分析" class="headerlink" title="Merge对比分析"></a>Merge对比分析</h3><p>如果我们没有明确的目标类，我们可以将两个 <code>hprof文件（泄漏前、泄漏后）</code> 进行对比。</p>
<p><img src="https://img-blog.csdnimg.cn/20200605195250377.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0dmVuX2tpbmc=,size_16,color_FFFFFF,t_70#pic_center" alt="mat-merge"></p>
<p>选择泄漏之前的 <code>hprof文件</code> 进行对比。</p>
<p><img src="https://img-blog.csdnimg.cn/20200605195427161.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0dmVuX2tpbmc=,size_16,color_FFFFFF,t_70#pic_center" alt="mat-gcroot-merge"></p>
<p>对比会得到哪些实例对象数量的增加和减少。如上图所示对比结果为 <code>LeakCanaryTestActivity</code> 和 <code>LeakCanaryTestActivity$a</code> （此处的<code>a</code> 为混淆之后的 <code>Test</code>）两个类梳理分别增加1个。</p>
<p>我们继续向上面<strong>MAT</strong>分析步骤一样操作：</p>
<ol>
<li><p>进行 <code>list objects -&gt; with incoming references</code> 操作;</p>
</li>
<li><p>进行 <code>Path To GC Roots -&gt; exclude all phantom/weak/soft etc. references</code>  操作;</p>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200605195313781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0dmVuX2tpbmc=,size_16,color_FFFFFF,t_70#pic_center" alt="mat-merge-result"></p>
<p>最终得到的结果和之前分析的相同的。</p>
<h2 id="Jhat-Java自带的性能监测工具"><a href="#Jhat-Java自带的性能监测工具" class="headerlink" title="Jhat-Java自带的性能监测工具"></a>Jhat-Java自带的性能监测工具</h2><p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jhat.html" target="_blank" rel="noopener">Java8 jhat Analyzes the Java heap docs</a></p>
<p><code>JHat</code> 是 <code>Oracle</code> 推出的一款 <code>Hprof</code> 分析软件，它和 <code>MAT</code> 并称为 <strong>Java 内存静态分析利器</strong>。不同于 <code>MAT</code> 的单人界面式分析，<code>jHat</code> <strong>使用多人界面式分析</strong>。它被 <strong>内置在 JDK 中</strong>，在命令行中输入 <code>jhat</code> 命令可查看有没有相应的命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  Desktop jhat</span><br><span class="line">ERROR: No arguments supplied</span><br><span class="line">Usage:  jhat [-stack &lt;bool&gt;] [-refs &lt;bool&gt;] [-port &lt;port&gt;] [-baseline &lt;file&gt;] [-debug &lt;int&gt;] [-version] [-h|-help] &lt;file&gt;</span><br><span class="line"></span><br><span class="line">	-J&lt;flag&gt;          Pass &lt;flag&gt; directly to the runtime system. For</span><br><span class="line">			  example, -J-mx512m to use a maximum heap size of 512MB</span><br><span class="line">	-stack false:     Turn off tracking object allocation call stack.</span><br><span class="line">	-refs false:      Turn off tracking of references to objects</span><br><span class="line">	-port &lt;port&gt;:     Set the port for the HTTP server.  Defaults to 7000</span><br><span class="line">	-exclude &lt;file&gt;:  Specify a file that lists data members that should</span><br><span class="line">			  be excluded from the reachableFrom query.</span><br><span class="line">	-baseline &lt;file&gt;: Specify a baseline object dump.  Objects in</span><br><span class="line">			  both heap dumps with the same ID and same class will</span><br><span class="line">			  be marked as not being "new".</span><br><span class="line">	-debug &lt;int&gt;:     Set debug level.</span><br><span class="line">			    0:  No debug output</span><br><span class="line">			    1:  Debug hprof file parsing</span><br><span class="line">			    2:  Debug hprof file parsing, no server</span><br><span class="line">	-version          Report version number</span><br><span class="line">	-h|-help          Print this help and exit</span><br><span class="line">	&lt;file&gt;            The file to read</span><br><span class="line"></span><br><span class="line">For a dump file that contains multiple heap dumps,</span><br><span class="line">you may specify which dump in the file</span><br><span class="line">by appending "#&lt;number&gt;" to the file name, i.e. "foo.hprof#3".</span><br><span class="line"></span><br><span class="line">All boolean options default to "true"</span><br></pre></td></tr></table></figure>
<p><code>Jhat</code> 使用的 <code>hprof</code> 文件和 <code>MAT</code> 一样都需要使用 <code>hprof-conv</code> 进行 <code>hprof</code> 转化。</p>
<p>使用 <code>Jhat</code> 分析完 <code>hprof</code> 文件后会给一个 <code>Server port</code> ，比如 <code>7000</code> 。那么我们可以访问 <code>http://localhost:7000/</code> 查看分析结果。</p>
<p><img src="https://img-blog.csdnimg.cn/20200605195500463.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0dmVuX2tpbmc=,size_16,color_FFFFFF,t_70#pic_center" alt="jhat-main"></p>
<p>以包为单位展示所有的类，我们下拉到最底部可以看到有其他的查询方式。</p>
<p><img src="https://img-blog.csdnimg.cn/20200605195530171.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0dmVuX2tpbmc=,size_16,color_FFFFFF,t_70#pic_center" alt="jhat-other-queries"></p>
<h3 id="Show-heap-histogram"><a href="#Show-heap-histogram" class="headerlink" title="Show heap histogram"></a>Show heap histogram</h3><p>我们可以看到对应的类的内存实例数量以及占用对应的内存大小。</p>
<p><a href="http://localhost:7000/histo/" target="_blank" rel="noopener">http://localhost:7000/histo/</a></p>
<p><img src="https://img-blog.csdnimg.cn/20200605195548301.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0dmVuX2tpbmc=,size_16,color_FFFFFF,t_70#pic_center" alt="jhat-histo"></p>
<h3 id="Execute-Object-Query-Language-OQL-query"><a href="#Execute-Object-Query-Language-OQL-query" class="headerlink" title="Execute Object Query Language (OQL) query"></a>Execute Object Query Language (OQL) query</h3><p>可以使用  <code>OQL</code> 查询~!</p>
<p><code>OQL</code> 查询语法与 <code>Visual VM</code> 的 <code>OQL</code> 类似~ 基本语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &lt;JavaScript expression <span class="keyword">to</span> <span class="keyword">select</span>&gt;</span><br><span class="line">        [ <span class="keyword">from</span> [instanceof] &lt;<span class="keyword">class</span> <span class="keyword">name</span>&gt; &lt;identifier&gt;</span><br><span class="line">        [ <span class="keyword">where</span> &lt;JavaScript <span class="built_in">boolean</span> expression <span class="keyword">to</span> filter&gt; ] ]</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200605195614229.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0dmVuX2tpbmc=,size_16,color_FFFFFF,t_70#pic_center" alt="jhat-oql-result"></p>
<p>我们点击某个类之后可以看到该类的详细信息：</p>
<p><img src="https://img-blog.csdnimg.cn/20200605195634698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0dmVuX2tpbmc=,size_16,color_FFFFFF,t_70#pic_center" alt="jhat-class-detail"></p>
<ul>
<li><p><code>Exclude subclasses</code> 相当于<strong>MAT</strong> 的 <code>with outgoing references</code> : 该对象内部引用了那些其他对象；</p>
</li>
<li><p><code>Include subclasses</code> 相当于MAT 的 <code>with incoming references</code> : 该对象被谁进行了引用；</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200605195805208.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0dmVuX2tpbmc=,size_16,color_FFFFFF,t_70#pic_center" alt="jhat-class-instances"></p>
<p>先查看类的实例，然后再查看每个实例的相关引用情况。</p>
<p><img src="https://img-blog.csdnimg.cn/20200605195824649.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0dmVuX2tpbmc=,size_16,color_FFFFFF,t_70#pic_center" alt="jhat-class-object"></p>
<h1 id="dumpsys-meminfo"><a href="#dumpsys-meminfo" class="headerlink" title="dumpsys meminfo"></a>dumpsys meminfo</h1><p> <code>Android</code> 系统是基于 <code>Linux</code> 内核的操作系统，所以在 <code>Linux</code> 中查看内存使用情况的命令在 <code>Android</code> 手机上也能使用比如 <code>top</code> 命令。除此之外</p>
<ul>
<li><code>procrank</code> ：获取所有进程的内存使用情况，排序是按照 <code>Pss</code> 大小，详细输出每个 <code>PID</code> 对应的 <code>Vss</code> 、 <code>Rss</code>      <code>Pss</code>  、<code>Uss</code>  、 <code>Swap</code>  、 <code>PSwap</code> 、 <code>USwap</code> 、 <code>ZSwap</code> 和 <code>cmdline</code>。但该命令使用需要 <code>root</code> 环境。</li>
</ul>
<p>一般来说内存占用大小有如下规律：<code>VSS</code>  &gt;=  <code>RSS</code>  &gt;= <code>PSS</code>  &gt;= <code>USS</code></p>
<table>
<thead>
<tr>
<th>简称</th>
<th>全称</th>
<th>含义</th>
<th>等价</th>
</tr>
</thead>
<tbody>
<tr>
<td>VSS</td>
<td>Virtual Set Size</td>
<td>虚拟耗用内存</td>
<td>（包含共享库占用的内存）是单个进程全部可访问的地址空间</td>
</tr>
<tr>
<td>RSS</td>
<td>Resident Set Size</td>
<td>实际使用物理内存</td>
<td>(包含共享库占用的内存）是单个进程实际占用的内存大小，对于单个共享库， 尽管无论多少个进程使用，实际该共享库只会被装入内存一次。</td>
</tr>
<tr>
<td>PSS</td>
<td>Proportional Set Size</td>
<td>实际使用的物理内存</td>
<td>（比例分配共享库占用的内存）</td>
</tr>
<tr>
<td>USS</td>
<td>Unique Set Size</td>
<td>进程独自占用的物理内存</td>
<td>（不包含共享库占用的内存）USS 是一个非常非常有用的数字， 因为它揭示了运行一个特定进程的真实的内存增量大小。如果进程被终止， USS 就是实际被返还给系统的内存大小。</td>
</tr>
</tbody>
</table>
<p><code>USS</code> 是针对某个进程开始有可疑内存泄露的情况，进行检测的最佳数字。怀疑某个程序有内存泄露可以查看这个值是否一直有增加。</p>
<ul>
<li><code>cat /proc/meminfo</code> ：展示系统整体的内存情况，按照内存类型进行分类。</li>
<li><code>free</code> ：查看可用内存，缺省单位为<code>KB</code>。该命令比较简单、轻量，专注于查看剩余内存情况。数据来源于 <code>/proc/meminfo</code> 。</li>
</ul>
<p>最后一个是本次叙述的重点 <code>dumpsys</code> 。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dumpsys [options]</span><br><span class="line">               meminfo 显示内存信息</span><br><span class="line">               cpuinfo 显示CPU信息</span><br><span class="line">               account 显示accounts信息</span><br><span class="line">               activity 显示所有的activities的信息</span><br><span class="line">               window 显示键盘，窗口和它们的关系</span><br><span class="line">               wifi 显示wifi信息</span><br></pre></td></tr></table></figure>
<p>使用 <code>dumpysys meminfo</code> 查看内存信息,后面可以添加 <code>pid | packagename</code> 查看该应用程序的内存信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">~/Desktop adb shell dumpsys meminfo com.tzx.androidcode</span><br><span class="line">Applications Memory Usage (in Kilobytes):</span><br><span class="line">Uptime: 131873995 Realtime: 240892295</span><br><span class="line"></span><br><span class="line">** MEMINFO in pid 19924 [com.tzx.androidcode] **</span><br><span class="line">                   Pss  Private  Private  SwapPss     Heap     Heap     Heap</span><br><span class="line">                 Total    Dirty    Clean    Dirty     Size    Alloc     Free</span><br><span class="line">                ------   ------   ------   ------   ------   ------   ------</span><br><span class="line">  Native Heap    11062    11032        0       99    38912    21656    17255</span><br><span class="line">  Dalvik Heap     4079     3984        0        0     5638     2819     2819</span><br><span class="line"> Dalvik Other     1405     1404        0        1</span><br><span class="line">        Stack       64       64        0        0</span><br><span class="line">       Ashmem        2        0        0        0</span><br><span class="line">      Gfx dev     2052     2052        0        0</span><br><span class="line">    Other dev        8        0        8        0</span><br><span class="line">     .so mmap      959       80       64        4</span><br><span class="line">    .jar mmap     1062        0       24        0</span><br><span class="line">    .apk mmap      109        0        0        0</span><br><span class="line">    .ttf mmap       33        0        0        0</span><br><span class="line">    .dex mmap     4513       36     4392        0</span><br><span class="line">    .oat mmap      197        0        0        0</span><br><span class="line">    .art mmap     6229     5924       16        1</span><br><span class="line">   Other mmap      680      196       96        0</span><br><span class="line">   EGL mtrack    19320    19320        0        0</span><br><span class="line">    GL mtrack     6392     6392        0        0</span><br><span class="line">      Unknown     1106     1092        0       15</span><br><span class="line">        TOTAL    59392    51576     4600      120    44550    24475    20074</span><br><span class="line"></span><br><span class="line"> App Summary</span><br><span class="line">                       Pss(KB)</span><br><span class="line">                        ------</span><br><span class="line">           Java Heap:     9924</span><br><span class="line">         Native Heap:    11032</span><br><span class="line">                Code:     4596</span><br><span class="line">               Stack:       64</span><br><span class="line">            Graphics:    27764</span><br><span class="line">       Private Other:     2796</span><br><span class="line">              System:     3216</span><br><span class="line"></span><br><span class="line">               TOTAL:    59392       TOTAL SWAP PSS:      120</span><br><span class="line"></span><br><span class="line"> Objects</span><br><span class="line">               Views:       82         ViewRootImpl:        2</span><br><span class="line">         AppContexts:        8           Activities:        2</span><br><span class="line">              Assets:       11        AssetManagers:        0</span><br><span class="line">       Local Binders:       22        Proxy Binders:       41</span><br><span class="line">       Parcel memory:       10         Parcel count:       24</span><br><span class="line">    Death Recipients:        2      OpenSSL Sockets:        0</span><br><span class="line">            WebViews:        0</span><br><span class="line"></span><br><span class="line"> SQL</span><br><span class="line">         MEMORY_USED:        0</span><br><span class="line">  PAGECACHE_OVERFLOW:        0          MALLOC_SIZE:        0</span><br></pre></td></tr></table></figure>
<p><code>Android</code> 程序内存被分为2部分：<code>native</code> 和 <code>虚拟机</code> ，<code>虚拟机</code> 就是我们平常说的 <code>java堆</code>，我们创建的对象是在这里面分配的，而 <code>bitmap</code> 是直接在 <code>native</code> 上分配的，对于内存的限制是<code>native+dalvik</code> 不能超过最大限制。以上信息可以看到该应用程序占用的 <code>native</code> 和 <code>dalvik</code>，对于分析内存泄露，内存溢出都有极大的作用。</p>
<h2 id="读取垃圾回收消息-GC-Log"><a href="#读取垃圾回收消息-GC-Log" class="headerlink" title="读取垃圾回收消息(GC Log)"></a>读取垃圾回收消息(GC Log)</h2><p><a href="https://developer.android.com/studio/debug/am-logcat?hl=zh-cn#memory-logs" target="_blank" rel="noopener">官网：读取垃圾回收消息</a></p>
<h3 id="Dalvik-日志消息"><a href="#Dalvik-日志消息" class="headerlink" title="Dalvik 日志消息"></a>Dalvik 日志消息</h3><p>在 <code>Dalvik</code>（而不是 <code>ART</code>）中，每个 <code>GC</code> 都会将以下信息输出到 <code>logcat</code> 中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D/dalvikvm(PID): GC_Reason Amount_freed, Heap_stats, External_memory_stats, Pause_time</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D/dalvikvm( <span class="number">9050</span>): GC_CONCURRENT freed <span class="number">2049</span>K, <span class="number">65</span>% free <span class="number">3571</span>K/<span class="number">9991</span>K, external <span class="number">4703</span>K/<span class="number">5261</span>K, paused <span class="number">2</span>ms+<span class="number">2</span>ms</span><br></pre></td></tr></table></figure>
<h3 id="ART-日志消息"><a href="#ART-日志消息" class="headerlink" title="ART 日志消息"></a>ART 日志消息</h3><p>与 <code>Dalvik</code> 不同，<code>ART</code> 不会为未明确请求的 <code>GC</code> 记录消息。只有在系统认为 <code>GC</code> 速度较慢时才会输出 <code>GC</code> 消息。更确切地说，仅在 <code>GC</code> 暂停时间超过 5 毫秒或 <code>GC</code> 持续时间超过 100 毫秒时。如果应用未处于可察觉到暂停的状态（例如应用在后台运行时，这种情况下，用户无法察觉 <code>GC</code> 暂停），则其所有 <code>GC</code> 都不会被视为速度较慢。系统一直会记录显式 <code>GC</code>。</p>
<p><code>ART</code> 会在其垃圾回收日志消息中包含以下信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">I/art: <span class="function">GC_Reason GC_Name <span class="title">Objects_freed</span><span class="params">(Size_freed)</span> AllocSpace Objects,</span></span><br><span class="line"><span class="function">        <span class="title">Large_objects_freed</span><span class="params">(Large_object_size_freed)</span> Heap_stats LOS objects, <span class="title">Pause_time</span><span class="params">(s)</span></span></span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">I/art : Explicit concurrent mark sweep GC freed <span class="number">104710</span>(<span class="number">7</span>MB) AllocSpace objects,</span><br><span class="line">        <span class="number">21</span>(<span class="number">416</span>KB) LOS objects, <span class="number">33</span>% free, <span class="number">25</span>MB/<span class="number">38</span>MB, paused <span class="number">1.230</span>ms total <span class="number">67.216</span>ms</span><br></pre></td></tr></table></figure>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>内存泄漏</tag>
      </tags>
  </entry>
  <entry>
    <title>Bitmap图片压缩，大图加载防止OOM</title>
    <url>/2020/04/22/bitmap-load-big-pic/</url>
    <content><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20200422150554242.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0dmVuX2tpbmc=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Android官网中<a href="https://developer.android.com/topic/performance/graphics" target="_blank" rel="noopener">处理位图</a> 和 <a href="https://developer.android.com/topic/performance/graphics/load-bitmap" target="_blank" rel="noopener">高效加载大型位图
</a> 这两篇文章中已经做了很明确指出了如何高效的加载大图。这篇文章只是对其中的内容进行总结和扩展（比如图片内存计算、图片压缩等）。</p>
<p>为了防止加载 <code>Bitmap</code> 的时候造成 <code>OOM</code> 崩溃，我们首选要知道：</p>
<ul>
<li>一张图片加载到 <code>Bitmap</code> 的时候的占用的是怎么内存计算；</li>
<li>占用内存过高的时候怎么进行图片压缩减小内存占用；</li>
</ul>
<h1 id="RGB介绍"><a href="#RGB介绍" class="headerlink" title="RGB介绍"></a>RGB介绍</h1><blockquote>
<p>RGB颜色模型: 最常见的颜色模型，设备相关。R、G、B分别代表红、绿和蓝色三种颜色通道，取值均为[0,255]。</p>
</blockquote>
<blockquote>
<p>RGB 8位色: 表示使用8位(bit)表示颜色，一共能表示2^8 = 128种颜色。<br>依次类推RGB 16位色，RGB 24位色，RGB 32位色，使用的位数越多，能表示的颜色越多，24位能表示的颜色数量已经很多了，称之为“真彩色”。</p>
</blockquote>
<blockquote>
<p>32位和24位能表示的颜色一样多，多一个了透明度。</p>
</blockquote>
<blockquote>
<p>Android Bitmap使用的三种颜色格式：</p>
<ul>
<li>ALPHA_8–每个像素占1个字节，存储透明度信息，没有颜色信息。</li>
<li>RGB_565–每个像素占2个字节存储颜色信息，R 5位，G 6位，B 5位，能表示2^16种颜色。</li>
<li>ARGB_8888–每个像素占4个字节存储颜色信息，A R G B各一个字节，能表示2^24种颜色，还有一个字节存储透明度信息。</li>
</ul>
</blockquote>
<h1 id="图片占用内存的计算"><a href="#图片占用内存的计算" class="headerlink" title="图片占用内存的计算"></a>图片占用内存的计算</h1><p><code>Bitmap</code> 所占内存大小计算方式：图片长度 x 图片宽度 x 一个像素点占用的字节数。</p>
<h2 id="读取位图尺寸和类型"><a href="#读取位图尺寸和类型" class="headerlink" title="读取位图尺寸和类型"></a>读取位图尺寸和类型</h2><p><code>BitmapFactory</code> 类提供了几种用于从各种来源创建 <code>Bitmap</code> 的解码方法<code>（decodeByteArray()、decodeFile()、decodeResource()</code>等）。根据您的图片数据源选择最合适的解码方法。这些方法尝试为构造的位图分配内存，因此很容易导致 <code>OutOfMemory</code> 异常。每种类型的解码方法都有额外的签名，允许您通过 <code>BitmapFactory.Options</code> 类指定解码选项。在解码时将<code>inJustDecodeBounds</code> 属性设置为 <code>true</code> 可避免内存分配，为位图对象返回 <code>null</code>，但设置 <code>outWidth</code>、<code>outHeight</code> 和 <code>outMimeType</code>。此方法可让您在构造位图并为其分配内存之前读取图片数据的尺寸和类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BitmapFactory.Options options = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">options.inJustDecodeBounds = <span class="keyword">true</span>;</span><br><span class="line">BitmapFactory.decodeResource(getResources(), R.id.myimage, options);</span><br><span class="line"><span class="keyword">int</span> imageHeight = options.outHeight;</span><br><span class="line"><span class="keyword">int</span> imageWidth = options.outWidth;</span><br><span class="line">String imageType = options.outMimeType;</span><br></pre></td></tr></table></figure>
<p>为避免出现 <code>java.lang.OutOfMemory</code> 异常，请先检查位图的尺寸，然后再对其进行解码，除非您绝对信任该来源可为您提供大小可预测的图片数据，以轻松适应可用的内存。</p>
<h2 id="内存中如果加载一张-500-500-的-png-高清图片-应该是占用多少的内存"><a href="#内存中如果加载一张-500-500-的-png-高清图片-应该是占用多少的内存" class="headerlink" title="内存中如果加载一张 500*500 的 png 高清图片.应该是占用多少的内存?"></a>内存中如果加载一张 <code>500*500</code> 的 <code>png</code> 高清图片.应该是占用多少的内存?</h2><p><code>png</code> 图片应该有<strong>alpha通道</strong>，所以  <code>Bitmap.Config</code> 是 <code>ARGB_8888</code> 。4个8位一种占用32位。<br>最终答案： <code>500 * 500 * 4 = 1000000Bytes = 0.95MB</code></p>
<h2 id="如果这个图片为本地资源图片，是否还是0-95MB呢？"><a href="#如果这个图片为本地资源图片，是否还是0-95MB呢？" class="headerlink" title="如果这个图片为本地资源图片，是否还是0.95MB呢？"></a>如果这个图片为本地资源图片，是否还是0.95MB呢？</h2><p>先看一些基础知识（后面有答案） <a href="https://developer.android.google.cn/training/multiscreen/screendensities#TaskProvideAltBmp" target="_blank" rel="noopener">Android官网-提供备用位图</a> 这篇文章链接中的有讲到：</p>
<blockquote>
<p>要在像素密度不同的设备上提供良好的图形质量，您应该以相应的分辨率在应用中提供每个位图的多个版本（针对每个密度级别提供一个版本）。否则，Android 系统必须缩放位图，使其在每个屏幕上占据相同的可见空间，从而导致缩放失真，如模糊。</p>
</blockquote>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5nb29nbGUuY24vaW1hZ2VzL3NjcmVlbnNfc3VwcG9ydC9kZXZpY2VzLWRlbnNpdHlfMngucG5n?x-oss-process=image/format,png#pic_center" alt=""></p>
<p>例如，如果您有一个可绘制位图资源，它在中密度屏幕上的大小为 48x48 像素，那么它在其他各种密度的屏幕上的大小应该为：</p>
<ul>
<li>36x36 (0.75x) - 低密度 (ldpi)</li>
<li>48x48（1.0x 基准）- 中密度 (mdpi)</li>
<li>72x72 (1.5x) - 高密度 (hdpi)</li>
<li>96x96 (2.0x) - 超高密度 (xhdpi)</li>
<li>144x144 (3.0x) - 超超高密度 (xxhdpi)</li>
<li>192x192 (4.0x) - 超超超高密度 (xxxhdpi)</li>
</ul>
<p>然后，将生成的图片文件放在 <code>res/</code> 下的相应子目录中，系统将根据运行应用的设备的像素密度自动选取正确的文件。之后，每当您引用<code>@drawable/xxx</code>时，系统都会根据屏幕的 <code>dpi</code> 选择适当的位图。如果您没有为某个密度提供特定于密度的资源，那么系统会选取下一个最佳匹配项并对其进行缩放以适合屏幕。</p>
<p>实测：<code>1520 x 2688</code> 大小为 <code>334.28KB</code> 图片，屏幕密度为480的手机；</p>
<ul>
<li>放在 <code>drawable-xxdpi</code> 下加载到 <code>Bitmap</code> 中占用内存为 <code>16343040(1520*2688*4)</code>，因为图片不需要进行缩放，所以只需要计算 <code>ARGB_8888</code> 占用的字节数就行；</li>
<li>放在 <code>drawable-mdpi</code> 下加载到 <code>Bitmap</code> 中占用内存为 <code>147087360(1520*3*2688*3*4)</code> ，因为 <code>mdip</code> 到 <code>xxdpi</code> 图片的宽高分别会放大4倍；</li>
</ul>
<p><code>nodpi</code> 目录中的资源被视为与密度无关，系统将不会对它们进行缩放。</p>
<h1 id="Bitmap压缩"><a href="#Bitmap压缩" class="headerlink" title="Bitmap压缩"></a>Bitmap压缩</h1><h2 id="压缩原理"><a href="#压缩原理" class="headerlink" title="压缩原理"></a>压缩原理</h2><p>在 <code>Android</code> 中进行图片压缩是非常常见的开发场景，主要的压缩方法有两种：其一是下 <strong>采样压缩</strong>，其二是 <strong>质量压缩</strong>。</p>
<ul>
<li>前者是降低图像尺寸，改变图片的存储体积；</li>
<li>后者则是在不改变图片尺寸的情况下，通过损失颜色精度，达到相同目的;</li>
</ul>
<h2 id="压缩Bitmap磁盘占用空间的大小"><a href="#压缩Bitmap磁盘占用空间的大小" class="headerlink" title="压缩Bitmap磁盘占用空间的大小"></a>压缩Bitmap磁盘占用空间的大小</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果成功地把压缩数据写入输出流，则返回true。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compress</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Bitmap.CompressFormat format, //图像的压缩格式；</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> quality,//图像压缩率，<span class="number">0</span><span class="number">-100</span>。 <span class="number">0</span> 压缩<span class="number">100</span>%，<span class="number">100</span>意味着不压缩；</span></span></span><br><span class="line"><span class="function"><span class="params">    OutputStream stream)</span> </span>;<span class="comment">//写入压缩数据的输出流；</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>Bitmap.CompressFormat.PNG</code> ，那不管第二个值如何变化，图片大小都不会变化，不支持 <code>png图片</code> 的压缩。因为 <code>PNG</code> 格式是无损的，它无法再进行质量压缩，<code>quality</code>这个参数就没有作用了，会被忽略，所以最后图片保存成的文件大小不会有变化；</li>
<li><code>CompressFormat.WEBP</code> ，这个格式是 <code>google</code> 推出的图片格式，它会比 <code>JPEG</code> 更加省空间。官方表示能节省 <code>25%-34%</code> 的空间；</li>
</ul>
<h2 id="压缩Bitmap占用内存的大小"><a href="#压缩Bitmap占用内存的大小" class="headerlink" title="压缩Bitmap占用内存的大小"></a>压缩Bitmap占用内存的大小</h2><p>图片尺寸的修改其实就是通过修改像素数，放大的过程称之为<strong>上采样</strong>，缩小的过程称之为<strong>下采样</strong>。</p>
<p>要知道怎么压缩才能使 <code>Bitmap</code> 占用的内存变小，首先需要知道 <code>Bitmap</code> 的内存占用怎么计算。 <a href="https://www.kancloud.cn/book/stven\_king/stven\_king\_android\_interview\_topic/preview/Bitmap/%E8%AE%A1%E7%AE%97%E5%9B%BE%E7%89%87%E7%9A%84%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8.md" target="_blank" rel="noopener">计算图片的内存占用</a> 这篇文章有详细讲解。</p>
<h3 id="使用inSampleSize进行压缩"><a href="#使用inSampleSize进行压缩" class="headerlink" title="使用inSampleSize进行压缩"></a>使用inSampleSize进行压缩</h3><p>既然图片尺寸已知，便可用于确定应将完整图片加载到内存中，还是应改为加载下采样版本。以下是需要考虑的一些因素：</p>
<ul>
<li>在内存中加载完整图片的估计内存使用量。</li>
<li>根据应用的任何其他内存要求，您愿意分配用于加载此图片的内存量。</li>
<li>图片要载入到的目标 ImageView 或界面组件的尺寸。</li>
<li>当前设备的屏幕大小和密度。</li>
</ul>
<p>例如，如果 1024x768 像素的图片最终会在 ImageView 中显示为 128x96 像素缩略图，则不值得将其加载到内存中。</p>
<p>要让解码器对图片进行下采样，以将较小版本加载到内存中，请在 <code>BitmapFactory.Options</code> 对象中将 <code>inSampleSize</code> 设置为 <code>true</code>。</p>
<p>例如，分辨率为 <code>2048x1536</code> 且以 <code>4</code> 作为 <code>inSampleSize</code> 进行解码的图片会生成大约 <code>512x384</code> 的位图。将此图片加载到内存中需使用 <code>0.75MB</code>，而不是完整图片所需的 <code>12MB</code>（假设位图配置为 <code>ARGB_8888</code>）。</p>
<p>下面的方法用于计算样本大小值，即基于目标宽度和高度的 <code>2</code> 的幂：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateInSampleSize</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            BitmapFactory.Options options, <span class="keyword">int</span> reqWidth, <span class="keyword">int</span> reqHeight)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Raw height and width of image</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> height = options.outHeight;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> width = options.outWidth;</span><br><span class="line">    <span class="keyword">int</span> inSampleSize = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (height &gt; reqHeight || width &gt; reqWidth) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> halfHeight = height / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> halfWidth = width / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// Calculate the largest inSampleSize value that is a power of 2 and keeps both</span></span><br><span class="line">        <span class="comment">// height and width larger than the requested height and width.</span></span><br><span class="line">        <span class="keyword">while</span> ((halfHeight / inSampleSize) &gt;= reqHeight</span><br><span class="line">                &amp;&amp; (halfWidth / inSampleSize) &gt;= reqWidth) &#123;</span><br><span class="line">            inSampleSize *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> inSampleSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：根据 <code>inSampleSize</code> 文档，计算 <code>2</code> 的幂的原因是解码器使用的最终值将向下舍入为最接近的 <code>2</code> 的幂。</p>
</blockquote>
<p>要使用此方法，请先将 <code>inJustDecodeBounds</code> 设为 <code>true</code> 进行解码，传递选项，然后使用新的 <code>inSampleSize</code> 值并将 设为<code>false</code> 再次进行解码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">decodeSampledBitmapFromResource</span><span class="params">(Resources res, <span class="keyword">int</span> resId,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> reqWidth, <span class="keyword">int</span> reqHeight)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// First decode with inJustDecodeBounds=true to check dimensions</span></span><br><span class="line">    <span class="keyword">final</span> BitmapFactory.Options options = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">    options.inJustDecodeBounds = <span class="keyword">true</span>;</span><br><span class="line">    BitmapFactory.decodeResource(res, resId, options);</span><br><span class="line">    <span class="comment">// Calculate inSampleSize</span></span><br><span class="line">    options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);</span><br><span class="line">    <span class="comment">// Decode bitmap with inSampleSize set</span></span><br><span class="line">    options.inJustDecodeBounds = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> BitmapFactory.decodeResource(res, resId, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Android</code> 使用的 <code>inSampleSize</code> 计算采样率使用的采样算法是<strong>邻近采样（Nearest Neighbour Resampling）</strong>， <code>x</code>（<code>x</code> 为 2 的倍数）个像素最后对应一个像素。比如采样率设置为 <code>1/2</code> ，所以是两个像素生成一个像素。邻近采样的方式比较粗暴，直接选择其中的一个像素作为生成像素，另一个像素直接抛弃。</p>
<h3 id="使用createScaledBitmap或Matrix"><a href="#使用createScaledBitmap或Matrix" class="headerlink" title="使用createScaledBitmap或Matrix"></a>使用createScaledBitmap或Matrix</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Bitmap bitmap = BitmapFactory.decodeFile(<span class="string">"/sdcard/test.png"</span>);</span><br><span class="line">Bitmap compress = Bitmap.createScaledBitmap(bitmap, bitmap.getWidth()/<span class="number">2</span>, bitmap.getHeight()/<span class="number">2</span>, <span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//或者直接使用 matrix 进行缩放，查看Bitmap.createScaledBitmap源码其实就是使用 matrix 缩放</span></span><br><span class="line">Bitmap bitmap = BitmapFactory.decodeFile(<span class="string">"/sdcard/test.png"</span>);</span><br><span class="line">Matrix matrix = <span class="keyword">new</span> Matrix();</span><br><span class="line">matrix.setScale(<span class="number">0.5f</span>, <span class="number">0.5f</span>);</span><br><span class="line">bm = Bitmap.createBitmap(bitmap, <span class="number">0</span>, <span class="number">0</span>, bit.getWidth(), bit.getHeight(), matrix, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
<p>同样是图片宽高各为原来的<code>1/2</code>，这种方式采用<strong>双线性采样（Bilinear Resampling）</strong>，这个算法不像邻近采样算法直接粗暴的选择一个像素，而是参考了源像素相应位置周围 <code>2x2</code> 个点的值，根据相对位置取对应的权重，经过计算之后得到目标图像。</p>
<p>不同的采样算法会产生不同效果，除了 <code>Android</code> 中这两种常用的采样算法之外，还有比较常见如：<code>双立方／双三次采样（Bicubic Resampling）</code> 和 <code>Lanczos Resampling</code> 等。如果对 <code>Android</code> 使用的这两种采样算法效果不满意，必要时可以引入其他的算法。</p>
<h3 id="BitmapFactory-Options三件套"><a href="#BitmapFactory-Options三件套" class="headerlink" title="BitmapFactory.Options三件套"></a>BitmapFactory.Options三件套</h3><blockquote>
<p><code>inScaled</code> + <code>inDensity</code> + <code>inTargetDensity</code></p>
</blockquote>
<p>当<strong>inScaled</strong>设置为true时（设置此标志时），如果<strong>inDensity</strong>与<strong>inTargetDensity</strong>不为0，<code>Bitmap</code> 就会在加载的时候直接进行缩放以匹配 <code>inTargetDensity</code> ，而不是绘制的时候进行缩放。（加载到堆内存时已经缩放了大小了，<code>.9图</code> 会忽略此标志）</p>
<p><strong>inDensity</strong>:加载图片的原始宽度，如果此密度与 <code>inTargetDensity</code> 不匹配，则在返回 <code>Bitmap</code>前会将它缩放至目标密度。<br><strong>inTargetDensity</strong> :目标图片的显示宽度，它与 <code>inScaled</code> 与 <code>inDensity</code> 结合使用，确定如何在返回 <code>Bitmap</code> 前对其进行缩放。</p>
<p>前面讲述的计算 <code>Bitmap</code> 大小的第二个例子，就是将相同图片加载放到不同的 <code>drawable-dpi</code> 的文件目录下去加载到内存中的 <code>Bitmap</code> 大小不同，其原因就是 <code>inDensity</code> 和 <code>inTargetDensity</code> 不一致导致。</p>
<h1 id="Bitmap局部解码"><a href="#Bitmap局部解码" class="headerlink" title="Bitmap局部解码"></a>Bitmap局部解码</h1><p><a href="https://developer.android.com/reference/android/graphics/BitmapRegionDecoder?hl=en" target="_blank" rel="noopener">官网文档-BitmapRegionDecoder</a> ，<code>BitmapRegionDecoder</code> 可用于解码图像中的矩形区域。当原始图像很大且只需要部分图像时，<code>BitmapRegionDecoder</code> 尤其有用。 要创建 <code>BitmapRegionDecoder</code>，请调用 <code>newInstance()</code> 。给定一个 <code>BitmapRegionDecoder</code>，用户可以重复调用 <code>encodeRegio()</code>以获取指定区域的解码后的 <code>Bitmap</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    inputStream = getResources().getAssets().open(<span class="string">"qq.jpg"</span>);</span><br><span class="line">    BitmapRegionDecoder mRegionDecoder = BitmapRegionDecoder.newInstance(inputStream, <span class="keyword">false</span>);</span><br><span class="line">    BitmapFactory.Options sOptions = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">    sOptions.inPreferredConfig = Bitmap.Config.ARGB_8888;</span><br><span class="line">    sOptions.inSampleSize = <span class="number">2</span>;</span><br><span class="line">    Rect mRect = <span class="keyword">new</span> Rect();</span><br><span class="line">    mRect.top = <span class="number">0</span>;</span><br><span class="line">    mRect.left = <span class="number">0</span>;</span><br><span class="line">    mRect.right = <span class="number">100</span>;</span><br><span class="line">    mRect.bottom = <span class="number">100</span>;</span><br><span class="line">    Bitmap bitmap = mRegionDecoder.decodeRegion(mRect, sOptions);</span><br><span class="line">    <span class="comment">//bitmap.getByteCount()=40000</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是 <code>mRect</code> 的宽高不能太大，否则加载得到的 <code>Bitmap</code> 的时候也会出现 <code>OOM</code> 的异常。</p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Bitmap</tag>
      </tags>
  </entry>
  <entry>
    <title>Gradle自定义Plugin插件和ASM修改字节码</title>
    <url>/2020/03/09/gradle-plugin-asm/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>先介绍一下 <code>AOP</code> 和 <code>ASM</code> 的概念，<code>AOP</code> 是一种<strong>面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术</strong>。和面向对象编程 的 <code>OOP</code> 相同。<code>ASM</code> 是一个框架可以看作 <code>AOP</code> 的工具，当然 <code>AOP</code> 也有其他工具，比如用的比较多的 <code>AspectJ</code> 、<code>Javassist</code> 、<code>Xposed</code> 和 <code>Dexposed</code> 等。</p>
<p>这里我们主要介绍一下在自定义<code>Plugin</code> 使用的 <code>ASM</code> :</p>
<blockquote>
<p><a href="https://asm.ow2.io/" target="_blank" rel="noopener">ASM</a> 是一个通用的<code>Java</code>字节码操作和分析框架。它可以直接以二进制形式用于修改现有类或动态生成类。 <code>ASM</code>提供了一些常见的字节码转换和分析算法，可以从中构建定制的复杂转换和代码分析工具。 <code>ASM</code>提供与其他<code>Java字</code>节码框架类似的功能，但侧重于性能。因为它的设计和实现是尽可能的小和尽可能快，所以它非常适合在动态系统中使用（但当然也可以以静态方式使用，例如在编译器中）。</p>
</blockquote>
<h1 id="自定义plugin开发"><a href="#自定义plugin开发" class="headerlink" title="自定义plugin开发"></a>自定义plugin开发</h1><p><code>Gradle</code>从1.5开始，<code>Gradle</code>插件包含了一个叫<code>Transform</code>的API，这个API允许第三方插件在<code>class</code>文件转为为<code>dex</code>文件前操作编译好的<code>class</code>文件，这个API的目标是简化自定义类操作，而不必处理<code>Task</code>，并且在操作上提供更大的灵活性。并且可以更加灵活地进行操作。官方文档：<a href="http://google.github.io/android-gradle-dsl/javadoc/" target="_blank" rel="noopener">http://google.github.io/android-gradle-dsl/javadoc/</a></p>
<h2 id="创建插件"><a href="#创建插件" class="headerlink" title="创建插件"></a>创建插件</h2><p>在 <code>AndroidStudio</code> 中创建一个纯净的<code>Module</code> ，删除 <code>res</code> 文件夹和 <code>AndroidManifest.xml</code> 文件。</p>
<p><strong>Gradle会默认在配置初始化前，编译buildSrc这个项目，可以是java、groovy、kotlin项目，并把项目配置到classpath下。</strong>所以如果<code>Module</code> 命名为 <code>buildSrc</code> 那么不需要在 <code>Project</code> 级别的 <code>build.gradle</code> 文件中使用 <code>classpath</code> 引入，也不需要在 <code>app</code> 级别的 <code>build.gradle</code> 文件中使用 <code>apply plugin:</code> 进行应用。  </p>
<p>下面我们介绍的是自定义的 <code>Plugin</code> 插件，是编译之后需要引入项目的。</p>
<blockquote>
<p>类继承<code>Plugin</code> </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmsPlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(@NonNull Project project)</span> </span>&#123;</span><br><span class="line">        AppExtension appExtension = project.getExtensions().findByType(AppExtension.class);</span><br><span class="line">        <span class="keyword">assert</span> appExtension != <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//注册task任务</span></span><br><span class="line">        appExtension.registerTransform(<span class="keyword">new</span> AmsTransform(project));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmsTransform</span> <span class="keyword">extends</span> <span class="title">Transform</span></span>&#123;</span><br><span class="line">  	<span class="comment">/***部分代码省略***/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>build.gradle</code> 文件配置</p>
</blockquote>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMzE5ODc5LWE4YTkxODBiODUzYzIxODkucG5n?x-oss-process=image/format,png#pic_center" alt="uploadArchives.png"></p>
<blockquote>
<p>配置<code>properties</code></p>
</blockquote>
<p>在 <code>/src/main/resources/META-INF/gradle-plugins</code> 目录下创建<code>xxx.properties</code> 文件，这个 <code>xxx</code> 就是以后项目<code>build.gradle</code> 文件中需要<code>apply</code> 的插件名称。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">implementation-class=com.tzx.ams.plugin.AmsPlugin</span><br></pre></td></tr></table></figure>
<p><code>com.tzx.ams.plugin.AmsPlugin</code> 就是插件对应的类。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMzE5ODc5LTI4MmY0MTVhMzdkYzRlZTQucG5n?x-oss-process=image/format,png#pic_center" alt="properties.png"></p>
<h2 id="生成插件"><a href="#生成插件" class="headerlink" title="生成插件"></a>生成插件</h2><p>我们在执行 <code>uploadArchives</code> 的任务的时候就在我们对于的仓库生成了我们需要的插件。</p>
<h2 id="在项目中引入插件"><a href="#在项目中引入插件" class="headerlink" title="在项目中引入插件"></a>在项目中引入插件</h2><blockquote>
<p>项目的根 <code>build.gradle</code>配置</p>
</blockquote>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123;<span class="comment">//添加repo本地仓库</span></span><br><span class="line">            url uri(<span class="string">"repo"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">'com.android.tools.build:gradle:3.5.3'</span></span><br><span class="line">        <span class="comment">//添加插件依赖</span></span><br><span class="line">        classpath <span class="string">'com.tzx.ams:ams-plugin:1.0.0'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>项目的 <code>build.gradle</code> 配置</p>
</blockquote>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'com.android.application'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'amsplugin'</span></span><br><span class="line"><span class="comment">/***部分代码省略***/</span></span><br></pre></td></tr></table></figure>
<h1 id="plugin自定义配置"><a href="#plugin自定义配置" class="headerlink" title="plugin自定义配置"></a>plugin自定义配置</h1><blockquote>
<p>配置类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmsConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//日志开关</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isDebug;</span><br><span class="line">    <span class="comment">//class包含str则不处理</span></span><br><span class="line">    <span class="keyword">public</span> String[] filterContainsClassStr;</span><br><span class="line">    <span class="comment">//class以str开头则不处理</span></span><br><span class="line">    <span class="keyword">public</span> String[] filterstartsWithClassStr;</span><br><span class="line">    <span class="comment">//拦截在这个文件中声明的class</span></span><br><span class="line">    <span class="keyword">public</span> String filterClassFile;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; filterClassNameList;</span><br><span class="line">    <span class="comment">//需要进行注入的method</span></span><br><span class="line">    <span class="keyword">public</span> String amsMethodFile;</span><br><span class="line">    <span class="comment">//需要进行注入的method对应的tag</span></span><br><span class="line">    <span class="keyword">public</span> String amsMethodTag;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Pair&lt;String, String&gt;&gt; amsMethodFileList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>创建<code>AmsConfig</code> 的类对象</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmsPlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(@NonNull Project project)</span> </span>&#123;</span><br><span class="line">        AppExtension appExtension = project.getExtensions().findByType(AppExtension.class);</span><br><span class="line">        <span class="keyword">assert</span> appExtension != <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//注册优先于task任务的添加</span></span><br><span class="line">        project.getExtensions().create(<span class="string">"AmsConfig"</span>, AmsConfig.class);</span><br><span class="line">        appExtension.registerTransform(<span class="keyword">new</span> AmsTransform(project));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>build.gradle</code> 文件中定义配置（如果gradle中没有定义，那么会反射构造一个对象）</p>
</blockquote>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'com.android.application'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'amsplugin'</span></span><br><span class="line">AmsConfig&#123;</span><br><span class="line">    isDebug = <span class="literal">true</span></span><br><span class="line">    filterContainsClassStr = [<span class="string">"R.class"</span>, <span class="string">".R\$"</span>]</span><br><span class="line">    filterstartsWithClassStr = [<span class="string">"android"</span>]</span><br><span class="line">    filterClassFile = <span class="string">"amsfilterclass.text"</span><span class="comment">//build.gradle相同目录级别的文件名</span></span><br><span class="line">    amsMethodFile = <span class="string">"amsmethods.text"</span><span class="comment">//build.gradle相同目录级别的文件名</span></span><br><span class="line">    amsMethodTag = <span class="string">"TEST"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>获取<code>gradle</code> 中定义的配置</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AmsConfig amsConfig = (AmsConfig) <span class="keyword">this</span>.project.getExtensions().getByName(AmsConfig.class.getSimpleName());</span><br><span class="line"><span class="comment">//配置文件的获取</span></span><br><span class="line">String projectDri = <span class="keyword">this</span>.project.getProjectDir().getAbsolutePath()</span><br><span class="line">String fileName = projectDri + File.separatorChar + amsConfig.filterClassFile;</span><br></pre></td></tr></table></figure>
<p>这个 <code>amsConfig</code> 在使用的时候不用判空，如果调用<code>project.getExtensions().create</code> 添加了那么就会反射构造出这个对象。如果<code>gradle</code> 文件中定义了，那么这个对象就会被赋与相应的属性值。</p>
<p>如果在获取的时候，没有被<code>create</code>那么就会跑出一下异常：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* Where:</span><br><span class="line">Build file &apos;/Users/tanzx/AndroidStudioWorkSpace/GitHub/AmsDemo/app/build.gradle&apos; line: 3</span><br><span class="line">* What went wrong:</span><br><span class="line">A problem occurred evaluating project &apos;:app&apos;.</span><br><span class="line">&gt; Could not find method AmsConfig() for arguments [build_5n6idkxwtmzfflm5k30ynjblo$_run_closure1@2cf1f355] on project &apos;:app&apos; of type org.gradle.api.Project</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/stven0king/AndroidPluginStudy" target="_blank" rel="noopener">代码传送门，拿走不谢^^！</a></p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>Picasso源码分析和对比</title>
    <url>/2019/12/30/picasso/</url>
    <content><![CDATA[<p>前面的 <a href="https://dandanlove.blog.csdn.net/article/details/103256724" target="_blank" rel="noopener">Android-Universal-Image-Loader源码分析</a> 和 <a href="https://dandanlove.blog.csdn.net/article/details/103564516" target="_blank" rel="noopener">Glide源码阅读理解一小时</a> 分别讲述了五年前和现在最受欢迎的 <code>Android</code> 图片加载库。今天讲述的<code>picasso</code>是<code>Square</code>公司开源的一个<code>Android</code>图片加载库，可以实现图片下载和缓存功能。它 <code>ImageLoader</code> 和 <code>Glide</code> 的都有些相同和和不同点以及自己独特的点。</p>
<p>本文参考的 <code>Picasso</code> 源码的版本为 <code>2.71828</code> 。</p>
<p><a href="https://square.github.io/picasso" target="_blank" rel="noopener">官网地址：https://square.github.io/picasso</a></p>
<p><a href="https://github.com/square/picasso" target="_blank" rel="noopener">GitHub地址：https://github.com/square/picasso</a></p>
<h1 id="Picasso组成部分"><a href="#Picasso组成部分" class="headerlink" title="Picasso组成部分"></a>Picasso组成部分</h1><center><br><img src="https://img-blog.csdnimg.cn/20191230174525919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kYW5kYW5sb3ZlLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></center>

<p>这幅图对应的是 <code>Picasso</code> 的主要组成部分。</p>
<ul>
<li><code>Picasso</code> ：图片加载、转换、缓存的管理类。提供 <code>get</code> 方法获取默认的单例对象，也提供了 <code>Builder</code> 供业务方自定义配置生成自己的单例对象。</li>
<li><code>RequestCreator</code> ：提供易用的 <code>API</code> ，内部维护了一个 <code>Request.Builder</code> 对象。用于构建图片下载的<code>Request</code> 。</li>
<li><code>Request</code> ：一个不可变的数据，用于控制图片使用之前的加载和变化。提供 <code>Builder</code> 进行数据的参数设置。</li>
<li><code>Action</code> ：图片架加载任务的请求包装，内部有 <code>picasso</code> 、<code>Request</code> 、<code>key</code> 和 <code>tag</code> 等。</li>
<li><code>Dispatcher</code> ：执行任务的分发器，以及任务的暂停、重复、回复等事件的处理。内部注册了 <code>BroadcastReceiver</code> 用来监测网络变化，从而进一步修改线程池的大小。</li>
<li><code>BitmapHunter</code> ：核心类负责任务执行具体操作，获取数据，解码数据为 <code>Bitmp</code> 。处理生成的 <code>Bitmap</code> 以及负责当前请求的 <code>transformation</code> 操作。</li>
<li><code>RequestHandler</code> ：用于自定义的请求处理类，需要重写 <code>canHandleRequest</code> 和 <code>load</code> 方法。<code>Picasso</code> 内部默认添加了7个 <code>RequestHandler</code> 子类。</li>
</ul>
<h1 id="Picasso的获取"><a href="#Picasso的获取" class="headerlink" title="Picasso的获取"></a>Picasso的获取</h1><p><code>Picasso</code> 的官网实例中 <code>Picasso.get()</code> 方式可以获取默认的 <code>Picasso</code> 的单例对象进行图片加载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.squareup.picasso.Picasso.java</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> Picasso singleton = <span class="keyword">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Picasso <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Picasso.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (PicassoProvider.context == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"context == null"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            singleton = <span class="keyword">new</span> Builder(PicassoProvider.context).build();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Picasso</code> 的单例使用了<strong>双重校验锁（ DCL：double-checked locking)</strong>，相关资料可以参考<a href="https://dandanlove.blog.csdn.net/article/details/101759634" target="_blank" rel="noopener">Java版的7种单例模式</a> 。</p>
<p>其中的 <code>Context</code> 不需要外部注入使用的是 <code>ContentProvider</code> 的 <code>Context</code> ，这个 <code>ContentProvider</code> 是<code>Picasso</code> 自己注册在 <code>AndroidManifest.xml</code> 中的。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">"com.squareup.picasso"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-sdk</span> <span class="attr">android:minSdkVersion</span>=<span class="string">"14"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">"com.squareup.picasso.PicassoProvider"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:authorities</span>=<span class="string">"$&#123;applicationId&#125;.com.squareup.picasso"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="Picasso的配置"><a href="#Picasso的配置" class="headerlink" title="Picasso的配置"></a>Picasso的配置</h1><p>根据 <code>Picasso.Builder</code> 的我们可以知道我们能自定义那些 <code>Picasso</code> 的配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.squareup.picasso.Picasso$Builder.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Picasso <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Context context = <span class="keyword">this</span>.context;</span><br><span class="line">    <span class="keyword">if</span> (downloader == <span class="keyword">null</span>) &#123;<span class="comment">//默认的下载为okhttp</span></span><br><span class="line">        downloader = <span class="keyword">new</span> OkHttp3Downloader(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cache == <span class="keyword">null</span>) &#123;<span class="comment">//默认的内存缓存使用的是LruCache</span></span><br><span class="line">        cache = <span class="keyword">new</span> LruCache(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (service == <span class="keyword">null</span>) &#123;<span class="comment">//默认的线程池</span></span><br><span class="line">        service = <span class="keyword">new</span> PicassoExecutorService();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (transformer == <span class="keyword">null</span>) &#123;<span class="comment">//请求转化接口</span></span><br><span class="line">        transformer = RequestTransformer.IDENTITY;</span><br><span class="line">    &#125;</span><br><span class="line">    Stats stats = <span class="keyword">new</span> Stats(cache);</span><br><span class="line">    Dispatcher dispatcher = <span class="keyword">new</span> Dispatcher(context, service, HANDLER, downloader, cache, stats);</span><br><span class="line">    <span class="comment">//listener:检测Picasso加载图片过程中的失败以及异常</span></span><br><span class="line">    <span class="comment">//requestHandlers:自定义请求处理模块</span></span><br><span class="line">    <span class="comment">//defaultBitmapConfig:自定义生成Bitmap的配置</span></span><br><span class="line">    <span class="comment">//indicatorsEnabled：是否显示图片来源的指示器</span></span><br><span class="line">    <span class="comment">//loggingEnabled：是否打印Picasso的日志</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Picasso(context, dispatcher, cache, listener, transformer, requestHandlers, stats,</span><br><span class="line">        defaultBitmapConfig, indicatorsEnabled, loggingEnabled);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显示指示器的图片加载完成之后会变为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> LoadedFrom &#123;</span><br><span class="line">    MEMORY(Color.GREEN),</span><br><span class="line">    DISK(Color.BLUE),</span><br><span class="line">    NETWORK(Color.RED);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> debugColor;</span><br><span class="line">    LoadedFrom(<span class="keyword">int</span> debugColor) &#123;</span><br><span class="line">      <span class="keyword">this</span>.debugColor = debugColor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center><br><img src="https://img-blog.csdnimg.cn/20191230174458691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kYW5kYW5sb3ZlLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></center>

<h1 id="Picasso加载数据类型"><a href="#Picasso加载数据类型" class="headerlink" title="Picasso加载数据类型"></a>Picasso加载数据类型</h1><p><code>Picasso</code> 一共提供了4中 <code>load</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RequestCreator <span class="title">load</span><span class="params">(@Nullable Uri uri)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestCreator <span class="title">load</span><span class="params">(@Nullable String path)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestCreator <span class="title">load</span><span class="params">(@NonNull File file)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestCreator <span class="title">load</span><span class="params">(@DrawableRes <span class="keyword">int</span> resourceId)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中 <code>String</code> 和 <code>File</code> 类型都会转化为 <code>Uri</code> 类型，所以 <code>Picasso</code> 支持 <code>Uri</code> 和 <code>ResourceId</code> 类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Picasso.get().load(R.drawable.landing_screen).into(imageView1);</span><br><span class="line">Picasso.get().load(<span class="string">"file:///android_asset/DvpvklR.png"</span>).into(imageView2);</span><br><span class="line">Picasso.get().load(<span class="keyword">new</span> File(...)).into(imageView3);</span><br></pre></td></tr></table></figure>
<h1 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h1><p><code>Picasso</code> 的简单实用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Picasso.get().load(<span class="string">"http://i.imgur.com/DvpvklR.png"</span>).into(imageView);</span><br></pre></td></tr></table></figure>
<p><code>Picasso</code> 的对图片的一些变化实用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Picasso.get()</span><br><span class="line">  .load(url)</span><br><span class="line">  .resize(<span class="number">50</span>, <span class="number">50</span>)</span><br><span class="line">  .centerCrop()</span><br><span class="line">  .into(imageView)</span><br></pre></td></tr></table></figure>
<p><code>Picasso</code> 的默认图以及错误处理默认图设置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Picasso.get()</span><br><span class="line">    .load(url)</span><br><span class="line">    .placeholder(R.drawable.user_placeholder)</span><br><span class="line">    .error(R.drawable.user_placeholder_error)</span><br><span class="line">    .into(imageView);</span><br></pre></td></tr></table></figure>
<p>以上的这些设置都是在修改 <code>Request</code> 的成员变量的属性。</p>
<h2 id="RequestCreator的构造"><a href="#RequestCreator的构造" class="headerlink" title="RequestCreator的构造"></a>RequestCreator的构造</h2><p>我们知道 <code>Picasso</code> 支持加载 <code>Uri</code> 和 <code>ResourceId</code> ，所以我们先来看看这两个数据类型的 <code>load</code> 的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.squareup.picasso.Picasso.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestCreator <span class="title">load</span><span class="params">(@Nullable Uri uri)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> RequestCreator(<span class="keyword">this</span>, uri, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestCreator <span class="title">load</span><span class="params">(@DrawableRes <span class="keyword">int</span> resourceId)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (resourceId == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Resource ID must not be zero."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> RequestCreator(<span class="keyword">this</span>, <span class="keyword">null</span>, resourceId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="RequestCreateor对Request的配置"><a href="#RequestCreateor对Request的配置" class="headerlink" title="RequestCreateor对Request的配置"></a>RequestCreateor对Request的配置</h2><ul>
<li>可以设置 <code>tag</code> 标签，<code>Picasso</code> 可以在暂停、恢复请求的时候操作具有相同的 <code>tag</code> 标签的请求。比如 <code>Activity</code> 或者 <code>Context</code> 我们可以根据这个 <code>tag</code> 标签，做请求的<strong>生命周期管理</strong>，但是需要注意内存泄漏；</li>
<li>可以设置缓存的额外的 <code>Key</code> ，从而对同一个请求资源做不同的缓存处理；</li>
<li>设置请求的优先级；</li>
<li>设置内存缓存策略，以及网络请求缓存策略；</li>
<li>设置禁用从磁盘缓存或网络加载的图像的进行淡入浅出动画；</li>
<li>设置对图片的转化，转化前的图片必须在转化后手动回收；</li>
<li>设置可以等到图片加载完成确定宽、高之后再进行资源的加载；</li>
<li>设置对图片的宽、高、裁剪方式，旋转角度和解码配置等；</li>
</ul>
<h2 id="Request的构造和Action的提交"><a href="#Request的构造和Action的提交" class="headerlink" title="Request的构造和Action的提交"></a>Request的构造和Action的提交</h2><p>我们通过 <code>Picasso.load</code> 方法构造 <code>RequestCreateor</code> ，<code>Request</code> 的构造再下一步调用 <code>RequestCreateor.into</code> 真正出发请求的时候产生。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.squareup.picasso.RequestCreator.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">into</span><span class="params">(ImageView target)</span> </span>&#123;</span><br><span class="line">    into(target, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">into</span><span class="params">(ImageView target, Callback callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> started = System.nanoTime();</span><br><span class="line">    checkMain();</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Target must not be null."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!data.hasImage()) &#123;<span class="comment">//判断uri为空，或者resourceid等于0</span></span><br><span class="line">      picasso.cancelRequest(target);<span class="comment">//取消在target上的请求</span></span><br><span class="line">      <span class="keyword">if</span> (setPlaceholder) &#123;<span class="comment">//如果设置默认占位图，那么默认图展现在target上</span></span><br><span class="line">        setPlaceholder(target, getPlaceholderDrawable());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (deferred) &#123;<span class="comment">//判断是否需要延迟初始化</span></span><br><span class="line">        <span class="keyword">if</span> (data.hasSize()) &#123;<span class="comment">//如果已经设置了宽高，那么不能进行延迟请求</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Fit cannot be used with resize."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> width = target.getWidth();</span><br><span class="line">        <span class="keyword">int</span> height = target.getHeight();</span><br><span class="line">        <span class="keyword">if</span> (width == <span class="number">0</span> || height == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (setPlaceholder) &#123;<span class="comment">//如果设置默认占位图，那么默认图展现在target上</span></span><br><span class="line">                setPlaceholder(target, getPlaceholderDrawable());</span><br><span class="line">            &#125;<span class="comment">//设置延迟加载，具体实现后续有讲解</span></span><br><span class="line">            picasso.defer(target, <span class="keyword">new</span> DeferredRequestCreator(<span class="keyword">this</span>, target, callback));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果target已经确定边界那么不需要延迟请求</span></span><br><span class="line">        data.resize(width, height);</span><br><span class="line">    &#125;</span><br><span class="line">    Request request = createRequest(started);<span class="comment">//创建Request,如果请求已更改，请复制原始ID和时间戳。</span></span><br><span class="line">    String requestKey = createKey(request);<span class="comment">//创建请求的key，用来标识请求和内存缓存</span></span><br><span class="line">    <span class="keyword">if</span> (shouldReadFromMemoryCache(memoryPolicy)) &#123;<span class="comment">//是否读取内存缓存（默认内存缓存，可读、可写）</span></span><br><span class="line">        Bitmap bitmap = picasso.quickMemoryCacheCheck(requestKey);<span class="comment">//从urlcache中获取</span></span><br><span class="line">        <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;<span class="comment">//如果有缓存的bitmap</span></span><br><span class="line">            picasso.cancelRequest(target);<span class="comment">//取消请求，target设置bitmap同时标识数据来源为内存缓存</span></span><br><span class="line">            setBitmap(target, picasso.context, bitmap, MEMORY, noFade, picasso.indicatorsEnabled);</span><br><span class="line">            <span class="keyword">if</span> (picasso.loggingEnabled) &#123;</span><br><span class="line">                log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), <span class="string">"from "</span> + MEMORY);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                callback.onSuccess();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (setPlaceholder) &#123;<span class="comment">//如果设置默认占位图，那么默认图展现在target上</span></span><br><span class="line">        setPlaceholder(target, getPlaceholderDrawable());</span><br><span class="line">    &#125;<span class="comment">//构建请求任务的Action，进行任务提交</span></span><br><span class="line">    Action action = <span class="keyword">new</span> ImageViewAction(picasso, target, request, memoryPolicy, networkPolicy, errorResId,errorDrawable, requestKey, tag, callback, noFade);</span><br><span class="line">    picasso.enqueueAndSubmit(action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码主要包含了一下以及逻辑:</p>
<ul>
<li>是否需要延迟请求，以便于确定加载图片的边界；</li>
<li>创建 <code>Request</code> 和 <code>requestkey</code> ；<ul>
<li><code>Request</code> 的创建主要是先调用 <code>RequestCreator</code> 对象中的 <code>Request.Builder</code> 的 <code>builder()</code> 方法构造，并且调用 <code>Picasso</code> 的请求转化操作进行 <code>请求</code> 的处理.</li>
<li><code>requestKey</code> 的创建主要是根据当前 <code>Request</code> 的 <code>uri</code> 或<code>stableKey</code> 以及旋转角度、宽高、裁剪样式和转变操作等构造。</li>
</ul>
</li>
<li>是否需要从内存缓存中读取并加载；</li>
<li>构建请求的任务 <code>Action</code> ，并进行提交；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueueAndSubmit</span><span class="params">(Action action)</span> </span>&#123;</span><br><span class="line">    Object target = action.getTarget();</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="keyword">null</span> &amp;&amp; targetToAction.get(target) != action) &#123;</span><br><span class="line">        <span class="comment">//检测是否在主线程，去掉target上的之前的action操作</span></span><br><span class="line">        cancelExistingRequest(target);</span><br><span class="line">        targetToAction.put(target, action);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//提交任务</span></span><br><span class="line">    submit(action);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">submit</span><span class="params">(Action action)</span> </span>&#123;</span><br><span class="line">    dispatcher.dispatchSubmit(action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>enqueueAndSubmit</code> 方法移除了 <code>ImageView</code> 上之前的操作，以便于加载新的图片。</p>
<h1 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h1><p>上面说到了构造 <code>Action</code> ，我们这里来分析一下 <code>Picasso</code> 提供的 <code>Action</code> 类型。</p>
<blockquote>
<p><code>GetAction</code> ：仅仅用来加载资源以及进行缓存，无任何回调；</p>
<p><code>FetchAction</code> ：用来加载资源以及进行缓存，只有成功失败回调，没有资源信息回调；</p>
<p><code>TargetAction</code> ：用来加载资源以及进行缓存，可以有有资源信息的成功、失败回调；</p>
<p><code>ImageViewAction</code> ：用来加载资源以及进行缓存，然后将产生的 <code>Bitmap</code> 加载在 <code>ImageView</code> 上。</p>
<p><code>RemoteViewAction</code> ：抽象类，用来加载资源以及进行缓存，然后将产生的 <code>Bitmap</code> 加载在 <code>RemoteView</code> 上。有两个实现类<code>NotificationAction</code> 和 <code>AppWidgetAction</code> ，分别对应通知栏和桌面小部件。</p>
</blockquote>
<h1 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h1><p><code>Dispatcher</code> 作为任务的分发器会将提交任务、恢复任务、暂停任务、取消任务、任务完成、任务失败以及网络状态变化。</p>
<p>我先接着上一步讲述任务的提交：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.squareup.picasso.Dispatcher.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchSubmit</span><span class="params">(Action action)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//切换任务执行的线程(主线程到异步线程)</span></span><br><span class="line">   handler.sendMessage(handler.obtainMessage(REQUEST_SUBMIT, action));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>handler</code> 是有着一个非主线程的 <code>Looper</code> ，为 <code>DispatcherHandler</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.squareup.picasso.Dispatcher.java</span></span><br><span class="line"><span class="keyword">this</span>.handler = <span class="keyword">new</span> DispatcherHandler(dispatcherThread.getLooper(), <span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatcherThread</span> <span class="keyword">extends</span> <span class="title">HandlerThread</span> </span>&#123;</span><br><span class="line">    DispatcherThread() &#123;</span><br><span class="line">        <span class="comment">//THREAD_PRIORITY_BACKGROUND=10</span></span><br><span class="line">    	<span class="keyword">super</span>(Utils.THREAD_PREFIX + DISPATCHER_THREAD_NAME, THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>切换线程执行 <code>Action</code> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.squareup.picasso.Dispatcher.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">performSubmit</span><span class="params">(Action action)</span> </span>&#123;</span><br><span class="line">    performSubmit(action, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">performSubmit</span><span class="params">(Action action, <span class="keyword">boolean</span> dismissFailed)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果当前的tag处于paused那么将这个action加入到pausedActions容器</span></span><br><span class="line">    <span class="keyword">if</span> (pausedTags.contains(action.getTag())) &#123;</span><br><span class="line">        pausedActions.put(action.getTarget(), action);</span><br><span class="line">        <span class="keyword">if</span> (action.getPicasso().loggingEnabled) &#123;</span><br><span class="line">            log(OWNER_DISPATCHER, VERB_PAUSED, action.request.logId(),<span class="string">"because tag '"</span> + action.getTag() + <span class="string">"' is paused"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否已经有对应的Bitmap捕捉器</span></span><br><span class="line">    BitmapHunter hunter = hunterMap.get(action.getKey());</span><br><span class="line">    <span class="keyword">if</span> (hunter != <span class="keyword">null</span>) &#123;<span class="comment">//如果有那么将当前的action进行依附（情景：多个imageview加载同一个图片资源）</span></span><br><span class="line">        hunter.attach(action);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (service.isShutdown()) &#123;<span class="comment">//任务线程池是否关闭</span></span><br><span class="line">        <span class="keyword">if</span> (action.getPicasso().loggingEnabled) &#123;</span><br><span class="line">            log(OWNER_DISPATCHER, VERB_IGNORED, action.request.logId(), <span class="string">"because shut down"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从Picasso中获取对应的Bitmap捕捉器</span></span><br><span class="line">    hunter = forRequest(action.getPicasso(), <span class="keyword">this</span>, cache, stats, action);</span><br><span class="line">    <span class="comment">//提交Bitmap的捕捉任务</span></span><br><span class="line">    hunter.future = service.submit(hunter);</span><br><span class="line">    hunterMap.put(action.getKey(), hunter);</span><br><span class="line">    <span class="keyword">if</span> (dismissFailed) &#123;<span class="comment">//失败不做处理，从failedActions移除</span></span><br><span class="line">        failedActions.remove(action.getTarget());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (action.getPicasso().loggingEnabled) &#123;</span><br><span class="line">        log(OWNER_DISPATCHER, VERB_ENQUEUED, action.request.logId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="线程池大小"><a href="#线程池大小" class="headerlink" title="线程池大小"></a>线程池大小</h1><p><code>Dispatcher</code>  在构造函数中注册了广播，监听网络状态的变化从而修改线程池执行线程数量的大小。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.squareup.picasso.PicassoExecutorService.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_THREAD_COUNT = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjustThreadCount</span><span class="params">(NetworkInfo info)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (info == <span class="keyword">null</span> || !info.isConnectedOrConnecting()) &#123;</span><br><span class="line">      setThreadCount(DEFAULT_THREAD_COUNT);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (info.getType()) &#123;</span><br><span class="line">      <span class="keyword">case</span> ConnectivityManager.TYPE_WIFI:<span class="comment">//WIFI</span></span><br><span class="line">      <span class="keyword">case</span> ConnectivityManager.TYPE_WIMAX:</span><br><span class="line">      <span class="keyword">case</span> ConnectivityManager.TYPE_ETHERNET:</span><br><span class="line">        setThreadCount(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> ConnectivityManager.TYPE_MOBILE:</span><br><span class="line">        <span class="keyword">switch</span> (info.getSubtype()) &#123;</span><br><span class="line">            <span class="keyword">case</span> TelephonyManager.NETWORK_TYPE_LTE:  <span class="comment">// 4G</span></span><br><span class="line">            <span class="keyword">case</span> TelephonyManager.NETWORK_TYPE_HSPAP:</span><br><span class="line">            <span class="keyword">case</span> TelephonyManager.NETWORK_TYPE_EHRPD:</span><br><span class="line">                setThreadCount(<span class="number">3</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TelephonyManager.NETWORK_TYPE_UMTS: <span class="comment">// 3G</span></span><br><span class="line">            <span class="keyword">case</span> TelephonyManager.NETWORK_TYPE_CDMA:</span><br><span class="line">            <span class="keyword">case</span> TelephonyManager.NETWORK_TYPE_EVDO_0:</span><br><span class="line">            <span class="keyword">case</span> TelephonyManager.NETWORK_TYPE_EVDO_A:</span><br><span class="line">            <span class="keyword">case</span> TelephonyManager.NETWORK_TYPE_EVDO_B:</span><br><span class="line">                setThreadCount(<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TelephonyManager.NETWORK_TYPE_GPRS: <span class="comment">// 2G</span></span><br><span class="line">            <span class="keyword">case</span> TelephonyManager.NETWORK_TYPE_EDGE:</span><br><span class="line">                setThreadCount(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                setThreadCount(DEFAULT_THREAD_COUNT);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        setThreadCount(DEFAULT_THREAD_COUNT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setThreadCount</span><span class="params">(<span class="keyword">int</span> threadCount)</span> </span>&#123;</span><br><span class="line">    setCorePoolSize(threadCount);</span><br><span class="line">    setMaximumPoolSize(threadCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="BitmapHunter"><a href="#BitmapHunter" class="headerlink" title="BitmapHunter"></a>BitmapHunter</h1><p><code>BitmapHunter</code> 实现了 <code>Runnable</code> 接口处理资源的加载，它内部有一个 <code>RequestHandler</code> 来 <code>load</code> 对应的 <code>Uri</code> 或者 <code>ResourceId</code> 。</p>
<h2 id="BitmapHunter的创建"><a href="#BitmapHunter的创建" class="headerlink" title="BitmapHunter的创建"></a>BitmapHunter的创建</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.squareup.picasso.BitmapHunter.java</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BitmapHunter <span class="title">forRequest</span><span class="params">(Picasso picasso, Dispatcher dispatcher, Cache cache, Stats stats, Action action)</span> </span>&#123;</span><br><span class="line">    Request request = action.getRequest();</span><br><span class="line">    List&lt;RequestHandler&gt; requestHandlers = picasso.getRequestHandlers();</span><br><span class="line">    <span class="comment">//基于索引的循环,分配迭代器。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, count = requestHandlers.size(); i &lt; count; i++) &#123;</span><br><span class="line">        RequestHandler requestHandler = requestHandlers.get(i);</span><br><span class="line">        <span class="keyword">if</span> (requestHandler.canHandleRequest(request)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BitmapHunter(picasso, dispatcher, cache, stats, action, requestHandler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BitmapHunter(picasso, dispatcher, cache, stats, action, ERRORING_HANDLER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RequestHandler</code> 前面讲述过 <code>Piacasso</code> 自己默认添加了7种，而且我们也可以自定义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Picasso(Context context, <span class="comment">//上线文环境</span></span><br><span class="line">        Dispatcher dispatcher, <span class="comment">//任务分发器</span></span><br><span class="line">        Cache cache, <span class="comment">//内存缓存</span></span><br><span class="line">        Listener listener,<span class="comment">//Picasso的异常回调</span></span><br><span class="line">        RequestTransformer requestTransformer, <span class="comment">//请求拦截处理类</span></span><br><span class="line">        List&lt;RequestHandler&gt; extraRequestHandlers, <span class="comment">//自定义的请求扩展处理</span></span><br><span class="line">        Stats stats,<span class="comment">//内存的状态</span></span><br><span class="line">        Bitmap.Config defaultBitmapConfig, <span class="comment">//Bitmap的解码配置</span></span><br><span class="line">        <span class="keyword">boolean</span> indicatorsEnabled, <span class="comment">//图片右上角是否显示指示器标识图片来源</span></span><br><span class="line">        <span class="keyword">boolean</span> loggingEnabled) &#123;<span class="comment">//是否打印日志</span></span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="keyword">int</span> builtInHandlers = <span class="number">7</span>; <span class="comment">//默认7个，可添加自定义扩展</span></span><br><span class="line">    <span class="comment">//allRequestHandlers的总数</span></span><br><span class="line">    <span class="keyword">int</span> extraCount = (extraRequestHandlers != <span class="keyword">null</span> ? extraRequestHandlers.size() : <span class="number">0</span>);</span><br><span class="line">    List&lt;RequestHandler&gt; allRequestHandlers = <span class="keyword">new</span> ArrayList&lt;&gt;(builtInHandlers + extraCount);</span><br><span class="line">    <span class="comment">//ResourceRequestHandler必须是列表中的第一个以避免强制其他RequestHandler对request.uri执行null检查涵盖（request.resourceId！= 0）的情况。 </span></span><br><span class="line">    allRequestHandlers.add(<span class="keyword">new</span> ResourceRequestHandler(context));</span><br><span class="line">    <span class="keyword">if</span> (extraRequestHandlers != <span class="keyword">null</span>) &#123;</span><br><span class="line">        allRequestHandlers.addAll(extraRequestHandlers);</span><br><span class="line">    &#125;</span><br><span class="line">    allRequestHandlers.add(<span class="keyword">new</span> ContactsPhotoRequestHandler(context));</span><br><span class="line">    allRequestHandlers.add(<span class="keyword">new</span> MediaStoreRequestHandler(context));</span><br><span class="line">    allRequestHandlers.add(<span class="keyword">new</span> ContentStreamRequestHandler(context));</span><br><span class="line">    allRequestHandlers.add(<span class="keyword">new</span> AssetRequestHandler(context));</span><br><span class="line">    allRequestHandlers.add(<span class="keyword">new</span> FileRequestHandler(context));</span><br><span class="line">    allRequestHandlers.add(<span class="keyword">new</span> NetworkRequestHandler(dispatcher.downloader, stats));</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们从 <code>Picasso</code> 的构造中可以看出 <code>RequestHandler</code> 都有哪些：</p>
<ul>
<li><code>ResourceRequestHandler</code> ：资源类型处理，<code>ResourceId</code> 类型的独有处理类；</li>
<li><code>ContactsPhotoRequestHandler</code> ：<code>ContactsPhoto</code> 请求处理器，加载<code>com.android.contacts/</code>下的图片。</li>
<li><code>MediaStoreRequestHandler</code> ：<code>MediaStore</code> 请求处理器，如果图片是存在<code>MediaStore</code>上的则用这个处理器处理。</li>
<li><code>ContentStreamRequestHandler</code> ：<code>content</code> 开头的类型，加载<code>ContentProvider</code> 提供的图片。</li>
<li><code>AssetRequestHandler</code> ：<code>file://android_asset/</code> 开头的类型，加载<code>asset</code>目录下的图片。</li>
<li><code>FileRequestHandler</code> ：<code>file</code> 开头的类型，处理文件类型的图片。</li>
<li><code>NetworkRequestHandler</code> ：<code>http</code> 或者 <code>https</code> 开头的类型，加载网络图片。</li>
</ul>
<p>可能一个数据类型有多个处理的 <code>RequestHandler</code> ，但从生成 <code>BitmapHunter</code> 的方法我们可以看出来最终由 <code>RequestHandler</code> 的添加顺序确定。</p>
<h2 id="BitmapHunter-run"><a href="#BitmapHunter-run" class="headerlink" title="BitmapHunter.run"></a>BitmapHunter.run</h2><p>执行请求任务，以及进行相应的异常捕获处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.squareup.picasso.BitmapHunter.java</span></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        updateThreadName(data);<span class="comment">//更新线程名称以方便与打印日志</span></span><br><span class="line">        <span class="keyword">if</span> (picasso.loggingEnabled) &#123;</span><br><span class="line">            log(OWNER_HUNTER, VERB_EXECUTING, getLogIdsForHunter(<span class="keyword">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        result = hunt();<span class="comment">//获取Bitmap</span></span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;<span class="comment">//处理失败回调</span></span><br><span class="line">            dispatcher.dispatchFailed(<span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//处理成功回调</span></span><br><span class="line">            dispatcher.dispatchComplete(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NetworkRequestHandler.ResponseException e) &#123;<span class="comment">//处理网络响应异常</span></span><br><span class="line">        <span class="keyword">if</span> (!NetworkPolicy.isOfflineOnly(e.networkPolicy) || e.code != <span class="number">504</span>) &#123;</span><br><span class="line">            exception = e;</span><br><span class="line">        &#125;</span><br><span class="line">        dispatcher.dispatchFailed(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;<span class="comment">//处理io异常</span></span><br><span class="line">        exception = e;</span><br><span class="line">        dispatcher.dispatchRetry(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError e) &#123;<span class="comment">//处理内存异常</span></span><br><span class="line">        StringWriter writer = <span class="keyword">new</span> StringWriter();</span><br><span class="line">        <span class="comment">//创建当前的内存数据快照，将其数据进行打印</span></span><br><span class="line">        stats.createSnapshot().dump(<span class="keyword">new</span> PrintWriter(writer));</span><br><span class="line">        exception = <span class="keyword">new</span> RuntimeException(writer.toString(), e);</span><br><span class="line">        dispatcher.dispatchFailed(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;<span class="comment">//处理其他异常</span></span><br><span class="line">        exception = e;</span><br><span class="line">        dispatcher.dispatchFailed(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;<span class="comment">//线程结束</span></span><br><span class="line">        Thread.currentThread().setName(Utils.THREAD_IDLE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Bitmap的获取"><a href="#Bitmap的获取" class="headerlink" title="Bitmap的获取"></a>Bitmap的获取</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.squareup.picasso.BitmapHunter.java</span></span><br><span class="line"><span class="function">Bitmap <span class="title">hunt</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Bitmap bitmap = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//是否允许从内存缓存中读取Bitmap</span></span><br><span class="line">    <span class="keyword">if</span> (shouldReadFromMemoryCache(memoryPolicy)) &#123;</span><br><span class="line">        bitmap = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;<span class="comment">//如果内存缓存有那么直接返回</span></span><br><span class="line">            stats.dispatchCacheHit();</span><br><span class="line">            loadedFrom = MEMORY;</span><br><span class="line">            <span class="keyword">if</span> (picasso.loggingEnabled) &#123;</span><br><span class="line">                log(OWNER_HUNTER, VERB_DECODED, data.logId(), <span class="string">"from cache"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> bitmap;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取对应的网络数据处理状态</span></span><br><span class="line">    networkPolicy = retryCount == <span class="number">0</span> ? NetworkPolicy.OFFLINE.index : networkPolicy;</span><br><span class="line">    <span class="comment">//对应的RequestHandler加载数据得到Result</span></span><br><span class="line">    RequestHandler.Result result = requestHandler.load(data, networkPolicy);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">        loadedFrom = result.getLoadedFrom();<span class="comment">//获取数据来源（内存、磁盘、文件）</span></span><br><span class="line">        exifOrientation = result.getExifOrientation();<span class="comment">//获取旋转角度</span></span><br><span class="line">        bitmap = result.getBitmap();<span class="comment">//获取Bitmap</span></span><br><span class="line">        <span class="comment">//如果没有位图，则需要从流中对其进行解码。</span></span><br><span class="line">        <span class="keyword">if</span> (bitmap == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Source source = result.getSource();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bitmap = decodeStream(source, data);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;<span class="comment">//关闭数据流</span></span><br><span class="line">                    source.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;<span class="comment">//Bitmap不为空</span></span><br><span class="line">        <span class="keyword">if</span> (picasso.loggingEnabled) &#123;</span><br><span class="line">            log(OWNER_HUNTER, VERB_DECODED, data.logId());</span><br><span class="line">        &#125;<span class="comment">//更新内存数据状态</span></span><br><span class="line">        stats.dispatchBitmapDecoded(bitmap);</span><br><span class="line">        <span class="comment">//如果Bitmap需要变换或者需要进行方向调整</span></span><br><span class="line">        <span class="keyword">if</span> (data.needsTransformation() || exifOrientation != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (DECODE_LOCK) &#123;</span><br><span class="line">                <span class="comment">//是否可以进行方向的调整</span></span><br><span class="line">                <span class="keyword">if</span> (data.needsMatrixTransform() || exifOrientation != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//Bitmap使用矩阵进行方向的变换</span></span><br><span class="line">                    bitmap = transformResult(data, bitmap, exifOrientation);</span><br><span class="line">                    <span class="keyword">if</span> (picasso.loggingEnabled) &#123;</span><br><span class="line">                        log(OWNER_HUNTER, VERB_TRANSFORMED, data.logId());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (data.hasCustomTransformations()) &#123;<span class="comment">//是否自定义了Bitmap的转换</span></span><br><span class="line">                    <span class="comment">//处理Bitmap的变换，如果Bitmap有的新的对象，那么之前的Bitmap必须主动回收</span></span><br><span class="line">                    bitmap = applyCustomTransformations(data.transformations, bitmap);</span><br><span class="line">                    <span class="keyword">if</span> (picasso.loggingEnabled) &#123;</span><br><span class="line">                        log(OWNER_HUNTER, VERB_TRANSFORMED, data.logId(), <span class="string">"from custom transformations"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;<span class="comment">//有了新的Bitmap产生，更新内存数据状态</span></span><br><span class="line">                stats.dispatchBitmapTransformed(bitmap);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bitmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里用一张网络图片举例说明怎么进行的数据获取：</p>
<p>我们根据 <code>Picasso</code> 中默认添加的  <code>RequestHandler</code>  了解到处理网络任务的 <code>NetworkRequestHandler</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.squareup.picasso.NetworkRequestHandler.java</span></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Result <span class="title">load</span><span class="params">(Request request, <span class="keyword">int</span> networkPolicy)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    okhttp3.Request downloaderRequest = createRequest(request, networkPolicy);</span><br><span class="line">    Response response = downloader.load(downloaderRequest);<span class="comment">//OKHTTP进行下载返回Response</span></span><br><span class="line">    ResponseBody body = response.body();<span class="comment">//获取Request的Body</span></span><br><span class="line">    <span class="keyword">if</span> (!response.isSuccessful()) &#123;<span class="comment">//如果接口失败那么跑出异常并关闭响应</span></span><br><span class="line">        body.close();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ResponseException(response.code(), request.networkPolicy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断响应的数据是否为http的缓存</span></span><br><span class="line">    Picasso.LoadedFrom loadedFrom = response.cacheResponse() == <span class="keyword">null</span> ? NETWORK : DISK;</span><br><span class="line">    <span class="comment">//判断http的缓存是否无效</span></span><br><span class="line">    <span class="keyword">if</span> (loadedFrom == DISK &amp;&amp; body.contentLength() == <span class="number">0</span>) &#123;</span><br><span class="line">        body.close();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ContentLengthException(<span class="string">"Received response with 0 content-length header."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有了新的数据产生，更新内存数据状态</span></span><br><span class="line">    <span class="keyword">if</span> (loadedFrom == NETWORK &amp;&amp; body.contentLength() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      stats.dispatchDownloadFinished(body.contentLength());</span><br><span class="line">    &#125;<span class="comment">//返回响应数据和数据来源</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Result(body.source(), loadedFrom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="磁盘缓存"><a href="#磁盘缓存" class="headerlink" title="磁盘缓存"></a>磁盘缓存</h1><p>从文章一开始的结构图和代码都没有体现<strong>磁盘缓存</strong> ，那么 <code>Picasso</code> 的 <strong>磁盘缓存</strong>怎么拥有的？为了回答这个问题我们先将上面的 <code>downloader.load</code> 来再次看一下，在一开始我们看到 <code>Picasso</code> 默认的 <code>downloader</code> 是 <code>OkHttp3Downloader</code> 。</p>
<blockquote>
<p><code>Downloader</code> ：一种从外部资源（例如磁盘缓存和网络）加载图像的机制。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Downloader</span> </span>&#123;</span><br><span class="line">  <span class="comment">//从互联网下载指定的图像。如果无法成功加载请求的URL，则抛出IOException。 </span></span><br><span class="line">  <span class="meta">@NonNull</span> <span class="function">Response <span class="title">load</span><span class="params">(@NonNull okhttp3.Request request)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">  <span class="comment">//允许对此进行清理，包括关闭磁盘缓存和其他资源</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们就发现一个很有意思的现象，<code>Downloader</code> 的接口包含了 <code>Okhtt3</code> 的 <code>Request</code> 。所以这就限定了 <code>Picasso</code> 的请求只能使用 <code>Okhttp3</code> （毕竟都是 <code>Square</code>  公司的当然使用自己产品）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OkHttp3Downloader</span> <span class="keyword">implements</span> <span class="title">Downloader</span> </span>&#123;</span><br><span class="line">    <span class="meta">@VisibleForTesting</span> <span class="keyword">final</span> Call.Factory client;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Cache cache;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> sharedClient = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//创建使用OkHttp的新下载器。这会将图像缓存安装到您的应用程序中缓存目录。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OkHttp3Downloader</span><span class="params">(<span class="keyword">final</span> Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(Utils.createDefaultCacheDir(context));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OkHttp3Downloader</span><span class="params">(<span class="keyword">final</span> File cacheDir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(cacheDir, Utils.calculateDiskCacheSize(cacheDir));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OkHttp3Downloader</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> <span class="keyword">long</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(Utils.createDefaultCacheDir(context), maxSize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OkHttp3Downloader</span><span class="params">(<span class="keyword">final</span> File cacheDir, <span class="keyword">final</span> <span class="keyword">long</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> OkHttpClient.Builder().cache(<span class="keyword">new</span> Cache(cacheDir, maxSize)).build());</span><br><span class="line">        sharedClient = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OkHttp3Downloader</span><span class="params">(OkHttpClient client)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">        <span class="keyword">this</span>.cache = client.cache();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OkHttp3Downloader</span><span class="params">(Call.Factory client)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">        <span class="keyword">this</span>.cache = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//同步执行</span></span><br><span class="line">    <span class="meta">@NonNull</span> <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">load</span><span class="params">(@NonNull Request request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> client.newCall(request).execute();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭缓存</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!sharedClient &amp;&amp; cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cache.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 <code>Downloader</code> 的实现我们可以看出来我们 <code>Picasso</code> 的磁盘缓存是利用的 <code>Http</code> 协议做的磁盘缓存。</p>
<h1 id="图片数据的呈现"><a href="#图片数据的呈现" class="headerlink" title="图片数据的呈现"></a>图片数据的呈现</h1><p>我们在将 <code>Bitmap</code> 获取的之后，下一步就应该展现在 <code>ImageView</code> 上。除此之前还应该处理内存缓存、成功失败等回调。</p>
<h2 id="内存缓存写入"><a href="#内存缓存写入" class="headerlink" title="内存缓存写入"></a>内存缓存写入</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.squareup.picasso.Dispatcher.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">performComplete</span><span class="params">(BitmapHunter hunter)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果允许写入内存缓存，那么将bitmap写入cache</span></span><br><span class="line">    <span class="keyword">if</span> (shouldWriteToMemoryCache(hunter.getMemoryPolicy())) &#123;</span><br><span class="line">        cache.set(hunter.getKey(), hunter.getResult());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移除key对应的BitmpHunter</span></span><br><span class="line">    hunterMap.remove(hunter.getKey());</span><br><span class="line">    batch(hunter);<span class="comment">//处理BitmapHunter</span></span><br><span class="line">    <span class="keyword">if</span> (hunter.getPicasso().loggingEnabled) &#123;</span><br><span class="line">        log(OWNER_DISPATCHER, VERB_BATCHED, getLogIdsForHunter(hunter), <span class="string">"for completion"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">batch</span><span class="params">(BitmapHunter hunter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hunter.isCancelled()) &#123;<span class="comment">//如果Bitmap捕捉任务已经被取消</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hunter.result != <span class="keyword">null</span>) &#123;<span class="comment">//重建所有与待画位图相关的缓存。</span></span><br><span class="line">        hunter.result.prepareToDraw();</span><br><span class="line">    &#125;</span><br><span class="line">    batch.add(hunter);<span class="comment">//将BitmapHunter添加都batch中进行批量的回调处理，500ms一批</span></span><br><span class="line">    <span class="keyword">if</span> (!handler.hasMessages(HUNTER_DELAY_NEXT_BATCH)) &#123;</span><br><span class="line">         handler.sendEmptyMessageDelayed(HUNTER_DELAY_NEXT_BATCH, BATCH_DELAY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>prepareToDraw</code> ：绘制准备：重建该<code>bitmap</code>相关联的缓存来绘制。在可清除的<code>bitmap</code>中，此方法会尝试确保像素已经被解码。</p>
</blockquote>
<h2 id="交付数据"><a href="#交付数据" class="headerlink" title="交付数据"></a>交付数据</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.squareup.picasso.Dispatcher.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">complete</span><span class="params">(BitmapHunter hunter)</span> </span>&#123;</span><br><span class="line">    Action single = hunter.getAction();<span class="comment">//获取BitmapHunter的Action</span></span><br><span class="line">    List&lt;Action&gt; joined = hunter.getActions();<span class="comment">//获取获取BitmapHunter的Actions</span></span><br><span class="line">    <span class="keyword">boolean</span> hasMultiple = joined != <span class="keyword">null</span> &amp;&amp; !joined.isEmpty();<span class="comment">//需要处理多个Action</span></span><br><span class="line">    <span class="keyword">boolean</span> shouldDeliver = single != <span class="keyword">null</span> || hasMultiple;<span class="comment">//是否有交付对象</span></span><br><span class="line">    <span class="keyword">if</span> (!shouldDeliver) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Uri uri = hunter.getData().uri;<span class="comment">//数据源的Uri</span></span><br><span class="line">    Exception exception = hunter.getException();<span class="comment">//数据加载过程中的异常</span></span><br><span class="line">    Bitmap result = hunter.getResult();<span class="comment">//数据对应Bitmap</span></span><br><span class="line">    LoadedFrom from = hunter.getLoadedFrom();<span class="comment">//数据来源</span></span><br><span class="line">    <span class="keyword">if</span> (single != <span class="keyword">null</span>) &#123;<span class="comment">//Action的数据交付</span></span><br><span class="line">      deliverAction(result, from, single, exception);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hasMultiple) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = joined.size(); i &lt; n; i++) &#123;</span><br><span class="line">            Action join = joined.get(i);<span class="comment">//Action的数据交付</span></span><br><span class="line">            deliverAction(result, from, join, exception);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如有有异常监听，并且有异常，那么进行回调</span></span><br><span class="line">    <span class="keyword">if</span> (listener != <span class="keyword">null</span> &amp;&amp; exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">        listener.onImageLoadFailed(<span class="keyword">this</span>, uri, exception);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//com.squareup.picasso.Picasso.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deliverAction</span><span class="params">(Bitmap result, LoadedFrom from, Action action, Exception e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (action.isCancelled()) &#123;<span class="comment">//请求已经被取消</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!action.willReplay()) &#123;<span class="comment">//是否需要等待监听网络状态重新加载</span></span><br><span class="line">        targetToAction.remove(action.getTarget());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (from == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"LoadedFrom cannot be null."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        action.complete(result, from);<span class="comment">//将Bitmap赋给View</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        action.error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//com.squareup.picasso.ImageViewAction.java</span></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">complete</span><span class="params">(Bitmap result, Picasso.LoadedFrom from)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(String.format(<span class="string">"Attempted to complete action with no result!\n%s"</span>, <span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    ImageView target = <span class="keyword">this</span>.target.get();</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Context context = picasso.context;</span><br><span class="line">    <span class="keyword">boolean</span> indicatorsEnabled = picasso.indicatorsEnabled;<span class="comment">//在target上显示Bitmap</span></span><br><span class="line">    PicassoDrawable.setBitmap(target, context, result, from, noFade, indicatorsEnabled);</span><br><span class="line">    <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        callback.onSuccess();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Picasso延迟加载"><a href="#Picasso延迟加载" class="headerlink" title="Picasso延迟加载"></a>Picasso延迟加载</h1><p>为什么需要<strong>延迟加载</strong>呢？因为我们在<code>View</code> 上进行图片加载的时候不确定 <code>View</code> 是否已经被绘制完确定了宽、高。只有确定宽高我们才能从数据中解码出响应大小的 <code>Bitmap</code> 。所以<strong>延迟加载</strong>只是为了等待 <code>View</code> 被绘制完。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeferredRequestCreator</span> <span class="keyword">implements</span> <span class="title">OnPreDrawListener</span>, <span class="title">OnAttachStateChangeListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RequestCreator creator;</span><br><span class="line">    <span class="meta">@VisibleForTesting</span> <span class="keyword">final</span> WeakReference&lt;ImageView&gt; target;</span><br><span class="line">    <span class="meta">@VisibleForTesting</span> Callback callback;</span><br><span class="line">    <span class="comment">/***部分代码被省略***/</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewAttachedToWindow</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        view.getViewTreeObserver().addOnPreDrawListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewDetachedFromWindow</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        view.getViewTreeObserver().removeOnPreDrawListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onPreDraw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ImageView target = <span class="keyword">this</span>.target.get();</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ViewTreeObserver vto = target.getViewTreeObserver();</span><br><span class="line">        <span class="keyword">if</span> (!vto.isAlive()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> width = target.getWidth();</span><br><span class="line">        <span class="keyword">int</span> height = target.getHeight();</span><br><span class="line">        <span class="keyword">if</span> (width &lt;= <span class="number">0</span> || height &lt;= <span class="number">0</span>) &#123;<span class="comment">//宽、高不合法继续监听</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="comment">//移除监听，取消请求延迟，设置size大小，重写请求</span></span><br><span class="line">        target.removeOnAttachStateChangeListener(<span class="keyword">this</span>);</span><br><span class="line">        vto.removeOnPreDrawListener(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.target.clear();</span><br><span class="line">        <span class="keyword">this</span>.creator.unfit().resize(width, height).into(target, callback);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        creator.clearTag();<span class="comment">//清除tag</span></span><br><span class="line">        callback = <span class="keyword">null</span>;</span><br><span class="line">        ImageView target = <span class="keyword">this</span>.target.get();</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.target.clear();<span class="comment">//清除引用</span></span><br><span class="line">        target.removeOnAttachStateChangeListener(<span class="keyword">this</span>);<span class="comment">//移除监听</span></span><br><span class="line">        ViewTreeObserver vto = target.getViewTreeObserver();</span><br><span class="line">        <span class="keyword">if</span> (vto.isAlive()) &#123;<span class="comment">//移除监听</span></span><br><span class="line">            vto.removeOnPreDrawListener(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***部分代码被省略***/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们通过监听 <code>View</code> 在 <code>Window</code> 上的状态变化，以及监听 <code>View</code> 绘制来进行宽高的获取。</p>
<h1 id="统计监控"><a href="#统计监控" class="headerlink" title="统计监控"></a>统计监控</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stats</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CACHE_HIT = <span class="number">0</span>;<span class="comment">//缓存命中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CACHE_MISS = <span class="number">1</span>;<span class="comment">//缓存没命中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BITMAP_DECODE_FINISHED = <span class="number">2</span>;<span class="comment">//图片解码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BITMAP_TRANSFORMED_FINISHED = <span class="number">3</span>;<span class="comment">//图片转码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DOWNLOAD_FINISHED = <span class="number">4</span>;<span class="comment">//数据下载完成</span></span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Picasso</code> 通过 <code>Stats</code> 监控了内存和使用情况包括内存命中率，内存占用大小，流量消耗等。在产生 <code>OutOfMemoryError</code> 的时候会对当前内存的使用做一份快照并进行日志输出。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>前面的 <a href="https://dandanlove.blog.csdn.net/article/details/103256724" target="_blank" rel="noopener">Android-Universal-Image-Loader源码分析</a> 和 <a href="https://dandanlove.blog.csdn.net/article/details/103564516" target="_blank" rel="noopener">Glide源码阅读理解一小时</a> 有过 <code>Glide</code> 和 <code>ImageLoader</code> 的对比，这次我们将 <code>Picasso</code> 与这两个图片加载库再次进行对比。</p>
<blockquote>
<p> <code>WEBP</code> ：在 <code>Android 4.0</code> <strong>(API level 14)</strong>中支持有损的<code>WebP</code>图像，在<code>Android 4.3</code><strong>(API level 18)</strong>和更高版本中支持无损和透明的 <code>WebP</code> 图像。</p>
</blockquote>
<center><br><img src="https://img-blog.csdnimg.cn/2019123017442183.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kYW5kYW5sb3ZlLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></center>

<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Picasso</tag>
      </tags>
  </entry>
  <entry>
    <title>Glide源码阅读理解一小时</title>
    <url>/2019/12/20/glide/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇<strong>图、文、表、代码</strong>一起组成的 <code>Glide</code> 源码分析的文章是在上一篇文章 <a href="https://dandanlove.blog.csdn.net/article/details/103256724" target="_blank" rel="noopener">Android-Universal-Image-Loader源码分析</a> 中之后的又一篇图片加载框架源码解析，它也具备了 <code>ImageLoader</code> 中讲述了<code>Android</code>一个图片加载库所需要的一些基础必备的：<code>MemoryCahce</code>、<code>DiskCahce</code> <code>Decoder</code> <code>DownLoader</code> 和<code>Executor</code> 等部分。这篇 <code>Glide</code>  的代码分析量可以说至少是 <code>ImageLoader</code> 的3倍多，本来想对 <code>Glide</code> 代码进行拆分，细化每个部分进行讲解这个每个部分讲的更加清楚一些。但最终还是打算整体一篇文章讲完，因为我觉得整体性的学习能更深的的了解到 <code>Glide</code> 的框架的设计之美。</p>
<blockquote>
<p>本篇文章讲述的<code>Glide</code> 相关知识比较多，阅读完需要大量的时间。所以我们按需分配，根据目录寻找自己需要的知识点进行查看。</p>
</blockquote>
<h1 id="Glide介绍"><a href="#Glide介绍" class="headerlink" title="Glide介绍"></a>Glide介绍</h1><p><a href="https://github.com/bumptech/glide" target="_blank" rel="noopener">Glide的Git地址：https://github.com/bumptech/glide</a></p>
<p><a href="https://muyangmin.github.io/glide-docs-cn/" target="_blank" rel="noopener">简体中文文档：https://muyangmin.github.io/glide-docs-cn/</a></p>
<p><a href="https://bumptech.github.io/glide/" target="_blank" rel="noopener">Glide’s documentation：https://bumptech.github.io/glide/</a></p>
<h2 id="关于Glide"><a href="#关于Glide" class="headerlink" title="关于Glide"></a>关于Glide</h2><p><code>Glide</code>是一个快速高效的<code>Android</code>图片加载库，注重于平滑的滚动。<code>Glide</code>提供了易用的<code>API</code>，高性能、可扩展的图片解码管道（<code>decode pipeline</code>），以及自动的资源池技术。</p>
<p><code>Glide</code> 支持拉取，解码和展示视频快照，图片，和GIF动画。<code>Glide</code>的Api是如此的灵活，开发者甚至可以插入和替换成自己喜爱的任何网络栈。默认情况下，<code>Glide</code>使用的是一个定制化的基于<code>HttpUrlConnection</code>的栈，但同时也提供了与<code>Google Volley</code>和<code>Square OkHttp</code>快速集成的工具库。</p>
<p>虽然<code>Glide</code> 的主要目标是让任何形式的图片列表的滚动尽可能地变得更快、更平滑，但实际上，<code>Glide</code>几乎能满足你对远程图片的拉取/缩放/显示的一切需求。</p>
<h2 id="Glide性能"><a href="#Glide性能" class="headerlink" title="Glide性能"></a>Glide性能</h2><p><code>Glide</code> 充分考虑了<code>Android</code>图片加载性能的两个关键方面：</p>
<ul>
<li>图片解码速度</li>
<li>解码图片带来的资源压力</li>
</ul>
<p>为了让用户拥有良好的App使用体验，图片不仅要快速加载，而且还不能因为过多的主线程I/O或频繁的垃圾回收导致页面的闪烁和抖动现象。</p>
<p><code>Glide</code>使用了多个步骤来确保在<code>Android</code>上加载图片尽可能的快速和平滑：</p>
<ul>
<li>自动、智能地下采样(<code>downsampling</code>)和缓存(<code>caching</code>)，以最小化存储开销和解码次数；</li>
<li>积极的资源重用，例如字节数组和<code>Bitmap</code>，以最小化昂贵的垃圾回收和堆碎片影响；</li>
<li>深度的生命周期集成，以确保仅优先处理活跃的<code>Fragment</code>和<code>Activity</code>的请求，并有利于应用在必要时释放资源以避免在后台时被杀掉。</li>
</ul>
<h2 id="GlideAPI"><a href="#GlideAPI" class="headerlink" title="GlideAPI"></a>GlideAPI</h2><p>Glide 使用简明的流式语法API，这是一个非常棒的设计，因为它允许你在大部分情况下一行代码搞定需求：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Glide.with(fragment)</span><br><span class="line">    .load(url)</span><br><span class="line">    .into(imageView);</span><br></pre></td></tr></table></figure>
<p>上述是<code>Fragmeng</code>中<code>Glide</code>将一张网络图片显示到<code>ImageView</code>的代码，下面源码分析的时候我们也会用这段代码进行分析，看看这么简单的<code>API</code>到底是怎么实现的。</p>
<h1 id="Glide源码分析"><a href="#Glide源码分析" class="headerlink" title="Glide源码分析"></a>Glide源码分析</h1><p>我们学习和了解一些框架主要不是看它某个功能的具体实现，主要是学习框架结构搭建和框架中模块的设计与实现。当然每个人的对每个框架的理解都各不相同，不过没关系我们可以多学习多总结，慢慢培养我们自己的框架结构意识。这个在我们平时开发过程中对我们帮助非常大。</p>
<center><img src="https://img-blog.csdnimg.cn/20191220185346375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kYW5kYW5sb3ZlLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></center>

<p>上图是对我<code>Glide</code>的一个总结。</p>
<h2 id="Glide接入"><a href="#Glide接入" class="headerlink" title="Glide接入"></a>Glide接入</h2><p><code>Glide</code>的用法网上有很多文章讲述的都非常好，这里不再进行讲述。这块主要想通过<code>Glide</code>的配置来分析<code>Glide</code>的运行机制。</p>
<p>我们在使用<code>Glide</code>的时候都会使用注解<code>@GlideModule</code> 实现<code>AppGlideModule</code> 或者 <code>GeneratedAppGlideModule</code> ，生成一个类名为<code>GeneratedAppGlideModuleImpl</code> 它是<code>Glide</code> 模块的代理。 在<code>GeneratedAppGlideModuleImpl</code> 会包含我们自定义的<code>GlideModel</code>。</p>
<p>下面为我们接入项目的<code>Glide</code>配置：</p>
<blockquote>
<p>实现Glide对缓存的配置</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GlideModule</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GlideModuleConfig</span> <span class="keyword">extends</span> <span class="title">AppGlideModule</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applyOptions</span><span class="params">(@NonNull Context context, @NonNull GlideBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.applyOptions(context, builder);</span><br><span class="line">        <span class="keyword">long</span> memoryCacheSizeBytes = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">20</span>;</span><br><span class="line">        builder.setMemoryCache(<span class="keyword">new</span> LruResourceCache(memoryCacheSizeBytes));</span><br><span class="line">        <span class="keyword">long</span> diskCacheSizeBytes = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>;</span><br><span class="line">        builder.setDiskCache(<span class="keyword">new</span> InternalCacheDiskCacheFactory(context, diskCacheSizeBytes));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>实现Okhttp的接入</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GlideModule</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OkHttpLibraryGlideModule</span> <span class="keyword">extends</span> <span class="title">LibraryGlideModule</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerComponents</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            @NonNull Context context, @NonNull Glide glide, @NonNull Registry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将GlideUrl数据转为InputStream的ModelLoader替换为Okhttp</span></span><br><span class="line">        registry.replace(GlideUrl.class, InputStream.class, <span class="keyword">new</span> OkHttpUrlLoader.Factory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们编译之后生成的<code>GeneratedAppGlideModuleImpl</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GeneratedAppGlideModuleImpl</span> <span class="keyword">extends</span> <span class="title">GeneratedAppGlideModule</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> GlideModuleConfig appGlideModule;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GeneratedAppGlideModuleImpl</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">      appGlideModule = <span class="keyword">new</span> GlideModuleConfig();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//GlideBuilder的配置项进行应用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applyOptions</span><span class="params">(@NonNull Context context, @NonNull GlideBuilder builder)</span> </span>&#123;</span><br><span class="line">      appGlideModule.applyOptions(context, builder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注册自定义GlideModule</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerComponents</span><span class="params">(@NonNull Context context, @NonNull Glide glide,</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull Registry registry)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">new</span> OkHttpLibraryGlideModule().registerComponents(context, glide, registry);</span><br><span class="line">      appGlideModule.registerComponents(context, glide, registry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面将<code>GeneratedAppGlideModuleImpl</code>的使用。</p>
<h2 id="Glide初始化"><a href="#Glide初始化" class="headerlink" title="Glide初始化"></a>Glide初始化</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Glide</span> <span class="keyword">implements</span> <span class="title">ComponentCallbacks2</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Get the singleton.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the singleton</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Glide <span class="title">get</span><span class="params">(@NonNull Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (glide == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            GeneratedAppGlideModule annotationGeneratedModule = </span><br><span class="line">                getAnnotationGeneratedGlideModules(context.getApplicationContext());</span><br><span class="line">            <span class="keyword">synchronized</span> (Glide.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (glide == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    checkAndInitializeGlide(context, annotationGeneratedModule);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> glide;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过Java反射机制获取通过注解生成的GeneratedAppGlideModuleImpl</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> GeneratedAppGlideModule <span class="title">getAnnotationGeneratedGlideModules</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        GeneratedAppGlideModule result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        Class&lt;GeneratedAppGlideModule&gt; clazz =</span><br><span class="line">            (Class&lt;GeneratedAppGlideModule&gt;)</span><br><span class="line">                Class.forName(<span class="string">"com.bumptech.glide.GeneratedAppGlideModuleImpl"</span>);</span><br><span class="line">        result =</span><br><span class="line">            clazz.getDeclaredConstructor(Context.class).newInstance(context.getApplicationContext());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        <span class="comment">/***部分代码省略**/</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Glide</code>是个单例，初始化的时候需要注解生成的<code>GeneratedAppGlideModuleImpl</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Glide</span> <span class="keyword">implements</span> <span class="title">ComponentCallbacks2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"Glide.class"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initializeGlide</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull Context context, @Nullable GeneratedAppGlideModule generatedAppGlideModule)</span> </span>&#123;</span><br><span class="line">        initializeGlide(context, <span class="keyword">new</span> GlideBuilder(), generatedAppGlideModule);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"Glide.class"</span>)</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initializeGlide</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull GlideBuilder builder,</span></span></span><br><span class="line"><span class="function"><span class="params">        @Nullable GeneratedAppGlideModule annotationGeneratedModule)</span> </span>&#123;</span><br><span class="line">        Context applicationContext = context.getApplicationContext();</span><br><span class="line">        List&lt;com.bumptech.glide.<span class="keyword">module</span>.GlideModule&gt; manifestModules = Collections.emptyList();</span><br><span class="line">        <span class="comment">//如果Manifest文件中配置了GlideModule，并且annotationGeneratedModule允许Manifest文件中配置生效，那么需要解析出来</span></span><br><span class="line">        <span class="keyword">if</span> (annotationGeneratedModule == <span class="keyword">null</span> || annotationGeneratedModule.isManifestParsingEnabled()) &#123;</span><br><span class="line">            manifestModules = <span class="keyword">new</span> ManifestParser(applicationContext).parse();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果annotationGeneratedModule配置了扩展模块需要解析出来，并且不能与果Manifest中的重复</span></span><br><span class="line">        <span class="keyword">if</span> (annotationGeneratedModule != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; !annotationGeneratedModule.getExcludedModuleClasses().isEmpty()) &#123;</span><br><span class="line">            Set&lt;Class&lt;?&gt;&gt; excludedModuleClasses = annotationGeneratedModule.getExcludedModuleClasses();</span><br><span class="line">            Iterator&lt;com.bumptech.glide.<span class="keyword">module</span>.GlideModule&gt; iterator = manifestModules.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                com.bumptech.glide.<span class="keyword">module</span>.GlideModule current = iterator.next();</span><br><span class="line">                <span class="keyword">if</span> (!excludedModuleClasses.contains(current.getClass())) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/***省略部分日志***/</span></span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/***省略部分日志***/</span></span><br><span class="line">        <span class="comment">//获取Request的构造管理工厂类</span></span><br><span class="line">        RequestManagerRetriever.RequestManagerFactory factory =</span><br><span class="line">            annotationGeneratedModule != <span class="keyword">null</span></span><br><span class="line">                ? annotationGeneratedModule.getRequestManagerFactory()</span><br><span class="line">                : <span class="keyword">null</span>;</span><br><span class="line">        builder.setRequestManagerFactory(factory);</span><br><span class="line">        <span class="comment">//Manifest中的配置项进行应用</span></span><br><span class="line">        <span class="keyword">for</span> (com.bumptech.glide.<span class="keyword">module</span>.GlideModule <span class="keyword">module</span> : manifestModules) &#123;</span><br><span class="line">            <span class="keyword">module</span>.applyOptions(applicationContext, builder);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//annotationGeneratedModule进行配置项的应用</span></span><br><span class="line">        <span class="keyword">if</span> (annotationGeneratedModule != <span class="keyword">null</span>) &#123;</span><br><span class="line">            annotationGeneratedModule.applyOptions(applicationContext, builder);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//构造Glide</span></span><br><span class="line">        Glide glide = builder.build(applicationContext);</span><br><span class="line">        <span class="comment">//Manifest中的组件进行注册</span></span><br><span class="line">        <span class="keyword">for</span> (com.bumptech.glide.<span class="keyword">module</span>.GlideModule <span class="keyword">module</span> : manifestModules) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">module</span>.registerComponents(applicationContext, glide, glide.registry);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (AbstractMethodError e) &#123;</span><br><span class="line">                <span class="comment">/***省略部分日志***/</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//annotationGeneratedModule中的组件进行注册</span></span><br><span class="line">        <span class="keyword">if</span> (annotationGeneratedModule != <span class="keyword">null</span>) &#123;</span><br><span class="line">            annotationGeneratedModule.registerComponents(applicationContext, glide, glide.registry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//application注册Glide组件</span></span><br><span class="line">        applicationContext.registerComponentCallbacks(glide);</span><br><span class="line">        Glide.glide = glide;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>获取<code>Manifest</code>的<code>GlideModule</code>，反射构造；</li>
<li>获取<code>GeneratedAppGlideModule</code>中扩展模块，如果包含<code>Manifest</code>的扩展那么进行删除；</li>
<li>获取<code>RequestManagerFactroy</code>;</li>
<li><code>Manifest.applyoptions</code>;</li>
<li><code>GeneratedAppGlideModule.applytions</code>;</li>
<li>构建<code>Glide</code>;</li>
<li><code>Manifest.registerComponents</code>;</li>
<li><code>GeneratedAppGlideModule.registerComponents</code>;</li>
</ol>
<h2 id="Glide和Engine构造"><a href="#Glide和Engine构造" class="headerlink" title="Glide和Engine构造"></a>Glide和Engine构造</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Glide</span> <span class="keyword">implements</span> <span class="title">ComponentCallbacks2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Engine engine;<span class="comment">//负责启动负载以及管理活动和缓存的资源。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BitmapPool bitmapPool;<span class="comment">//Bitmap的缓存池（LruBitmapPool）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MemoryCache memoryCache;<span class="comment">//Resource缓存池（LruResourceCache）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> GlideContext glideContext;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Registry registry;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayPool arrayPool;<span class="comment">//存储大小可变的数组的缓存池(LruArrayPool)</span></span><br><span class="line">    <span class="comment">//一组静态方法用来创建一个新的RequestManager或者从已经存在的activity和fragment中获取</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RequestManagerRetriever requestManagerRetriever;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConnectivityMonitorFactory connectivityMonitorFactory;</span><br><span class="line">    <span class="keyword">new</span> Glide(</span><br><span class="line">        <span class="meta">@NonNull</span> context,<span class="comment">//上下文环境</span></span><br><span class="line">        <span class="meta">@NonNull</span> engine,<span class="comment">//任务执行引擎</span></span><br><span class="line">        <span class="meta">@NonNull</span> memoryCache,<span class="comment">//内存资源缓存</span></span><br><span class="line">        <span class="meta">@NonNull</span> bitmapPool,<span class="comment">//内存Bitmap缓存</span></span><br><span class="line">        <span class="meta">@NonNull</span> arrayPool,<span class="comment">//数据缓存池</span></span><br><span class="line">        <span class="meta">@NonNull</span> requestManagerRetriever,<span class="comment">//RequestManager管理集合</span></span><br><span class="line">        <span class="meta">@NonNull</span> connectivityMonitorFactory,<span class="comment">//网络监听器的生产工厂</span></span><br><span class="line">        <span class="keyword">int</span> logLevel,<span class="comment">//log日志等级，默认为Log.info=4</span></span><br><span class="line">        <span class="meta">@NonNull</span> defaultRequestOptionsFactory,<span class="comment">//默认的RequestOptions生产工厂</span></span><br><span class="line">        <span class="meta">@NonNull</span> defaultTransitionOptions,<span class="comment">//默认的资源展现过渡配置容器，，默认map大小为0</span></span><br><span class="line">        <span class="meta">@NonNull</span> defaultRequestListeners,<span class="comment">//在图像加载时的监听器数组，默认数组大小为0</span></span><br><span class="line">        <span class="keyword">boolean</span> isLoggingRequestOriginsEnabled,<span class="comment">//是否需要请求日志</span></span><br><span class="line">        <span class="keyword">boolean</span> isImageDecoderEnabledForBitmaps,<span class="comment">//在安卓P或更高版本进行解码bitmap</span></span><br><span class="line">        <span class="keyword">int</span> hardwareBitmapFdLimit,<span class="comment">//700,</span></span><br><span class="line">        <span class="keyword">int</span> minHardwareDimension)&#123;<span class="comment">//128,</span></span><br><span class="line">        <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Glide</code>构造的时候需要构造<code>Engine</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Engine</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">EngineJobListener</span>,</span></span><br><span class="line"><span class="class">        <span class="title">MemoryCache</span>.<span class="title">ResourceRemovedListener</span>,</span></span><br><span class="line"><span class="class">        <span class="title">EngineResource</span>.<span class="title">ResourceListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Engine</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        MemoryCache memoryCache,//内存缓存</span></span></span><br><span class="line"><span class="function"><span class="params">        DiskCache.Factory diskCacheFactory,//磁盘缓存</span></span></span><br><span class="line"><span class="function"><span class="params">        //磁盘缓存执行器，该线程池的核心线程数和最大线程数为<span class="number">1</span></span></span></span><br><span class="line"><span class="function"><span class="params">        GlideExecutor diskCacheExecutor,</span></span></span><br><span class="line"><span class="function"><span class="params">        //检索资源尚未在缓存中，该线程池的核心线程数和最大线程数为cpu内核数量，最大为<span class="number">4</span></span></span></span><br><span class="line"><span class="function"><span class="params">        GlideExecutor sourceExecutor,</span></span></span><br><span class="line"><span class="function"><span class="params">        ////newScheduledThreadPool，核心线程数为<span class="number">0</span>，用来执行网络操作</span></span></span><br><span class="line"><span class="function"><span class="params">        GlideExecutor sourceUnlimitedExecutor,</span></span></span><br><span class="line"><span class="function"><span class="params">        //加载动画线程池，加载动画图像的帧时使用，尤其是GitDrawable，该线程池的核心线程数和最大线程数为<span class="number">1</span>或<span class="number">2</span>（cpu内核数量&gt;=<span class="number">4</span>）</span></span></span><br><span class="line"><span class="function"><span class="params">        GlideExecutor animationExecutor,</span></span></span><br><span class="line"><span class="function"><span class="params">        //活动资源是否允许被保留，默认为<span class="keyword">false</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> isActiveResourceRetentionAllowed)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在阅读源码的时候<code>Glide.java</code>的构造方法，除过基础的赋值操作之前就剩下大量的注册。注册的所有组件都由<code>Registry</code>进行管理。</p>
<h2 id="Register"><a href="#Register" class="headerlink" title="Register"></a>Register</h2><blockquote>
<p><code>Register</code> ：管理组件注册以扩展或替换<code>Glide</code>的默认加载，解码和编码逻辑。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Registry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BUCKET_GIF = <span class="string">"Gif"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BUCKET_BITMAP = <span class="string">"Bitmap"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BUCKET_BITMAP_DRAWABLE = <span class="string">"BitmapDrawable"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BUCKET_PREPEND_ALL = <span class="string">"legacy_prepend_all"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BUCKET_APPEND_ALL = <span class="string">"legacy_append"</span>;</span><br><span class="line">    <span class="comment">//维护&#123;@link ModelLoader&#125;的有序放置以及它们处理的模型和数据类型,从最高优先级到最低优先级的顺序。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ModelLoaderRegistry modelLoaderRegistry;</span><br><span class="line">    <span class="comment">//编码数据容器，有序列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EncoderRegistry encoderRegistry;</span><br><span class="line">    <span class="comment">//包含能够解码任意数据类型的&#123;@link ResourceDecoder&#125;的有序列表</span></span><br><span class="line">    <span class="comment">//分为从最高优先级解码器到最低优先级解码器的任意资源类型。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ResourceDecoderRegistry decoderRegistry;</span><br><span class="line">    <span class="comment">//包含能够编码任意资源*类型的&#123;@link ResourceEncoder&#125;的有序列表。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ResourceEncoderRegistry resourceEncoderRegistry;</span><br><span class="line">    <span class="comment">//DataRewinder的生产工厂</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DataRewinderRegistry dataRewinderRegistry;</span><br><span class="line">    <span class="comment">//注册和转化ResourceTranscoder</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TranscoderRegistry transcoderRegistry;</span><br><span class="line">    <span class="comment">//包含能够解析图像标题的&#123;@link ImageHeaderParser&#125;的无序列表。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ImageHeaderParserRegistry imageHeaderParserRegistry;</span><br><span class="line">    <span class="comment">//维护“模型+资源”类的高速缓存到一组已注册资源类的集合，这些资源类是可以从模型类中解码的资源类的子类。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ModelToResourceClassCache modelToResourceClassCache = <span class="keyword">new</span> ModelToResourceClassCache();</span><br><span class="line">    <span class="comment">//维护数据，资源和转码类的缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LoadPathCache loadPathCache = <span class="keyword">new</span> LoadPathCache();</span><br><span class="line">    <span class="comment">//异常列表维护容器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Pool&lt;List&lt;Throwable&gt;&gt; throwableListPool = FactoryPools.threadSafeList();</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我们看看<code>Glide</code>默认注册的各种组件。</p>
<h3 id="Encoder"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</h3><p><strong>Encoder</strong>：用于将数据编码成文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用于将数据写入某些持久性数据存储的接口，例如文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Encoder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//将给定数据写入给定输出流，如果写入完成，则返回True</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">encode</span><span class="params">(@NonNull T data, @NonNull File file, @NonNull Options options)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>EncoderRegistry</code> ：包含能够编码任意数据类型的<code>Encoder</code>的有序列表。</p>
</blockquote>
<table>
<thead>
<tr>
<th>DataClass</th>
<th>Encoder</th>
</tr>
</thead>
<tbody>
<tr>
<td>ByteBuffer</td>
<td>ByteBufferEncoder</td>
</tr>
<tr>
<td>InputStream</td>
<td>StreamEncoder</td>
</tr>
<tr>
<td>Bitmap</td>
<td>BitmapEncoder</td>
</tr>
<tr>
<td>BitmapDrawable</td>
<td>BitmapDrawableEncoder</td>
</tr>
<tr>
<td>GifDrawable</td>
<td>GifDrawableEncoder</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用于将数据从资源写入某些持久性数据存储的接口，例如文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResourceEncoder</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Encoder</span>&lt;<span class="title">Resource</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//获取对应的策略模式</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function">EncodeStrategy <span class="title">getEncodeStrategy</span><span class="params">(@NonNull Options options)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ResourceEncoder进行资源编码缓存枚举</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EncodeStrategy &#123;</span><br><span class="line">    <span class="comment">//将资源的原始未修改数据写入磁盘,不包括采样和转化</span></span><br><span class="line">    SOURCE,</span><br><span class="line">    <span class="comment">//将资源的解码，下采样和转换后的数据写入磁盘。</span></span><br><span class="line">    TRANSFORMED,</span><br><span class="line">    <span class="comment">/** Will write no data. */</span></span><br><span class="line">    NONE,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>ResourceEncoderRegistry</code> ：包含能够编码任意资源类型的<code>ResourceEncoder</code>的有序列表。</p>
</blockquote>
<table>
<thead>
<tr>
<th>ResourceClass</th>
<th>ResourceEncoder</th>
</tr>
</thead>
<tbody>
<tr>
<td>BitmapDrawable</td>
<td>BitmapDrawableEncoder</td>
</tr>
<tr>
<td>GifDrawable</td>
<td>GifDrawableEncoder</td>
</tr>
<tr>
<td>Bitmap</td>
<td>BitmapEncoder</td>
</tr>
</tbody>
</table>
<h3 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h3><p><strong>Decoder</strong>：解码给定的资源类型文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *用于解码资源的接口。</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@param</span> &lt;T&gt;将从中解码资源的类型（文件，InputStream等）。</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@param</span> &lt;Z&gt;解码资源的类型（位图，可绘制等）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResourceDecoder</span>&lt;<span class="title">T</span>, <span class="title">Z</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *如果此解码器能够使用给定的源解码给定的源，则返回true选项，否则为false。</span></span><br><span class="line"><span class="comment">     *解码器应尽最大努力快速确定是否可能够解码数据，但不应尝试完全读取给定的数据。</span></span><br><span class="line"><span class="comment">     *典型的实现将检查文件头，以确保它们与解码器期望的内容匹配句柄（即GIF解码器应验证图像是否包含GIF标头块)。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">handles</span><span class="params">(@NonNull T source, @NonNull Options options)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="comment">//从给定的数据返回已解码的资源；如果无法解码任何资源，则返回null。</span></span><br><span class="line">    <span class="comment">//注意width和height参数仅是提示，没有要求解码后的资源与给定尺寸完全匹配。</span></span><br><span class="line">    <span class="comment">//一个典型的用例将使用目标尺寸来确定对位图进行降采样的量，以避免分配过多。</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">Resource&lt;Z&gt; <span class="title">decode</span><span class="params">(@NonNull T source, <span class="keyword">int</span> width, <span class="keyword">int</span> height, @NonNull Options options)</span><span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>ResourceDecoderRegistry</code> ：包含<code>ResourceDecoder</code>的有序列表，这些列表可以将任意数据类型解码为从最高优先级解码器到最低优先级解码器的任意资源类型。</p>
</blockquote>
<table>
<thead>
<tr>
<th>Bucket</th>
<th>DataClass</th>
<th>ResourceClass</th>
<th>ResourceDecoder</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bitmap</td>
<td>ByteBuffer</td>
<td>Bitmap</td>
<td>ByteBufferBitmapImageDecoderResourceDecoder</td>
</tr>
<tr>
<td>Bitmap</td>
<td>InputStream</td>
<td>Bitmap</td>
<td>InputStreamBitmapImageDecoderResourceDecoder</td>
</tr>
<tr>
<td>Bitmap</td>
<td>ParcelFileDescriptor</td>
<td>Bitmap</td>
<td>VideoDecoder</td>
</tr>
<tr>
<td>Bitmap</td>
<td>AssetFileDescriptor</td>
<td>Bitmap</td>
<td>VideoDecoder</td>
</tr>
<tr>
<td>Bitmap</td>
<td>Bitmap</td>
<td>Bitmap</td>
<td>UnitBitmapDecoder</td>
</tr>
<tr>
<td>Bitmap</td>
<td>GifDecoder</td>
<td>Bitmap</td>
<td>GifFrameResourceDecoder</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Bucket</th>
<th>DataClass</th>
<th>ResourceClass</th>
<th>ResourceDecoder</th>
</tr>
</thead>
<tbody>
<tr>
<td>BitmapDrawables</td>
<td>ByteBuffer</td>
<td>BitemapDrawable</td>
<td>BitmapDrawableDecoder</td>
</tr>
<tr>
<td>BitmapDrawables</td>
<td>InputStream</td>
<td>BitemapDrawable</td>
<td>BitmapDrawableDecoder</td>
</tr>
<tr>
<td>BitmapDrawables</td>
<td>ParcelFileDescriptor</td>
<td>BitemapDrawable</td>
<td>BitmapDrawableDecoder</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Bucket</th>
<th>DataClass</th>
<th>ResourceClass</th>
<th>ResourceDecoder</th>
</tr>
</thead>
<tbody>
<tr>
<td>Gif</td>
<td>ByteBuffer</td>
<td>GifDrawable</td>
<td>ByteBufferGifDecoder</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Bucket</th>
<th>DataClass</th>
<th>ResourceClass</th>
<th>ResourceDecoder</th>
</tr>
</thead>
<tbody>
<tr>
<td>All</td>
<td>Uri</td>
<td>Drawable</td>
<td>ResourceDrawableDecoder</td>
</tr>
<tr>
<td>All</td>
<td>Uri</td>
<td>Bitmap</td>
<td>ResourceBitmapDecoder</td>
</tr>
<tr>
<td>All</td>
<td>File</td>
<td>File</td>
<td>FileDecoder</td>
</tr>
<tr>
<td>All</td>
<td>Drawable</td>
<td>Drawable</td>
<td>UnitDrawableDecoder</td>
</tr>
</tbody>
</table>
<h3 id="Transcoder"><a href="#Transcoder" class="headerlink" title="Transcoder"></a>Transcoder</h3><p><strong>Transcoder</strong>：将一种类型的资源转码为另一种类型的资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将一种类型的资源转码为另一种类型的资源。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;Z&gt; 要被转码的资源类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;R&gt; 需要转成的资源类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResourceTranscoder</span>&lt;<span class="title">Z</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//将给定资源转码为新资源类型并返回新资源。</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">Resource&lt;R&gt; <span class="title">transcode</span><span class="params">(@NonNull Resource&lt;Z&gt; toTranscode, @NonNull Options options)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>TranscoderRegistry</code> ：该类允许<code>ResourceTranscoder</code>在它们之间进行转换的类中进行注册和检索。</p>
</blockquote>
<table>
<thead>
<tr>
<th>ResourceClass</th>
<th>TranscoeClass</th>
<th>ResourceTranscoder</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bitmap</td>
<td>BitmapDrawable</td>
<td>BitmapDrawableTranscoder</td>
</tr>
<tr>
<td>Bitmap</td>
<td>byte[]</td>
<td>BitmapBytesTranscoder</td>
</tr>
<tr>
<td>Drawable</td>
<td>byte[]</td>
<td>DrawableBytesTranscoder</td>
</tr>
<tr>
<td>GifDrawable</td>
<td>byte[]</td>
<td>GifDrawableBytesTranscoder</td>
</tr>
</tbody>
</table>
<h3 id="ModelLoader"><a href="#ModelLoader" class="headerlink" title="ModelLoader"></a>ModelLoader</h3><p><code>ModelLoader</code> 是<code>Glide</code> 比较核心的类，主要是用来加载数据源<code>Model</code> 中的数据。</p>
<p>一般加载资源类型有<code>Bitmap</code> 、<code>String(网络图片、本地图片、资源图片)</code> 、<code>Uri(网络图片、本地图片、资源图片)</code> 、<code>URL(网络图片)</code> 、<code>Integer(资源图片)</code> 和<code>File(本地文件)</code>等。</p>
<p><code>Glide</code> 为每中资源类型设计了对应的<code>ModelLoaderFactory</code> ，每种<code>ModelLoaderFactory</code>对应一种<code>ModleLoader</code>。</p>
<p>资源类型可以相互转化，比如<code>String</code>转<code>URL</code>。所以<code>ModelLoader</code> 内部也是可以相互进行代理。</p>
<center><img src="https://img-blog.csdnimg.cn/20191220185627504.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kYW5kYW5sb3ZlLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></center>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.bumptech.glide.load.model.MultiModelLoaderFactory</span></span><br><span class="line"><span class="comment">//通过仅在以下位置创建加载器来避免堆栈溢出递归地创建模型加载器</span></span><br><span class="line"><span class="comment">//递归请求（如果尚未在链中的早期创建）。例如：Uri加载程序可以转换为另一个模型，而后者又可以转换回Uri。</span></span><br><span class="line"><span class="comment">//尽管原始Uri加载程序不会提供给中间模型加载程序，其他的Uri装载程序也会。</span></span><br><span class="line"><span class="keyword">synchronized</span> &lt;Model&gt; List&lt;ModelLoader&lt;Model, ?&gt;&gt; build(<span class="meta">@NonNull</span> Class&lt;Model&gt; modelClass) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        List&lt;ModelLoader&lt;Model, ?&gt;&gt; loaders = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;?, ?&gt; entry : entries) &#123;</span><br><span class="line">            <span class="keyword">if</span> (alreadyUsedEntries.contains(entry)) &#123;<span class="comment">//去重</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (entry.handles(modelClass)) &#123;</span><br><span class="line">                alreadyUsedEntries.add(entry);</span><br><span class="line">                <span class="comment">//递归调用MultiModelLoaderFactory.build</span></span><br><span class="line">                loaders.add(<span class="keyword">this</span>.&lt;Model, Object&gt;build(entry));</span><br><span class="line">                alreadyUsedEntries.remove(entry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> loaders;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        alreadyUsedEntries.clear();</span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用ModelLoaderFactory.build</span></span><br><span class="line"><span class="keyword">private</span> &lt;Model, Data&gt; <span class="function">ModelLoader&lt;Model, Data&gt; <span class="title">build</span><span class="params">(@NonNull Entry&lt;?, ?&gt; entry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (ModelLoader&lt;Model, Data&gt;) Preconditions.checkNotNull(entry.factory.build(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如<code>ModelClass</code> 是 <code>String</code> 类型，我们遍历找到 <code>StreamFactory</code> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamFactory</span> <span class="keyword">implements</span> <span class="title">ModelLoaderFactory</span>&lt;<span class="title">String</span>, <span class="title">InputStream</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelLoader&lt;String, InputStream&gt; <span class="title">build</span><span class="params">(@NonNull MultiModelLoaderFactory multiFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringLoader&lt;&gt;(multiFactory.build(Uri.class, InputStream.class));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">teardown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Do nothing.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候有会进行一次递归：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.bumptech.glide.load.model.MultiModelLoaderFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> &lt;Model, Data&gt; <span class="function">ModelLoader&lt;Model, Data&gt; <span class="title">build</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      @NonNull Class&lt;Model&gt; modelClass, @NonNull Class&lt;Data&gt; dataClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        List&lt;ModelLoader&lt;Model, Data&gt;&gt; loaders = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span> ignoredAnyEntries = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;?, ?&gt; entry : entries) &#123;</span><br><span class="line">            <span class="keyword">if</span> (alreadyUsedEntries.contains(entry)) &#123;<span class="comment">//去重</span></span><br><span class="line">                ignoredAnyEntries = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (entry.handles(modelClass, dataClass)) &#123;</span><br><span class="line">                alreadyUsedEntries.add(entry);</span><br><span class="line">                <span class="comment">//递归调用MultiModelLoaderFactory.build</span></span><br><span class="line">                loaders.add(<span class="keyword">this</span>.&lt;Model, Data&gt;build(entry));</span><br><span class="line">                alreadyUsedEntries.remove(entry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (loaders.size() &gt; <span class="number">1</span>) &#123;<span class="comment">//数量大于1的时候构建MultiModelLoader存储loaders</span></span><br><span class="line">            <span class="keyword">return</span> factory.build(loaders, throwableListPool);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (loaders.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> loaders.get(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果递归导致没有可用的加载程序，请避免崩溃。该断言应该捕获完全未处理的类型，递归可能意味着未在某处处理子类型进入堆栈，这通常是可以的。 </span></span><br><span class="line">            <span class="keyword">if</span> (ignoredAnyEntries) &#123;</span><br><span class="line">                <span class="keyword">return</span> emptyModelLoader();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoModelLoaderAvailableException(modelClass, dataClass);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        alreadyUsedEntries.clear();</span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以我们根据<code>Model</code>的类型从注册到<code>Glide</code>的<code>ModelLoaderFactory</code>中寻找匹配项，这个查找是按照添加的顺序进行遍历。找到对应的<code>ModelLoaderFactory</code> 在生成 <code>ModelLoader</code>的时候可能会继续寻找它的代理的<code>ModelLoader</code>，直到不需要代理为止，我们会对这个结果<strong>去重</strong>然后如果结果数量大于<strong>1</strong>那么会生成<code>MultiModelLoader</code> 存储这一组 <code>ModelLoader</code> 。如果这组中的 <code>ModelLoader</code> 中还包括 <code>MultiModelLoader</code> 那么这个 <code>MultiModelLoader</code> 内还会有一组 <code>ModelLoader</code> 。</p>
<p>下面为<strong>ModelLoader</strong>涉及到的类:</p>
<blockquote>
<p><code>DataSource</code> ：表示某些检索到的数据的来源。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> DataSource &#123;</span><br><span class="line">    <span class="comment">//表示数据可能是从设备本地检索的，尽管可能已经是通过可能已从远程源获取数据的内容提供者获得的。</span></span><br><span class="line">    LOCAL,</span><br><span class="line">    <span class="comment">//表示从设备以外的远程源检索到数据。</span></span><br><span class="line">    REMOTE,</span><br><span class="line">    <span class="comment">//表示从设备缓存中检索的数据未经修改。</span></span><br><span class="line">    DATA_DISK_CACHE,</span><br><span class="line">    <span class="comment">//表示数据是从设备上缓存中的已修改内容中检索到的。</span></span><br><span class="line">    RESOURCE_DISK_CACHE,</span><br><span class="line">    <span class="comment">//表示已从内存缓存中检索数据。</span></span><br><span class="line">    MEMORY_CACHE,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>DataFetcher</code> ：加载资源的数据。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒惰地检索可用于加载资源的数据。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; 要加载的数据类型  (InputStream, byte[], File etc).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DataFetcher</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//获取可以从中解码资源的数据。</span></span><br><span class="line">    <span class="comment">//没有数据的时候调用，异步线程执行，io不会阻塞</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">loadData</span><span class="params">(@NonNull Priority priority, @NonNull DataCallback&lt;? <span class="keyword">super</span> T&gt; callback)</span></span>;</span><br><span class="line">    <span class="comment">//清理或回收此数据获取器使用的任何资源。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//取消任务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//返回此访存器将尝试获取的数据的类。</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function">Class&lt;T&gt; <span class="title">getDataClass</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//返回要处理的资源数据类型</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function">DataSource <span class="title">getDataSource</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>ModelLoaderFactory</code> ：用于为给定模型类型创建<code>ModelLoader</code>的接口。使用设计模式之工厂模式，让每一个<code>ModelLoader</code> 对应一个工厂。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ModelLoaderFactory</span>&lt;<span class="title">T</span>, <span class="title">Y</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//为此模型类型构建一个具体的ModelLoader。</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function">ModelLoader&lt;T, Y&gt; <span class="title">build</span><span class="params">(@NonNull MultiModelLoaderFactory multiFactory)</span></span>;</span><br><span class="line">    <span class="comment">//一种生命周期方法，该工厂即将被替换时将被调用。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">teardown</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>ModelLoader</code> ：用于将任意复杂的数据模型转换为具体的数据类型。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *工厂接口，用于将任意复杂的数据模型转换为具体的数据类型,DataFetcher可以使用来获取由模型。</span></span><br><span class="line"><span class="comment"> *此接口有两个目标：</span></span><br><span class="line"><span class="comment"> *1.将特定模型转换为可以被解码为资源。</span></span><br><span class="line"><span class="comment"> *2.允许将模型与视图的尺寸组合以获取模型的资源具体尺寸。</span></span><br><span class="line"><span class="comment"> *这不仅避免了必须在xml和代码中重复尺寸，以便确定具有不同密度的设备上视图的大小，</span></span><br><span class="line"><span class="comment"> *但也允许您使用布局权重或通过编程方式放置视图的尺寸而不会强迫您获取通用资源大小。</span></span><br><span class="line"><span class="comment"> *您获取的资源越小，使用的带宽和电池寿命越少，并且越低每个资源的内存占用量。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@param</span> &lt;Model&gt; 模型的类型。</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@param</span> &lt;Data&gt; 可以使用的数据类型ResourceDecoder来解码资源。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ModelLoader</span>&lt;<span class="title">Model</span>, <span class="title">Data</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//返回可以解码model的LoadData来进行资源解码</span></span><br><span class="line">    <span class="comment">//注意-如果无法返回有效的数据提取程序（例如，如果模型的URL为空），然后可以从此方法返回空数据获取程序。</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">LoadData&lt;Data&gt; <span class="title">buildLoadData</span><span class="params">(@NonNull Model model, <span class="keyword">int</span> width, <span class="keyword">int</span> height, @NonNull Options options)</span></span>;</span><br><span class="line">    <span class="comment">//当前的数据模型是否能被处理</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">handles</span><span class="params">(@NonNull Model model)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>LoadData</code> ：加载的资源的<code>Key</code>和对应加载该资源的<code>DataFetcher</code> 的包装对象。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//包含一组标识负载源的keys，指向等效数据的备用缓存键以及DataFetcher，可用于获取在缓存中找不到的数据。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoadData</span>&lt;<span class="title">Data</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> Key sourceKey;<span class="comment">//数据源标识</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> List&lt;Key&gt; alternateKeys;<span class="comment">//备用的标识</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> DataFetcher&lt;Data&gt; fetcher;<span class="comment">//可用于加载资源的数据</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LoadData</span><span class="params">(@NonNull Key sourceKey, @NonNull DataFetcher&lt;Data&gt; fetcher)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(sourceKey, Collections.&lt;Key&gt;emptyList(), fetcher);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LoadData</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    @NonNull Key sourceKey,</span></span></span><br><span class="line"><span class="function"><span class="params">    @NonNull List&lt;Key&gt; alternateKeys,</span></span></span><br><span class="line"><span class="function"><span class="params">    @NonNull DataFetcher&lt;Data&gt; fetcher)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sourceKey = Preconditions.checkNotNull(sourceKey);</span><br><span class="line">    <span class="keyword">this</span>.alternateKeys = Preconditions.checkNotNull(alternateKeys);</span><br><span class="line">    <span class="keyword">this</span>.fetcher = Preconditions.checkNotNull(fetcher);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>ModelLoaderRegistry</code> ：维护<code>ModelLoader</code>的有序放置以及它们处理的模型和数据类型,从最高优先级到最低优先级的顺序。</p>
</blockquote>
<table>
<thead>
<tr>
<th>ModelClass</th>
<th>DataClass</th>
<th>ModelLoaderFactory</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bitmap</td>
<td>Bitmap</td>
<td>UnitModelLoader.Factory</td>
</tr>
<tr>
<td>GifDecoder</td>
<td>GifDecoder</td>
<td>UnitModelLoader.Factory</td>
</tr>
<tr>
<td>File</td>
<td>ByteBuffer</td>
<td>ByteBufferFileLoader.Factory</td>
</tr>
<tr>
<td>File</td>
<td>InputStream</td>
<td>FileLoader.StreamFactory</td>
</tr>
<tr>
<td>File</td>
<td>ParcelFileDescriptor</td>
<td>FileLoader.FileDescriptorFactory</td>
</tr>
<tr>
<td>File</td>
<td>File</td>
<td>UnitModelLoader.Factory</td>
</tr>
<tr>
<td>int</td>
<td>InputStream</td>
<td>ResourceLoader.StreamFactory</td>
</tr>
<tr>
<td>int</td>
<td>ParcelFileDescriptor</td>
<td>ResourceLoader.FileDescriptorFactory</td>
</tr>
<tr>
<td>int</td>
<td>Uri</td>
<td>ResourceLoader.UriFactory</td>
</tr>
<tr>
<td>int</td>
<td>AssetFileDescriptor</td>
<td>ResourceLoader.AssetFileDescriptorFactory</td>
</tr>
<tr>
<td>Integer</td>
<td>InputStream</td>
<td>ResourceLoader.StreamFactory</td>
</tr>
<tr>
<td>Integer</td>
<td>ParcelFileDescriptor</td>
<td>ResourceLoader.FileDescriptorFactory</td>
</tr>
<tr>
<td>Integer</td>
<td>Uri</td>
<td>ResourceLoader.UriFactory</td>
</tr>
<tr>
<td>Integer</td>
<td>AssetFileDescriptor</td>
<td>ResourceLoader.AssetFileDescriptorFactory</td>
</tr>
<tr>
<td>String</td>
<td>InputStream</td>
<td>DataUrlLoader.StreamFactory</td>
</tr>
<tr>
<td>String</td>
<td>InputStream</td>
<td>StringLoader.StreamFactory</td>
</tr>
<tr>
<td>String</td>
<td>ParcelFileDescriptor</td>
<td>StringLoader.FileDescriptorFactory</td>
</tr>
<tr>
<td>String</td>
<td>AssetFileDescriptor</td>
<td>StringLoader.AssetFileDescriptorFactory</td>
</tr>
<tr>
<td>Uri</td>
<td>InputStream</td>
<td>DataUrlLoader.StreamFactory</td>
</tr>
<tr>
<td>Uri</td>
<td>InputStream</td>
<td>HttpUriLoader.Factory()</td>
</tr>
<tr>
<td>Uri</td>
<td>InputStream</td>
<td>AssetUriLoader.StreamFactory</td>
</tr>
<tr>
<td>Uri</td>
<td>InputStream</td>
<td>MediaStoreImageThumbLoader.Factory</td>
</tr>
<tr>
<td>Uri</td>
<td>InputStream</td>
<td>MediaStoreVideoThumbLoader.Factory</td>
</tr>
<tr>
<td>Uri</td>
<td>InputStream</td>
<td>UriLoader.StreamFactory</td>
</tr>
<tr>
<td>Uri</td>
<td>InputStream</td>
<td>UrlUriLoader.StreamFactory</td>
</tr>
<tr>
<td>Uri</td>
<td>ParcelFileDescriptor</td>
<td>AssetUriLoader.FileDescriptorFactory</td>
</tr>
<tr>
<td>Uri</td>
<td>ParcelFileDescriptor</td>
<td>UriLoader.FileDescriptorFactory</td>
</tr>
<tr>
<td>Uri</td>
<td>AssetFileDescriptor</td>
<td>UriLoader.AssetFileDescriptorFactory</td>
</tr>
<tr>
<td>Uri</td>
<td>File</td>
<td>MediaStoreFileLoader.Factory</td>
</tr>
<tr>
<td>Uri</td>
<td>Uri</td>
<td>UnitModelLoader.Factory</td>
</tr>
<tr>
<td>URL</td>
<td>InputStream</td>
<td>UrlLoader.StreamFactory</td>
</tr>
<tr>
<td>GlideUrl</td>
<td>InputStream</td>
<td>HttpGlideUrlLoader.Factory</td>
</tr>
<tr>
<td>byte[]</td>
<td>InputStream</td>
<td>ByteArrayLoader.StreamFactory</td>
</tr>
<tr>
<td>byte[]</td>
<td>ByteBuffer</td>
<td>ByteArrayLoader.ByteBufferFactory</td>
</tr>
<tr>
<td>Drawable</td>
<td>Drawable</td>
<td>UnitModelLoader.Factory</td>
</tr>
</tbody>
</table>
<p>我们现在就用 <code>String</code> 类型的网络图片地址的 <code>Model</code> 来看一下：</p>
<p>寻找处理 <code>String</code> 的 <code>ModelLoader</code> :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DataUrlLoader.StreamFactory.build=DataUrlLoader</span><br><span class="line">  </span><br><span class="line">StringLoader.StreamFactory.build</span><br><span class="line">  =MultiModelLoaderFactory(Uri.class, InputStream.class)=MultiModelLoader</span><br><span class="line">  ==&gt;DataUrlLoader.StreamFactory=DataUrlLoader</span><br><span class="line">  ==&gt;HttpUriLoader.Factory=HttpUriLoader</span><br><span class="line">  ==&gt;==&gt;MultiModelLoaderFactory(Uri.class, ParcelFileDescriptor.class)</span><br><span class="line">  ==&gt;==&gt;==&gt;AssetUriLoader.FileDescriptorFactory=AssetUriLoader</span><br><span class="line">  ==&gt;==&gt;==&gt;UriLoader.FileDescriptorFactory=AssetUriLoader</span><br><span class="line">  ==&gt;==&gt;==&gt;AssetUriLoader(去重)</span><br><span class="line">  ==&gt;AssetUriLoader.StreamFactory=AssetUriLoader</span><br><span class="line">  ==&gt;MediaStoreImageThumbLoader.Factory=MediaStoreImageThumbLoader</span><br><span class="line">  ==&gt;MediaStoreVideoThumbLoader.Factory=MediaStoreVideoThumbLoader</span><br><span class="line">  ==&gt;UriLoader.StreamFactory=AssetUriLoader</span><br><span class="line">  ==&gt;UrlUriLoader.StreamFactory</span><br><span class="line">  ==&gt;==&gt;MultiModelLoaderFactory(GlideUrl.class, InputStream.class)</span><br><span class="line">  ==&gt;==&gt;==&gt;HttpGlideUrlLoader.Factory=HttpGlideUrlLoader</span><br><span class="line">  </span><br><span class="line">StringLoader.FileDescriptorFactory.build</span><br><span class="line">  =MultiModelLoaderFactory(Uri.class, ParcelFileDescriptor.class)=MultiModelLoader</span><br><span class="line">  ==&gt;AssetUriLoader.FileDescriptorFactory=AssetUriLoader</span><br><span class="line">  ==&gt;UriLoader.FileDescriptorFactory=UriLoader</span><br><span class="line">  </span><br><span class="line">StringLoader.AssetFileDescriptorFactory.build</span><br><span class="line">  =MultiModelLoaderFactory(Uri.class, AssetFileDescriptor.class)</span><br><span class="line">  =UriLoader.AssetFileDescriptorFactory=UriLoader</span><br></pre></td></tr></table></figure>
<center><img src="https://img-blog.csdnimg.cn/20191220185656297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kYW5kYW5sb3ZlLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></center>

<p>接下来对这一组 <code>ModelLoader</code> 进行处理，过滤掉无法处理 <code>Model</code> 数据的 <code>ModelLoader</code> 。其中 <code>MultiModelLoader</code> 中只要有一个 <code>ModelLoader</code> 能处理 <code>Model</code> 数据， 那么这个 <code>MultiModelLoader</code> 就可以不被过滤。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringLoader.StreamFactory=MultiModelLoader[<span class="number">7</span>]</span><br><span class="line">StringLoader.FileDescriptorFactory=MultiModelLoader[<span class="number">2</span>]</span><br><span class="line">StringLoader.AssetFileDescriptorFactory=UriLoader</span><br></pre></td></tr></table></figure>
<center><img src="https://img-blog.csdnimg.cn/20191220185718404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kYW5kYW5sb3ZlLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></center>

<h3 id="Transformation"><a href="#Transformation" class="headerlink" title="Transformation"></a>Transformation</h3><p><a href="https://muyangmin.github.io/glide-docs-cn/doc/transformations.html" target="_blank" rel="noopener">Glid-Transformation文档：https://muyangmin.github.io/glide-docs-cn/doc/transformations.html</a></p>
<p><strong>Transformation</strong>：用于在实现资源上执行任意转换的类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//唯一标识某些数据放置的接口。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Key</span> </span>&#123;</span><br><span class="line">    String STRING_CHARSET_NAME = <span class="string">"UTF-8"</span>;</span><br><span class="line">    Charset CHARSET = Charset.forName(STRING_CHARSET_NAME);</span><br><span class="line">    <span class="comment">//将所有唯一标识信息添加到给定的摘要中。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateDiskCacheKey</span><span class="params">(@NonNull MessageDigest messageDigest)</span></span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用于在实现资源上执行任意转换的类</span></span><br><span class="line"><span class="comment">//equals和hashCode来标识内存缓存中的转换</span></span><br><span class="line"><span class="comment">//updateDiskCacheKey来标识磁盘中的转换缓存。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Transformation</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Key</span> </span>&#123;</span><br><span class="line">    <span class="comment">//转换给定资源并返回转换后的资源</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function">Resource&lt;T&gt; <span class="title">transform</span><span class="params">(@NonNull Context context, @NonNull Resource&lt;T&gt; resource, <span class="keyword">int</span> outWidth, <span class="keyword">int</span> outHeight)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DataRewinder"><a href="#DataRewinder" class="headerlink" title="DataRewinder"></a>DataRewinder</h3><p><strong>DataRewinder</strong>：对数据的游标进行重置，也就是所谓的倒带。</p>
<p>这个逻辑在上一篇文章 <a href="https://dandanlove.blog.csdn.net/article/details/103256724" target="_blank" rel="noopener">Android-Universal-Image-Loader源码分析</a> 中也有讲到过，我们拿到数据流之后可能会从它的头部信息中获取一些图片本身的参数，然后我们再将数据流写入文件缓存的时候要重置数据流的游标保证写入的数据完整。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DataRewinder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">      <span class="meta">@NonNull</span></span><br><span class="line">      <span class="function">DataRewinder&lt;T&gt; <span class="title">build</span><span class="params">(@NonNull T data)</span></span>;</span><br><span class="line">      <span class="meta">@NonNull</span></span><br><span class="line">      <span class="function">Class&lt;T&gt; <span class="title">getDataClass</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将包装的数据回退到实例化此对象时的位置，然后返回重新包装的数据</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function">T <span class="title">rewindAndGet</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="comment">//当不再需要该复卷机并可以对其进行清理时调用。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Glide</code> 中的 <code>DataRewinder</code> 模块设计也使用的是<strong>工厂模式</strong>。</p>
<table>
<thead>
<tr>
<th>DataClass</th>
<th>DataRewinder</th>
<th>Factory</th>
<th>添加时机</th>
</tr>
</thead>
<tbody>
<tr>
<td>InputStream</td>
<td>InputStreamRewinder</td>
<td>InputStreamRewinder.Factory</td>
<td>Glide构造中注册</td>
</tr>
<tr>
<td>ByteBuffer</td>
<td>ByteBufferRewinder</td>
<td>ByteBufferRewinder.Factory</td>
<td>Glide构造中注册</td>
</tr>
<tr>
<td>ALL</td>
<td>DefaultRewinder</td>
<td>DEFAULT_FACTORY</td>
<td>默认值，不用添加</td>
</tr>
</tbody>
</table>
<h3 id="Transition"><a href="#Transition" class="headerlink" title="Transition"></a>Transition</h3><p><code>Transition</code> 不是由<code>Glide</code>进行注册的，而是我们在业务代码中按照需要添加的。它作为<code>Glide</code>组件的一种，所以我们放在这里来进行介绍。</p>
<p><a href="https://muyangmin.github.io/glide-docs-cn/doc/transitions.html" target="_blank" rel="noopener">Glide-Transition文档：https://muyangmin.github.io/glide-docs-cn/doc/transitions.html</a></p>
<p><code>Glide</code> 提供了很多的过渡效果，用户可以手动地应用于每个请求。<code>Glide</code> 的内置过渡以一致的方式运行，并且将根据加载图像的位置在某些情况下避免运行。</p>
<center><img src="https://img-blog.csdnimg.cn/201912201901022.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kYW5kYW5sb3ZlLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></center>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//包装视图的目标将能够提供所有必要的参数并开始过渡。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Transition</span>&lt;<span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//包含视图的接口，该视图公开了运行各种类型的必需的方法</span></span><br><span class="line">    <span class="comment">//Glide中所有ViewTarget的子类都实现了该接口</span></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">ViewAdapter</span> </span>&#123;</span><br><span class="line">        <span class="comment">//返回包装的view</span></span><br><span class="line">        <span class="function">View <span class="title">getView</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">//返回在视图中显示的当前可绘制对象；如果不存在这样的可绘制对象，则返回null（或无法检索）。</span></span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="function">Drawable <span class="title">getCurrentDrawable</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">//设置当前可绘制对象（通常是动画可绘制对象）以在包装视图中显示。</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setDrawable</span><span class="params">(Drawable drawable)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从当前正在使用的上一个Drawable进行动画处理在给定视图中显示，</span></span><br><span class="line">    <span class="comment">//如果在运行过渡过程中将新资源放在视图中，则为True，</span></span><br><span class="line">    <span class="comment">//如果调用者需要手动将当前资源放在视图上，则为false。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">transition</span><span class="params">(R current, ViewAdapter adapter)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一个工厂类，可以根据请求的状态产生不同的Transition</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransitionFactory</span>&lt;<span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//返回一个新的Transition</span></span><br><span class="line">    <span class="comment">//isFirstResource如果这是要加载到目标中的第一个资源，则为True。</span></span><br><span class="line">    <span class="function">Transition&lt;R&gt; <span class="title">build</span><span class="params">(DataSource dataSource, <span class="keyword">boolean</span> isFirstResource)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Glide使用"><a href="#Glide使用" class="headerlink" title="Glide使用"></a>Glide使用</h2><p>我们上面从业务代码中自定义的<code>@GlideModule</code>注解讲到了<code>Glide</code>的构造，以及<code>Glide</code>中模块&amp;组件的注册以及其对应的功能和处理逻辑。</p>
<p>接下来我们继续根据业务代码中<code>Glide</code>最常用的代码，来讲述<code>Glide</code>的其它部分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Glide.with(context)</span><br><span class="line">    .load(myUrl)</span><br><span class="line">    .into(imageView);</span><br></pre></td></tr></table></figure>
<p>这段代码中有我们三个业务逻辑参数：<code>context</code>、<code>myUrl</code>、<code>imageView</code>。</p>
<blockquote>
<ul>
<li><code>context</code> ：本次加载图片的上下文环境；</li>
<li><code>myUrl</code> ：本次需要加载图片的地址，也叫数据；</li>
<li><code>imageView</code> ：本次需要加载图片的<code>View</code> ，也叫目标；</li>
</ul>
</blockquote>
<h2 id="RequestManager"><a href="#RequestManager" class="headerlink" title="RequestManager"></a>RequestManager</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Glide.with(context)</span><br></pre></td></tr></table></figure>
<p>根据这一行代码我们进行分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.bumptech.glide.Glide.java</span></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(@NonNull Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getRetriever(context).get(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Glide.with(context)</code>获取的是<code>RequestManager</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用于管理和启动对Glide的请求的类。可以使用活动，片段和连接性生命周期事件智能地停止，启动和重新启动请求。</span></span><br><span class="line"><span class="comment">//通过实例化一个新对象或利用Activity和Fragment生命周期内置的处理功能进行检索，请对Fragment或Activity使用静态Glide.load方法。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestManager</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">ComponentCallbacks2</span>, <span class="title">LifecycleListener</span>, <span class="title">ModelTypes</span>&lt;<span class="title">RequestBuilder</span>&lt;<span class="title">Drawable</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/***代码全都省略***/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>ComponentCallbacks2</code> ：<code>Android</code> 自带的内存管理的接口，<code>Application</code> 和 <code>Activity</code> 都有实现。主要可以根据系统的内存状况及时调整App内存占用，提升用户体验或让App存活更久。</p>
</blockquote>
<blockquote>
<p><code>LifecycleListener</code> ：activity或者fragment的声明周期监听接口</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LifecycleListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span></span>;<span class="comment">//fragmetn或者activity的onstart</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span></span>;<span class="comment">//fragmetn或者activity的onstop</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span></span>;<span class="comment">//fragmetn或者activity的ondestroy</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>ModelTypes</code> ：通俗的说就是<code>Glide</code>的<strong>API</strong>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ModelTypes</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@CheckResult</span></span><br><span class="line">    <span class="function">T <span class="title">load</span><span class="params">(@Nullable Bitmap bitmap)</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">load</span><span class="params">(@Nullable Drawable drawable)</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">load</span><span class="params">(@Nullable String string)</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">load</span><span class="params">(@Nullable Uri uri)</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">load</span><span class="params">(@Nullable File file)</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">load</span><span class="params">(@RawRes @DrawableRes @Nullable Integer resourceId)</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">load</span><span class="params">(@Nullable URL url)</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">load</span><span class="params">(@Nullable <span class="keyword">byte</span>[] model)</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">load</span><span class="params">(@Nullable Object model)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RequestManager的获取"><a href="#RequestManager的获取" class="headerlink" title="RequestManager的获取"></a>RequestManager的获取</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.bumptech.glide.manager.RequestManagerRetriever.java</span></span><br><span class="line"><span class="comment">//Application的生命周期单独管理</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RequestManager applicationManager;</span><br><span class="line"><span class="comment">//一个是support包，一个是Android的api，RequestManagerFragment的临时存储</span></span><br><span class="line"><span class="comment">//RequestManagerFragment用来管理RequestManager和同步生命周期</span></span><br><span class="line"><span class="keyword">final</span> Map&lt;android.app.FragmentManager, RequestManagerFragment&gt; pendingRequestManagerFragments = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">final</span> Map&lt;FragmentManager, SupportRequestManagerFragment&gt; pendingSupportRequestManagerFragments = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestManager <span class="title">get</span><span class="params">(@NonNull Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"You cannot start a load on a null Context"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Util.isOnMainThread() &amp;&amp; !(context <span class="keyword">instanceof</span> Application)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (context <span class="keyword">instanceof</span> FragmentActivity) &#123;<span class="comment">//FragmentActivity</span></span><br><span class="line">            <span class="keyword">return</span> get((FragmentActivity) context);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (context <span class="keyword">instanceof</span> Activity) &#123;<span class="comment">//Activity</span></span><br><span class="line">            <span class="keyword">return</span> get((Activity) context);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (context <span class="keyword">instanceof</span> ContextWrapper<span class="comment">//找到context的basecontext</span></span><br><span class="line">            &amp;&amp; ((ContextWrapper) context).getBaseContext().getApplicationContext() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> get(((ContextWrapper) context).getBaseContext());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getApplicationManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们用<code>Fragment</code> 来举例看看<code>RequestManager</code>的获取（<code>Activity</code>和<code>FragmentActivity</code>的实现都类似）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RequestManager <span class="title">get</span><span class="params">(@NonNull Fragment fragment)</span> </span>&#123;</span><br><span class="line">    Preconditions.checkNotNull(fragment.getContext(),<span class="string">"fragment必须被attch，不能被destroy"</span>);</span><br><span class="line">    <span class="keyword">if</span> (Util.isOnBackgroundThread()) &#123;<span class="comment">//如果应用在后台，那么切换为Application</span></span><br><span class="line">        <span class="keyword">return</span> get(fragment.getContext().getApplicationContext());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        FragmentManager fm = fragment.getChildFragmentManager();</span><br><span class="line">        <span class="keyword">return</span> supportFragmentGet(fragment.getContext(), fm, fragment, fragment.isVisible());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> RequestManager <span class="title">supportFragmentGet</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      @NonNull Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">      @NonNull FragmentManager fm,</span></span></span><br><span class="line"><span class="function"><span class="params">      @Nullable Fragment parentHint,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> isParentVisible)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前上下文中的SupportRequestManagerFragment</span></span><br><span class="line">    SupportRequestManagerFragment current =</span><br><span class="line">        getSupportRequestManagerFragment(fm, parentHint, isParentVisible);</span><br><span class="line">    <span class="comment">//获取SupportRequestManagerFragment的RequestManager</span></span><br><span class="line">    RequestManager requestManager = current.getRequestManager();</span><br><span class="line">    <span class="keyword">if</span> (requestManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//给新创建的SupportRequestManagerFragment添加RequestManager</span></span><br><span class="line">        Glide glide = Glide.get(context);</span><br><span class="line">        requestManager =</span><br><span class="line">            factory.build(</span><br><span class="line">                glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);</span><br><span class="line">        current.setRequestManager(requestManager);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> requestManager;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> SupportRequestManagerFragment <span class="title">getSupportRequestManagerFragment</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      @NonNull <span class="keyword">final</span> FragmentManager fm, @Nullable Fragment parentHint, <span class="keyword">boolean</span> isParentVisible)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先看看当前的FragmentManager中有没有SupportRequestManagerFragment，有就复用</span></span><br><span class="line">    SupportRequestManagerFragment current = (SupportRequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);</span><br><span class="line">    <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//pendingSupportRequestManagerFragments，只是一个临时性的存储,因为每次put之后必定会remove</span></span><br><span class="line">        <span class="comment">//因为add之后立即进行findFragmentByTag是获取不到的，所以需要临时存储</span></span><br><span class="line">        current = pendingSupportRequestManagerFragments.get(fm);</span><br><span class="line">        <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//创建新的SupportRequestManagerFragment</span></span><br><span class="line">            current = <span class="keyword">new</span> SupportRequestManagerFragment();</span><br><span class="line">            current.setParentFragmentHint(parentHint);  </span><br><span class="line">            <span class="comment">//如果fragment已经展示，那么添加的SupportRequestManagerFragment也要同步生命周期</span></span><br><span class="line">            <span class="keyword">if</span> (isParentVisible) &#123;</span><br><span class="line">                current.getGlideLifecycle().onStart();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//添加临时存储</span></span><br><span class="line">            pendingSupportRequestManagerFragments.put(fm, current);</span><br><span class="line">            <span class="comment">//创建的SupportRequestManagerFragment添加到FragmentManager中</span></span><br><span class="line">            fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();</span><br><span class="line">            <span class="comment">//删除临时存储</span></span><br><span class="line">            handler.obtainMessage(ID_REMOVE_SUPPORT_FRAGMENT_MANAGER, fm).sendToTarget();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其它功能"><a href="#其它功能" class="headerlink" title="其它功能"></a>其它功能</h3><p>执行\取消一个请求、暂停所有请求、重启所有请求等对请求的标记，这部分会在<code>Request</code> 详细讲解。在说<code>Request</code> 之前先说一下<code>Request</code>需要为谁加载目标资源。</p>
<h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><blockquote>
<p><code>Target</code> ：在声明周期内Glide加载资源回调接口；</p>
<p><code>BaseTarget</code> ：用于加载<code>Resource</code>的基础 <code>Target</code> 大多数方法的基本或空实现；</p>
<p><code>TargetView</code> ：为Bitmap添加到View上提供了默认实现，</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span>&lt;<span class="title">R</span>&gt; <span class="keyword">extends</span> <span class="title">LifecycleListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">//表示我们希望资源保持其原始的未修改宽度和/或高度</span></span><br><span class="line">    <span class="keyword">int</span> SIZE_ORIGINAL = Integer.MIN_VALUE;</span><br><span class="line">    <span class="comment">//开始加载</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onLoadStarted</span><span class="params">(@Nullable Drawable placeholder)</span></span>;</span><br><span class="line">    <span class="comment">//加载失败</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onLoadFailed</span><span class="params">(@Nullable Drawable errorDrawable)</span></span>;</span><br><span class="line">    <span class="comment">//资源加载完成时将调用的方法。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onResourceReady</span><span class="params">(@NonNull R resource, @Nullable Transition&lt;? <span class="keyword">super</span> R&gt; transition)</span></span>;</span><br><span class="line">    <span class="comment">//在取消负载及其资源释放时调用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onLoadCleared</span><span class="params">(@Nullable Drawable placeholder)</span></span>;</span><br><span class="line">    <span class="comment">//一种检索此目标大小的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getSize</span><span class="params">(@NonNull SizeReadyCallback cb)</span></span>;</span><br><span class="line">    <span class="comment">//如果给定的回调仍保留，则将其从待处理集中删除</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeCallback</span><span class="params">(@NonNull SizeReadyCallback cb)</span></span>;</span><br><span class="line">    <span class="comment">//设置为此目标保留的当前请求</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRequest</span><span class="params">(@Nullable Request request)</span></span>;</span><br><span class="line">    <span class="comment">//检索对此目标的当前请求</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">Request <span class="title">getRequest</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="RequestBuilder"><a href="#RequestBuilder" class="headerlink" title="RequestBuilder"></a>RequestBuilder</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Glide.with(context)</span><br><span class="line">    .load(myUrl)</span><br></pre></td></tr></table></figure>
<p>我们继续看下一行<code>load</code>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.bumptech.glide.RequestManager.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="title">load</span><span class="params">(@Nullable String string)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> asDrawable().load(string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RequestBuilder</code>通用类，可以处理通用资源类型的设置选项和启动负载。<code>GlideRequest</code>虽然继承了<code>RequestBuilder</code> 但内部的实现都是<code>super</code>调用父类的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.bumptech.glide.RequestManager.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="title">asDrawable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> as(Drawable.class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> &lt;ResourceType&gt; <span class="function">RequestBuilder&lt;ResourceType&gt; <span class="title">as</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      @NonNull Class&lt;ResourceType&gt; resourceClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RequestBuilder&lt;&gt;(glide, <span class="keyword">this</span>, resourceClass, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>asDrawable</code> 创建一个请求资源类型为 <code>Drawable.class</code> 的 <code>RequestBuilder</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.bumptech.glide.RequestBuilder.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestBuilder&lt;TranscodeType&gt; <span class="title">load</span><span class="params">(@Nullable String string)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> loadGeneric(string);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> RequestBuilder&lt;TranscodeType&gt; <span class="title">loadGeneric</span><span class="params">(@Nullable Object model)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.model = model;</span><br><span class="line">    isModelSet = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来设置这个 <code>RequestBuilder</code> 的 <code>Model</code> 为<code>String.class</code> 的 <code>myUrl</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Glide.with(context)</span><br><span class="line">    .load(myUrl)</span><br><span class="line">    .into(imageView);</span><br></pre></td></tr></table></figure>
<p><code>RequestBuilder</code> 的 <code>into</code>  方法是 <code>Glide</code> 加载图片的最后一步。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ViewTarget&lt;ImageView, TranscodeType&gt; <span class="title">into</span><span class="params">(@NonNull ImageView view)</span> </span>&#123;</span><br><span class="line">    Util.assertMainThread();</span><br><span class="line">    Preconditions.checkNotNull(view);</span><br><span class="line">    BaseRequestOptions&lt;?&gt; requestOptions = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">//下面是根据view修改requestOptions的属性</span></span><br><span class="line">    <span class="keyword">if</span> (!requestOptions.isTransformationSet()</span><br><span class="line">        &amp;&amp; requestOptions.isTransformationAllowed()</span><br><span class="line">        &amp;&amp; view.getScaleType() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (view.getScaleType()) &#123;</span><br><span class="line">        <span class="keyword">case</span> CENTER_CROP:</span><br><span class="line">          requestOptions = requestOptions.clone().optionalCenterCrop();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> CENTER_INSIDE:</span><br><span class="line">          requestOptions = requestOptions.clone().optionalCenterInside();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FIT_CENTER:</span><br><span class="line">        <span class="keyword">case</span> FIT_START:</span><br><span class="line">        <span class="keyword">case</span> FIT_END:</span><br><span class="line">          requestOptions = requestOptions.clone().optionalFitCenter();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FIT_XY:</span><br><span class="line">          requestOptions = requestOptions.clone().optionalCenterInside();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> CENTER:</span><br><span class="line">        <span class="keyword">case</span> MATRIX:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="comment">// Do nothing.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> into(</span><br><span class="line">        glideContext.buildImageViewTarget(view, transcodeClass),</span><br><span class="line">        <span class="comment">/*targetListener=*/</span> <span class="keyword">null</span>,</span><br><span class="line">        requestOptions,</span><br><span class="line">        Executors.mainThreadExecutor());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>into</code> 方法主要根据 <code>View</code> 的属性重构造 <code>requestOptions</code> ， 并生成 <code>DrawableImageViewTarget</code> 。</p>
<h3 id="ViewTarget的生成"><a href="#ViewTarget的生成" class="headerlink" title="ViewTarget的生成"></a>ViewTarget的生成</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlideContext</span> <span class="keyword">extends</span> <span class="title">ContextWrapper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;X&gt; <span class="function">ViewTarget&lt;ImageView, X&gt; <span class="title">buildImageViewTarget</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull ImageView imageView, @NonNull Class&lt;X&gt; transcodeClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> imageViewTargetFactory.buildTarget(imageView, transcodeClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageViewTargetFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> &lt;Z&gt; <span class="function">ViewTarget&lt;ImageView, Z&gt; <span class="title">buildTarget</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull ImageView view, @NonNull Class&lt;Z&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Bitmap.class.equals(clazz)) &#123;</span><br><span class="line">            <span class="keyword">return</span> (ViewTarget&lt;ImageView, Z&gt;) <span class="keyword">new</span> BitmapImageViewTarget(view);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Drawable.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line">            <span class="keyword">return</span> (ViewTarget&lt;ImageView, Z&gt;) <span class="keyword">new</span> DrawableImageViewTarget(view);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">            <span class="string">"Unhandled class: "</span> + clazz + <span class="string">", try .as*(Class).transcode(ResourceTranscoder)"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>transcodeClass</code> 实际就是上面的 <code>resourceClass</code> 也就是 <code>Drawable.class</code> 。</p>
<p>接下来我们继续看它的 <code>into</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;Y extends Target&lt;TranscodeType&gt;&gt; <span class="function">Y <span class="title">into</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      @NonNull Y target,</span></span></span><br><span class="line"><span class="function"><span class="params">      @Nullable RequestListener&lt;TranscodeType&gt; targetListener,</span></span></span><br><span class="line"><span class="function"><span class="params">      BaseRequestOptions&lt;?&gt; options,</span></span></span><br><span class="line"><span class="function"><span class="params">      Executor callbackExecutor)</span> </span>&#123;</span><br><span class="line">    Preconditions.checkNotNull(target);</span><br><span class="line">    <span class="comment">//检测是否设置了model</span></span><br><span class="line">    <span class="keyword">if</span> (!isModelSet) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"You must call #load() before calling #into()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建请求,Executors.mainThreadExecutor()标识callback在主线程</span></span><br><span class="line">    Request request = buildRequest(target, targetListener, options, callbackExecutor);</span><br><span class="line">    Request previous = target.getRequest();</span><br><span class="line">    <span class="comment">//如果target上的当前请求与上一次的相同，且请求缓存磁盘并且上一个请求为完成时使用上一个请求</span></span><br><span class="line">    <span class="keyword">if</span> (request.isEquivalentTo(previous)</span><br><span class="line">        &amp;&amp; !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) &#123;</span><br><span class="line">      <span class="comment">//如果请求已完成，请重新开始，以确保重新发送结果，触发RequestListeners和Targets。</span></span><br><span class="line">      <span class="comment">//如果请求失败，将重新开始重新启动请求，使它有另一个完成的机会。</span></span><br><span class="line">      <span class="comment">//如果请求已经正在运行，我们可以让它继续运行而不会受到干扰。</span></span><br><span class="line">      <span class="keyword">if</span> (!Preconditions.checkNotNull(previous).isRunning()) &#123;</span><br><span class="line">        <span class="comment">//使用上一个请求而不是新请求来进行优化，例如跳过设置占位符，跟踪和取消跟踪目标并获取视图尺寸在单独的请求中完成。 </span></span><br><span class="line">        previous.begin();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//清除target之前的请求</span></span><br><span class="line">    requestManager.clear(target);</span><br><span class="line">    <span class="comment">//给target设置新的请求</span></span><br><span class="line">    target.setRequest(request);</span><br><span class="line">    <span class="comment">//target同步requestmanager的声明周期，并将request添加到请求列表</span></span><br><span class="line">    requestManager.track(target, request);</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSkipMemoryCacheWithCompletePreviousRequest</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    BaseRequestOptions&lt;?&gt; options, Request previous)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !options.isMemoryCacheable() &amp;&amp; previous.isComplete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好吧，终于看见加载图片的请求了~！</p>
<p>这里会根据之前构建的一些参数来生成 <code>Request</code> ，然后和 <code>ViewTarget</code> 的 <code>Request</code> 进行比较决定是否重用之前的 <code>Request</code> ，或者清除之前的 <code>Request</code> 。</p>
<h2 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h2><blockquote>
<p><code>Request</code> ：为 <code>Target</code> 加载资源的请求。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span></span>;<span class="comment">//开始异步加载</span></span><br><span class="line">    <span class="comment">//防止从以前的请求中加载任何位图，释放由此持有的任何资源请求，并将该请求标记为具有已取消。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//暂停请求</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//如果此请求正在运行并且尚未完成或失败，则返回true。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//如果请求成功完成，则返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isComplete</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//如果请求已清除，则返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCleared</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//判断两个请求是否相同</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEquivalentTo</span><span class="params">(Request other)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Request的创建"><a href="#Request的创建" class="headerlink" title="Request的创建"></a>Request的创建</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Request request = buildRequest(target, targetListener, options, callbackExecutor);</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>target</code> : 我们对 <code>ImageView</code> 包装之后的的 <code>ViewTarget</code>；</li>
<li><code>targetListener</code> ：默认为<code>null</code>；</li>
<li><code>options</code> ：为重新根据<code>view</code> 属性修改之后的 <code>requestOptions</code> ；</li>
<li><code>callbackExecutor</code> : 回调的线程池，在主线程中执行回调；</li>
</ul>
</blockquote>
<p>生成的<code>Request</code> 实例为 <code>SingleRequest</code>，它是专门为了<code>Target</code>而加载资源的。</p>
<p>如果需要设置处理 <code>Error</code> 的请求那么会在 <code>Request</code> 外包一层生成 <code>ErrorRequestCoordinator</code>。</p>
<blockquote>
<p><code>ErrorRequestCoordinator</code> ：运行单个主要的Request直到完成，然后仅在单个主要请求失败的情况下后退错误请求；</p>
</blockquote>
<p>如果需要设置处理缩略图的请求那么会在 <code>Request</code> 外包一层生成 <code>ThumbnailRequestCoordinator</code>。</p>
<blockquote>
<p><code>ThumbnailRequestCoordinator</code> ：一个协调器，用于协调两个单独的<code>Request</code>，它们同时加载图像的小缩略图版本和图像的完整尺寸版本。</p>
</blockquote>
<p>整个<code>Glide</code> 中 <code>Request</code> 的实现类就<code>SingleRequest</code> 、<code>ErrorRequestCoordinator</code> 和 <code>ThumbnailRequestCoordinator</code> 一共三个。</p>
<h3 id="SingleRequest"><a href="#SingleRequest" class="headerlink" title="SingleRequest"></a>SingleRequest</h3><p><code>SingleRequest</code> 不仅实现了 <code>Request</code> ，还实现了<code>SizeReadyCallback</code> 和 <code>ResourceCallback</code> 接口。</p>
<blockquote>
<p><code>SizeReadyCallback</code> ：当目标确定其大小时必须调用的回调。对于固定尺寸的目标可以同步调用。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SizeReadyCallback</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onSizeReady</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>ResourceCallback</code> ：侦听资源加载成功完成或失败的回调。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResourceCallback</span> </span>&#123;</span><br><span class="line">  <span class="comment">//成功加载资源时调用。</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onResourceReady</span><span class="params">(Resource&lt;?&gt; resource, DataSource dataSource)</span></span>;</span><br><span class="line">  <span class="comment">//当资源无法成功加载时调用。</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onLoadFailed</span><span class="params">(GlideException e)</span></span>;</span><br><span class="line">  <span class="comment">//返回通知单个请求时要使用的锁</span></span><br><span class="line">  <span class="function">Object <span class="title">getLock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面我们阅读<code>into</code>代码的时候知道了 <code>request</code> 的执行是调用了<code>RequestManager.track</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.bumptech.glide.RequestManager</span></span><br><span class="line"><span class="comment">//对request进行追踪，默认的new RequestTracker()；</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RequestTracker requestTracker；</span><br><span class="line"><span class="comment">//对target进行追踪</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TargetTracker targetTracker = <span class="keyword">new</span> TargetTracker();</span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">track</span><span class="params">(@NonNull Target&lt;?&gt; target, @NonNull Request request)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//添加到RequestManger的target追踪容器中</span></span><br><span class="line">    targetTracker.track(target);</span><br><span class="line">    <span class="comment">//运行request</span></span><br><span class="line">    requestTracker.runRequest(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>TargetTracker</code> : 保留当前对有效的一组Target，并转发生命周期事件。</li>
<li><code>RequestTracker</code> ：用于跟踪，取消和重新启动进行中，已完成和失败的请求的类。</li>
</ul>
</blockquote>
<p><code>Request</code> 已经讲述了一部分了，之前 <code>RequestManger</code> 部分对于 <code>Request</code> 的请求、清除、暂停、重新启动没有详细讲述，现在可以开始。</p>
<h3 id="Request-begin"><a href="#Request-begin" class="headerlink" title="Request.begin"></a>Request.begin</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.bumptech.glide.manager.RequestTracker</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runRequest</span><span class="params">(@NonNull Request request)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//添加到请求容器中</span></span><br><span class="line">    requests.add(request);</span><br><span class="line">    <span class="comment">//如果当前的RequestManager不处于暂停状态，那么直接开始请求</span></span><br><span class="line">    <span class="keyword">if</span> (!isPaused) &#123;</span><br><span class="line">        request.begin();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//否则延迟该请求</span></span><br><span class="line">        request.clear();</span><br><span class="line">        <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">            Log.v(TAG, <span class="string">"Paused, delaying request"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">         pendingRequests.add(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来看<code>SingleRequest</code> 的 <code>begin</code> 方法，开始真正的获取资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.bumptech.glide.manager.RequestTracker</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (requestLock) &#123;</span><br><span class="line">        assertNotCallingCallbacks();<span class="comment">//如果已经进行了回调，那么抛异常</span></span><br><span class="line">        stateVerifier.throwIfRecycled();<span class="comment">//如果任务已经被回收，那么抛异常</span></span><br><span class="line">        startTime = LogTime.getLogTime();</span><br><span class="line">        <span class="keyword">if</span> (model == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//校验宽高是否有效</span></span><br><span class="line">            <span class="keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</span><br><span class="line">                width = overrideWidth;</span><br><span class="line">                height = overrideHeight;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//详细的日志级别进行记录</span></span><br><span class="line">            <span class="keyword">int</span> logLevel = getFallbackDrawable() == <span class="keyword">null</span> ? Log.WARN : Log.DEBUG;</span><br><span class="line">            onLoadFailed(<span class="keyword">new</span> GlideException(<span class="string">"Received null model"</span>), logLevel);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (status == Status.RUNNING) &#123;<span class="comment">//如果任务已经处于运行状态，那么抛异常</span></span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot restart a running request"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果任务已经执行完成，那么直接回调加载资源</span></span><br><span class="line">        <span class="keyword">if</span> (status == Status.COMPLETE) &#123;</span><br><span class="line">            onResourceReady(resource, DataSource.MEMORY_CACHE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//重新启动既未完成也未运行的请求，可以视为新请求并可以从头开始再次运行。</span></span><br><span class="line">        status = Status.WAITING_FOR_SIZE;</span><br><span class="line">        <span class="keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</span><br><span class="line">           onSizeReady(overrideWidth, overrideHeight);<span class="comment">//内部有请求资源的实现方法调用</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           target.getSize(<span class="keyword">this</span>);<span class="comment">//重新回调onSizeReady方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//加载占位图</span></span><br><span class="line">        <span class="keyword">if</span> ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE)</span><br><span class="line">            &amp;&amp; canNotifyStatusChanged()) &#123;</span><br><span class="line">            target.onLoadStarted(getPlaceholderDrawable());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>已知加载的<code>ViewTarget</code>的宽高才会进一步加载资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.bumptech.glide.request.SingleRequest</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSizeReady</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    stateVerifier.throwIfRecycled();<span class="comment">//如果任务已经被回收，那么抛异常</span></span><br><span class="line">    <span class="keyword">synchronized</span> (requestLock) &#123;<span class="comment">//加锁，进行数据请求</span></span><br><span class="line">        <span class="keyword">if</span> (status != Status.WAITING_FOR_SIZE) &#123;<span class="comment">//必须size确定</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        status = Status.RUNNING;<span class="comment">//进入运行状态</span></span><br><span class="line">        <span class="comment">//在加载资源之前，对Target的大小应用乘数。对于加载缩略图或避免加载大量资源非常有用。默认为1f。</span></span><br><span class="line">        <span class="keyword">float</span> sizeMultiplier = requestOptions.getSizeMultiplier();</span><br><span class="line">        <span class="keyword">this</span>.width = maybeApplySizeMultiplier(width, sizeMultiplier);</span><br><span class="line">        <span class="keyword">this</span>.height = maybeApplySizeMultiplier(height, sizeMultiplier);</span><br><span class="line">        loadStatus =</span><br><span class="line">                engine.load(</span><br><span class="line">                        glideContext,</span><br><span class="line">                        model,<span class="comment">//myUrl</span></span><br><span class="line">                        requestOptions.getSignature(),<span class="comment">//缓存签名，默认为EmptySignature</span></span><br><span class="line">                        <span class="keyword">this</span>.width,</span><br><span class="line">                        <span class="keyword">this</span>.height,</span><br><span class="line">                        requestOptions.getResourceClass(),<span class="comment">//不设置decode的话，默认为Object</span></span><br><span class="line">                        transcodeClass,<span class="comment">//Drawable.class</span></span><br><span class="line">                        priority,</span><br><span class="line">                        requestOptions.getDiskCacheStrategy(),</span><br><span class="line">                        requestOptions.getTransformations(),</span><br><span class="line">                        requestOptions.isTransformationRequired(),</span><br><span class="line">                        requestOptions.isScaleOnlyOrNoTransform(),</span><br><span class="line">                        requestOptions.getOptions(),</span><br><span class="line">                        requestOptions.isMemoryCacheable(),</span><br><span class="line">                        requestOptions.getUseUnlimitedSourceGeneratorsPool(),</span><br><span class="line">                        requestOptions.getUseAnimationPool(),</span><br><span class="line">                        requestOptions.getOnlyRetrieveFromCache(),</span><br><span class="line">                        <span class="keyword">this</span>,</span><br><span class="line">                        callbackExecutor);</span><br><span class="line">        <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Engine-load"><a href="#Engine-load" class="headerlink" title="Engine.load"></a>Engine.load</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.bumptech.glide.load.engine.Engine</span></span><br><span class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">LoadStatus <span class="title">load</span><span class="params">(<span class="comment">/***部分代码省略***/</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTime = VERBOSE_IS_LOGGABLE ? LogTime.getLogTime() : <span class="number">0</span>;</span><br><span class="line">    EngineKey key = <span class="comment">//构造缓存的key</span></span><br><span class="line">            keyFactory.buildKey(</span><br><span class="line">                    model,<span class="comment">//数据myUrl</span></span><br><span class="line">                    signature,<span class="comment">//签名</span></span><br><span class="line">                    width,</span><br><span class="line">                    height,</span><br><span class="line">                    transformations,<span class="comment">//转变</span></span><br><span class="line">                    resourceClass,<span class="comment">//Object.class</span></span><br><span class="line">                    transcodeClass,<span class="comment">//Drawable.class</span></span><br><span class="line">                    options);</span><br><span class="line">    EngineResource&lt;?&gt; memoryResource;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//先从缓存中加载</span></span><br><span class="line">        memoryResource = loadFromMemory(key, isMemoryCacheable, startTime);</span><br><span class="line">        <span class="keyword">if</span> (memoryResource == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> waitForExistingOrStartNewJob(<span class="comment">/***部分代码省略***/</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//回调可以并发，不需要进行锁操作</span></span><br><span class="line">    cb.onResourceReady(memoryResource, DataSource.MEMORY_CACHE);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内存缓存加载"><a href="#内存缓存加载" class="headerlink" title="内存缓存加载"></a>内存缓存加载</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> EngineResource&lt;?&gt; loadFromMemory(EngineKey key, <span class="keyword">boolean</span> isMemoryCacheable, <span class="keyword">long</span> startTime) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isMemoryCacheable) &#123;<span class="comment">//如果不允许使用内存，那么直接返回null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    EngineResource&lt;?&gt; active = loadFromActiveResources(key);<span class="comment">//获取活跃的资源</span></span><br><span class="line">    <span class="keyword">if</span> (active != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> active;</span><br><span class="line">    &#125;</span><br><span class="line">    EngineResource&lt;?&gt; cached = loadFromCache(key);<span class="comment">//获取内存缓存中的资源</span></span><br><span class="line">    <span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cached;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ActiveResources"><a href="#ActiveResources" class="headerlink" title="ActiveResources"></a>ActiveResources</h4><blockquote>
<p><code>ActiveResources</code> ：利用持有<code>Resource</code> 弱引用的 <code>HashMap</code> 来进行数据保存。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> EngineResource&lt;?&gt; loadFromActiveResources(Key key) &#123;</span><br><span class="line">    EngineResource&lt;?&gt; active = activeResources.get(key);</span><br><span class="line">    <span class="keyword">if</span> (active != <span class="keyword">null</span>) &#123;</span><br><span class="line">        active.acquire();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> active;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>添加操作：有两个触发点，一个是从 <code>cache</code> 中读取的时候会将资源添加到 <code>ActiveResources</code> 。另一个获取资源完成的时候会添加到 <code>ActiveResources</code> 。它们有一个相同的点都在使用资源的时候添加到 <code>ActiveRsources</code> 。</li>
<li>删除操作：<code>EngineResource</code> 在内部有一个引用计数器，每次被获取的时候都会进行 <code>acquire</code> 自加。被释放的时候也是会自减。当引用计数为0的时候，会被 <code>ActivityResources</code> 释放，并添加到 <code>MemoryCache</code> 中。</li>
</ul>
<h4 id="MemoryCache"><a href="#MemoryCache" class="headerlink" title="MemoryCache"></a>MemoryCache</h4><blockquote>
<p><code>MemoryCache</code> ：同样使用 <strong>LRU 算法</strong>，实现类为<code>LruResourceCache</code> ，它提供了一个 <code>ResourceRemovedListener</code>接口，当有资源从 <code>MemoryCache</code> 中被移除时会回调其中的方法，<code>Engine</code> 中接收到这个消息后就会进行 <code>Bitmap</code> 的回收操作。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> EngineResource&lt;?&gt; loadFromCache(Key key) &#123;</span><br><span class="line">    EngineResource&lt;?&gt; cached = getEngineResourceFromCache(key);</span><br><span class="line">    <span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cached.acquire();</span><br><span class="line">        activeResources.activate(key, cached);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cached;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> EngineResource&lt;?&gt; getEngineResourceFromCache(Key key) &#123;</span><br><span class="line">    Resource&lt;?&gt; cached = cache.remove(key);</span><br><span class="line">    <span class="keyword">final</span> EngineResource&lt;?&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (cached == <span class="keyword">null</span>) &#123;</span><br><span class="line">        result = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cached <span class="keyword">instanceof</span> EngineResource) &#123;</span><br><span class="line">        result = (EngineResource&lt;?&gt;) cached;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = <span class="keyword">new</span> EngineResource&lt;&gt;(cached, <span class="keyword">true</span>, <span class="keyword">true</span>, key, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResourceReleased</span><span class="params">(Key cacheKey, EngineResource&lt;?&gt; resource)</span> </span>&#123;</span><br><span class="line">    activeResources.deactivate(cacheKey);</span><br><span class="line">    <span class="keyword">if</span> (resource.isMemoryCacheable()) &#123;</span><br><span class="line">        cache.put(cacheKey, resource);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resourceRecycler.recycle(resource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>添加操作：当资源被 <code>ActiveResources</code> 释放的时候；</li>
<li>删除操作：当资源被 <code>ActivityResource</code> 获取的时候；</li>
</ul>
<p>以上两点保证了 <code>ActiveResource</code> 和 <code>MemoryCache</code> 中的资源是不会有重复的。</p>
<h3 id="DecodeJob"><a href="#DecodeJob" class="headerlink" title="DecodeJob"></a>DecodeJob</h3><blockquote>
<p><code>DecodeJob</code> ：负责从缓存的数据或原始源解码资源，并应用转换和转码。<br>接下来的部分会详细讲解上图的每个部分。</p>
</blockquote>
<center><img src="https://img-blog.csdnimg.cn/20191220190409636.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kYW5kYW5sb3ZlLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></center>

<h3 id="磁盘缓存加载"><a href="#磁盘缓存加载" class="headerlink" title="磁盘缓存加载"></a>磁盘缓存加载</h3><p>等待创建或者是获取已经存在的加载状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;R&gt; <span class="function">LoadStatus <span class="title">waitForExistingOrStartNewJob</span><span class="params">(<span class="comment">/***部分代码省略***/</span>)</span> </span>&#123;</span><br><span class="line">    EngineJob&lt;?&gt; current = jobs.get(key, onlyRetrieveFromCache);<span class="comment">//从hashmap中获取加载key的工作引擎</span></span><br><span class="line">    <span class="keyword">if</span> (current != <span class="keyword">null</span>) &#123;<span class="comment">//如果已经存在那么直接返回</span></span><br><span class="line">        current.addCallback(cb, callbackExecutor);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LoadStatus(cb, current);</span><br><span class="line">    &#125;</span><br><span class="line">    EngineJob&lt;R&gt; engineJob = <span class="comment">//通过添加和删除负载的回调并在负载完成时通知回调来管理负载的类。</span></span><br><span class="line">            engineJobFactory.build(<span class="comment">/***部分代码省略***/</span>);</span><br><span class="line">    DecodeJob&lt;R&gt; decodeJob = <span class="comment">//负责从缓存的数据或原始源解码资源，并应用转换和转码。</span></span><br><span class="line">            decodeJobFactory.build(<span class="comment">/***部分代码省略***/</span>);</span><br><span class="line">    jobs.put(key, engineJob);<span class="comment">//添加到hashmap中</span></span><br><span class="line">    engineJob.addCallback(cb, callbackExecutor);<span class="comment">//添加回调信息</span></span><br><span class="line">    engineJob.start(decodeJob);<span class="comment">//开始工作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LoadStatus(cb, engineJob);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>选择执行线程，开始执行任务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.bumptech.glide.load.engine.EngineJob</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(DecodeJob&lt;R&gt; decodeJob)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.decodeJob = decodeJob;</span><br><span class="line">    <span class="comment">//根据磁盘缓存策略，判断使用哪个线程池执行任务</span></span><br><span class="line">    GlideExecutor executor = decodeJob.willDecodeFromCache() ? diskCacheExecutor : getActiveSourceExecutor();</span><br><span class="line">    executor.execute(decodeJob);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>diskCacheExecutor</code> 线程池中执行 <code>DecoceJob</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.bumptech.glide.load.engine.DecodeJob</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    DataFetcher&lt;?&gt; localFetcher = currentFetcher;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isCancelled) &#123;<span class="comment">//如果任务已经取消，那么进行失败回调</span></span><br><span class="line">            notifyFailed();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        runWrapped();<span class="comment">//开始执行任务</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (CallbackException e) &#123;</span><br><span class="line">        <span class="comment">//如果不受Glide控制的回调引发异常，则应避免使用Glide下面的特定调试逻辑。 </span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">//通知失败，进行失败回调，抛出异常</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (localFetcher != <span class="keyword">null</span>) &#123;</span><br><span class="line">            localFetcher.cleanup();</span><br><span class="line">        &#125;</span><br><span class="line">        GlideTrace.endSection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>runWrapped</code> 为 <code>run</code> 实现的包装。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.bumptech.glide.load.engine.DecodeJob</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">enum</span> RunReason &#123;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    INITIALIZE,</span><br><span class="line">    <span class="comment">//切换执行服务</span></span><br><span class="line">    SWITCH_TO_SOURCE_SERVICE,</span><br><span class="line">    <span class="comment">//获取数据之后的资源编解码</span></span><br><span class="line">    DECODE_DATA,</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runWrapped</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (runReason) &#123;</span><br><span class="line">        <span class="keyword">case</span> INITIALIZE:</span><br><span class="line">            stage = getNextStage(Stage.INITIALIZE);</span><br><span class="line">            currentGenerator = getNextGenerator();</span><br><span class="line">            runGenerators();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SWITCH_TO_SOURCE_SERVICE:</span><br><span class="line">            runGenerators();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DECODE_DATA:</span><br><span class="line">            decodeFromRetrievedData();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unrecognized run reason: "</span> + runReason);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再讲下一步数据从磁盘的获取之前，先看一下我们默认的磁盘策略：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DiskCacheStrategy AUTOMATIC =</span><br><span class="line">    <span class="keyword">new</span> DiskCacheStrategy() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDataCacheable</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> dataSource == DataSource.REMOTE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isResourceCacheable</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> isFromAlternateCacheKey, DataSource dataSource, EncodeStrategy encodeStrategy)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ((isFromAlternateCacheKey &amp;&amp; dataSource == DataSource.DATA_DISK_CACHE)</span><br><span class="line">                    || dataSource == DataSource.LOCAL)</span><br><span class="line">                &amp;&amp; encodeStrategy == EncodeStrategy.TRANSFORMED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">decodeCachedResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">decodeCachedData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果数据时 <code>REMOTE</code> 类型那么可以进行缓存；</li>
<li>如果是解码资源而且<code>Key</code> 不是源数据的<code>Key</code> ，资源为 <code>DATA_DISK_CACHE</code> 的话，那么这个资源可以缓存；</li>
<li>可以缓存解码资源；</li>
<li>可以缓存解码数据；</li>
</ul>
<p>从上面我们可以了解到缓存有<code>数据缓存</code> 和 <code>解码后的数据缓存</code> 。</p>
<p>我们接着分析 <code>runWrapped</code> 方法内调用的 <code>getNextStage</code> :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.bumptech.glide.load.engine.DecodeJob</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Stage <span class="title">getNextStage</span><span class="params">(Stage current)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (current) &#123;</span><br><span class="line">        <span class="keyword">case</span> INITIALIZE:<span class="comment">//AUTOMATIC默认为true，所以初始化的第一步应该检测Stage.RESOURCE_CACHE</span></span><br><span class="line">            <span class="keyword">return</span> diskCacheStrategy.decodeCachedResource()</span><br><span class="line">                ? Stage.RESOURCE_CACHE</span><br><span class="line">                : getNextStage(Stage.RESOURCE_CACHE);</span><br><span class="line">        <span class="keyword">case</span> RESOURCE_CACHE:<span class="comment">//AUTOMATIC默认为true，所以初始化的下一步应该检测Stage.DATA_CACHE</span></span><br><span class="line">            <span class="keyword">return</span> diskCacheStrategy.decodeCachedData()</span><br><span class="line">                ? Stage.DATA_CACHE</span><br><span class="line">                : getNextStage(Stage.DATA_CACHE);</span><br><span class="line">        <span class="keyword">case</span> DATA_CACHE:<span class="comment">////如果用户选择仅从缓存中检索资源，则从源跳过加载。否则应该检测Stage.SOURCE</span></span><br><span class="line">            <span class="keyword">return</span> onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE;</span><br><span class="line">        <span class="keyword">case</span> SOURCE:</span><br><span class="line">        <span class="keyword">case</span> FINISHED:</span><br><span class="line">            <span class="keyword">return</span> Stage.FINISHED;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unrecognized stage: "</span> + current);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>知道了<code>Stage</code> 类型接着分析 <code>runWrapped</code> 方法内调用的 <code>getNextStage</code> :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.bumptech.glide.load.engine.DecodeJob</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> DataFetcherGenerator <span class="title">getNextGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (stage) &#123;</span><br><span class="line">        <span class="keyword">case</span> RESOURCE_CACHE:<span class="comment">//解码之后的资源缓存</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ResourceCacheGenerator(decodeHelper, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">case</span> DATA_CACHE:<span class="comment">//源数据的缓存</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DataCacheGenerator(decodeHelper, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">case</span> SOURCE:<span class="comment">//数据源</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SourceGenerator(decodeHelper, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">case</span> FINISHED:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unrecognized stage: "</span> + stage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>DataFetcherGenerator</code> : 注册 <code>ModelLoaders</code> 和 <code>Model</code> 的数据提取构造器。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">DataFetcherGenerator</span> </span>&#123;</span><br><span class="line">    <span class="comment">//尝试使用一个新的DataFetcher，则返回true已启动，否则为false。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">startNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//尝试取消当前正在运行的提取程序</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ResourceCacheGenerator</code> 、<code>DataCacheGenerator</code> 和 <code>SourceGenerator</code> 除过实现了<code>DataFetcherGenerator</code> 还实现了 <code>DataCallback</code> 接口。</p>
<blockquote>
<p><code>DataCallback</code> : 数据已加载且可用时或加载时必须调用的回调失败。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">DataCallback</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//如果加载成功，则使用加载的数据进行调用；如果加载失败，则使用null进行调用。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onDataReady</span><span class="params">(@Nullable T data)</span></span>;</span><br><span class="line">    <span class="comment">//加载失败时调用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onLoadFailed</span><span class="params">(@NonNull Exception e)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取到<code>DataFetcherGenerator</code> 构造器之后执行 <code>startNext</code> ，判断是否下一步能开始加载数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.bumptech.glide.load.engine.EngineJob</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runGenerators</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    currentThread = Thread.currentThread();</span><br><span class="line">    startFetchTime = LogTime.getLogTime();</span><br><span class="line">    <span class="keyword">boolean</span> isStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isCancelled &amp;&amp; currentGenerator != <span class="keyword">null</span> </span><br><span class="line">        &amp;&amp; !(isStarted = currentGenerator.startNext())) &#123;<span class="comment">//执行当前数据构造的判断是否能加载数据</span></span><br><span class="line">        stage = getNextStage(stage);<span class="comment">//切换数据状态</span></span><br><span class="line">        currentGenerator = getNextGenerator();<span class="comment">//获取新的数据构造器</span></span><br><span class="line">        <span class="keyword">if</span> (stage == Stage.SOURCE) &#123;<span class="comment">//需要需要进行源数据加载那么切换执行线程</span></span><br><span class="line">            reschedule();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果已经完成或者取消，而且没开始获取数据。那么通知失败</span></span><br><span class="line">    <span class="keyword">if</span> ((stage == Stage.FINISHED || isCancelled) &amp;&amp; !isStarted) &#123;</span><br><span class="line">        notifyFailed();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则，生成器将开始新的加载，我们希望将其调回onDataFetcherReady。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ResourceCacheGenerator"><a href="#ResourceCacheGenerator" class="headerlink" title="ResourceCacheGenerator"></a>ResourceCacheGenerator</h4><blockquote>
<p><code>ResourceCacheGenerator</code> ：从包含降采样/转换后的资源缓存文件中获取数据。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResourceCacheGenerator</span> <span class="keyword">implements</span> <span class="title">DataFetcherGenerator</span>, <span class="title">DataFetcher</span>.<span class="title">DataCallback</span>&lt;<span class="title">Object</span>&gt; </span>&#123;    </span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Key&gt; sourceIds = helper.getCacheKeys();<span class="comment">//能处理Model（myUrl）的LoadData列表，返回其Key</span></span><br><span class="line">        <span class="keyword">if</span> (sourceIds.isEmpty()) &#123;<span class="comment">//如果没有，那么标示Model（myUrl）这个数据类型无法处理，直接返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取glide中注册的，能加载Model（url），能解码resourceClass（Drawable），能转码transcodeClass(Object)的组件集合</span></span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; resourceClasses = helper.getRegisteredResourceClasses();</span><br><span class="line">        <span class="keyword">if</span> (resourceClasses.isEmpty()) &#123;<span class="comment">//如果没有适配的组件集合，而且转码的类型为文件的话那么抛异常。因为File都不能转码那么根本无法磁盘缓存</span></span><br><span class="line">            <span class="keyword">if</span> (File.class.equals(helper.getTranscodeClass())) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="comment">/***部分代码省略***/</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (modelLoaders == <span class="keyword">null</span> || !hasNextModelLoader()) &#123;<span class="comment">//如果还有modelLoader</span></span><br><span class="line">            resourceClassIndex++;</span><br><span class="line">            <span class="comment">//双重判断使LoadData列表进行完全遍历</span></span><br><span class="line">            <span class="keyword">if</span> (resourceClassIndex &gt;= resourceClasses.size()) &#123;</span><br><span class="line">                sourceIdIndex++;</span><br><span class="line">                <span class="keyword">if</span> (sourceIdIndex &gt;= sourceIds.size()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                resourceClassIndex = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Key sourceId = sourceIds.get(sourceIdIndex);</span><br><span class="line">            Class&lt;?&gt; resourceClass = resourceClasses.get(resourceClassIndex);</span><br><span class="line">            Transformation&lt;?&gt; transformation = helper.getTransformation(resourceClass);</span><br><span class="line">            <span class="comment">//ResourceCacheKey用于下采样和转换的资源数据的缓存密钥+任何请求的签名。</span></span><br><span class="line">            currentKey =</span><br><span class="line">                <span class="keyword">new</span> ResourceCacheKey(</span><br><span class="line">                    helper.getArrayPool(),</span><br><span class="line">                    sourceId,<span class="comment">//modelLoaddata</span></span><br><span class="line">                    helper.getSignature(),<span class="comment">//签名</span></span><br><span class="line">                    helper.getWidth(),<span class="comment">//宽</span></span><br><span class="line">                    helper.getHeight(),<span class="comment">//高</span></span><br><span class="line">                    transformation,<span class="comment">//转换</span></span><br><span class="line">                    resourceClass,<span class="comment">//解码</span></span><br><span class="line">                    helper.getOptions());</span><br><span class="line">            cacheFile = helper.getDiskCache().get(currentKey);</span><br><span class="line">            <span class="comment">//判断Resource是否有缓存，如果有那么加载这个缓存文件数据</span></span><br><span class="line">            <span class="keyword">if</span> (cacheFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">                sourceKey = sourceId;</span><br><span class="line">                modelLoaders = helper.getModelLoaders(cacheFile);<span class="comment">//获取能加载文件的ModelLoader列表</span></span><br><span class="line">                modelLoaderIndex = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        loadData = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!started &amp;&amp; hasNextModelLoader()) &#123;</span><br><span class="line">            ModelLoader&lt;File, ?&gt; modelLoader = modelLoaders.get(modelLoaderIndex++);</span><br><span class="line">            <span class="comment">//ModelLoader根据cacheFile，width，height，options构造LoadData</span></span><br><span class="line">            loadData = modelLoader.buildLoadData(cacheFile, helper.getWidth(), helper.getHeight(), helper.getOptions());</span><br><span class="line">            <span class="comment">//该LoadData是否被Glide进行加载过，是否可用</span></span><br><span class="line">            <span class="keyword">if</span> (loadData != <span class="keyword">null</span> &amp;&amp; helper.hasLoadPath(loadData.fetcher.getDataClass())) &#123;</span><br><span class="line">                started = <span class="keyword">true</span>;<span class="comment">//如果可用，那么使用该LoadData中的DataFetcher进行数据获取</span></span><br><span class="line">                loadData.fetcher.loadData(helper.getPriority(), <span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> started;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LoadData&lt;?&gt; local = loadData;</span><br><span class="line">        <span class="keyword">if</span> (local != <span class="keyword">null</span>) &#123;</span><br><span class="line">            local.fetcher.cancel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span><span class="comment">//数据已经准备好，标识数据源为RESOURCE_DISK_CACHE</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataReady</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">        cb.onDataFetcherReady(</span><br><span class="line">            sourceKey, data, loadData.fetcher, DataSource.RESOURCE_DISK_CACHE, currentKey);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span><span class="comment">//加载失败，标识数据源为RESOURCE_DISK_CACHE</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoadFailed</span><span class="params">(@NonNull Exception e)</span> </span>&#123;</span><br><span class="line">        cb.onDataFetcherFailed(currentKey, e, loadData.fetcher, DataSource.RESOURCE_DISK_CACHE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="DataCacheGenerator"><a href="#DataCacheGenerator" class="headerlink" title="DataCacheGenerator"></a>DataCacheGenerator</h4><blockquote>
<p><code>DataCacheGenerator</code> ： 构造来自包含原始未修改源数据的缓存文件。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataCacheGenerator</span> <span class="keyword">implements</span> <span class="title">DataFetcherGenerator</span>, <span class="title">DataFetcher</span>.<span class="title">DataCallback</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果还有modelLoader</span></span><br><span class="line">        <span class="keyword">while</span> (modelLoaders == <span class="keyword">null</span> || !hasNextModelLoader()) &#123;</span><br><span class="line">            sourceIdIndex++;</span><br><span class="line">            <span class="comment">//cacheKyes（helper.getCacheKeys）在构造的时候传入，和ResourceCacheGenerator的相同</span></span><br><span class="line">            <span class="keyword">if</span> (sourceIdIndex &gt;= cacheKeys.size()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Key sourceId = cacheKeys.get(sourceIdIndex);</span><br><span class="line">            <span class="comment">//原始源数据的缓存键和任何请求的签名。</span></span><br><span class="line">            Key originalKey = <span class="keyword">new</span> DataCacheKey(sourceId, helper.getSignature());</span><br><span class="line">            cacheFile = helper.getDiskCache().get(originalKey);</span><br><span class="line">            <span class="comment">//判断Resource是否有缓存，如果有那么加载这个缓存文件数据</span></span><br><span class="line">            <span class="keyword">if</span> (cacheFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.sourceKey = sourceId;</span><br><span class="line">                modelLoaders = helper.getModelLoaders(cacheFile);<span class="comment">//获取能加载文件的ModelLoader列表</span></span><br><span class="line">                modelLoaderIndex = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        loadData = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!started &amp;&amp; hasNextModelLoader()) &#123;</span><br><span class="line">            ModelLoader&lt;File, ?&gt; modelLoader = modelLoaders.get(modelLoaderIndex++);</span><br><span class="line">            <span class="comment">//ModelLoader根据cacheFile，width，height，options构造LoadData</span></span><br><span class="line">            loadData = modelLoader.buildLoadData(cacheFile, helper.getWidth(), helper.getHeight(), helper.getOptions());</span><br><span class="line">            <span class="comment">//该LoadData是否被Glide进行加载过，是否可用</span></span><br><span class="line">            <span class="keyword">if</span> (loadData != <span class="keyword">null</span> &amp;&amp; helper.hasLoadPath(loadData.fetcher.getDataClass())) &#123;</span><br><span class="line">                started = <span class="keyword">true</span>;<span class="comment">//如果可用，那么使用该LoadData中的DataFetcher进行数据获取</span></span><br><span class="line">                loadData.fetcher.loadData(helper.getPriority(), <span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> started;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataReady</span><span class="params">(Object data)</span> </span>&#123;<span class="comment">//数据已经准备好，标识数据源为DATA_DISK_CACHE</span></span><br><span class="line">        cb.onDataFetcherReady(sourceKey, data, loadData.fetcher, DataSource.DATA_DISK_CACHE, sourceKey);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoadFailed</span><span class="params">(@NonNull Exception e)</span> </span>&#123;<span class="comment">//加载失败，标识数据源为DATA_DISK_CACHE</span></span><br><span class="line">        cb.onDataFetcherFailed(sourceKey, e, loadData.fetcher, DataSource.DATA_DISK_CACHE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出来 <code>ResourceCacheGenerator</code> 的实现其实和 <code>DataCacheGenerator</code> 的实现逻辑很相似，只不过是缓存的 <code>Key</code> 不同而已。</p>
<h3 id="源数据请求"><a href="#源数据请求" class="headerlink" title="源数据请求"></a>源数据请求</h3><blockquote>
<p><code>SourceGenerator</code> ： 根据磁盘缓存策略，可以先将源数据编码后写入磁盘，然后再加载从缓存文件而不是直接返回。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SourceGenerator</span> <span class="keyword">implements</span> <span class="title">DataFetcherGenerator</span>,<span class="title">DataFetcher</span>.<span class="title">DataCallback</span>&lt;<span class="title">Object</span>&gt;,</span></span><br><span class="line"><span class="class">				<span class="title">DataFetcherGenerator</span>.<span class="title">FetcherReadyCallback</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DataCacheGenerator sourceCacheGenerator;<span class="comment">//磁盘缓存的数据构造器</span></span><br><span class="line">    <span class="keyword">private</span> Object dataToCache;<span class="comment">//需要缓存的数据</span></span><br><span class="line">    <span class="keyword">private</span> DataCacheKey originalKey;<span class="comment">//磁盘缓存的key</span></span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dataToCache != <span class="keyword">null</span>) &#123;<span class="comment">//是否已经拥有缓存的数据</span></span><br><span class="line">            Object data = dataToCache;</span><br><span class="line">            dataToCache = <span class="keyword">null</span>;</span><br><span class="line">            cacheData(data);<span class="comment">//进行据缓存，缓存后sourceCacheGenerator不为空</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//由SourceGenerator转到DataCacheGenerator（网络转磁盘）</span></span><br><span class="line">        <span class="keyword">if</span> (sourceCacheGenerator != <span class="keyword">null</span> &amp;&amp; sourceCacheGenerator.startNext()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sourceCacheGenerator = <span class="keyword">null</span>;</span><br><span class="line">        loadData = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!started &amp;&amp; hasNextModelLoader()) &#123;<span class="comment">//如果还有LoadData(model,width，height，options构造LoadData)</span></span><br><span class="line">            loadData = helper.getLoadData().get(loadDataListIndex++);</span><br><span class="line">            <span class="comment">//fetcher.getDataSource()是否可以进行磁盘缓存</span></span><br><span class="line">            <span class="keyword">if</span> (loadData != <span class="keyword">null</span> &amp;&amp; (helper.getDiskCacheStrategy().isDataCacheable(loadData.fetcher.getDataSource())</span><br><span class="line">                    || helper.hasLoadPath(loadData.fetcher.getDataClass()))) &#123;<span class="comment">//该LoadData是否被Glide进行加载过，是否可用</span></span><br><span class="line">                started = <span class="keyword">true</span>;<span class="comment">//如果可用，那么使用该LoadData中的DataFetcher进行数据获取</span></span><br><span class="line">                loadData.fetcher.loadData(helper.getPriority(), <span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> started;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cacheData</span><span class="params">(Object dataToCache)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = LogTime.getLogTime();</span><br><span class="line">        <span class="keyword">try</span> &#123;<span class="comment">//获取dataToCache对应的解码器，StreamEncoder</span></span><br><span class="line">            Encoder&lt;Object&gt; encoder = helper.getSourceEncoder(dataToCache);</span><br><span class="line">            DataCacheWriter&lt;Object&gt; writer = <span class="keyword">new</span> DataCacheWriter&lt;&gt;(encoder, dataToCache, helper.getOptions());</span><br><span class="line">            originalKey = <span class="keyword">new</span> DataCacheKey(loadData.sourceKey, helper.getSignature());<span class="comment">//生成数据源的key</span></span><br><span class="line">            helper.getDiskCache().put(originalKey, writer);<span class="comment">//将writer写入到磁盘缓存中，对应的key为originalKey</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            loadData.fetcher.cleanup();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//构造原始数据缓存构造器，转到磁盘读取数据</span></span><br><span class="line">        sourceCacheGenerator = <span class="keyword">new</span> DataCacheGenerator(Collections.singletonList(loadData.sourceKey), helper, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span><span class="comment">//数据加载成功回调，date类型为InputStream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataReady</span><span class="params">(Object data)</span> </span>&#123;DiskCacheStrategy diskCacheStrategy = helper.getDiskCacheStrategy();</span><br><span class="line">        <span class="comment">//如果数据不为空，而且可以缓存那么机进行SourceGenerator转DataCacheGenerator</span></span><br><span class="line">        <span class="keyword">if</span> (data != <span class="keyword">null</span> &amp;&amp; diskCacheStrategy.isDataCacheable(loadData.fetcher.getDataSource())) &#123;</span><br><span class="line">            dataToCache = data;</span><br><span class="line">            cb.reschedule();<span class="comment">//切换线程，切换完之后currentGenerator还是SourceGenerator</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//否早直接将数据进行回调</span></span><br><span class="line">            cb.onDataFetcherReady(loadData.sourceKey,data,loadData.fetcher,loadData.fetcher.getDataSource(),originalKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span><span class="comment">//数据加载失败回调</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoadFailed</span><span class="params">(@NonNull Exception e)</span> </span>&#123;</span><br><span class="line">        cb.onDataFetcherFailed(originalKey, e, loadData.fetcher, loadData.fetcher.getDataSource());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span><span class="comment">//DataCacheGenerator的数据加载成功回调，data类型为ByteBuffer</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataFetcherReady</span><span class="params">(Key sourceKey, Object data, DataFetcher&lt;?&gt; fetcher, DataSource dataSource, Key attemptedKey)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 此数据提取程序将从文件中加载并提供错误的数据源，因此请覆盖使用原始提取程序的数据源 </span></span><br><span class="line">        cb.onDataFetcherReady(sourceKey, data, fetcher, loadData.fetcher.getDataSource(), sourceKey);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span><span class="comment">//DataCacheGenerator的数据加载失败回调</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataFetcherFailed</span><span class="params">(Key sourceKey, Exception e, DataFetcher&lt;?&gt; fetcher, DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        cb.onDataFetcherFailed(sourceKey, e, fetcher, loadData.fetcher.getDataSource());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>SourceGenerator</code> 、<code>DataCacheGenerator</code> 和 <code>ResourceCacheGenerator</code> 的 <code>startNext</code> 方法都会寻找合适的 <code>ModelLoader</code> 构建对应的 <code>LoadData</code> 来加载数据。</p>
<p>现在我们的 <code>Model</code> 是 <code>myUrl</code> 一个网络图片地址，在没有加载过之前<code>ResourceCacheGenerator</code> 和 <code>DataCacheGenerator</code> 当然是没有缓存的，所以我们这里用<code>SourceGenerator</code> 加载一个网络图片的过程在详细讲述一下 <code>startNext</code> 中怎么获取<code>LoadData</code> 进行数据加载（其他两个都实现都类似）。</p>
<blockquote>
<p>需要注意的是<code>Data</code>已经是从磁盘缓存读出来的 <code>ByteBuffer</code> ，但是<code>DataSource</code> 还是 <code>REMOTE</code> 。</p>
</blockquote>
<h3 id="数据解码和转码"><a href="#数据解码和转码" class="headerlink" title="数据解码和转码"></a>数据解码和转码</h3><p>无论加载的缓存还是其他的数据成功后都会回调 <code>onDataFetcherReady</code> ，然后进行数据解码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.bumptech.glide.load.engine.DecodeJob</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataFetcherReady</span><span class="params">(Key sourceKey, Object data, DataFetcher&lt;?&gt; fetcher, DataSource dataSource, Key attemptedKey)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.currentSourceKey = sourceKey;<span class="comment">//url</span></span><br><span class="line">    <span class="keyword">this</span>.currentData = data;<span class="comment">//ByteBuffer</span></span><br><span class="line">    <span class="keyword">this</span>.currentFetcher = fetcher;<span class="comment">//ByteBufferFetcher</span></span><br><span class="line">    <span class="keyword">this</span>.currentDataSource = dataSource;<span class="comment">//REMOTE</span></span><br><span class="line">    <span class="keyword">this</span>.currentAttemptingKey = attemptedKey;<span class="comment">//url</span></span><br><span class="line">    <span class="comment">//如果当前线程不是主线程，那么切换到主线程执行数据解码（调用decodeFromRetrievedData）</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != currentThread) &#123;</span><br><span class="line">        runReason = RunReason.DECODE_DATA;</span><br><span class="line">        callback.reschedule(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        GlideTrace.beginSection(<span class="string">"DecodeJob.decodeFromRetrievedData"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            decodeFromRetrievedData();<span class="comment">//进行数据解码</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            GlideTrace.endSection();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来的步骤：</p>
<ol>
<li><code>decodeFromRetrievedData</code> 中调用 <code>decodeFromData</code> ；</li>
<li><code>decodeFromData</code> 中调用 <code>decodeFromFetcher</code> ；</li>
<li><code>decodeFromFetcher</code> 获取 <code>Registry.getLoadPath</code>  以及 <code>Registry.getRewinder</code>；</li>
</ol>
<p>最终是为了获得 <code>DecodePaht</code> 和 <code>LoadPath</code> 。</p>
<h4 id="解码-amp-渐变-amp-转码"><a href="#解码-amp-渐变-amp-转码" class="headerlink" title="解码&amp;渐变&amp;转码"></a>解码&amp;渐变&amp;转码</h4><blockquote>
<p><code>LoadPath</code> ：一个或多个 <code>DecodePath</code> 来进行数据的解码；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.bumptech.glide.Registry</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> &lt;Data, TResource, Transcode&gt; <span class="function">LoadPath&lt;Data, TResource, Transcode&gt; <span class="title">getLoadPath</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      @NonNull Class&lt;Data&gt; dataClass,//ByteBuffer.class</span></span></span><br><span class="line"><span class="function"><span class="params">      @NonNull Class&lt;TResource&gt; resourceClass,//Object.class</span></span></span><br><span class="line"><span class="function"><span class="params">      @NonNull Class&lt;Transcode&gt; transcodeClass)</span> </span>&#123;<span class="comment">//Drawable.class</span></span><br><span class="line">    LoadPath&lt;Data, TResource, Transcode&gt; result = loadPathCache.get(dataClass, resourceClass, transcodeClass);</span><br><span class="line">    <span class="keyword">if</span> (loadPathCache.isEmptyLoadPath(result)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">        List&lt;DecodePath&lt;Data, TResource, Transcode&gt;&gt; decodePaths = getDecodePaths(dataClass, resourceClass, transcodeClass);</span><br><span class="line">        <span class="comment">//可能无法将给定的类型解码或转码为所需的类型数据类。 </span></span><br><span class="line">        <span class="keyword">if</span> (decodePaths.isEmpty()) &#123;</span><br><span class="line">            result = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = <span class="keyword">new</span> LoadPath&lt;&gt;(dataClass, resourceClass, transcodeClass, decodePaths, throwableListPool);</span><br><span class="line">        &#125;</span><br><span class="line">        loadPathCache.put(dataClass, resourceClass, transcodeClass, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>DecodePath</code> ：尝试从给定的数据类型解码和转码资源类型；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.bumptech.glide.Registry</span></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">private</span> &lt;Data, TResource, Transcode&gt; List&lt;DecodePath&lt;Data, TResource, Transcode&gt;&gt; getDecodePaths(</span><br><span class="line">      <span class="meta">@NonNull</span> Class&lt;Data&gt; dataClass,</span><br><span class="line">      <span class="meta">@NonNull</span> Class&lt;TResource&gt; resourceClass,</span><br><span class="line">      <span class="meta">@NonNull</span> Class&lt;Transcode&gt; transcodeClass) &#123;</span><br><span class="line">    List&lt;DecodePath&lt;Data, TResource, Transcode&gt;&gt; decodePaths = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//GifDrawable,Bitmap,BitmapDrawable</span></span><br><span class="line">    List&lt;Class&lt;TResource&gt;&gt; registeredResourceClasses = decoderRegistry.getResourceClasses(dataClass, resourceClass);</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;TResource&gt; registeredResourceClass : registeredResourceClasses) &#123;</span><br><span class="line">        List&lt;Class&lt;Transcode&gt;&gt; registeredTranscodeClasses = transcoderRegistry.getTranscodeClasses(registeredResourceClass, transcodeClass);</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;Transcode&gt; registeredTranscodeClass : registeredTranscodeClasses) &#123;</span><br><span class="line">            List&lt;ResourceDecoder&lt;Data, TResource&gt;&gt; decoders = decoderRegistry.getDecoders(dataClass, registeredResourceClass);</span><br><span class="line">            ResourceTranscoder&lt;TResource, Transcode&gt; transcoder = transcoderRegistry.get(registeredResourceClass, registeredTranscodeClass);</span><br><span class="line">            <span class="comment">//transcoder=DrawableBytesTranscoder</span></span><br><span class="line">            DecodePath&lt;Data, TResource, Transcode&gt; path =</span><br><span class="line">                <span class="keyword">new</span> DecodePath&lt;&gt;(</span><br><span class="line">                    dataClass,<span class="comment">//ByteBuffer</span></span><br><span class="line">                    registeredResourceClass,<span class="comment">//GifDrawable/Bitmap/BitmapDrawable</span></span><br><span class="line">                    registeredTranscodeClass,<span class="comment">//Drawable/Drawable/Drawable</span></span><br><span class="line">              			<span class="comment">//ByteBufferGifDecoder/ByteBufferBitmapDecoder/BitmapDrawableDecoder</span></span><br><span class="line">                    decoders,</span><br><span class="line">              			<span class="comment">///UnitTranscoder/BitmapDrawableTranscoder/UnitTranscoder</span></span><br><span class="line">                    transcoder,</span><br><span class="line">                    throwableListPool);</span><br><span class="line">            decodePaths.add(path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> decodePaths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>解码的时候调用 <code>DecodePath.decode</code> 方法，该方法会循环遍历内部的<code>decoders</code>列表中的 <code>ResourceDecoder</code> 如果<code>ByteBufferBitmapDecoder.decode</code>解码成功(<code>Bitmap</code>)直接返回。</li>
<li>继续回调判断是或否进行<code>transform</code> 如果需要那么 <code>DecodeJob.onResourceDecoded</code> 进行 <code>transform</code> 进行资源的渐变，渐变之后重新构造缓存的 <code>Key</code> 将再次进行 <code>Encoder</code> 。</li>
<li>然后再进行 <code>BitmapDrawableTranscoder.transcode</code> 进行转码得到 <code>LazyBitmapDrawableResource</code> 。</li>
<li>回到 <code>notifyEncodeAndRelease</code> 方法进行资源成功回调，以及判断判断是否需要 <code>Encoder</code> 进行磁盘缓存，回调编码成功释放资源。</li>
</ol>
<center><img src="https://img-blog.csdnimg.cn/20191220192134589.png#pic_center" alt="在这里插入图片描述"></center>

<p>至此整个资源的获取过程完成，最后我们获取出了<code>Drawable</code> 。</p>
<h3 id="加载-amp-释放资源"><a href="#加载-amp-释放资源" class="headerlink" title="加载&amp;释放资源"></a>加载&amp;释放资源</h3><blockquote>
<p><code>DecodeJob</code></p>
</blockquote>
<ul>
<li><p>进行 <code>notifyComplete</code> : 回调 <code>EngineJob.onResourceReady</code> ;</p>
</li>
<li><p>进行 <code>onEncodeComplete</code> ：释放当前的 <code>DecodeJob</code> ;</p>
</li>
</ul>
<blockquote>
<p><code>EngineJob</code></p>
</blockquote>
<ul>
<li>进行 <code>notifyCallbacksOfResult</code> ，回调 <code>incrementPendingCallbacks</code> 进行资源的引用+1 ；</li>
<li>回调 <code>Engine.onEngineJobComplete</code> ；</li>
<li>执行 <code>CallResourceReady</code> 任务，回调 <code>SingleRequest.onResourceReady</code> ，并进行资源的引用+1；</li>
<li>执行 <code>decrementPendingCallbacks</code> 进行资源的引用-1；</li>
</ul>
<blockquote>
<p><code>Engine</code></p>
</blockquote>
<ul>
<li>将资源添加到 <code>activeResource</code> ;</li>
<li>移除当前<code>jobs</code> 中对应的 <code>EngineJob</code>;</li>
</ul>
<blockquote>
<p><code>SingleRequest</code></p>
</blockquote>
<ul>
<li>判断&amp;校验，获取资源；</li>
<li>进行 <code>target.onResourceReadt</code> 将资源加载到 <code>View</code> 上。 </li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>因为上一篇文章是 <a href="https://dandanlove.blog.csdn.net/article/details/103256724" target="_blank" rel="noopener">Android-Universal-Image-Loader源码分析</a>  ，所以这里主要是结合 <code>ImageLoader</code> 来和 <code>Glide</code> 进行比较。</p>
<blockquote>
<p>功能</p>
</blockquote>
<ol>
<li><code>Glide</code> 默认的网络请求和 <code>ImageLoader</code> 相同都是 <code>HttpUrlConnection</code>；</li>
<li><code>Glide</code> 和 <code>ImageLoader</code> 都可以添加自定义的网络请求比如 <code>OkHttp</code> ;</li>
<li><code>Glide</code> 和 <code>ImageLoader</code> 都支持在图片加载前获取图片的数据（图片的宽、高）。</li>
<li><code>Glide</code> 会根据请求时会根据当前 <code>context</code> 的声明周期进行 <code>Request</code> 的管理（粒度为 <code>Application</code> 和 <code>Activity</code>）。这个功能是 <code>ImageLoader</code> 不具备的，<code>ImageLoader</code> 只能停止一个请求，或者停止所有请求。</li>
<li><code>Glide</code> 和 <code>ImageLoader</code> 都具有加载默认图、加载失败备用图的功能。</li>
<li><code>Glide</code> 具备加载缩略图的功能，这个功能是 <code>ImageLoader</code> 不具备的。</li>
<li><code>Glide</code> 可以设置请求时候的优先级，虽然说这个请求优先级不是十分严格仅仅是指导来做请求的优化处理，但这个功能是 <code>ImageLoader</code> 不具备的。</li>
<li><code>Glide</code> 加载图片的数据可支持多种类型，<code>ImageLoader</code> 只支持 <code>String</code> 。</li>
<li><code>Glide</code> 和 <code>ImageLoader</code> 都可以自定义配置图片加载库使用的 <code>download</code> 、<code>decoder</code> 、<code>executor</code> 、<code>cache</code> 等，只不过 <code>Glide</code> 对自定义模块配置更加的方便以及粒度更细。</li>
</ol>
<blockquote>
<p>缓存</p>
</blockquote>
<ol>
<li><code>ImageLoader</code> 缓存的 <code>key</code> 只能根据图片地址进行处理生成。 <code>Glide</code> 的原始数据的磁盘缓存的 <code>Key</code> 是由 <code>url</code> 和 <code>signature</code> 组成，资源图片的缓存（磁盘缓存和内存缓存）的 <code>Key</code> 是由图片的（宽、高、资源类型、资源转换类型、资源解码类型、签名、<code>model</code> 以及 <code>option</code>）组成而且签名可以由我们自己的 <code>request</code> 进行设置。</li>
<li><code>Gilde</code> 可以进行请求时的设置跳过缓存，或者进行 <code>signature</code> 设置防止缓存失效问题。这个是 <code>ImageLoader</code> 不具备的功能。</li>
<li><code>Glide</code> 进行渐变处理的图片会被再次缓存，这个功能是 <code>ImageLoader</code> 不具备的。</li>
<li><code>Glide</code> 的内存缓存分为两级<code>MemoryCache</code> 和 <code>ActiveResource</code> ，<code>MemoryCache</code> 和 <code>ImageLoader</code> 相同都是使用 <code>LruCache</code> ，<code>ActiveResource</code> 对正在使用的图片做了弱引用，防止使用中的 <code>资源</code> 被 <code>LRU</code> 算法回收掉。</li>
</ol>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Glide</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-Universal-Image-Loader源码分析</title>
    <url>/2019/11/26/AndroidUniversalImageLoader/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>ImageLoader</code> 是 <code>android</code> 使用中出现比较早（PS：即的刚接触安卓项目的时候就用的是这个图片加载图，算算已经快5年了），使用最多的一个开源图片加载库了。随着<code>glide</code> , <code>fresco</code> 和 <code>picasso</code>等图片加载的库出现，<code>ImageLoader</code>使用变得越来越少。最近在看其他图片加载库的源码，顺便补补之前错过的一些事情。</p>
<p>代码仓库地址：<a href="https://github.com/nostra13/Android-Universal-Image-Loader" target="_blank" rel="noopener">Android-Universal-Image-Loader</a></p>
<h1 id="ImageLoader"><a href="#ImageLoader" class="headerlink" title="ImageLoader"></a>ImageLoader</h1><p><img src="https://img-blog.csdnimg.cn/20191126150914933.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kYW5kYW5sb3ZlLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>这个是 <code>ImageLoader</code> 的架构，<code>ImageLader</code> 图片加载库的主要组成部分都包括在其中。</p>
<p>下边这幅图对应的是，组成上面架构的每个部分的对应的类实现：</p>
<p><img src="https://img-blog.csdnimg.cn/201911261509582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kYW5kYW5sb3ZlLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li><code>ImageLoader</code> ：为<code>ImageView</code> 下载和展示图片的单例；</li>
<li><code>DisplayImageOptions</code> : 图片展示的配置项（加载中、空url、加载失败默认图等）；</li>
<li><code>ImageLoaderConfiguration</code> : <code>ImageLoader</code> 的配置项；</li>
<li><code>ImageAware</code> ：表示图像感知视图，该视图提供了图像处理和显示所需的所有属性和行为；</li>
<li><code>ImageLoadingListener</code> ：监听图片加载进度，开始、失败、成功、取消；</li>
<li><code>ImageLoaderEngine</code> ：执行图片下载和展现任务；</li>
<li><code>BitmapDisplayer</code> ：展现 <code>Bitmap</code> 在 <code>ImageView</code> 上的时候可以修改这个 <code>Bitmap</code> 或添加展示的动画效果；</li>
<li><code>BitmapProcessor</code> ：可以处理原始的<code>Bitmap</code> ；</li>
<li><code>MemoryCache</code> ： <code>Bitmap</code> 内存缓存接口；</li>
<li><code>DiskCache</code> ：磁盘缓存；</li>
<li><code>ImageDecoder</code> ：根据<code>ImageDecodingInfo</code>信息得到图片并根据参数将其转换为 Bitmap。</li>
<li><code>ImageDownloader</code> ：通过<code>URI</code> 获取图片；</li>
<li><code>DisplayBitmapTask</code> ：展示图片并进行回调；</li>
<li><code>ProcessAndDisplayImageTask</code> ：处理图片和展现图片的任务，用于加载内存缓存中的图片；</li>
<li><code>LoadAndDisplayImagTask</code> ：处理加载和显示图像的任务，用于从Internet或文件系统加载图像为 <code>Bitmap</code>；</li>
</ul>
<h2 id="Config配置"><a href="#Config配置" class="headerlink" title="Config配置"></a>Config配置</h2><p>初始化配置参数，参数<code>configuration</code>为<code>ImageLoader</code>的配置信息，包括图片最大尺寸、任务线程池、磁盘缓存、下载器、解码器等等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ImageLoaderConfiguration&#123;</span><br><span class="line">    <span class="keyword">final</span> Resources resources;<span class="comment">//上下文环境中的resource</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> maxImageWidthForMemoryCache;<span class="comment">//内存缓存最大宽度</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> maxImageHeightForMemoryCache;<span class="comment">//内存缓存最大高度</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> maxImageWidthForDiskCache;<span class="comment">//磁盘缓存最大宽度</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> maxImageHeightForDiskCache;<span class="comment">//磁盘缓存最大高度</span></span><br><span class="line">    <span class="comment">//在将图像保存到磁盘缓存之前先对其进行调整大小/压缩处理</span></span><br><span class="line">    <span class="keyword">final</span> BitmapProcessor processorForDiskCache;</span><br><span class="line">    <span class="keyword">final</span> Executor taskExecutor;<span class="comment">//自定义图片加载和展现的线程池</span></span><br><span class="line">    <span class="keyword">final</span> Executor taskExecutorForCachedImages;<span class="comment">//自定义展现在磁盘上的图片的线程池</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> customExecutor;<span class="comment">//是否自定义下载的线程池</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> customExecutorForCachedImages;<span class="comment">//是否自定义缓存图片的线程池</span></span><br><span class="line">    <span class="comment">//默认核心线程数和线程池容量为3</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> threadPoolSize;</span><br><span class="line">    <span class="comment">//默认的线程优先级低两级</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> threadPriority;</span><br><span class="line">    <span class="comment">//LIFO,FIFO;默认为先进先出FIFO</span></span><br><span class="line">    <span class="keyword">final</span> QueueProcessingType tasksProcessingType;</span><br><span class="line">    <span class="comment">//内存缓存，默认为MemoryClass的八分之一，3.0之后为LargeMemoryClass的八分之一</span></span><br><span class="line">    <span class="comment">//如果开启denyCacheImageMultipleSizesInMemory，那么缓存为FuzzyKeyMemoryCache实例，只判断图片地址不判断大小，如果相同那么刷新缓存</span></span><br><span class="line">    <span class="keyword">final</span> MemoryCache memoryCache;</span><br><span class="line">    <span class="comment">//LruDiskCache，大小默认存储为Long.MAX_VALUE，默认最大数量为Long.MAX_VALUE;</span></span><br><span class="line">    <span class="keyword">final</span> DiskCache diskCache;</span><br><span class="line">    <span class="comment">//通过URI从网络或文件系统或应用程序资源中检索图像，默认为HttpURLConnection进行网络下载</span></span><br><span class="line">    <span class="comment">//提供了imageDownloader方法可以自定义，比如使用HttpClient或者OkHttp</span></span><br><span class="line">    <span class="keyword">final</span> ImageDownloader downloader;</span><br><span class="line">    <span class="comment">//将图像解码为Bitmap，将其缩放到所需大小</span></span><br><span class="line">    <span class="keyword">final</span> ImageDecoder decoder;</span><br><span class="line">    <span class="comment">//包含图像显示选项(默认图设置以及其他默认选项)</span></span><br><span class="line">    <span class="keyword">final</span> DisplayImageOptions defaultDisplayImageOptions;</span><br><span class="line">    <span class="comment">//网络禁止下载器，一般不直接应用</span></span><br><span class="line">    <span class="keyword">final</span> ImageDownloader networkDeniedDownloader;</span><br><span class="line">    <span class="comment">//在慢速网络上处理下载</span></span><br><span class="line">    <span class="keyword">final</span> ImageDownloader slowNetworkDownloader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一个对于某个<code>ImageView</code> 进行展示设置的 <code>DisplayImageOptions</code> ，配置图片显示的配置项。比如加载前、加载中、加载失败应该显示的占位图片，图片是否需要在磁盘缓存，是否需要在内存缓存等。</p>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>讲视图主要是想让<code>ImageView</code> 与 <code>ImageLoader</code> 联系在一起来，<code>ImageLoader</code> 通过 <code>ImageAware</code> 接口实现图片在视图上的展现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImageAware</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getWidth</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">ViewScaleType <span class="title">getScaleType</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">View <span class="title">getWrappedView</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isCollected</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">setImageDrawable</span><span class="params">(Drawable drawable)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">setImageBitmap</span><span class="params">(Bitmap bitmap)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>ImageAware-&gt;ViewAware</li>
<li>ImageAware-&gt;ViewAware-&gt;ImageViewAware</li>
<li>ImageAware-&gt;NonViewAware</li>
</ul>
<p>其中 <code>ViewAware</code> 是抽象类，所以 <code>ImageAware</code> 只有 <code>ImageViewAware</code> 和 <code>NonViewAware</code> 两个实现类。 </p>
<p><code>NonViewAware</code> 提供处理原始图像所需的信息，但不显示图像。当用户只需要加载和解码图像的时候可以使用它。</p>
<h2 id="加载回调"><a href="#加载回调" class="headerlink" title="加载回调"></a>加载回调</h2><p>主要进行图片加载过程中的事件监听。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImageLoadingListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">//开始加载</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onLoadingStarted</span><span class="params">(String imageUri, View view)</span></span>;</span><br><span class="line">    <span class="comment">//加载失败</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onLoadingFailed</span><span class="params">(String imageUri, View view, FailReason failReason)</span></span>;</span><br><span class="line">    <span class="comment">//加载完成</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onLoadingComplete</span><span class="params">(String imageUri, View view, Bitmap loadedImage)</span></span>;</span><br><span class="line">    <span class="comment">//取消加载</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onLoadingCancelled</span><span class="params">(String imageUri, View view)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="图片展示"><a href="#图片展示" class="headerlink" title="图片展示"></a>图片展示</h2><p>在<code>ImageAware</code>中显示<code>bitmap</code> 对象的接口。可在实现中对 <code>bitmap</code> 做一些额外处理，比如加圆角、动画效果。</p>
<p>默认的<code>BitmapDisplay</code> 是 <code>SimpleBitmapDisplayer</code> 仅仅实现了加载图片的功能，<code>ImageLoader</code> 还提供了<code>CircleBitmapDisplayer</code> 、<code>FadeInBitmapDisplayer</code> 和 <code>RoundedBitmapDisplayer</code> 等其他的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BitmapDisplayer</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(Bitmap bitmap, ImageAware imageAware, LoadedFrom loadedFrom)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleBitmapDisplayer</span> <span class="keyword">implements</span> <span class="title">BitmapDisplayer</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(Bitmap bitmap, ImageAware imageAware, LoadedFrom loadedFrom)</span> </span>&#123;</span><br><span class="line">		imageAware.setImageBitmap(bitmap);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="位图处理"><a href="#位图处理" class="headerlink" title="位图处理"></a>位图处理</h2><p>图片处理接口。可用于对图片预处理(<code>Pre-process</code>)和后处理(<code>Post-process</code> )，这两个处理器的配置都是在<code>DisplayImageOptions</code> 进行设置。其中预处理是在图片获取完缓存之前处理，后端处理是指在展示前的处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BitmapProcessor</span> </span>&#123;</span><br><span class="line">	<span class="function">Bitmap <span class="title">process</span><span class="params">(Bitmap bitmap)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="内存缓存"><a href="#内存缓存" class="headerlink" title="内存缓存"></a>内存缓存</h2><p>内存缓存的是<code>Bitmap</code> ，默认的缓存容器是<code>LruMemoryCache</code> 。内存缓存的<code>Bitmap</code> 都是通过数据流解码生成的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MemoryCache</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">put</span><span class="params">(String key, Bitmap value)</span></span>;</span><br><span class="line">	<span class="function">Bitmap <span class="title">get</span><span class="params">(String key)</span></span>;</span><br><span class="line">	<span class="function">Bitmap <span class="title">remove</span><span class="params">(String key)</span></span>;</span><br><span class="line">	<span class="function">Collection&lt;String&gt; <span class="title">keys</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MemoryCache <span class="title">createMemoryCache</span><span class="params">(Context context, <span class="keyword">int</span> memoryCacheSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (memoryCacheSize == <span class="number">0</span>) &#123;</span><br><span class="line">        ActivityManager am = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);</span><br><span class="line">        <span class="keyword">int</span> memoryClass = am.getMemoryClass();</span><br><span class="line">        <span class="keyword">if</span> (hasHoneycomb() &amp;&amp; isLargeHeap(context)) &#123;</span><br><span class="line">            memoryClass = getLargeMemoryClass(am);</span><br><span class="line">        &#125;</span><br><span class="line">        memoryCacheSize = <span class="number">1024</span> * <span class="number">1024</span> * memoryClass / <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LruMemoryCache(memoryCacheSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>LruMemoryCache</code> 是区分<strong>size</strong>的，如果<code>ImageLoaderConfiguration</code> 设置 <code>denyCacheImageMultipleSizesInMemory</code> 那么缓存为 <code>FuzzyKeyMemoryCache</code> 实例，只判断图片地址不判断大小，如果相同那么刷新缓存。 <code>FuzzyKeyMemoryCache</code>  只是重写了<code>MemoryCache</code> 的 <code>put</code>  方法。</p>
<h2 id="图片解码器"><a href="#图片解码器" class="headerlink" title="图片解码器"></a>图片解码器</h2><p>根据<code>ImageDecodingInfo</code>信息得到图片并根据参数将其转换为 <code>Bitmap</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImageDecoder</span> </span>&#123;</span><br><span class="line">	<span class="function">Bitmap <span class="title">decode</span><span class="params">(ImageDecodingInfo imageDecodingInfo)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ImageDecoder <span class="title">createImageDecoder</span><span class="params">(<span class="keyword">boolean</span> loggingEnabled)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> BaseImageDecoder(loggingEnabled);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>BaseImageDecoder</code> 是<code>ImageLoaderConfiguration</code>默认的解码器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseImageDecoder</span> <span class="keyword">implements</span> <span class="title">ImageDecoder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Bitmap <span class="title">decode</span><span class="params">(ImageDecodingInfo decodingInfo)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		Bitmap decodedBitmap;</span><br><span class="line">		ImageFileInfo imageInfo;</span><br><span class="line">        <span class="comment">//通过ImageDecodingInfo中的信息获取数据流，图片下载器部分会讲怎么获取数据流</span></span><br><span class="line">		InputStream imageStream = getImageStream(decodingInfo);</span><br><span class="line">		<span class="keyword">if</span> (imageStream == <span class="keyword">null</span>) &#123;</span><br><span class="line">			L.e(ERROR_NO_IMAGE_STREAM, decodingInfo.getImageKey());</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//确定图片尺寸和旋转角度，生成图片文件信息</span></span><br><span class="line">            imageInfo = defineImageSizeAndRotation(imageStream, decodingInfo);</span><br><span class="line">            <span class="comment">//数据流的游标重置</span></span><br><span class="line">            imageStream = resetStream(imageStream, decodingInfo);</span><br><span class="line">            <span class="comment">//生成控制Bitmap进行采样的Option</span></span><br><span class="line">            Options decodingOptions = prepareDecodingOptions(imageInfo.imageSize, decodingInfo);</span><br><span class="line">            <span class="comment">//将输入流解码为位图</span></span><br><span class="line">			decodedBitmap = BitmapFactory.decodeStream(imageStream, <span class="keyword">null</span>, decodingOptions);</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			IoUtils.closeSilently(imageStream);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (decodedBitmap == <span class="keyword">null</span>) &#123;</span><br><span class="line">			L.e(ERROR_CANT_DECODE_IMAGE, decodingInfo.getImageKey());</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//对Bitmmap进行缩放和旋转</span></span><br><span class="line">			decodedBitmap = considerExactScaleAndOrientatiton(decodedBitmap, decodingInfo, imageInfo.exif.rotation,</span><br><span class="line">					imageInfo.exif.flipHorizontal);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> decodedBitmap;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/****部分代码省略***/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在解码的过程中我们之所以要重置游标，是因为我们在读头信息的时候已经读出了部分数据，所以这里要重置游标得到完整的图片数据。</p>
<h2 id="磁盘缓存"><a href="#磁盘缓存" class="headerlink" title="磁盘缓存"></a>磁盘缓存</h2><p>本地图片缓存，可向本地磁盘缓存保存图片或从本地磁盘读取图片。<code>LruDiskCache</code>是<code>ImageLoaderConfiguration</code>默认的磁盘缓存容器。这次缓存的图片文件都是通过<code>InputStream</code> 保存在磁盘上的，实现是通过调用 <code>save</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DiskCache</span> </span>&#123;</span><br><span class="line">	<span class="function">File <span class="title">getDirectory</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">File <span class="title">get</span><span class="params">(String imageUri)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">save</span><span class="params">(String imageUri, InputStream imageStream, IoUtils.CopyListener listener)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">save</span><span class="params">(String imageUri, Bitmap bitmap)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(String imageUri)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DiskCache <span class="title">createDiskCache</span><span class="params">(Context context, FileNameGenerator diskCacheFileNameGenerator,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> diskCacheSize, <span class="keyword">int</span> diskCacheFileCount)</span> </span>&#123;</span><br><span class="line">    File reserveCacheDir = createReserveDiskCacheDir(context);</span><br><span class="line">    <span class="keyword">if</span> (diskCacheSize &gt; <span class="number">0</span> || diskCacheFileCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">///Android/data/[app_package_name]/cache/uil-images</span></span><br><span class="line">        File individualCacheDir = StorageUtils.getIndividualCacheDirectory(context);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//缓存目录，缓存大小，缓存数量，缓存文件名生成器都不能为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LruDiskCache(individualCacheDir, reserveCacheDir, diskCacheFileNameGenerator, diskCacheSize,</span><br><span class="line">                    diskCacheFileCount);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            L.e(e);</span><br><span class="line">            <span class="comment">// continue and create unlimited cache</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    File cacheDir = StorageUtils.getCacheDirectory(context);</span><br><span class="line">    <span class="comment">//UnlimitedDiskCache大小没有限制</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UnlimitedDiskCache(cacheDir, reserveCacheDir, diskCacheFileNameGenerator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="网络下载"><a href="#网络下载" class="headerlink" title="网络下载"></a>网络下载</h2><p>获取<code>Uri</code> 对应的 <code>Stream</code> , <code>extra</code> 为辅助的下载器，可以通过<code>DisplayImageOptions</code> 得到<code>extraForDownloader</code> 。下载主要有<code>http</code> 、<code>https</code> 、<code>file</code> 、<code>content</code> 、<code>assets</code> 和 <code>drawable</code> 。    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImageDownloader</span> </span>&#123;</span><br><span class="line">    <span class="function">InputStream <span class="title">getStream</span><span class="params">(String imageUri, Object extra)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="comment">/** Represents supported schemes(protocols) of URI. Provides convenient methods for work with schemes and URIs. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Scheme &#123;</span><br><span class="line">        HTTP(<span class="string">"http"</span>), HTTPS(<span class="string">"https"</span>), FILE(<span class="string">"file"</span>), CONTENT(<span class="string">"content"</span>), ASSETS(<span class="string">"assets"</span>), DRAWABLE(<span class="string">"drawable"</span>), UNKNOWN(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">private</span> String scheme;</span><br><span class="line">        <span class="keyword">private</span> String uriPrefix;</span><br><span class="line">        Scheme(String scheme) &#123;</span><br><span class="line">            <span class="keyword">this</span>.scheme = scheme;</span><br><span class="line">            uriPrefix = scheme + <span class="string">"://"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>BaseImageDownloader</code> 为默认的下载器：内部通过下载资源的类型的不同有着不同的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseImageDownloader</span> <span class="keyword">implements</span> <span class="title">ImageDownloader</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> InputStream <span class="title">getStream</span><span class="params">(String imageUri, Object extra)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="keyword">switch</span> (Scheme.ofUri(imageUri)) &#123;</span><br><span class="line">			<span class="keyword">case</span> HTTP:</span><br><span class="line">			<span class="keyword">case</span> HTTPS:</span><br><span class="line">				<span class="keyword">return</span> getStreamFromNetwork(imageUri, extra);</span><br><span class="line">			<span class="keyword">case</span> FILE:</span><br><span class="line">				<span class="keyword">return</span> getStreamFromFile(imageUri, extra);</span><br><span class="line">			<span class="keyword">case</span> CONTENT:</span><br><span class="line">				<span class="keyword">return</span> getStreamFromContent(imageUri, extra);</span><br><span class="line">			<span class="keyword">case</span> ASSETS:</span><br><span class="line">				<span class="keyword">return</span> getStreamFromAssets(imageUri, extra);</span><br><span class="line">			<span class="keyword">case</span> DRAWABLE:</span><br><span class="line">				<span class="keyword">return</span> getStreamFromDrawable(imageUri, extra);</span><br><span class="line">			<span class="keyword">case</span> UNKNOWN:</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">return</span> getStreamFromOtherSource(imageUri, extra);</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看一个从网络请求中获取<code>Stream</code> 的实现（<code>ImageLoader</code>默认的网络下载）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseImageDownloader</span> <span class="keyword">implements</span> <span class="title">ImageDownloader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> InputStream <span class="title">getStreamFromNetwork</span><span class="params">(String imageUri, Object extra)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//根据imageUri，创建HttpURLConnection对象</span></span><br><span class="line">		HttpURLConnection conn = createConnection(imageUri, extra);</span><br><span class="line">        <span class="keyword">int</span> redirectCount = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//最多重定向请求5次</span></span><br><span class="line">		<span class="keyword">while</span> (conn.getResponseCode() / <span class="number">100</span> == <span class="number">3</span> &amp;&amp; redirectCount &lt; MAX_REDIRECT_COUNT) &#123;</span><br><span class="line">			conn = createConnection(conn.getHeaderField(<span class="string">"Location"</span>), extra);</span><br><span class="line">			redirectCount++;</span><br><span class="line">		&#125;</span><br><span class="line">		InputStream imageStream;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			imageStream = conn.getInputStream();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="comment">// Read all data to allow reuse connection (http://bit.ly/1ad35PY)</span></span><br><span class="line">			IoUtils.readAndCloseStream(conn.getErrorStream());</span><br><span class="line">			<span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果responseCode不是200那么关闭请求抛出IO异常</span></span><br><span class="line">		<span class="keyword">if</span> (!shouldBeProcessed(conn)) &#123;</span><br><span class="line">			IoUtils.closeSilently(imageStream);</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Image request failed with response code "</span> + conn.getResponseCode());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ContentLengthInputStream(<span class="keyword">new</span> BufferedInputStream(imageStream, BUFFER_SIZE), conn.getContentLength());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="OkHttp网络下载"><a href="#OkHttp网络下载" class="headerlink" title="OkHttp网络下载"></a>OkHttp网络下载</h3><p>只需要在进行<code>ImageLoader</code>配置的时候调用<code>ImageLoaderConfiguration.Builder</code>的<code>imageDownloader</code> 方法进行设置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OkHttpImageDownloader</span> <span class="keyword">extends</span> <span class="title">BaseImageDownloader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> OkHttpClient client;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OkHttpImageDownloader</span><span class="params">(Context context, OkHttpClient client)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> InputStream <span class="title">getStreamFromNetwork</span><span class="params">(String imageUri, Object extra)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Request request = <span class="keyword">new</span> Request.Builder().url(imageUri).build();</span><br><span class="line">        ResponseBody responseBody = client.newCall(request).execute().body();</span><br><span class="line">        InputStream inputStream = responseBody.byteStream();</span><br><span class="line">        <span class="keyword">int</span> contentLength = (<span class="keyword">int</span>) responseBody.contentLength();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ContentLengthInputStream(inputStream, contentLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ImageLoader-1"><a href="#ImageLoader-1" class="headerlink" title="ImageLoader"></a>ImageLoader</h2><p>讲完了组成的<code>ImageLoader</code> 的一整套图片加载流程的没个部分：网络下载、磁盘缓存、数据解码、内存缓存、位图处理、图片展示和业务回调。下面我们看看<code>ImageLoader</code>是怎么将这些部分是怎么串在一起的。</p>
<p>使用双重校验锁（DCL：double-checked locking）实现单例操作 <a href="https://dandanlove.blog.csdn.net/article/details/101759634" target="_blank" rel="noopener">Java版的7种单例模式</a>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ImageLoaderConfiguration configuration;<span class="comment">//图片加载配置信息</span></span><br><span class="line">    <span class="keyword">private</span> ImageLoaderEngine engine;<span class="comment">//图片加载引擎</span></span><br><span class="line">    <span class="keyword">private</span> ImageLoadingListener defaultListener = <span class="keyword">new</span> SimpleImageLoadingListener();<span class="comment">//默认的回调监听</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> ImageLoader instance;<span class="comment">//单例</span></span><br><span class="line">    <span class="comment">/** Returns singleton class instance */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ImageLoader <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (ImageLoader.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> ImageLoader();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ImageLoaderConfiguration configuration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (configuration == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(ERROR_INIT_CONFIG_WITH_NULL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.configuration == <span class="keyword">null</span>) &#123;</span><br><span class="line">            L.d(LOG_INIT_CONFIG);</span><br><span class="line">            engine = <span class="keyword">new</span> ImageLoaderEngine(configuration);</span><br><span class="line">            <span class="keyword">this</span>.configuration = configuration;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            L.w(WARNING_RE_INIT_CONFIG);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***其他代码省略***/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码是 <code>ImageLoader</code> 的构造初始化方法，接下分析它加载图片时候的调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayImage</span><span class="params">(String uri, ImageView imageView)</span> </span>&#123;</span><br><span class="line">	    	displayImage(uri, <span class="keyword">new</span> ImageViewAware(imageView), <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">  	&#125;</span><br><span class="line">    <span class="comment">//最终加载图片的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayImage</span><span class="params">(String uri, ImageAware imageAware, DisplayImageOptions options,</span></span></span><br><span class="line"><span class="function"><span class="params">                             ImageSize targetSize, ImageLoadingListener listener, ImageLoadingProgressListener progressListener)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//校验配置是否为空</span></span><br><span class="line">        checkConfiguration();</span><br><span class="line">        <span class="keyword">if</span> (imageAware == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(ERROR_WRONG_ARGUMENTS);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加默认的空回调</span></span><br><span class="line">        <span class="keyword">if</span> (listener == <span class="keyword">null</span>) &#123;</span><br><span class="line">            listener = defaultListener;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加默认的图片展示配置</span></span><br><span class="line">        <span class="keyword">if</span> (options == <span class="keyword">null</span>) &#123;</span><br><span class="line">            options = configuration.defaultDisplayImageOptions;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//下载地址为空</span></span><br><span class="line">        <span class="keyword">if</span> (TextUtils.isEmpty(uri)) &#123;</span><br><span class="line">            engine.cancelDisplayTaskFor(imageAware);<span class="comment">//取消对于当前imageAware的展示任务</span></span><br><span class="line">            listener.onLoadingStarted(uri, imageAware.getWrappedView());<span class="comment">//回调展示开始</span></span><br><span class="line">            <span class="comment">//展示配置中有处理为空的url的默认图</span></span><br><span class="line">            <span class="keyword">if</span> (options.shouldShowImageForEmptyUri()) &#123;</span><br><span class="line">                <span class="comment">//给imageAware设置这个默认图</span></span><br><span class="line">                imageAware.setImageDrawable(options.getImageForEmptyUri(configuration.resources));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                imageAware.setImageDrawable(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            listener.onLoadingComplete(uri, imageAware.getWrappedView(), <span class="keyword">null</span>);<span class="comment">//回调展示结束</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取当前需要下载的图片的size</span></span><br><span class="line">        <span class="keyword">if</span> (targetSize == <span class="keyword">null</span>) &#123;</span><br><span class="line">            targetSize = ImageSizeUtils.defineTargetSizeForView(imageAware, configuration.getMaxImageSize());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取内存缓存的key(url_width_height)</span></span><br><span class="line">        String memoryCacheKey = MemoryCacheUtils.generateKey(uri, targetSize);</span><br><span class="line">        <span class="comment">//添加到执行引擎cacheKeysForImageAwares的容器中</span></span><br><span class="line">        engine.prepareDisplayTaskFor(imageAware, memoryCacheKey);</span><br><span class="line">        listener.onLoadingStarted(uri, imageAware.getWrappedView());<span class="comment">//回调展示开始</span></span><br><span class="line">        <span class="comment">//从内存中获取缓存的memoryCacheKey对应的bitmap</span></span><br><span class="line">        Bitmap bmp = configuration.memoryCache.get(memoryCacheKey);</span><br><span class="line">        <span class="comment">//bitmap不为空，而且没有被回收</span></span><br><span class="line">        <span class="keyword">if</span> (bmp != <span class="keyword">null</span> &amp;&amp; !bmp.isRecycled()) &#123;</span><br><span class="line">            L.d(LOG_LOAD_IMAGE_FROM_MEMORY_CACHE, memoryCacheKey);</span><br><span class="line">            <span class="comment">//如果需要展示加载的进度，默认是不设置BitmapProcessor处理器的</span></span><br><span class="line">            <span class="keyword">if</span> (options.shouldPostProcess()) &#123;</span><br><span class="line">                <span class="comment">//构造图片加载信息</span></span><br><span class="line">                ImageLoadingInfo imageLoadingInfo = <span class="keyword">new</span> ImageLoadingInfo(uri, imageAware, targetSize, memoryCacheKey,</span><br><span class="line">                        options, listener, progressListener, engine.getLockForUri(uri));</span><br><span class="line">                <span class="comment">//构造处理展示图片的任务</span></span><br><span class="line">                ProcessAndDisplayImageTask displayTask = <span class="keyword">new</span> ProcessAndDisplayImageTask(engine, bmp, imageLoadingInfo,</span><br><span class="line">                        defineHandler(options));</span><br><span class="line">                <span class="comment">//如果需要同步加载</span></span><br><span class="line">                <span class="keyword">if</span> (options.isSyncLoading()) &#123;</span><br><span class="line">                    displayTask.run();<span class="comment">//直接进行展现任务</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    engine.submit(displayTask);<span class="comment">//提交任务到加载引擎中</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//从内存中加载bitmap设置给imageAware，</span></span><br><span class="line">                options.getDisplayer().display(bmp, imageAware, LoadedFrom.MEMORY_CACHE);</span><br><span class="line">                <span class="comment">//回调加载完成</span></span><br><span class="line">                listener.onLoadingComplete(uri, imageAware.getWrappedView(), bmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果需要展示加载的进度</span></span><br><span class="line">            <span class="keyword">if</span> (options.shouldShowImageOnLoading()) &#123;</span><br><span class="line">                <span class="comment">//展示默认的加载中的图片</span></span><br><span class="line">                imageAware.setImageDrawable(options.getImageOnLoading(configuration.resources));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options.isResetViewBeforeLoading()) &#123;</span><br><span class="line">                imageAware.setImageDrawable(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//构造图片加载信息</span></span><br><span class="line">            ImageLoadingInfo imageLoadingInfo = <span class="keyword">new</span> ImageLoadingInfo(uri, imageAware, targetSize, memoryCacheKey,</span><br><span class="line">                    options, listener, progressListener, engine.getLockForUri(uri));</span><br><span class="line">            <span class="comment">//构造加载展示图片的任务</span></span><br><span class="line">            LoadAndDisplayImageTask displayTask = <span class="keyword">new</span> LoadAndDisplayImageTask(engine, imageLoadingInfo,</span><br><span class="line">                    defineHandler(options));</span><br><span class="line">            <span class="comment">//如果需要同步加载</span></span><br><span class="line">            <span class="keyword">if</span> (options.isSyncLoading()) &#123;</span><br><span class="line">                displayTask.run();<span class="comment">//直接进行展现任务</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                engine.submit(displayTask);<span class="comment">//提交任务到加载引擎中</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***其他代码省略***/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Imageloader</code>图片加载流程叙述：</p>
<blockquote>
<ol>
<li>校验配置；</li>
<li>赋值默认值（回调监听、图片展现配置）；</li>
<li>判断下载地址为空；<br>3.1. 取消当前imageAware的图片展示任务；<br>3.2. 如果图片展示配置有url为空的默认处理图那么加载默认图；</li>
<li>获取当前需要加载图的size；</li>
<li>获取缓存的key<br>5.1. 根据key从内存缓存中获取bitmap，且bitmap有效；<br>5.1.1. 如果需要展现加载进度，那么构造处理图片展示任务（ProcessAndDisplayImageTask）并执行（如果展现需要同步那么直接展示，否则任务提交到线程池）；<br>5.1.2. 否则直接加载bitmap给当前的imageAware；<br>5.2. 如果需要展现加载进度，那么获取图片展示配置中的加载状态资源进行展示，准备下一步加载真实图片资源；<br>5.2.1. 构造加载展示图片任务（LoadAndDisplayImageTask）并执行（如果展现需要同步那么直接展示，否则任务提交到线程池）；</li>
</ol>
</blockquote>
<h2 id="图片加载引擎"><a href="#图片加载引擎" class="headerlink" title="图片加载引擎"></a>图片加载引擎</h2><p>虽然叫做图片加载引起，但其实它仅仅只是一个任务分发处理器，负责分发<code>LoadAndDisplayImageTask</code>和<code>ProcessAndDisplayImageTask</code>给具体的线程池去执行，以及任务的暂停等操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImageLoaderEngine</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ImageLoaderConfiguration configuration;<span class="comment">//图片加载配置信息</span></span><br><span class="line">    <span class="keyword">private</span> Executor taskExecutor;<span class="comment">//configuration.taskExecutor</span></span><br><span class="line">    <span class="keyword">private</span> Executor taskExecutorForCachedImages;<span class="comment">//configuration.taskExecutorForCachedImages</span></span><br><span class="line">    <span class="keyword">private</span> Executor taskDistributor;<span class="comment">//分配任务的线程池为newCachedThreadPool</span></span><br><span class="line">    <span class="comment">//imageview的hashcode和下载的key(url_width_height)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Integer, String&gt; cacheKeysForImageAwares = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;Integer, String&gt;());</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ReentrantLock&gt; uriLocks = <span class="keyword">new</span> WeakHashMap&lt;String, ReentrantLock&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean paused = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean networkDenied = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean slowNetwork = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>); </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object pauseLock = <span class="keyword">new</span> Object();</span><br><span class="line">    ImageLoaderEngine(ImageLoaderConfiguration configuration) &#123;</span><br><span class="line">        <span class="keyword">this</span>.configuration = configuration;</span><br><span class="line">        taskExecutor = configuration.taskExecutor;</span><br><span class="line">        taskExecutorForCachedImages = configuration.taskExecutorForCachedImages;</span><br><span class="line">        taskDistributor = DefaultConfigurationFactory.createTaskDistributor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***其他代码省略***/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任务提交处理，主要做了不同类型的任务分发给对应的任务执行的线程池：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImageLoaderEngine</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Submits task to execution pool */</span></span><br><span class="line">    <span class="comment">//执行从磁盘获取和网络上加载图片的任务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">submit</span><span class="params">(<span class="keyword">final</span> LoadAndDisplayImageTask task)</span> </span>&#123;</span><br><span class="line">        taskDistributor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                File image = configuration.diskCache.get(task.getLoadingUri());</span><br><span class="line">                <span class="comment">//是否已经缓存在磁盘上</span></span><br><span class="line">                <span class="keyword">boolean</span> isImageCachedOnDisk = image != <span class="keyword">null</span> &amp;&amp; image.exists();</span><br><span class="line">                initExecutorsIfNeed();</span><br><span class="line">                <span class="keyword">if</span> (isImageCachedOnDisk) &#123;</span><br><span class="line">                    taskExecutorForCachedImages.execute(task);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    taskExecutor.execute(task);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Submits task to execution pool */</span></span><br><span class="line">    <span class="comment">//支持从缓存中加载图片的任务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">submit</span><span class="params">(ProcessAndDisplayImageTask task)</span> </span>&#123;</span><br><span class="line">        initExecutorsIfNeed();</span><br><span class="line">        taskExecutorForCachedImages.execute(task);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//任务线程池是否关闭，关闭则重新创建</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initExecutorsIfNeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!configuration.customExecutor &amp;&amp; ((ExecutorService) taskExecutor).isShutdown()) &#123;</span><br><span class="line">            taskExecutor = createTaskExecutor();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!configuration.customExecutorForCachedImages &amp;&amp; ((ExecutorService) taskExecutorForCachedImages)</span><br><span class="line">                .isShutdown()) &#123;</span><br><span class="line">            taskExecutorForCachedImages = createTaskExecutor();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建任务线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Executor <span class="title">createTaskExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DefaultConfigurationFactory</span><br><span class="line">                .createExecutor(configuration.threadPoolSize, configuration.threadPriority,</span><br><span class="line">                configuration.tasksProcessingType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***其他代码省略***/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从<code>ImageLoader</code> 的<code>displayImage</code> 方法实现和 <code>ImageLoaderEngine</code> 的任务分发可以看出来，<code>ImageLoader</code> 主要有两种类型的任务 <code>ProcessAndDisplayImageTask</code> 和 <code>LoadAndDisplayImageTask</code> 。</p>
<h2 id="处理和展示图片任务"><a href="#处理和展示图片任务" class="headerlink" title="处理和展示图片任务"></a>处理和展示图片任务</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessAndDisplayImageTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        L.d(LOG_POSTPROCESS_IMAGE, imageLoadingInfo.memoryCacheKey);</span><br><span class="line">        <span class="comment">//获取图片展现配置中的图片处理器</span></span><br><span class="line">        BitmapProcessor processor = imageLoadingInfo.options.getPostProcessor();</span><br><span class="line">        <span class="comment">//获取处理过后的Biamtp</span></span><br><span class="line">        Bitmap processedBitmap = processor.process(bitmap); </span><br><span class="line">        DisplayBitmapTask displayBitmapTask = <span class="keyword">new</span> DisplayBitmapTask(processedBitmap, imageLoadingInfo, engine,</span><br><span class="line">                LoadedFrom.MEMORY_CACHE);</span><br><span class="line">        <span class="comment">//如果isSyncLoading那么调用displayBitmapTask的run方法，否则如果handler不为空切换到主线程执行displayBitmapTask.run</span></span><br><span class="line">        LoadAndDisplayImageTask.runTask(displayBitmapTask, imageLoadingInfo.options.isSyncLoading(), handler, engine);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="加载和展示图片任务"><a href="#加载和展示图片任务" class="headerlink" title="加载和展示图片任务"></a>加载和展示图片任务</h2><p>先看<code>LoadAndDisplayImageTask.runTask</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runTask</span><span class="params">(Runnable r, <span class="keyword">boolean</span> sync, Handler handler, ImageLoaderEngine engine)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sync) &#123;<span class="comment">//如果需要同步那么在当前线程执行</span></span><br><span class="line">        r.run();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;<span class="comment">//handler为空切换线程到taskDistributor线程池中执行</span></span><br><span class="line">        engine.fireCallback(r);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        handler.post(r);<span class="comment">//切换到handler主线程执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="run（内存加载）"><a href="#run（内存加载）" class="headerlink" title="run（内存加载）"></a>run（内存加载）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadAndDisplayImageTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">IoUtils</span>.<span class="title">CopyListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果ImageLoader暂停执行任务（ImageLoader.pause方法被调用），那么当前线程进入等待被唤醒（ImageLoader.resume方法被调用）；</span></span><br><span class="line">        <span class="comment">//否则校验当前任务是否有效（校验目标ImageAware是否已经被回收，或者ImageAware需要加载的uri已经不是当前的uri）</span></span><br><span class="line">        <span class="keyword">if</span> (waitIfPaused()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//是否需要延迟加载（图片展示配置中如果delayBeforeLoading时间大于0）</span></span><br><span class="line">        <span class="comment">////否则校验当前任务是否有效（校验目标ImageAware是否已经被回收，或者ImageAware需要加载的uri已经不是当前的uri）</span></span><br><span class="line">        <span class="keyword">if</span> (delayIfNeed()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//获取当前图片加载任务的锁</span></span><br><span class="line">        ReentrantLock loadFromUriLock = imageLoadingInfo.loadFromUriLock;</span><br><span class="line">        L.d(LOG_START_DISPLAY_IMAGE_TASK, memoryCacheKey);</span><br><span class="line">        <span class="keyword">if</span> (loadFromUriLock.isLocked()) &#123;</span><br><span class="line">            L.d(LOG_WAITING_FOR_IMAGE_LOADED, memoryCacheKey);</span><br><span class="line">        &#125;</span><br><span class="line">        loadFromUriLock.lock();</span><br><span class="line">        Bitmap bmp;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//校验目标ImageAware是否已经被回收，或者ImageAware需要加载的uri已经不是当前的uri</span></span><br><span class="line">            checkTaskNotActual();</span><br><span class="line">            <span class="comment">//先从内存缓存中获取对应的Bitmap</span></span><br><span class="line">            bmp = configuration.memoryCache.get(memoryCacheKey);</span><br><span class="line">            <span class="comment">//如果bitmap被回收或者为空</span></span><br><span class="line">            <span class="keyword">if</span> (bmp == <span class="keyword">null</span> || bmp.isRecycled()) &#123;</span><br><span class="line">                <span class="comment">//尝试加载Bitmap（磁盘、资源、网络等）</span></span><br><span class="line">                bmp = tryLoadBitmap();</span><br><span class="line">                <span class="comment">//加载失败直接返回</span></span><br><span class="line">                <span class="keyword">if</span> (bmp == <span class="keyword">null</span>) <span class="keyword">return</span>; <span class="comment">// listener callback already was fired</span></span><br><span class="line">                <span class="comment">//校验目标ImageAware是否已经被回收，或者ImageAware需要加载的uri已经不是当前的uri</span></span><br><span class="line">                checkTaskNotActual();</span><br><span class="line">                <span class="comment">//检验是否当前线程被打断</span></span><br><span class="line">                checkTaskInterrupted();</span><br><span class="line">                <span class="comment">//根据图片展示配置项是否要进行保存前处理</span></span><br><span class="line">                <span class="keyword">if</span> (options.shouldPreProcess()) &#123;</span><br><span class="line">                    L.d(LOG_PREPROCESS_IMAGE, memoryCacheKey);</span><br><span class="line">                    bmp = options.getPreProcessor().process(bmp);</span><br><span class="line">                    <span class="keyword">if</span> (bmp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        L.e(ERROR_PRE_PROCESSOR_NULL, memoryCacheKey);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//是否需要对这个Bitmap进行内存缓存</span></span><br><span class="line">                <span class="keyword">if</span> (bmp != <span class="keyword">null</span> &amp;&amp; options.isCacheInMemory()) &#123;</span><br><span class="line">                    L.d(LOG_CACHE_IMAGE_IN_MEMORY, memoryCacheKey);</span><br><span class="line">                    configuration.memoryCache.put(memoryCacheKey, bmp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                loadedFrom = LoadedFrom.MEMORY_CACHE;</span><br><span class="line">                L.d(LOG_GET_IMAGE_FROM_MEMORY_CACHE_AFTER_WAITING, memoryCacheKey);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//根据图片展示配置项是否要进行展示前处理</span></span><br><span class="line">            <span class="keyword">if</span> (bmp != <span class="keyword">null</span> &amp;&amp; options.shouldPostProcess()) &#123;</span><br><span class="line">                L.d(LOG_POSTPROCESS_IMAGE, memoryCacheKey);</span><br><span class="line">                bmp = options.getPostProcessor().process(bmp);</span><br><span class="line">                <span class="keyword">if</span> (bmp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    L.e(ERROR_POST_PROCESSOR_NULL, memoryCacheKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//校验目标ImageAware是否已经被回收，或者ImageAware需要加载的uri已经不是当前的uri</span></span><br><span class="line">            checkTaskNotActual();</span><br><span class="line">            <span class="comment">//检验是否当前线程被打断</span></span><br><span class="line">            checkTaskInterrupted();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TaskCancelledException e) &#123;</span><br><span class="line">            <span class="comment">//进行失败处理</span></span><br><span class="line">            fireCancelEvent();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            loadFromUriLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//执行展示图片任务此处和ProcessAndDisplayImageTask任务后的展示逻辑相同</span></span><br><span class="line">        DisplayBitmapTask displayBitmapTask = <span class="keyword">new</span> DisplayBitmapTask(bmp, imageLoadingInfo, engine, loadedFrom);</span><br><span class="line">        runTask(displayBitmapTask, syncLoading, handler, engine);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>任务是否有效</strong>：校验目标<code>ImageAware</code>是否已经被回收，或者<code>ImageAware</code>需要加载的<code>uri</code>已经不是当前的<code>uri</code>(被取消或者被代替)。</p>
<blockquote>
<ol>
<li>校验<code>ImageLoader</code>是否暂停执行任务和当前的任务是否有效；</li>
<li>是否需要进行延迟加载，延迟加载后校验当前是否任务有效；</li>
<li>获取当前图片加载任务的锁进行上锁；</li>
<li>校验当前是否任务有效后开始进行<code>Bitmap</code>获取；<br>4.1 先从内存缓存中获取对应的<code>Bitmap</code>；<br>4.2 获取<code>Bitmap</code> 为空获取已经被回收那么尝试加载<code>Bitmap</code>;<br>4.2.1 <code>Bitmap</code>加载失败直接返回；<br>4.2.2 校验当前是否任务有效；<br>4.2.3 检验是否当前线程被打断；<br>4.2.4 根据图片展示配置项是否要进行保存前处理；<br>4.2.5 是否需要对这个<code>Bitmap</code>进行内存缓存;<br>4.3 根据图片展示配置项是否要进行展示前处理<br>4.4 校验当前是否任务有效；<br>4.5 检验是否当前线程被打断；</li>
<li>释放锁;</li>
<li>执行展示图片任务;</li>
</ol>
</blockquote>
<h3 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadAndDisplayImageTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">IoUtils</span>.<span class="title">CopyListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Bitmap <span class="title">tryLoadBitmap</span><span class="params">()</span> <span class="keyword">throws</span> TaskCancelledException </span>&#123;</span><br><span class="line">        Bitmap bitmap = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            File imageFile = configuration.diskCache.get(uri);</span><br><span class="line">            <span class="comment">//从磁盘获取存储的图片</span></span><br><span class="line">            <span class="keyword">if</span> (imageFile != <span class="keyword">null</span> &amp;&amp; imageFile.exists() &amp;&amp; imageFile.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                L.d(LOG_LOAD_IMAGE_FROM_DISK_CACHE, memoryCacheKey);</span><br><span class="line">                loadedFrom = LoadedFrom.DISC_CACHE;</span><br><span class="line">                <span class="comment">//校验目标ImageAware是否已经被回收，或者ImageAware需要加载的uri已经不是当前的uri</span></span><br><span class="line">                checkTaskNotActual();</span><br><span class="line">                bitmap = decodeImage(Scheme.FILE.wrap(imageFile.getAbsolutePath()));<span class="comment">//进行图片解码</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//bitmap为空，或者长宽小于0重新进行数据获取</span></span><br><span class="line">            <span class="keyword">if</span> (bitmap == <span class="keyword">null</span> || bitmap.getWidth() &lt;= <span class="number">0</span> || bitmap.getHeight() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                L.d(LOG_LOAD_IMAGE_FROM_NETWORK, memoryCacheKey);</span><br><span class="line">                loadedFrom = LoadedFrom.NETWORK;</span><br><span class="line">                String imageUriForDecoding = uri;</span><br><span class="line">                <span class="comment">//是否需要缓存在磁盘上，如果需要进行磁盘缓存</span></span><br><span class="line">                <span class="keyword">if</span> (options.isCacheOnDisk() &amp;&amp; tryCacheImageOnDisk()) &#123;</span><br><span class="line">                    imageFile = configuration.diskCache.get(uri);</span><br><span class="line">                    <span class="keyword">if</span> (imageFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        imageUriForDecoding = Scheme.FILE.wrap(imageFile.getAbsolutePath());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//校验目标ImageAware是否已经被回收，或者ImageAware需要加载的uri已经不是当前的uri</span></span><br><span class="line">                checkTaskNotActual();</span><br><span class="line">                bitmap = decodeImage(imageUriForDecoding);<span class="comment">//进行图片解码</span></span><br><span class="line">                <span class="comment">//bitmap为空，或者长宽小于0进行异常处理</span></span><br><span class="line">                <span class="keyword">if</span> (bitmap == <span class="keyword">null</span> || bitmap.getWidth() &lt;= <span class="number">0</span> || bitmap.getHeight() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    fireFailEvent(FailType.DECODING_ERROR, <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (）&#123;</span><br><span class="line">            <span class="comment">/***异常处理省略***/</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bitmap;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="缓存图片到磁盘"><a href="#缓存图片到磁盘" class="headerlink" title="缓存图片到磁盘"></a>缓存图片到磁盘</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadAndDisplayImageTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">IoUtils</span>.<span class="title">CopyListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">tryCacheImageOnDisk</span><span class="params">()</span> <span class="keyword">throws</span> TaskCancelledException </span>&#123;</span><br><span class="line">        L.d(LOG_CACHE_IMAGE_ON_DISK, memoryCacheKey);</span><br><span class="line">        <span class="keyword">boolean</span> loaded;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            loaded = downloadImage();<span class="comment">//下载图片，缓存到磁盘</span></span><br><span class="line">            <span class="keyword">if</span> (loaded) &#123;</span><br><span class="line">                <span class="keyword">int</span> width = configuration.maxImageWidthForDiskCache;</span><br><span class="line">                <span class="keyword">int</span> height = configuration.maxImageHeightForDiskCache;</span><br><span class="line">                <span class="keyword">if</span> (width &gt; <span class="number">0</span> || height &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    L.d(LOG_RESIZE_CACHED_IMAGE_FILE, memoryCacheKey);</span><br><span class="line">                    <span class="comment">//设置图片的大小，重新保存到磁盘</span></span><br><span class="line">                    resizeAndSaveImage(width, height); <span class="comment">// TODO : process boolean result</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            L.e(e);</span><br><span class="line">            loaded = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> loaded;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">downloadImage</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//通过download获取数据流</span></span><br><span class="line">        InputStream is = getDownloader().getStream(uri, options.getExtraForDownloader());</span><br><span class="line">        <span class="keyword">if</span> (is == <span class="keyword">null</span>) &#123;</span><br><span class="line">            L.e(ERROR_NO_IMAGE_STREAM, memoryCacheKey);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;<span class="comment">//保存到磁盘</span></span><br><span class="line">                <span class="keyword">return</span> configuration.diskCache.save(uri, is, <span class="keyword">this</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                IoUtils.closeSilently(is);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="comment">//解码图像文件，压缩并重新保存（会覆盖之前的文件）</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">resizeAndSaveImage</span><span class="params">(<span class="keyword">int</span> maxWidth, <span class="keyword">int</span> maxHeight)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> saved = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//获取磁盘缓存的文件</span></span><br><span class="line">        File targetFile = configuration.diskCache.get(uri);</span><br><span class="line">        <span class="keyword">if</span> (targetFile != <span class="keyword">null</span> &amp;&amp; targetFile.exists()) &#123;</span><br><span class="line">            ImageSize targetImageSize = <span class="keyword">new</span> ImageSize(maxWidth, maxHeight);</span><br><span class="line">            <span class="comment">//生成新的配置</span></span><br><span class="line">            DisplayImageOptions specialOptions = <span class="keyword">new</span> DisplayImageOptions.Builder().cloneFrom(options)</span><br><span class="line">                    .imageScaleType(ImageScaleType.IN_SAMPLE_INT).build();</span><br><span class="line">            ImageDecodingInfo decodingInfo = <span class="keyword">new</span> ImageDecodingInfo(memoryCacheKey,</span><br><span class="line">                    Scheme.FILE.wrap(targetFile.getAbsolutePath()), uri, targetImageSize, ViewScaleType.FIT_INSIDE,</span><br><span class="line">                    getDownloader(), specialOptions);</span><br><span class="line">            <span class="comment">//对图像文件做解码</span></span><br><span class="line">            Bitmap bmp = decoder.decode(decodingInfo);</span><br><span class="line">            <span class="comment">//压缩文件</span></span><br><span class="line">            <span class="keyword">if</span> (bmp != <span class="keyword">null</span> &amp;&amp; configuration.processorForDiskCache != <span class="keyword">null</span>) &#123;</span><br><span class="line">                L.d(LOG_PROCESS_IMAGE_BEFORE_CACHE_ON_DISK, memoryCacheKey);</span><br><span class="line">                bmp = configuration.processorForDiskCache.process(bmp);</span><br><span class="line">                <span class="keyword">if</span> (bmp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    L.e(ERROR_PROCESSOR_FOR_DISK_CACHE_NULL, memoryCacheKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//重新保存，覆盖之前的uri对应的缓存文件</span></span><br><span class="line">            <span class="keyword">if</span> (bmp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                saved = configuration.diskCache.save(uri, bmp);</span><br><span class="line">                bmp.recycle();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> saved;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>取消当前<code>imageview</code>对应的任务</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancelDisplayTask</span><span class="params">(ImageView imageView)</span> </span>&#123;</span><br><span class="line">    engine.cancelDisplayTaskFor(<span class="keyword">new</span> ImageViewAware(imageView));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>拒绝或允许<code>ImageLoader</code>从网络下载图像</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">denyNetworkDownloads</span><span class="params">(<span class="keyword">boolean</span> denyNetworkDownloads)</span> </span>&#123;</span><br><span class="line">    engine.denyNetworkDownloads(denyNetworkDownloads);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>设置<code>ImageLoader</code>是否使用<code>FlushedInputStream</code>进行网络下载的选项</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleSlowNetwork</span><span class="params">(<span class="keyword">boolean</span> handleSlowNetwork)</span> </span>&#123;</span><br><span class="line">    engine.handleSlowNetwork(handleSlowNetwork);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>暂停ImageLoader。在ImageLoader#resume恢复之前，不会执行所有新的“加载和显示”任务。</li>
<li>已经运行的任务不会暂停。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    engine.pause();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>恢复等待的“加载和显示”任务</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    engine.resume();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>取消所有正在运行和计划的显示图像任务</li>
<li>还可以继续使用<code>ImageLoader</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    engine.stop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>取消所有正在运行和计划的显示图像任务</li>
<li>销毁所有配置，重新使用ImageLoader需要进行初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (configuration != <span class="keyword">null</span>) L.d(LOG_DESTROY);</span><br><span class="line">    stop();</span><br><span class="line">    configuration.diskCache.close();</span><br><span class="line">    engine = <span class="keyword">null</span>;</span><br><span class="line">    configuration = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>为了更友好的用户体验，在列表滑动过程中可以暂停加载（调用<code>pause</code>和<code>resume</code>）；</li>
<li>RGB_565代替ARGB_8888，减少占用内存；</li>
<li>使用<code>memoryCache(new WeakMemoryCache())</code> 将内存中的<code>Bitmap</code> 变为软引用；</li>
</ul>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Image</tag>
        <tag>ImageLoader</tag>
      </tags>
  </entry>
  <entry>
    <title>Android数据库开源框架GreenDao分析</title>
    <url>/2019/11/06/sqlite-greendao/</url>
    <content><![CDATA[<p>前段时间写Demo的时候遇到了数据库的并发问题 <a href="https://dandanlove.blog.csdn.net/article/details/102876043" target="_blank" rel="noopener">Android数据库多线程并发操作异常</a> ，然后研究了一下 <a href="https://dandanlove.blog.csdn.net/article/details/102942832" target="_blank" rel="noopener">Android中的数据库连接池</a> 。在看相关代码的时候阅读了我们项目使用的数据库框架<code>GreenDao</code> 。哈哈，挺有意思的^ _ ^。</p>
<h1 id="Android原始数据库的使用"><a href="#Android原始数据库的使用" class="headerlink" title="Android原始数据库的使用"></a>Android原始数据库的使用</h1><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseHelper</span> <span class="keyword">extends</span> <span class="title">SQLiteOpenHelper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String USER_TABLE_NAME = <span class="string">"user"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String USER_NAME = <span class="string">"username"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AGE = <span class="string">"age"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DatabaseHelper</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, <span class="string">"demo.db"</span>, <span class="keyword">null</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(SQLiteDatabase db)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建数据库</span></span><br><span class="line">        db.execSQL(<span class="string">"create table "</span> + USER_TABLE_NAME + <span class="string">"("</span> + USER_NAME + <span class="string">" varchar(20) not null,"</span> + AGE + <span class="string">" varchar(10) not null"</span> + <span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUpgrade</span><span class="params">(SQLiteDatabase db, <span class="keyword">int</span> oldVersion, <span class="keyword">int</span> newVersion)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//todo 更新数据库</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mDatabaseHelper = <span class="keyword">new</span> DatabaseHelper(<span class="keyword">this</span>);</span><br><span class="line">mSqLiteDatabase = mDatabaseHelper.getWritableDatabase();</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">ContentValues values = <span class="keyword">new</span> ContentValues();</span><br><span class="line">values.put(mDatabaseHelper.USER_NAME, <span class="string">"老张"</span>);</span><br><span class="line">values.put(mDatabaseHelper.AGE, <span class="string">"18岁"</span>);</span><br><span class="line">mSqLiteDatabase.insert(mDatabaseHelper.USER_TABLE_NAME, <span class="keyword">null</span>, values);</span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">String conditions = <span class="string">"username=?"</span>;</span><br><span class="line">String[] args = &#123;<span class="string">"老张"</span>&#125;;</span><br><span class="line">mSqLiteDatabase.delete(DatabaseHelper.USER_TABLE_NAME, conditions, args);</span><br><span class="line"><span class="comment">//更新</span></span><br><span class="line">ContentValues contentValues = <span class="keyword">new</span> ContentValues();</span><br><span class="line">contentValues.put(DatabaseHelper.AGE, <span class="string">"20岁"</span>);</span><br><span class="line">String conditions = <span class="string">"age=?"</span>;</span><br><span class="line">String[] valueStr = &#123;<span class="string">"18岁"</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> affectNum = mSqLiteDatabase.update(DatabaseHelper.USER_TABLE_NAME, contentValues, conditions, valueStr);</span><br><span class="line"><span class="comment">//查询</span></span><br><span class="line">Cursor cursor = mSqLiteDatabase.query(mDatabaseHelper.USER_TABLE_NAME, <span class="keyword">new</span> String[] &#123;DatabaseHelper.USER_NAME&#125;, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">if</span> (cursor.moveToFirst()) &#123;</span><br><span class="line">    <span class="keyword">int</span> count = cursor.getCount();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        String userName = cursor.getString(cursor.getColumnIndex(DatabaseHelper.USER_NAME));</span><br><span class="line">        Log.i(TAG,  i + <span class="string">" --&gt; "</span> + userName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其内部实现为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入</span></span><br><span class="line">SQLiteStatement.executeInsert</span><br><span class="line"><span class="comment">//更新、删除</span></span><br><span class="line">SQLiteStatement.executeUpdateDelete</span><br><span class="line"><span class="comment">//查询</span></span><br><span class="line">SQLiteCursor</span><br></pre></td></tr></table></figure>
<p>Android原生的数据库操作默认是没有开启事务的，我们自己使用的时候可以开启。</p>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><blockquote>
<ol>
<li>预编译SQL语句，重复的操作使用SQLiteStatement；</li>
<li>显示使用事务操作，做数据库更新修改操作时用事物能够提高写入性能；</li>
<li>查询数据优化，少用cursor.getColumnIndex；</li>
<li>ContentValues的容量调整，内部是HashMap每次扩容进行double，最好能预估大小；</li>
<li>及时关闭Cursor；</li>
<li>耗时异步化；</li>
</ol>
</blockquote>
<p>Android平台上的数据库框架非常多，但是有一个共同特点就是基于对象关系映射<code>(ORM)</code>模型的。实现的目标也都是不需要写<code>SQL</code>语句，通过对对象的操作保存和操作数据。</p>
<p><code>GreenDAO</code>是基于<code>AndroidSQLite</code>的最快、性能最强悍的数据库框架之一，因为他不涉及反射，靠的是代码辅助生成。</p>
<h1 id="GreenDao框架分析"><a href="#GreenDao框架分析" class="headerlink" title="GreenDao框架分析"></a>GreenDao框架分析</h1><p><a href="http://greenrobot.org/greendao/documentation/updating-to-greendao-3-and-annotations/" target="_blank" rel="noopener">GreenDao3.0官网介绍</a><br><a href="http://greenrobot.org/greendao/documentation/" target="_blank" rel="noopener">GreenDao文档</a><br><a href="https://github.com/greenrobot/greenDAO" target="_blank" rel="noopener">GreenDao的Github仓库</a></p>
<p><code>GreenDao</code> 的使用在这里就不介绍了，上面的文档链接或者网络上的各种使用教程讲的都很详细。这里主要分析、对比一下<code>GreenDao框架</code> 在原生的基础之上进行了怎么样的封装。</p>
<p>在进行源码分析之前我们先说一下<code>GreenDao</code> 的优缺点，然后在下面的阅读过程中自己进行体会。</p>
<p><strong>优点：</strong></p>
<ol>
<li>库文件比较小，小于100K，编译时间低，而且可以避免65K方法限制；</li>
<li>性能最大化(官方词汇)；</li>
<li>API 非常易用，提升了开发效率；</li>
<li>最小的内存开销(这个没有实际测试过)；</li>
<li>可支持原生语句，从Android原生 <code>SQLite</code> 过度到 <code>GreenDao</code> 相对还是比较容易；</li>
<li>数据表结构和<code>Entity</code>数据结构<code>convert</code>支持，<code>Entity</code>的不同数据结构和数据库存储结构之间做一个灵活的转换；</li>
</ol>
<p><strong>缺点:</strong></p>
<ol>
<li>不支持组合主键，这个很少用到。</li>
<li>数据库表有关系时，在第一次请求上会有延迟并且之后的更新都不会自动同步，需要主动更新或者清楚缓存之后再请求，写的时候需要主动同时更新。当然这个也不算缺点，现在很多时候在数据库建表的时候很很少使用关联，要么建索引，要么查询的时候自己做关联。</li>
<li>不支持<code>min</code>、<code>max</code>等函数，需要自己写<code>sql</code>执行<code>execSQL</code>。但这些都可以通过其他方式进行实现。</li>
<li>不支持合并写，写入的时候判断已有这条数据那么进行更新，没有则实现插入。</li>
</ol>
<h2 id="数据库框架设计"><a href="#数据库框架设计" class="headerlink" title="数据库框架设计"></a>数据库框架设计</h2><p>文章前面简单的用代码进行数据库操作，我们可以从中看到一般在Android中操作数据库所需要的对象有：</p>
<ul>
<li><p><strong>SQLiteOpenHelper</strong>：数据库的创建、更新的操作对象；</p>
</li>
<li><p><strong>SQLiteDatabase</strong>：执行数据的增删改查的操作对象；</p>
</li>
<li><p><strong>SQLiteStatement</strong>：<code>SQL</code> 执行的操作对象；</p>
</li>
</ul>
<p>所以首先任何一个数据框架都需要对这几个对象做封装，其次就是对于<code>ORM模式</code> 的数据库框架来说对象和数据库之间映射的元数据<code>Entity</code> 的管理，以及对外提供建议操作数据的API的封装。</p>
<center><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMzE5ODc5LTA0MzI1YWI1OWY1MjVjNjEucG5n?x-oss-process=image/format,png#pic_center" alt="greendao-framework.png"></center>

<h2 id="GreenDao底层封装"><a href="#GreenDao底层封装" class="headerlink" title="GreenDao底层封装"></a>GreenDao底层封装</h2><h3 id="Database"><a href="#Database" class="headerlink" title="Database"></a>Database</h3><p><code>StandardDatabase</code>实现<code>Database</code>接口，内部代理<code>SQLiteDatabase</code>。</p>
<ul>
<li>提供数据库操作对象；</li>
<li>执行<code>SQL</code> 语句；</li>
<li>进行<strong>事务</strong>操作；</li>
<li>数据库的关闭和打开；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Database</span> </span>&#123;</span><br><span class="line">    <span class="function">Cursor <span class="title">rawQuery</span><span class="params">(String sql, String[] selectionArgs)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execSQL</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">beginTransaction</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">endTransaction</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">inTransaction</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setTransactionSuccessful</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execSQL</span><span class="params">(String sql, Object[] bindArgs)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="function">DatabaseStatement <span class="title">compileStatement</span><span class="params">(String sql)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDbLockedByCurrentThread</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Object <span class="title">getRawDatabase</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardDatabase</span> <span class="keyword">implements</span> <span class="title">Database</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SQLiteDatabase delegate;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DatabaseStatement"><a href="#DatabaseStatement" class="headerlink" title="DatabaseStatement"></a>DatabaseStatement</h3><p><code>StandardDatabaseStatement</code>实现<code>DatabaseStatement</code>，内部代理<code>SQLiteStatement</code></p>
<ul>
<li>数据对象的<strong>增删改查</strong>；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DatabaseStatement</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">simpleQueryForLong</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bindNull</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">executeInsert</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bindString</span><span class="params">(<span class="keyword">int</span> index, String value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bindBlob</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">byte</span>[] value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bindLong</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">long</span> value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearBindings</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bindDouble</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">double</span> value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Object <span class="title">getRawStatement</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardDatabaseStatement</span> <span class="keyword">implements</span> <span class="title">DatabaseStatement</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SQLiteStatement delegate;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DatabaseOpenHelper"><a href="#DatabaseOpenHelper" class="headerlink" title="DatabaseOpenHelper"></a>DatabaseOpenHelper</h3><p><code>DatabaseOpenHelper</code>内部<code>SQLiteDataBase</code>改为<code>StandardDatabase</code>进行代理。</p>
<ul>
<li>数据库的创建；</li>
<li>数据库的更新以及版本管理；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseOpenHelper</span> <span class="keyword">extends</span> <span class="title">SQLiteOpenHelper</span> </span>&#123;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Database <span class="title">getWritableDb</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> wrap(getWritableDatabase());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Database <span class="title">getReadableDb</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> wrap(getReadableDatabase());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Database <span class="title">wrap</span><span class="params">(SQLiteDatabase sqLiteDatabase)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StandardDatabase(sqLiteDatabase);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMzE5ODc5LTc3NGUxOTFjYjhhMGRiMDEucG5n?x-oss-process=image/format,png#pic_center" alt="greendao.png"></center>

<h2 id="GreenDao访问层"><a href="#GreenDao访问层" class="headerlink" title="GreenDao访问层"></a>GreenDao访问层</h2><p>提供 <code>XXEntity</code> 数据模型对象、数据模型对象的<code>Properties</code>用来做每个字段的快速访问以及操作数据模型的<code>XXEntityDao</code>。</p>
<center><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMzE5ODc5LTVmN2Y4MTJmMDM5YWIyMzIucG5n?x-oss-process=image/format,png#pic_center" alt="green-entity.png"></center>

<p>上图为<code>XXEntity</code>、<code>XXEntity.Properties</code>、<code>XXEntityDao</code> 的关系和类的相关功能。</p>
<p>除此之外还未查询提供了 <a href="http://greenrobot.org/greendao/documentation/queries/" target="_blank" rel="noopener">QueryBuilder</a> 方便查询，可进行<code>分页</code>和<code>偏移量</code>的查询设置。还有 <a href="http://greenrobot.org/greendao/documentation/joins/" target="_blank" rel="noopener">join</a> 方法可以进行 <strong>表的关联查询</strong> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">QueryBuilder&lt;User&gt; queryBuilder = userDao.queryBuilder();</span><br><span class="line">queryBuilder.join(Address.class, AddressDao.Properties.userId)</span><br><span class="line">     .where(AddressDao.Properties.Street.eq(<span class="string">"Sesame Street"</span>));</span><br><span class="line">List&lt;User&gt; users = queryBuilder.list();</span><br></pre></td></tr></table></figure>
<h2 id="GreenDao中间层"><a href="#GreenDao中间层" class="headerlink" title="GreenDao中间层"></a>GreenDao中间层</h2><ul>
<li>数据操作者<code>XXEntityDao</code> 的具体操作 <code>AbstractDao</code>；</li>
<li><code>XXEntityDao</code> 的管理者 <code>AbstractDaoSession</code>；</li>
<li>封装过程中的性能优化；</li>
</ul>
<center><img src="https://img-blog.csdnimg.cn/20191106205012741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kYW5kYW5sb3ZlLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></center>

<h1 id="GreenDao的优化"><a href="#GreenDao的优化" class="headerlink" title="GreenDao的优化"></a>GreenDao的优化</h1><p><code>GreenDao</code> 的优化主要体现在 <code>DaoConfig</code> 这个类中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoConfig</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Database db;<span class="comment">//数据库</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String tablename;<span class="comment">//表名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Property[] properties;<span class="comment">//表的属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String[] allColumns;<span class="comment">//表的字段名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String[] pkColumns;<span class="comment">//表主键字段名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String[] nonPkColumns;<span class="comment">//表的非主键字段名</span></span><br><span class="line">    <span class="comment">/** Single property PK or null if there's no PK or a multi property PK. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Property pkProperty;<span class="comment">//表的主键属性，如果有多个或者没有那么为null</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> keyIsNumeric;<span class="comment">//主键是否为数字类型，用来区别缓存容器类型，long和Object</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> TableStatements statements;<span class="comment">//sql语句预编译的Statement</span></span><br><span class="line">    <span class="keyword">private</span> IdentityScope&lt;?, ?&gt; identityScope;<span class="comment">//对应数据对象的缓存容器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DaoConfig</span><span class="params">(Database db, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt; daoClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.db = db;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.tablename = (String) daoClass.getField(<span class="string">"TABLENAME"</span>).get(<span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//读取对应表的字段属性</span></span><br><span class="line">            Property[] properties = reflectProperties(daoClass);</span><br><span class="line">            <span class="keyword">this</span>.properties = properties;</span><br><span class="line">            allColumns = <span class="keyword">new</span> String[properties.length];</span><br><span class="line">            List&lt;String&gt; pkColumnList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">            List&lt;String&gt; nonPkColumnList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">            Property lastPkProperty = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//循环遍历所有字段，为pkProperty，allColumns，pkColumns，nonPkColumns赋值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; properties.length; i++) &#123;</span><br><span class="line">                Property property = properties[i];</span><br><span class="line">                String name = property.columnName;</span><br><span class="line">                allColumns[i] = name;</span><br><span class="line">                <span class="keyword">if</span> (property.primaryKey) &#123;</span><br><span class="line">                    pkColumnList.add(name);</span><br><span class="line">                    lastPkProperty = property;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    nonPkColumnList.add(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//字段赋值</span></span><br><span class="line">            String[] nonPkColumnsArray = <span class="keyword">new</span> String[nonPkColumnList.size()];</span><br><span class="line">            nonPkColumns = nonPkColumnList.toArray(nonPkColumnsArray);</span><br><span class="line">            String[] pkColumnsArray = <span class="keyword">new</span> String[pkColumnList.size()];</span><br><span class="line">            pkColumns = pkColumnList.toArray(pkColumnsArray);</span><br><span class="line">            pkProperty = pkColumns.length == <span class="number">1</span> ? lastPkProperty : <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//sql增删改查语句的预编译，Statement的缓存</span></span><br><span class="line">            statements = <span class="keyword">new</span> TableStatements(db, tablename, allColumns, pkColumns);</span><br><span class="line">            <span class="keyword">if</span> (pkProperty != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Class&lt;?&gt; type = pkProperty.type;</span><br><span class="line">                keyIsNumeric = type.equals(<span class="keyword">long</span>.class) || type.equals(Long.class) || type.equals(<span class="keyword">int</span>.class)</span><br><span class="line">                        || type.equals(Integer.class) || type.equals(<span class="keyword">short</span>.class) || type.equals(Short.class)</span><br><span class="line">                        || type.equals(<span class="keyword">byte</span>.class) || type.equals(Byte.class);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                keyIsNumeric = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> DaoException(<span class="string">"Could not init DAOConfig"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>增删改查的<code>SQL</code>的预编译的<code>Statement</code>的缓存：<br><code>insertStatement</code>、<code>insertOrReplaceStatement</code>、<code>updateStatement</code>、<code>deleteStatement</code>和<code>countStatement</code> 。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TableStatements</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Database db;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String tablename;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] allColumns;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] pkColumns;</span><br><span class="line">    <span class="keyword">private</span> DatabaseStatement insertStatement;</span><br><span class="line">    <span class="keyword">private</span> DatabaseStatement insertOrReplaceStatement;</span><br><span class="line">    <span class="keyword">private</span> DatabaseStatement updateStatement;</span><br><span class="line">    <span class="keyword">private</span> DatabaseStatement deleteStatement;</span><br><span class="line">    <span class="keyword">private</span> DatabaseStatement countStatement;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String selectAll;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String selectByKey;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String selectByRowId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String selectKeys;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DatabaseStatement <span class="title">getInsertStatement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (insertStatement == <span class="keyword">null</span>) &#123;</span><br><span class="line">            String sql = SqlUtils.createSqlInsert(<span class="string">"INSERT INTO "</span>, tablename, allColumns);</span><br><span class="line">            DatabaseStatement newInsertStatement = db.compileStatement(sql);</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (insertStatement == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    insertStatement = newInsertStatement;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (insertStatement != newInsertStatement) &#123;</span><br><span class="line">                newInsertStatement.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> insertStatement;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>每次数据库操作都使用了事务提高的性能。<br>我们来看一个插入操作的执行过程：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AbstractDao.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">insert</span><span class="params">(T entity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> executeInsert(entity, statements.getInsertStatement(), <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">executeInsert</span><span class="params">(T entity, DatabaseStatement stmt, <span class="keyword">boolean</span> setKeyAndAttach)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> rowId;</span><br><span class="line">    <span class="keyword">if</span> (db.isDbLockedByCurrentThread()) &#123;</span><br><span class="line">        rowId = insertInsideTx(entity, stmt);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Do TX to acquire a connection before locking the stmt to avoid deadlocks</span></span><br><span class="line">        <span class="comment">//开起事务</span></span><br><span class="line">        db.beginTransaction();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            rowId = insertInsideTx(entity, stmt);</span><br><span class="line">            <span class="comment">//提交事务</span></span><br><span class="line">            db.setTransactionSuccessful();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭事务</span></span><br><span class="line">            db.endTransaction();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (setKeyAndAttach) &#123;</span><br><span class="line">        updateKeyAfterInsertAndAttach(entity, rowId, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rowId;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//stmt绑定对应entity的value，并进行数据库写入</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">insertInsideTx</span><span class="params">(T entity, DatabaseStatement stmt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (stmt) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isStandardSQLite) &#123;</span><br><span class="line">            SQLiteStatement rawStmt = (SQLiteStatement) stmt.getRawStatement();</span><br><span class="line">            bindValues(rawStmt, entity);</span><br><span class="line">            <span class="keyword">return</span> rawStmt.executeInsert();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            bindValues(stmt, entity);</span><br><span class="line">            <span class="keyword">return</span> stmt.executeInsert();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>数据对象的缓存</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//提供两种配置，缓存和不缓存，在生成DaoSession的时候做的配置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> IdentityScopeType &#123;</span><br><span class="line">    Session, None</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdentityScopeObject</span>&lt;<span class="title">K</span>, <span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">IdentityScope</span>&lt;<span class="title">K</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;K, Reference&lt;T&gt;&gt; map;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdentityScopeLong</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">IdentityScope</span>&lt;<span class="title">Long</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//LongHashMap内部是一个数组，对于索引做了优化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LongHashMap&lt;Reference&lt;T&gt;&gt; map;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用这个缓存有一个问题需要注意，如果直接使用<code>SQL</code>进行的操作是这里的缓存是不会进行更新的。但可以执行<code>refresh</code>更新，或者执行<code>clearIdentityScope</code>之后进行重新<code>load</code>。</p>
<h1 id="数据库多线程并发操作"><a href="#数据库多线程并发操作" class="headerlink" title="数据库多线程并发操作"></a>数据库多线程并发操作</h1><p><a href="https://dandanlove.blog.csdn.net/article/details/102942832" target="_blank" rel="noopener">Android数据库多线程并发操作异常</a></p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>greendao</tag>
      </tags>
  </entry>
  <entry>
    <title>Android数据库多线程并发操作异常</title>
    <url>/2019/11/06/sqlite-multithread/</url>
    <content><![CDATA[<p>在我们做项目的过程中经常会有多线程异步处理的情况，那么<code>Android</code>中多线程操作数据我们一般会遇到什么样的问题？</p>
<h1 id="多个数据库对象执行并发"><a href="#多个数据库对象执行并发" class="headerlink" title="多个数据库对象执行并发"></a>多个数据库对象执行并发</h1><p>指由不同的<code>SQLiteOpenHelper</code>打开的相同数据库对象，默认<code>enableWriteAheadLogging=false</code>。</p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p><strong>单进程和多进程结果一样。</strong></p>
<ul>
<li><p>同时进行数据库的读操作不会产生任何问题；</p>
</li>
<li><p>如果都需要创建表，那么多次创建可能会出现问题；</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android.database.sqlite.SQLiteException：table key_value_alerady exits (code 1)</span><br></pre></td></tr></table></figure>
<ul>
<li>如果表已经创建，那么同时进行读写操作；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">14:48:41.039#[androidcode@]#29329#E#SQLiteDatabase #Error inserting TITLE=1572590918524</span><br><span class="line">android.database.sqlite.SQLiteDatabaseLockedException: database is locked (code 5)</span><br></pre></td></tr></table></figure>
<p>因为Android的数据库默认配置是不支持多个多线程读写的，<code>enableWriteAheadLogging=true</code> 可以进行多线程的读写。</p>
<h2 id="一个数据库对象执行并发"><a href="#一个数据库对象执行并发" class="headerlink" title="一个数据库对象执行并发"></a>一个数据库对象执行并发</h2><p>多线程操作问题：已经打开的数据库在进行读写的时候被其他地方调用了<code>close</code>关闭了数据库。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.lang.IllegalStateException: attempt to re-open an already-closed object</span><br></pre></td></tr></table></figure></p>
<p>同一个<code>SQLiteOpenHelper</code>实例获取的<code>database</code>是相同的，多在线程的情况下应该进行统一的<code>open</code>和<code>close</code>，所以一般都通过<strong>单例</strong>去管理<code>database</code> 的打开和关闭。</p>
<h1 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h1><p>如果 <code>SQLiteOpenHelper</code> 使用的是单例，<code>SQLiteDatabase</code> 对<code>CRUD</code> 操作都是从同一个连接池中获取连接. 默认情况下, 连接池中只有一条主连接, 所以同一时间只能进行一项操作，多线程读写几乎是无用功；</p>
<blockquote>
<p><code>enableWriteAheadLogging()</code>方法可以使得多链接并发查询可行，但默认没有开启该功能, 该方法会根据配置在连接池中创建多条连接；</p>
</blockquote>
<p>为什么<code>Android</code>数据库链接池默认只有一条链接，请阅读 <a href="https://dandanlove.blog.csdn.net/article/details/102876043" target="_blank" rel="noopener">Android中的数据库连接池</a> 这篇文章~！</p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>多线程</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Android中的数据库</title>
    <url>/2019/11/02/sqlconnectionpool/</url>
    <content><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20191102201512480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kYW5kYW5sb3ZlLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>最近在看数据库相关的三方库的时候，我发现在Android应用开发的时候是可以并行操作数据库的读写，但Android默认的数据连接池中只有一个数据库链接。一个数据库连接能实现并发么？要是一个数据库链接可以实现并发，那么为什么需要数据库连接池？</p>
<h1 id="数据库连接池介绍"><a href="#数据库连接池介绍" class="headerlink" title="数据库连接池介绍"></a>数据库连接池介绍</h1><p>每次提到<strong>连接池</strong>我们很快能想到<strong>线程池</strong>。线程池的创建可以减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</p>
<p><strong>数据库连接</strong>是一种关键的有限的昂贵的资源，对数据库连接的管理能显著影响到整个应用程序的伸缩性和健壮性,影响到程序的性能指标。<strong>数据库连接池负责分配,管理和释放数据库连接,它允许应用程序重复使用一个现有的数据库连接，减少链接不断传销和销毁带来的资源浪费。</strong></p>
<p><strong>数据库连接池</strong>在初始化时将创建一定数量的数据库连接放到连接池中,，这些数据库连接的数量是由最小数据库连接数来设定的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。</p>
<blockquote>
<p> 数据库连接池的最小连接数和最大连接数的设置要考虑到以下几个因素:</p>
</blockquote>
<ol>
<li><p>最小连接数：是连接池一直保持的数据库连接，所以如果应用程序对数据库连接的使用量不大，将会有大量的数据库连接资源被浪费。</p>
</li>
<li><p>最大连接数:是连接池能申请的最大连接数,如果数据库连接请求超过次数,后面的数据库连接请求将被加入到等待队列中,这会影响以后的数据库操作</p>
</li>
<li><p>如果最小连接数与最大连接数相差很大：那么最先连接请求将会获利，之后超过最小连接数量的连接请求等价于建立一个新的数据库连接。不过，这些大于最小连接数的数据库连接在使用完不会马上被释放，他将被放到连接池中等待重复使用或是空间超时后被释放。</p>
</li>
</ol>
<h1 id="Android数据库相关类介绍"><a href="#Android数据库相关类介绍" class="headerlink" title="Android数据库相关类介绍"></a>Android数据库相关类介绍</h1><ul>
<li>SQLiteOpenHelper：管理SQLite的帮助类，提供获取SQLIteDatabase实例的方法，它会在第一次使用数据库时调用获取实例方法时创建SQLiteDatabase实例，并且处理数据库版本变化，开发人员在实现ContentProvider时都要实现一个自定义的SQLiteOpenHelper类，处理数据的创建、升级和降级。</li>
<li>SQLiteDatabase：代表一个打开的SQLite数据库，提供了执行数据库操作的接口方法。如果不需要在进程之间共享数据，应用程序也可以自行创建这个类的实例来读写SQLite数据库。 </li>
<li>SQLiteSession：SQLiteSession负责管理数据库连接和事务的生命周期，通过SQLiteConnectionPool获取数据库连接来执行具体的数据库操作。 </li>
<li>SQLiteConnectionPool：数据库连接池，管理所有打开的数据库连接（Connection）。所有数据库连接都是通过它来打开，打开后会加入连接池，在读写数据库时需要从连接池中获取一个数据库连接来使用。 </li>
<li>SQLiteConnection：代表了数据库连接，每个Connection封装了一个native层的sqlite3实例，通过JNI调用SQLite动态库的接口方法操作数据库，Connection要么被Session持有，要么被连接池持有。 </li>
<li>CursorFactory：可选的Cursor工厂，可以提供自定义工厂来创建Cursor。 </li>
<li>DatabaseErrorHandler：可选的数据库异常处理器（目前仅处理数据库Corruption），如果不提供，将会使用默认的异常处理器。 </li>
<li>SQLiteDatabaseConfiguration：数据库配置，应用程序可以创建多个到SQLite数据库的连接，这个类用来保证每个连接的配置都是相同的。 </li>
<li>SQLiteQuery和SQLiteStatement：从抽象类SQLiteProgram派生，封装了SQL语句的执行过程，在执行时自动组装待执行的SQL语句，并调用SQLiteSession来执行数据库操作。这两个类的实现应用了设计模式中的命令模式。 </li>
</ul>
<p>每个类的更加详细的介绍可以阅读 <a href="https://www.cnblogs.com/supersand/p/5560091.html" target="_blank" rel="noopener"><strong>SQLite</strong>数据库学习小结<strong>——Frameworks</strong>层实现</a> 这篇文章，我们这里主要学习 <code>SQLiteConnectionPool</code> 相关的知识。</p>
<h1 id="SQLiteConnectionPool"><a href="#SQLiteConnectionPool" class="headerlink" title="SQLiteConnectionPool"></a>SQLiteConnectionPool</h1><p><strong>数据库连接池</strong>我们先看一下它的大小，每个链接的获取以及其他功能？</p>
<h2 id="连接池大小"><a href="#连接池大小" class="headerlink" title="连接池大小"></a>连接池大小</h2><p>目前Android系统的实现中，如果以非WAL模式打开数据库，连接池中只会保持一个数据库连接，如果以WAL模式打开数据库，连接池中的最大连接数量则根据系统配置决定，默认配置是两个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SQLiteConnectionPool.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">SQLiteConnectionPool</span><span class="params">(SQLiteDatabaseConfiguration configuration)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//数据库的配置信息</span></span><br><span class="line">    mConfiguration = <span class="keyword">new</span> SQLiteDatabaseConfiguration(configuration);</span><br><span class="line">    <span class="comment">//设置最大的数据库链接个数</span></span><br><span class="line">    setMaxConnectionPoolSizeLocked();</span><br><span class="line">    <span class="comment">//超时处理句柄设置，如果超时时间为MAX_VALUE，那么链接永远不关闭</span></span><br><span class="line">    <span class="comment">// If timeout is set, setup idle connection handler</span></span><br><span class="line">    <span class="comment">// In case of MAX_VALUE - idle connections are never closed</span></span><br><span class="line">    <span class="keyword">if</span> (mConfiguration.idleConnectionTimeoutMs != Long.MAX_VALUE) &#123;</span><br><span class="line">        setupIdleConnectionHandler(Looper.getMainLooper(),</span><br><span class="line">                mConfiguration.idleConnectionTimeoutMs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setMaxConnectionPoolSizeLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mConfiguration.isInMemoryDb()</span><br><span class="line">            &amp;&amp; (mConfiguration.openFlags &amp; SQLiteDatabase.ENABLE_WRITE_AHEAD_LOGGING) != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//获取debug.sqlite.wal.poolsize配置的大小，默认值是com.android.internal.R.integer.db_connection_pool_size</span></span><br><span class="line">        <span class="comment">//最小值为2</span></span><br><span class="line">        mMaxConnectionPoolSize = SQLiteGlobal.getWALConnectionPoolSize();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// We don't actually need to always restrict the connection pool size to 1</span></span><br><span class="line">        <span class="comment">// for non-WAL databases.  There might be reasons to use connection pooling</span></span><br><span class="line">        <span class="comment">// with other journal modes. However, we should always keep pool size of 1 for in-memory</span></span><br><span class="line">        <span class="comment">// databases since every :memory: db is separate from another.</span></span><br><span class="line">        <span class="comment">// For now, enabling connection pooling and using WAL are the same thing in the API.</span></span><br><span class="line">        <span class="comment">//内存数据库和非WAL数据库时数据库连接池大小为1</span></span><br><span class="line">        mMaxConnectionPoolSize = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然名为连接池，但是从源码来看，目前实现的池中只有一个数据库连接（以后的Android版本可能会扩展），所以如果应用程序中有大量的并发数据库读和写操作的话，每个操作的时长都可能受到影响，所以数据库操作应放在工作线程中执行，以免影响UI响应。</p>
<p><strong>这里有人可能产生疑问，我在进行Android应用开发的时候是可以并行操作数据库的读写，一个数据库连接能实现并发么？要是一个数据库链接可以实现并发，那么为什么需要数据库连接池？</strong></p>
<p>这里说一下我自己的理解：一个<strong>数据库链接</strong>是一个<code>Socket</code> 通道，当这个<code>Connection</code> 被其它 <code>Session</code>占用的时候后续的<code>Session</code> 的操作必须等待这个 <code>Connection</code> 被释放，所以数据库的 <code>Connection</code> 的工作其实是串行的，这个在 <code>MySql</code> 和 <code>Oracle</code> 的文档中也能找到描述。所以在Android中默认的<strong>数据库连接池</strong>只有一个数据库链接的时候，所有在这个数据库上的操作都是串行的。我们平时在多线程中的数据库操作都是串行的。</p>
<p>这些将会下下面代码分析的过程中一一体现出来^_^</p>
<h2 id="数据库链接池的构造"><a href="#数据库链接池的构造" class="headerlink" title="数据库链接池的构造"></a>数据库链接池的构造</h2><p>这里主要讲数据库连接池的创建和池中的第一条链接的产生。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SQLiteConnectionPool.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SQLiteConnectionPool</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"SQLiteConnectionPool"</span>;</span><br><span class="line">    <span class="comment">// Amount of time to wait in milliseconds before unblocking acquireConnection</span></span><br><span class="line">    <span class="comment">// and logging a message about the connection pool being busy.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> CONNECTION_POOL_BUSY_MILLIS = <span class="number">30</span> * <span class="number">1000</span>; <span class="comment">// 30 seconds</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CloseGuard mCloseGuard = CloseGuard.get();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object mLock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean mConnectionLeaked = <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line">    <span class="comment">//数据库的配置信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SQLiteDatabaseConfiguration mConfiguration;</span><br><span class="line">    <span class="comment">//数据库连接池的最大链接数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mMaxConnectionPoolSize;</span><br><span class="line">    <span class="comment">//数据库是否打开</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mIsOpen;</span><br><span class="line">    <span class="comment">//创建的链接id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mNextConnectionId;</span><br><span class="line">    <span class="comment">//连接等待池其实是由等待的连接组成的链</span></span><br><span class="line">    <span class="keyword">private</span> ConnectionWaiter mConnectionWaiterPool;</span><br><span class="line">    <span class="comment">//连接等待队列</span></span><br><span class="line">    <span class="keyword">private</span> ConnectionWaiter mConnectionWaiterQueue;</span><br><span class="line">    <span class="comment">//非主链接的引用，强引用需要主动回收</span></span><br><span class="line">    <span class="comment">// Strong references to all available connections.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;SQLiteConnection&gt; mAvailableNonPrimaryConnections =</span><br><span class="line">            <span class="keyword">new</span> ArrayList&lt;SQLiteConnection&gt;();</span><br><span class="line">    <span class="comment">//主链接</span></span><br><span class="line">    <span class="keyword">private</span> SQLiteConnection mAvailablePrimaryConnection;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="打开数据库"><a href="#打开数据库" class="headerlink" title="打开数据库"></a>打开数据库</h2><p>当我们在进行 <code>SQLiteOpenHelper.getWritableDatabase</code> 和 <code>SQLiteOpenHelper.getReadableDatabase</code> 的时候如果数据库没有打开那么会打开数据库，打开数据库也就是创建数据库链接。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SQLiteDatabase.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> SQLiteDatabase <span class="title">openDatabase</span><span class="params">(@NonNull String path,</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull OpenParams openParams)</span> </span>&#123;</span><br><span class="line">    Preconditions.checkArgument(openParams != <span class="keyword">null</span>, <span class="string">"OpenParams cannot be null"</span>);</span><br><span class="line">    SQLiteDatabase db = <span class="keyword">new</span> SQLiteDatabase(path, openParams.mOpenFlags,</span><br><span class="line">            openParams.mCursorFactory, openParams.mErrorHandler,</span><br><span class="line">            openParams.mLookasideSlotSize, openParams.mLookasideSlotCount,</span><br><span class="line">            openParams.mIdleConnectionTimeout, openParams.mJournalMode, openParams.mSyncMode);</span><br><span class="line">    <span class="comment">//内部调用openInner</span></span><br><span class="line">    db.open();</span><br><span class="line">    <span class="keyword">return</span> db;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打开数据库</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openInner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">assert</span> mConnectionPoolLocked == <span class="keyword">null</span>;</span><br><span class="line">        mConnectionPoolLocked = SQLiteConnectionPool.open(mConfigurationLocked);</span><br><span class="line">        mCloseGuardLocked.open(<span class="string">"close"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (sActiveDatabases) &#123;</span><br><span class="line">        sActiveDatabases.put(<span class="keyword">this</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里我们看到了<code>SQLiteConnectionPoll</code> 的调用，这里由数据库链接池创建数据库链接从而打开数据库。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SQLiteConnectionPool.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SQLiteConnectionPool <span class="title">open</span><span class="params">(SQLiteDatabaseConfiguration configuration)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//校验数据库信息</span></span><br><span class="line">    <span class="keyword">if</span> (configuration == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"configuration must not be null."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Create the pool.创建连接池</span></span><br><span class="line">    SQLiteConnectionPool pool = <span class="keyword">new</span> SQLiteConnectionPool(configuration);</span><br><span class="line">    pool.open(); <span class="comment">// might throw</span></span><br><span class="line">    <span class="keyword">return</span> pool;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Might throw，打开数据库</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Open the primary connection.</span></span><br><span class="line">    <span class="comment">// This might throw if the database is corrupt.</span></span><br><span class="line">    <span class="comment">//获取主链接并打开数据库，如果数据库损坏可能抛出异常</span></span><br><span class="line">    mAvailablePrimaryConnection = openConnectionLocked(mConfiguration,</span><br><span class="line">            <span class="keyword">true</span> <span class="comment">/*primaryConnection*/</span>); <span class="comment">// might throw</span></span><br><span class="line">    <span class="comment">// Mark it released so it can be closed after idle timeout</span></span><br><span class="line">    <span class="comment">//释放当前链接，以便于被关闭或者被超时回收</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mIdleConnectionHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mIdleConnectionHandler.connectionReleased(mAvailablePrimaryConnection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Mark the pool as being open for business.</span></span><br><span class="line">    mIsOpen = <span class="keyword">true</span>;</span><br><span class="line">    mCloseGuard.open(<span class="string">"close"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Might throw.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> SQLiteConnection <span class="title">openConnectionLocked</span><span class="params">(SQLiteDatabaseConfiguration configuration,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> primaryConnection)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//connectionId作为链接id，每次新创建一个数据库链接id自增1</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> connectionId = mNextConnectionId++;</span><br><span class="line">    <span class="keyword">return</span> SQLiteConnection.open(<span class="keyword">this</span>, configuration,connectionId, primaryConnection); <span class="comment">// might throw</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//SQLiteConnection.java</span></span><br><span class="line"><span class="comment">// Called by SQLiteConnectionPool only.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> SQLiteConnection <span class="title">open</span><span class="params">(SQLiteConnectionPool pool, SQLiteDatabaseConfiguration configuration,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> connectionId, <span class="keyword">boolean</span> primaryConnection)</span> </span>&#123;</span><br><span class="line">    SQLiteConnection connection = <span class="keyword">new</span> SQLiteConnection(pool, configuration,connectionId, primaryConnection);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//建立数据库链接</span></span><br><span class="line">        connection.open();</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLiteException ex) &#123;</span><br><span class="line">        connection.dispose(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里我们能看到<strong>数据库连接池</strong>第一条链接的创建是在打开数据库的时候。</p>
<h2 id="创建数据库链接"><a href="#创建数据库链接" class="headerlink" title="创建数据库链接"></a>创建数据库链接</h2><p>除过在打开数据的时候创建数据库链接，我们还会在一下情况下可能创建数据库链接。</p>
<ul>
<li>创建数据库，调用open</li>
<li>重新加载数据库配置，调用reconfigure</li>
<li>创建主链接，调用tryAcquirePrimaryConnectionLocked</li>
<li>创建非主链接，调用tryAcquireNonPrimaryConnectionLocked</li>
</ul>
<p>这四种情况我们都可能会调用 <code>SQLiteConnectionPool.openConnectionLocked</code> 创建数据库链接，其中<strong>创建数据库</strong>和<strong>重新加载数据库配置</strong>都是创建的<strong>主链接</strong>。</p>
<h2 id="数据库链接的使用"><a href="#数据库链接的使用" class="headerlink" title="数据库链接的使用"></a>数据库链接的使用</h2><p>在这之前我们先回想 <code>Connection</code> 和 <code>Session</code> 的概念：</p>
<blockquote>
<p>连接（Connection）：连接是从客户端到ORACLE实例的一条物理路径。连接可以在网络上建立，或者在本机通过IPC机制建立。通常会在客户端进程与一个专用服务器或一个调度器之间建立连接。</p>
</blockquote>
<blockquote>
<p>会话(Session) 是和连接(Connection)是同时建立的，两者是对同一件事情不同层次的描述。简单讲，连接(Connection)是物理上的客户端同服务器的通信链路，会话(Session)是逻辑上的用户同服务器的通信交互。</p>
</blockquote>
<p>我们一般往数据库插入一条数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建数据库的help</span></span><br><span class="line">OpenHelper openHelper = <span class="keyword">new</span> OpenHelper(getApplicationContext(), <span class="string">"demo"</span>, <span class="keyword">null</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//打开数据库标识写操作</span></span><br><span class="line">SQLiteDatabase writableDatabase = tanzhenxing.getWritableDatabase();</span><br><span class="line">ContentValues contentValues = <span class="keyword">new</span> ContentValues();</span><br><span class="line">contentValues.put(<span class="string">"TIME"</span>, System.currentTimeMillis());</span><br><span class="line"><span class="comment">//向SYSTEM_MSG表插入一条数据，TIME的当时间戳</span></span><br><span class="line">writableDatabase.insert(<span class="string">"SYSTEM_MSG"</span>, <span class="keyword">null</span>, contentValues);</span><br></pre></td></tr></table></figure>
<p>SQliteDatabase的内部调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SQLiteDatabase.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">insert</span><span class="params">(String table, String nullColumnHack, ContentValues values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//内部封装SQLiteStatement，调用statement.executeInsert();</span></span><br><span class="line">        <span class="keyword">return</span> insertWithOnConflict(table, nullColumnHack, values, CONFLICT_NONE);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"Error inserting "</span> + values, e);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//SQLiteStatement.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">executeInsert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquireReference();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getSession().executeForLastInsertedRowId(</span><br><span class="line">                getSql(), getBindArgs(), getConnectionFlags(), <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLiteDatabaseCorruptException ex) &#123;</span><br><span class="line">        onCorruption();</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        releaseReference();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//SQLiteStatement.java的父类SQLiteProgram的方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> SQLiteSession <span class="title">getSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mDatabase.getThreadSession();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里我们能看到最终的执行是有 <code>Session</code> 进行操作的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SQLiteDatabase.java</span></span><br><span class="line"><span class="comment">// Thread-local for database sessions that belong to this database.</span></span><br><span class="line"><span class="comment">// Each thread has its own database session.</span></span><br><span class="line"><span class="comment">// INVARIANT: Immutable.</span></span><br><span class="line"><span class="comment">//属于当前数据库的会话，每个线程都有一会话，不可变。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;SQLiteSession&gt; mThreadSession = ThreadLocal</span><br><span class="line">        .withInitial(<span class="keyword">this</span>::createSession);</span><br><span class="line"><span class="function">SQLiteSession <span class="title">createSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> SQLiteConnectionPool pool;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        throwIfNotOpenLocked();</span><br><span class="line">        pool = mConnectionPoolLocked;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SQLiteSession(pool);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">SQLiteSession <span class="title">getThreadSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mThreadSession.get(); <span class="comment">// initialValue() throws if database closed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了扯了这么久到底什么时候使用 <code>Connection</code> 呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SQLiteSession.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">executeForLastInsertedRowId</span><span class="params">(String sql, Object[] bindArgs, <span class="keyword">int</span> connectionFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">        CancellationSignal cancellationSignal)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//校验sql</span></span><br><span class="line">    <span class="keyword">if</span> (sql == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"sql must not be null."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对某些SQL语句（例如“ BEGIN”," COMMIT”和“ ROLLBACK”）执行特殊的重新解释,以确保事务状态不变式为保持。 </span></span><br><span class="line">    <span class="keyword">if</span> (executeSpecial(sql, bindArgs, connectionFlags, cancellationSignal)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取数据库链接</span></span><br><span class="line">    acquireConnection(sql, connectionFlags, cancellationSignal); <span class="comment">// might throw</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//使用数据库链接进行数据库操作</span></span><br><span class="line">        <span class="keyword">return</span> mConnection.executeForLastInsertedRowId(sql, bindArgs,</span><br><span class="line">                cancellationSignal); <span class="comment">// might throw</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放数据库链接</span></span><br><span class="line">        releaseConnection(); <span class="comment">// might throw</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从数据库连接池中获取链接</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">acquireConnection</span><span class="params">(String sql, <span class="keyword">int</span> connectionFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">        CancellationSignal cancellationSignal)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mConnection == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">assert</span> mConnectionUseCount == <span class="number">0</span>;</span><br><span class="line">        mConnection = mConnectionPool.acquireConnection(sql, connectionFlags,</span><br><span class="line">                cancellationSignal); <span class="comment">// might throw</span></span><br><span class="line">        mConnectionFlags = connectionFlags;</span><br><span class="line">    &#125;</span><br><span class="line">    mConnectionUseCount += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们总结一下上述内容：我们进行数据库操作的时候每次操作都使用的<code>Session</code> ，多个线程执行数据库操作会有多个<code>Session</code> 。<code>Session</code> 的内部操作调用的是<code>Connection</code> ，<code>Connection</code> 是从<strong>数据库连接池</strong>中获取的。</p>
<p>如果<strong>数据库连接池</strong>有多个数据库链接，那么数据库的殂谢操作可以并发，否则只能串行操作。</p>
<h2 id="从连接池中获取数据库链接"><a href="#从连接池中获取数据库链接" class="headerlink" title="从连接池中获取数据库链接"></a>从连接池中获取数据库链接</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SQLiteConnectionPool.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SQLiteConnection <span class="title">acquireConnection</span><span class="params">(String sql, <span class="keyword">int</span> connectionFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">        CancellationSignal cancellationSignal)</span> </span>&#123;</span><br><span class="line">    SQLiteConnection con = waitForConnection(sql, connectionFlags, cancellationSignal);</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mIdleConnectionHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mIdleConnectionHandler.connectionAcquired(con);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> con;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的 <code>waitForConnection</code> 方法的名字我们可以猜测这个方法可能产生阻塞。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SQLiteConnectionPool.java</span></span><br><span class="line"><span class="comment">// Might throw.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> SQLiteConnection <span class="title">waitForConnection</span><span class="params">(String sql, <span class="keyword">int</span> connectionFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">        CancellationSignal cancellationSignal)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//是否需要主链接</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> wantPrimaryConnection =</span><br><span class="line">            (connectionFlags &amp; CONNECTION_FLAG_PRIMARY_CONNECTION_AFFINITY) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> ConnectionWaiter waiter;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> nonce;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        throwIfClosedLocked();<span class="comment">//如果数据库关闭，那么抛出异常</span></span><br><span class="line">        <span class="comment">// Abort if canceled.</span></span><br><span class="line">        <span class="comment">//如果取消信号的回调不为空，那么执行回调检测是否需要取消</span></span><br><span class="line">        <span class="keyword">if</span> (cancellationSignal != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cancellationSignal.throwIfCanceled();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Try to acquire a connection.</span></span><br><span class="line">        <span class="comment">//尝试获得一个数据库链接</span></span><br><span class="line">        SQLiteConnection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//如果不需要主链接，那么尝试获取非主链接</span></span><br><span class="line">        <span class="keyword">if</span> (!wantPrimaryConnection) &#123;</span><br><span class="line">            connection = tryAcquireNonPrimaryConnectionLocked(</span><br><span class="line">                    sql, connectionFlags); <span class="comment">// might throw</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果获取不到非链接，那么尝试获取主链接</span></span><br><span class="line">        <span class="keyword">if</span> (connection == <span class="keyword">null</span>) &#123;</span><br><span class="line">            connection = tryAcquirePrimaryConnectionLocked(connectionFlags); <span class="comment">// might throw</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> connection;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// No connections available.  Enqueue a waiter in priority order.</span></span><br><span class="line">        <span class="comment">//没有可用的连接。按优先级排队服务员。</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> priority = getPriority(connectionFlags);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> startTime = SystemClock.uptimeMillis();</span><br><span class="line">        <span class="comment">//创建一个等待获取链接的对象</span></span><br><span class="line">        waiter = obtainConnectionWaiterLocked(Thread.currentThread(), startTime,</span><br><span class="line">                priority, wantPrimaryConnection, sql, connectionFlags);</span><br><span class="line">        ConnectionWaiter predecessor = <span class="keyword">null</span>;</span><br><span class="line">        ConnectionWaiter successor = mConnectionWaiterQueue;</span><br><span class="line">        <span class="comment">//按照优先级查找插入的位置</span></span><br><span class="line">        <span class="keyword">while</span> (successor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (priority &gt; successor.mPriority) &#123;</span><br><span class="line">                waiter.mNext = successor;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            predecessor = successor;</span><br><span class="line">            successor = successor.mNext;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//插入等待队列</span></span><br><span class="line">        <span class="keyword">if</span> (predecessor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            predecessor.mNext = waiter;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mConnectionWaiterQueue = waiter;</span><br><span class="line">        &#125;</span><br><span class="line">        nonce = waiter.mNonce;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Set up the cancellation listener.</span></span><br><span class="line">    <span class="comment">//设置取消监听器，在等待的过程中如果取消等待那么执行cancelConnectionWaiterLocked</span></span><br><span class="line">    <span class="keyword">if</span> (cancellationSignal != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cancellationSignal.setOnCancelListener(<span class="keyword">new</span> CancellationSignal.OnCancelListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (waiter.mNonce == nonce) &#123;</span><br><span class="line">                        <span class="comment">//从等待队列中删除这个节点数据</span></span><br><span class="line">                        <span class="comment">//给waiter添加OperationCanceledException异常信息</span></span><br><span class="line">                        <span class="comment">//唤醒waiter对应线程的阻塞</span></span><br><span class="line">                        <span class="comment">//调用wakeConnectionWaitersLocked判断队列其他waiter是否状态有更新</span></span><br><span class="line">                        cancelConnectionWaiterLocked(waiter);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Park the thread until a connection is assigned or the pool is closed.</span></span><br><span class="line">        <span class="comment">// Rethrow an exception from the wait, if we got one.</span></span><br><span class="line">        <span class="comment">//驻留线程，直到分配了连接或关闭了池。</span></span><br><span class="line">        <span class="comment">//如果有异常，则从等待中抛出异常。 </span></span><br><span class="line">        <span class="keyword">long</span> busyTimeoutMillis = CONNECTION_POOL_BUSY_MILLIS;</span><br><span class="line">        <span class="keyword">long</span> nextBusyTimeoutTime = waiter.mStartTime + busyTimeoutMillis;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// Detect and recover from connection leaks.</span></span><br><span class="line">            <span class="comment">//是否需要从泄露中进行恢复，之前被调用onConnectionLeaked</span></span><br><span class="line">            <span class="keyword">if</span> (mConnectionLeaked.compareAndSet(<span class="keyword">true</span>, <span class="keyword">false</span>)) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">                    <span class="comment">//为等待数据库链接队列进行链接赋值</span></span><br><span class="line">                    wakeConnectionWaitersLocked();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Wait to be unparked (may already have happened), a timeout, or interruption.</span></span><br><span class="line">            <span class="comment">//阻塞busyTimeoutMillis毫秒，或者中间被执行LockSupport.unpark</span></span><br><span class="line">            <span class="comment">//被执行cancelConnectionWaiterLocked进行取消</span></span><br><span class="line">            <span class="comment">//或者被执行wakeConnectionWaitersLocked进行链接分配</span></span><br><span class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, busyTimeoutMillis * <span class="number">1000000L</span>);</span><br><span class="line">            <span class="comment">// Clear the interrupted flag, just in case.</span></span><br><span class="line">            Thread.interrupted();<span class="comment">//重置当前线程的中断状态</span></span><br><span class="line">            <span class="comment">// Check whether we are done waiting yet.</span></span><br><span class="line">            <span class="comment">//检查我们是否已经完成等待。</span></span><br><span class="line">            <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">                throwIfClosedLocked();<span class="comment">//如果数据库关闭，那么抛出异常</span></span><br><span class="line">                <span class="keyword">final</span> SQLiteConnection connection = waiter.mAssignedConnection;</span><br><span class="line">                <span class="keyword">final</span> RuntimeException ex = waiter.mException;</span><br><span class="line">                <span class="comment">//如果已经分配链接，或者发送异常</span></span><br><span class="line">                <span class="keyword">if</span> (connection != <span class="keyword">null</span> || ex != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    recycleConnectionWaiterLocked(waiter);<span class="comment">//回收waiter</span></span><br><span class="line">                    <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;<span class="comment">//返回分配链接</span></span><br><span class="line">                        <span class="keyword">return</span> connection;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">throw</span> ex; <span class="comment">// rethrow!重新抛出异常</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">                <span class="keyword">if</span> (now &lt; nextBusyTimeoutTime) &#123;</span><br><span class="line">                    <span class="comment">//parkNanos阻塞时间不够busyTimeoutMillis毫秒，被执行LockSupport.unpark</span></span><br><span class="line">                    busyTimeoutMillis = now - nextBusyTimeoutTime;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//输出日志</span></span><br><span class="line">                    logConnectionPoolBusyLocked(now - waiter.mStartTime, connectionFlags);</span><br><span class="line">                    <span class="comment">//重置下次阻塞时间</span></span><br><span class="line">                    busyTimeoutMillis = CONNECTION_POOL_BUSY_MILLIS;</span><br><span class="line">                    nextBusyTimeoutTime = now + busyTimeoutMillis;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// Remove the cancellation listener.</span></span><br><span class="line">        <span class="comment">//有异常，或者获取等到了分配的链接那么解绑回调信息</span></span><br><span class="line">        <span class="keyword">if</span> (cancellationSignal != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cancellationSignal.setOnCancelListener(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里利用<code>LockSupport.parkNanos</code> 循环<strong>判断是否获得了数据库链接否则继续睡眠</strong>，直到这次操作被取消或者获得数据库链接。</p>
<h3 id="主链接的获取"><a href="#主链接的获取" class="headerlink" title="主链接的获取"></a>主链接的获取</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SQLiteConnectionPool.java</span></span><br><span class="line"><span class="comment">// Might throw.</span></span><br><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"mLock"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> SQLiteConnection <span class="title">tryAcquirePrimaryConnectionLocked</span><span class="params">(<span class="keyword">int</span> connectionFlags)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If the primary connection is available, acquire it now.</span></span><br><span class="line">    <span class="comment">//如果主要连接可用，请立即获取。</span></span><br><span class="line">    SQLiteConnection connection = mAvailablePrimaryConnection;</span><br><span class="line">    <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mAvailablePrimaryConnection = <span class="keyword">null</span>;</span><br><span class="line">        finishAcquireConnectionLocked(connection, connectionFlags); <span class="comment">// might throw</span></span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Make sure that the primary connection actually exists and has just been acquired.</span></span><br><span class="line">    <span class="comment">//确保主要连接确实存在并且刚刚被获取。</span></span><br><span class="line">    <span class="keyword">for</span> (SQLiteConnection acquiredConnection : mAcquiredConnections.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (acquiredConnection.isPrimaryConnection()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Uhoh.  No primary connection!  Either this is the first time we asked</span></span><br><span class="line">    <span class="comment">// for it, or maybe it leaked?</span></span><br><span class="line">    <span class="comment">//第一次创建数据库主链接，或者主链接被回收</span></span><br><span class="line">    connection = openConnectionLocked(mConfiguration,</span><br><span class="line">            <span class="keyword">true</span> <span class="comment">/*primaryConnection*/</span>); <span class="comment">// might throw</span></span><br><span class="line">    finishAcquireConnectionLocked(connection, connectionFlags); <span class="comment">// might throw</span></span><br><span class="line">    <span class="keyword">return</span> connection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到<strong>主数据库链接</strong>只会有一个，如果被占用那么需要等待，如果没有那么就需要创建。</p>
<h3 id="获取非主链接"><a href="#获取非主链接" class="headerlink" title="获取非主链接"></a>获取非主链接</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SQLiteConnectionPool.java</span></span><br><span class="line"><span class="comment">// Might throw.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> SQLiteConnection <span class="title">tryAcquireNonPrimaryConnectionLocked</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        String sql, <span class="keyword">int</span> connectionFlags)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Try to acquire the next connection in the queue.</span></span><br><span class="line">    SQLiteConnection connection;</span><br><span class="line">    <span class="comment">//尝试获取队列中的下一个连接。</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> availableCount = mAvailableNonPrimaryConnections.size();</span><br><span class="line">    <span class="keyword">if</span> (availableCount &gt; <span class="number">1</span> &amp;&amp; sql != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// If we have a choice, then prefer a connection that has the</span></span><br><span class="line">        <span class="comment">// prepared statement in its cache.</span></span><br><span class="line">        <span class="comment">//检查我们是否可以在其缓存中选择具有prepare语句的连接。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; availableCount; i++) &#123;</span><br><span class="line">            connection = mAvailableNonPrimaryConnections.get(i);</span><br><span class="line">            <span class="keyword">if</span> (connection.isPreparedStatementInCache(sql)) &#123;</span><br><span class="line">                mAvailableNonPrimaryConnections.remove(i);</span><br><span class="line">                finishAcquireConnectionLocked(connection, connectionFlags); <span class="comment">// might throw</span></span><br><span class="line">                <span class="keyword">return</span> connection;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则获取可以非用连接队列中的最后一个链接</span></span><br><span class="line">    <span class="keyword">if</span> (availableCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Otherwise, just grab the next one.</span></span><br><span class="line">        connection = mAvailableNonPrimaryConnections.remove(availableCount - <span class="number">1</span>);</span><br><span class="line">        finishAcquireConnectionLocked(connection, connectionFlags); <span class="comment">// might throw</span></span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果没有可以的非主链接，那么就需要扩展数据库连接池</span></span><br><span class="line">    <span class="comment">// Expand the pool if needed.</span></span><br><span class="line">    <span class="keyword">int</span> openConnections = mAcquiredConnections.size();</span><br><span class="line">    <span class="keyword">if</span> (mAvailablePrimaryConnection != <span class="keyword">null</span>) &#123;</span><br><span class="line">        openConnections += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果数据库连接池已经达到上限那么，返回null</span></span><br><span class="line">    <span class="keyword">if</span> (openConnections &gt;= mMaxConnectionPoolSize) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则创建新的非主链接</span></span><br><span class="line">    connection = openConnectionLocked(mConfiguration,</span><br><span class="line">            <span class="keyword">false</span> <span class="comment">/*primaryConnection*/</span>); <span class="comment">// might throw</span></span><br><span class="line">    finishAcquireConnectionLocked(connection, connectionFlags); <span class="comment">// might throw</span></span><br><span class="line">    <span class="keyword">return</span> connection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>非主数据库链接</strong>数量的多少受限于数据库连接池的大小。</p>
<h2 id="数据库链接释放"><a href="#数据库链接释放" class="headerlink" title="数据库链接释放"></a>数据库链接释放</h2><p>有创建获取就会有释放回收。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SQLiteConnectionPool.java</span></span><br><span class="line"><span class="comment">//释放数据库链接返回连接池</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseConnection</span><span class="params">(SQLiteConnection connection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">//idle链接句柄事件处理connectionReleased</span></span><br><span class="line">        <span class="keyword">if</span> (mIdleConnectionHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mIdleConnectionHandler.connectionReleased(connection);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取这个链接的状态</span></span><br><span class="line">        <span class="comment">//NORMAL,正常返回连接池</span></span><br><span class="line">        <span class="comment">//RECONFIGURE,必须先重新配置连接，然后才能返回。</span></span><br><span class="line">        <span class="comment">//DISCARD,连接必须关闭并丢弃。</span></span><br><span class="line">        AcquiredConnectionStatus status = mAcquiredConnections.remove(connection);</span><br><span class="line">        <span class="keyword">if</span> (status == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot perform this operation "</span></span><br><span class="line">                    + <span class="string">"because the specified connection was not acquired "</span></span><br><span class="line">                    + <span class="string">"from this pool or has already been released."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//简历是否已经关闭连接池</span></span><br><span class="line">        <span class="keyword">if</span> (!mIsOpen) &#123;</span><br><span class="line">            closeConnectionAndLogExceptionsLocked(connection);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (connection.isPrimaryConnection()) &#123;<span class="comment">//如果是主链接</span></span><br><span class="line">            <span class="comment">//判断这个数据库链接是否需要回收</span></span><br><span class="line">            <span class="keyword">if</span> (recycleConnectionLocked(connection, status)) &#123;</span><br><span class="line">                <span class="keyword">assert</span> mAvailablePrimaryConnection == <span class="keyword">null</span>;</span><br><span class="line">                mAvailablePrimaryConnection = connection;<span class="comment">//标识主链接可用，被占用的时候为null</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">////判断队列其他waiter是否状态有更新</span></span><br><span class="line">            wakeConnectionWaitersLocked();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mAvailableNonPrimaryConnections.size() &gt;= mMaxConnectionPoolSize - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//可用的非主链接数+主链接大于或等于数据库连接池的最大链接数的时候关闭这个链接</span></span><br><span class="line">            closeConnectionAndLogExceptionsLocked(connection);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//判断这个数据库链接是否需要回收</span></span><br><span class="line">            <span class="keyword">if</span> (recycleConnectionLocked(connection, status)) &#123;</span><br><span class="line">                <span class="comment">//将这个链接添加到非主链接容器中</span></span><br><span class="line">                mAvailableNonPrimaryConnections.add(connection);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断队列其他waiter是否状态有更新</span></span><br><span class="line">            wakeConnectionWaitersLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取消所有具有我们可以满足的要求的waiter的park，即唤醒该waiter对应的线程</span></span><br><span class="line"><span class="comment">//这个方法并不会抛异常，而是将异常赋值给waiter进行抛出</span></span><br><span class="line"><span class="comment">// Can't throw.</span></span><br><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"mLock"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">wakeConnectionWaitersLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Unpark all waiters that have requests that we can fulfill.</span></span><br><span class="line">    <span class="comment">// This method is designed to not throw runtime exceptions, although we might send</span></span><br><span class="line">    <span class="comment">// a waiter an exception for it to rethrow.</span></span><br><span class="line">    ConnectionWaiter predecessor = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//链表的头结点</span></span><br><span class="line">    ConnectionWaiter waiter = mConnectionWaiterQueue;</span><br><span class="line">    <span class="keyword">boolean</span> primaryConnectionNotAvailable = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> nonPrimaryConnectionNotAvailable = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (waiter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> unpark = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//是否关闭了数据库，如果关闭了那么唤醒所有waiter的线程</span></span><br><span class="line">        <span class="keyword">if</span> (!mIsOpen) &#123;</span><br><span class="line">            unpark = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                SQLiteConnection connection = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//如果该waiter需要非主链接，而且现在有可用的非主链接</span></span><br><span class="line">                <span class="keyword">if</span> (!waiter.mWantPrimaryConnection &amp;&amp; !nonPrimaryConnectionNotAvailable) &#123;</span><br><span class="line">                    <span class="comment">//获取非主链接</span></span><br><span class="line">                    connection = tryAcquireNonPrimaryConnectionLocked(</span><br><span class="line">                            waiter.mSql, waiter.mConnectionFlags); <span class="comment">// might throw</span></span><br><span class="line">                    <span class="comment">//获取为空，标识现在没有可用的非主链接        </span></span><br><span class="line">                    <span class="keyword">if</span> (connection == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        nonPrimaryConnectionNotAvailable = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//主链接可以用</span></span><br><span class="line">                <span class="keyword">if</span> (connection == <span class="keyword">null</span> &amp;&amp; !primaryConnectionNotAvailable) &#123;</span><br><span class="line">                    <span class="comment">//尝试获取主链接</span></span><br><span class="line">                    connection = tryAcquirePrimaryConnectionLocked(</span><br><span class="line">                            waiter.mConnectionFlags); <span class="comment">// might throw</span></span><br><span class="line">                    <span class="comment">//获取为空，标识现在主链接不可用</span></span><br><span class="line">                    <span class="keyword">if</span> (connection == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        primaryConnectionNotAvailable = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//获取到了数据库链接</span></span><br><span class="line">                <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    waiter.mAssignedConnection = connection;<span class="comment">//改waiter赋值链接</span></span><br><span class="line">                    unpark = <span class="keyword">true</span>;<span class="comment">//唤醒该waiter的对应线程</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nonPrimaryConnectionNotAvailable &amp;&amp; primaryConnectionNotAvailable) &#123;</span><br><span class="line">                    <span class="comment">// There are no connections available and the pool is still open.</span></span><br><span class="line">                    <span class="comment">// We cannot fulfill any more connection requests, so stop here.</span></span><br><span class="line">                    <span class="comment">//连接池任然可用，但是没有可用的链接没法对其他的waiter状态做更新直接返回</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">                <span class="comment">// Let the waiter handle the exception from acquiring a connection.</span></span><br><span class="line">                waiter.mException = ex;</span><br><span class="line">                unpark = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ConnectionWaiter successor = waiter.mNext;</span><br><span class="line">        <span class="comment">//如果需要唤醒，那么从链表中删除这个waiter，并进行对应线程唤醒操作</span></span><br><span class="line">        <span class="keyword">if</span> (unpark) &#123;</span><br><span class="line">            <span class="keyword">if</span> (predecessor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                predecessor.mNext = successor;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mConnectionWaiterQueue = successor;</span><br><span class="line">            &#125;</span><br><span class="line">            waiter.mNext = <span class="keyword">null</span>;</span><br><span class="line">            LockSupport.unpark(waiter.mThread);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            predecessor = waiter;</span><br><span class="line">        &#125;</span><br><span class="line">        waiter = successor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>链接的释放有时候是为了回收，有时候为了重用。重用的时候还需要唤醒等待链接队列中获得这个链接的<code>waiter</code> 。</p>
<h2 id="数据库链接池的关闭"><a href="#数据库链接池的关闭" class="headerlink" title="数据库链接池的关闭"></a>数据库链接池的关闭</h2><p>说到<strong>数据库连接池</strong>的关闭，我们会联想到<strong>数据库的关闭</strong>和<strong>数据库链接的关闭</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SQLiteClosable.java，它是SQLiteDatabase的父类</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Releases a reference to the object, closing the object if the last reference</span></span><br><span class="line"><span class="comment"> * was released.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Calling this method is equivalent to calling &#123;<span class="doctag">@link</span> #releaseReference&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #releaseReference()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #onAllReferencesReleased()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//释放引用的对象，直到所有的引用都被释放了那么关闭数据库</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    releaseReference();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> refCountIsZero = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        refCountIsZero = --mReferenceCount == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (refCountIsZero) &#123;</span><br><span class="line">        onAllReferencesReleased();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//SQLiteDatabase.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onAllReferencesReleased</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    dispose(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">(<span class="keyword">boolean</span> finalized)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> SQLiteConnectionPool pool;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCloseGuardLocked != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (finalized) &#123;</span><br><span class="line">                mCloseGuardLocked.warnIfOpen();</span><br><span class="line">            &#125;</span><br><span class="line">            mCloseGuardLocked.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//连接池置空，无法进行新操作</span></span><br><span class="line">        pool = mConnectionPoolLocked;</span><br><span class="line">        mConnectionPoolLocked = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!finalized) &#123;</span><br><span class="line">        <span class="comment">//删除当前数据库的引用</span></span><br><span class="line">        <span class="keyword">synchronized</span> (sActiveDatabases) &#123;</span><br><span class="line">            sActiveDatabases.remove(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭数据库连接池</span></span><br><span class="line">        <span class="keyword">if</span> (pool != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pool.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到<strong>数据库连接池的关闭</strong>是由<strong>数据库关闭</strong>引起的。</p>
<h3 id="数据库连接池的关闭"><a href="#数据库连接池的关闭" class="headerlink" title="数据库连接池的关闭"></a>数据库连接池的关闭</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SQLiteConnectionPool.java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Closes the connection pool.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * When the connection pool is closed, it will refuse all further requests</span></span><br><span class="line"><span class="comment"> * to acquire connections.  All connections that are currently available in</span></span><br><span class="line"><span class="comment"> * the pool are closed immediately.  Any connections that are still in use</span></span><br><span class="line"><span class="comment"> * will be closed as soon as they are returned to the pool.</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException if the pool has been closed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//关闭数据库连接池，停止接受新的数据库链接的请求。</span></span><br><span class="line"><span class="comment">//链接池中的可用链接立即被关闭，其他正在使用的链接被归还到数据的时候关闭</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    dispose(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">(<span class="keyword">boolean</span> finalized)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mCloseGuard != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (finalized) &#123;</span><br><span class="line">            mCloseGuard.warnIfOpen();</span><br><span class="line">        &#125;</span><br><span class="line">        mCloseGuard.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!finalized) &#123;</span><br><span class="line">        <span class="comment">// Close all connections.  We don't need (or want) to do this</span></span><br><span class="line">        <span class="comment">// when finalized because we don't know what state the connections</span></span><br><span class="line">        <span class="comment">// themselves will be in.  The finalizer is really just here for CloseGuard.</span></span><br><span class="line">        <span class="comment">// The connections will take care of themselves when their own finalizers run.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            throwIfClosedLocked();<span class="comment">//检测是否已经被关闭</span></span><br><span class="line">            mIsOpen = <span class="keyword">false</span>;<span class="comment">//标识数据库连接池关闭</span></span><br><span class="line">            <span class="comment">//关闭数据库连接池中目前可用的链接（空闲的数据库链接、包括空闲的主链接）</span></span><br><span class="line">            closeAvailableConnectionsAndLogExceptionsLocked();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> pendingCount = mAcquiredConnections.size();</span><br><span class="line">            <span class="comment">//任然有链接正在使用中</span></span><br><span class="line">            <span class="keyword">if</span> (pendingCount != <span class="number">0</span>) &#123;</span><br><span class="line">                Log.i(TAG, <span class="string">"The connection pool for "</span> + mConfiguration.label</span><br><span class="line">                        + <span class="string">" has been closed but there are still "</span></span><br><span class="line">                        + pendingCount + <span class="string">" connections in use.  They will be closed "</span></span><br><span class="line">                        + <span class="string">"as they are released back to the pool."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断队列其他waiter是否状态有更新</span></span><br><span class="line">            wakeConnectionWaitersLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关闭数据库链接"><a href="#关闭数据库链接" class="headerlink" title="关闭数据库链接"></a>关闭数据库链接</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SQLiteConnectionPool.java</span></span><br><span class="line"><span class="comment">// Can't throw.</span></span><br><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"mLock"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">closeAvailableConnectionsAndLogExceptionsLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//关闭可用的非主链接</span></span><br><span class="line">    closeAvailableNonPrimaryConnectionsAndLogExceptionsLocked();</span><br><span class="line">    <span class="comment">//如果主链接可用，那么关闭主链接</span></span><br><span class="line">    <span class="keyword">if</span> (mAvailablePrimaryConnection != <span class="keyword">null</span>) &#123;</span><br><span class="line">        closeConnectionAndLogExceptionsLocked(mAvailablePrimaryConnection);</span><br><span class="line">        mAvailablePrimaryConnection = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Can't throw.</span></span><br><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"mLock"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">closeAvailableNonPrimaryConnectionsAndLogExceptionsLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//循环遍历可用的非主链接，进行数据库链接的关闭</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = mAvailableNonPrimaryConnections.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        closeConnectionAndLogExceptionsLocked(mAvailableNonPrimaryConnections.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    mAvailableNonPrimaryConnections.clear();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Can't throw.</span></span><br><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"mLock"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">closeConnectionAndLogExceptionsLocked</span><span class="params">(SQLiteConnection connection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        connection.close(); <span class="comment">// might throw</span></span><br><span class="line">        <span class="keyword">if</span> (mIdleConnectionHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mIdleConnectionHandler.connectionClosed(connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"Failed to close connection, its fate is now in the hands "</span></span><br><span class="line">                + <span class="string">"of the merciful GC: "</span> + connection, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>数据库关闭的时候引用次数自减，若引用次数归零则真正执行关闭数据库；</li>
<li>数据库关闭清楚引用后进行的是数据库连接池的关闭；</li>
<li>数据库的关闭先状态，然后关闭所有的空闲链接，使用中的连接回归连接池后被关闭；</li>
</ul>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库连接池</tag>
      </tags>
  </entry>
  <entry>
    <title>View的postDelayed方法深度思考</title>
    <url>/2019/10/25/view-postDelayed/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><center><br><img src="https://img-blog.csdnimg.cn/20191025162156513.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kYW5kYW5sb3ZlLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br></center>

<p>突然某天好友老瑞问我 <code>“View的postdelayed方法，延迟时间如果设置10分钟或者更长的时间有什么问题吗？“</code> 。当时听到这个问题时候我只能联想到 <code>Handle.postDelay</code>  ，与此同时让我回想起了之前的一些疑问？</p>
<blockquote>
<ul>
<li>View的postDelayed方法，延迟时间如果设置10分钟或者更长的时间有什么问题吗？</li>
<li>View的postDelayed方法，延迟时间如果设置为负数有没有问题？</li>
<li>View的postDelayed方法，是先delay还是先post？</li>
<li>View的postDelayed方法，有没有可能造成内存泄露？</li>
<li>Handle有没有可能造成内存泄露？</li>
<li>Looper的无线循环会使线程卡死么？</li>
</ul>
</blockquote>
<p>如果上面的问题大家知道答案，那么文章大家可以快速阅读。如果不是，那么我们脑海中可以带着问题跟着我的思路去一步步学习和理解相关的知识点，最后回过头来自己再回答这些问题。</p>
<p>网上搜索资料找到一篇 [<a href="http://www.dss886.com/2016/08/17/01/" target="_blank" rel="noopener">Handler.postDelayed()精确延迟指定时间的原理</a>] 文章，自己感觉从中学到很很多知识。本篇文章是我结合 <code>Android源码</code> 在此基础之上进行了思考和分析，文章内容也包含这篇资料所讲的内容。</p>
<p>关于 <code>Handler</code> 和 <code>Looper</code> 的大部分知识在以前的 <a href="https://dandanlove.blog.csdn.net/article/details/73730417" target="_blank" rel="noopener">又一年对Android消息机制（Handler&amp;Looper）的思考</a>  文章讲的比较详细，这里讲的比较省略。</p>
<p>文章代码基于 <code>Android5.1</code>  进行分析。</p>
<h1 id="postDelayed源码分析"><a href="#postDelayed源码分析" class="headerlink" title="postDelayed源码分析"></a>postDelayed源码分析</h1><h2 id="View-postDelayed"><a href="#View-postDelayed" class="headerlink" title="View.postDelayed"></a>View.postDelayed</h2><blockquote>
<p>导致将Runnable添加到消息队列中，并在经过指定的时间后运行。runnable将在用户界面线程上运行。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//View.java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Causes the Runnable to be added to the message queue, to be run</span></span><br><span class="line"><span class="comment"> * after the specified amount of time elapses.</span></span><br><span class="line"><span class="comment"> * The runnable will be run on the user interface thread.&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * *********</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">postDelayed</span><span class="params">(Runnable action, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AttachInfo attachInfo = mAttachInfo;</span><br><span class="line">    <span class="comment">//如果mAttachInfo不为空，调用mAttachInfo的mHandler的post方法</span></span><br><span class="line">    <span class="comment">//即ViewRootHandler的postDelayed方法，ViewRootHandler继承Handler</span></span><br><span class="line">    <span class="keyword">if</span> (attachInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> attachInfo.mHandler.postDelayed(action, delayMillis);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//假设会稍后成功，为什么假设？可以看方法前面的注释，后面也会讲。</span></span><br><span class="line">  	<span class="comment">//Assume that post will succeed later</span></span><br><span class="line">    ViewRootImpl.getRunQueue().postDelayed(action, delayMillis);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>mAttachInfo</code> 是在 <code>dispatchAttachedToWindow</code> 方法中进行赋值的；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//View.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchAttachedToWindow</span><span class="params">(AttachInfo info, <span class="keyword">int</span> visibility)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//System.out.println("Attached! " + this);</span></span><br><span class="line">    mAttachInfo = info;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    onAttachedToWindow();</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>View</code> 的 <code>dispatchAttachedToWindow</code> 方法是在 <code>ViewRootImpl.performTraversals</code>  第一次执行的时候调用的。相关知识可以看 <a href="https://dandanlove.blog.csdn.net/article/details/78775166" target="_blank" rel="noopener">ViewRootImpl的独白，我不是一个View(布局篇)</a> 这篇文章。 </p>
<p>上面通过判断 <code>mAttachInfo</code> 是否为空分为两种情况：</p>
<ul>
<li>间接调用 <code>ViewRootHandler</code> 的 <code>postDelayed</code> 方法；</li>
<li>调用 <code>ViewRootImpl.RunQueue</code>  的 <code>postDelayed</code> 方法；</li>
</ul>
<h3 id="ViewRootImpl-getRunQueue"><a href="#ViewRootImpl-getRunQueue" class="headerlink" title="ViewRootImpl.getRunQueue"></a>ViewRootImpl.getRunQueue</h3><blockquote>
<p>当没有附加处理程序时，运行队列用于将未完成的工作从View中排队。 该工作在线程的下一次对performTraversals的调用期间执行。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ViewRootImpl.java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The run queue is used to enqueue pending work from Views when no Handler is</span></span><br><span class="line"><span class="comment"> * attached.  The work is executed during the next call to performTraversals on</span></span><br><span class="line"><span class="comment"> * the thread.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RunQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;HandlerAction&gt; mActions = <span class="keyword">new</span> ArrayList&lt;HandlerAction&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">post</span><span class="params">(Runnable action)</span> </span>&#123;</span><br><span class="line">        postDelayed(action, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//往队列中添加HandlerAction对象</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postDelayed</span><span class="params">(Runnable action, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">        HandlerAction handlerAction = <span class="keyword">new</span> HandlerAction();</span><br><span class="line">        handlerAction.action = action;</span><br><span class="line">        handlerAction.delay = delayMillis;</span><br><span class="line">        <span class="keyword">synchronized</span> (mActions) &#123;</span><br><span class="line">            mActions.add(handlerAction);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeCallbacks</span><span class="params">(Runnable action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> HandlerAction handlerAction = <span class="keyword">new</span> HandlerAction();</span><br><span class="line">        handlerAction.action = action;</span><br><span class="line">        <span class="comment">//这里不考虑delay，所以HandlerAction的equals不考虑delay是否相等</span></span><br><span class="line">        <span class="keyword">synchronized</span> (mActions) &#123;</span><br><span class="line">            <span class="keyword">final</span> ArrayList&lt;HandlerAction&gt; actions = mActions;</span><br><span class="line">            <span class="comment">//循环删除队列中的HandlerAction，如果该对象的Runnable与action相等</span></span><br><span class="line">            <span class="keyword">while</span> (actions.remove(handlerAction)) &#123;</span><br><span class="line">                <span class="comment">// Keep going</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行RunQueue队列中的HandlerAction，并清空mActions</span></span><br><span class="line">    <span class="comment">//执行调用的是handler.postDelayed，这里的handler也是mAttachInfo.mHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">executeActions</span><span class="params">(Handler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mActions) &#123;</span><br><span class="line">            <span class="keyword">final</span> ArrayList&lt;HandlerAction&gt; actions = mActions;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> count = actions.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> HandlerAction handlerAction = actions.get(i);</span><br><span class="line">                handler.postDelayed(handlerAction.action, handlerAction.delay);</span><br><span class="line">            &#125;</span><br><span class="line">            actions.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对Runnable和delay进行包装</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerAction</span> </span>&#123;</span><br><span class="line">        Runnable action;</span><br><span class="line">        <span class="keyword">long</span> delay;</span><br><span class="line">        <span class="comment">//判断两个对象是否相等，action相等则两个对象相等，不用考虑delay</span></span><br><span class="line">        <span class="comment">//为什么不用考虑，上面有讲</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            HandlerAction that = (HandlerAction) o;</span><br><span class="line">            <span class="keyword">return</span> !(action != <span class="keyword">null</span> ? !action.equals(that.action) : that.action != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里不太清楚为什么这样重写hashCode方法</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> result = action != <span class="keyword">null</span> ? action.hashCode() : <span class="number">0</span>;</span><br><span class="line">            result = <span class="number">31</span> * result + (<span class="keyword">int</span>) (delay ^ (delay &gt;&gt;&gt; <span class="number">32</span>));</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>RunQueue.executeActions</code>   是在 <code>ViewRootImpl.performTraversal</code> 当中进行调用；</p>
</li>
<li><p><code>RunQueue.executeActions</code>   是在执行完 <code>host.dispatchAttachedToWindow(mAttachInfo, 0);</code> 之后调用；</p>
</li>
<li><p><code>RunQueue.executeActions</code>   是每次执行 <code>ViewRootImpl.performTraversal</code> 都会进行调用；</p>
</li>
<li><code>RunQueue.executeActions</code>   的参数是 <code>mAttachInfo</code> 中的 <code>Handler</code> 也就是 <code>ViewRootHandler</code> ;</li>
</ul>
<p><strong>这里我们得到的结论是 <code>ViewRootImpl.getRunQueue</code> 的 <code>postDelayed</code> 方法最终也是间接调用 <code>ViewRootHandler</code> 的 <code>postDelayed</code> 方法。</strong></p>
<h4 id="RunQueue的小问题"><a href="#RunQueue的小问题" class="headerlink" title="RunQueue的小问题"></a>RunQueue的小问题</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ViewRootImpl.java </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;RunQueue&gt; sRunQueues = <span class="keyword">new</span> ThreadLocal&lt;RunQueue&gt;();</span><br><span class="line"><span class="function"><span class="keyword">static</span> RunQueue <span class="title">getRunQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前线程的RunQueue</span></span><br><span class="line">    <span class="comment">//其他线程：你不管我了么？</span></span><br><span class="line">    RunQueue rq = sRunQueues.get();</span><br><span class="line">    <span class="keyword">if</span> (rq != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> rq;</span><br><span class="line">    &#125;</span><br><span class="line">    rq = <span class="keyword">new</span> RunQueue();</span><br><span class="line">    sRunQueues.set(rq);</span><br><span class="line">    <span class="keyword">return</span> rq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个是 <code>ViewRootImpl</code> 中的 <code>geRunQueue</code> 实现，并且 <code>sRunQueues</code> 使用的是 <code>ThreadLocal</code> 。</p>
<p><code>ThreadLocal</code> 相关知识可以阅读 <a href="https://dandanlove.blog.csdn.net/article/details/50791483" target="_blank" rel="noopener">Android与Java中的ThreadLocal</a> 。</p>
<p>也就是说这里<strong>只能执行主线程</strong>中  <code>postDelayed</code> 中的 <code>Runnable</code> 。</p>
<p>我用 <code>Android4.1.2</code> 设备在 <code>new Thread</code>  使用 <code>View.postDelayed</code> 的 <code>Runnable</code> 是不执行的， 但相同代码在 <code>Android8.0</code> 上是没有任何问题的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//android-28中的View.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">postDelayed</span><span class="params">(Runnable action, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AttachInfo attachInfo = mAttachInfo;</span><br><span class="line">    <span class="keyword">if</span> (attachInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> attachInfo.mHandler.postDelayed(action, delayMillis);</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 我们看到这里的注解也不一样了~！</span></span><br><span class="line">    <span class="comment">// Postpone the runnable until we know on which thread it needs to run.</span></span><br><span class="line">    <span class="comment">// Assume that the runnable will be successfully placed after attach.</span></span><br><span class="line">    getRunQueue().postDelayed(action, delayMillis);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> HandlerActionQueue mRunQueue;</span><br><span class="line"><span class="function"><span class="keyword">private</span> HandlerActionQueue <span class="title">getRunQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mRunQueue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mRunQueue = <span class="keyword">new</span> HandlerActionQueue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mRunQueue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>android-28</code> 中不仅修改了之前的小问题， <code>HandlerActionQueue</code> 同样也做了些许优化。</p>
<h3 id="View-postDelayed小结"><a href="#View-postDelayed小结" class="headerlink" title="View.postDelayed小结"></a>View.postDelayed小结</h3><p><code>postDelayed</code> 方法调用的时候如果当前的 <code>View</code> 没有依附在 <code>Window</code> 上的时候先将 <code>Runnable</code> 缓存在 <code>RunQueue</code> 队列中等到 <code>View.dispatchAttachedToWindow</code> 调用之后再被 <code>ViewRootHandler</code> 一次 <code>postDelayed</code> 这个过程中相同的 <code>Runnable</code> 只会被 <code>postDelay</code> 一次。</p>
<p>在当前的 <code>View</code> 依附在 <code>Window</code> 上的时候直接调用 <code>ViewRootHandler</code> 的 <code>postDelayed</code> 方法。</p>
<p><strong><code>View.postDelayed</code> 最终都调用 <code>ViewRootHandler.postDelayed</code> 。</strong></p>
<h2 id="ViewRootHandler-postDelayed"><a href="#ViewRootHandler-postDelayed" class="headerlink" title="ViewRootHandler.postDelayed"></a>ViewRootHandler.postDelayed</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ViewRootImpl.java</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewRootHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessageName</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/***部分代码省略***/</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getMessageName(message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ViewRootImpl</code> 继承 <code>Handler</code> ，所以下边我们只需要分析 <code>Handler.postDelayed</code> 即可。 </p>
<p><a href="https://dandanlove.blog.csdn.net/article/details/73730417" target="_blank" rel="noopener">又一年对Android消息机制（Handler&amp;Looper）的思考</a> 这篇文章讲了一些 <code>Handler</code> 和 <code>Looper</code> 的基础知识。</p>
<center><br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzEzMTk4NzktYzk2YzAyMDk1OTUzNTI0Ni5qcGc?x-oss-process=image/format,png#pic_center" alt="handler.jpg"><br></center>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Handler.java</span></span><br><span class="line"><span class="comment">//构造Message消息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">postDelayed</span><span class="params">(Runnable r, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sendMessageDelayed(getPostMessage(r), delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取缓存中的Message，绑定callback</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    Message m = Message.obtain();</span><br><span class="line">    m.callback = r;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对Delay时间做判断，将delaytime改变为updatetime（延迟时间变为执行时间）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        delayMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对Queue队列做判空校验</span></span><br><span class="line"><span class="comment">//这里有一个思考，如果uptimeMillis小于当前时间或者小于0呢？</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    MessageQueue queue = mQueue;</span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</span><br><span class="line">        Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//给当前的Message绑定当前的Handler，如果handler构造为async那么将message设置为异步消息</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    msg.target = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是 <code>postDelay</code> 将一个 <code>Runnable</code> 添加到消息队列的方法调用路径。</p>
<p>将 <code>Runnable</code> 绑定到了一个 <code>Message</code> 上，这个 <code>Message</code> 也绑定了当前的 <code>Handler</code> 。</p>
<h3 id="MessageQueue-enqueueMessage"><a href="#MessageQueue-enqueueMessage" class="headerlink" title="MessageQueue.enqueueMessage"></a>MessageQueue.enqueueMessage</h3><p>将<code>Message</code> 添加到 <code>Looper</code> 的消息队列：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MessageQueue.java</span></span><br><span class="line"><span class="comment">//标识是否next方法被poolOnce阻塞进行等待</span></span><br><span class="line"><span class="comment">// Indicates whether next() is blocked waiting in pollOnce() with a non-zero timeout.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> mBlocked;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * msg:消息体</span></span><br><span class="line"><span class="comment"> * when：消息的执行时间=SystemClock.uptimeMillis() + delayMillis</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//校验message对应的handler是否被回收；</span></span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//校验消息是否有效；</span></span><br><span class="line">    <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加锁机进行同步，以下代码并发执行会有逻辑错误；</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//当前消息队列是否执行了quit方法进行退出；</span></span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">            IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</span><br><span class="line">            Log.w(<span class="string">"MessageQueue"</span>, e.getMessage(), e);</span><br><span class="line">            msg.recycle();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//标记当前的message已经被使用过；</span></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        <span class="comment">//将当前连表的头消息赋值给p；</span></span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="comment">//是否需要唤醒looper；</span></span><br><span class="line">        <span class="keyword">boolean</span> needWake;</span><br><span class="line">        <span class="comment">//如果头消息为空，或者新消息执行时间为0，或者头消息的执行时间比新消息的还晚；</span></span><br><span class="line">        <span class="comment">//那么新消息作为连表的消息头，如果被阻塞了也需要唤醒事件队列；</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//将新的消息插入到队列中；</span></span><br><span class="line">            <span class="comment">//通常我们不必唤醒事件队列，除非队列的开头有同步障碍并且消息是队列中最早的异步消息</span></span><br><span class="line">            <span class="comment">//如果当前是阻塞状态奇，且队列开头是同步屏障的话，那么当改消息为异步消息的时候时候可能需要需要唤醒消息队列的</span></span><br><span class="line">            <span class="comment">// Inserted within the middle of the queue.  Usually we don't have to wake</span></span><br><span class="line">            <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">            <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="comment">//找打一个比当前消息执行时间更晚的消息，插入到它的前面</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果可能需要唤醒，但是在队列中找到其他异步消息。</span></span><br><span class="line">                <span class="comment">//那么不需要进行唤醒，因为当前的异步消息不会即可被执行</span></span><br><span class="line">                <span class="comment">//要执行也是它前面的异步消息p被执行</span></span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果需要唤醒</span></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个过程讲述了将一个 <code>Message</code> 根据他的<strong>执行时间从小到大</strong>插入到链表中。除过 <strong>同步屏障</strong> 之外应该都不难理解，<a href="https://dandanlove.blog.csdn.net/article/details/73730417" target="_blank" rel="noopener">又一年对Android消息机制（Handler&amp;Looper）的思考</a>  这一篇文章中我们讲了<strong>同步屏障的产生、使用和移除</strong> <code>MessageQueue.next</code> 方法。</p>
<h3 id="Handler-postDelayed小结"><a href="#Handler-postDelayed小结" class="headerlink" title="Handler.postDelayed小结"></a>Handler.postDelayed小结</h3><p>看到这里的话，文章开始提的问题几乎都能够找到答案了吧~！</p>
<blockquote>
<ul>
<li>View的postDelay方法，延迟时间如果设置10分钟或者更长的时间有什么问题吗？</li>
</ul>
</blockquote>
<p><strong>Delay时间是没有任何限制的，这个时间过程长只是使 post的Runnable的执行时间变长 。当前在这个过程中对应的Handler和Runnable是没有办法进行回收的，因为他们一直存储在消息队列中。</strong></p>
<blockquote>
<ul>
<li>View的postDelay方法，延迟时间如果设置为负数有没有问题？</li>
</ul>
</blockquote>
<p><strong>Delay的时间为负数也是没有问题，因为sendMessageDelayed方法会对Delay的时间做校验小于零的时候赋值为零。</strong></p>
<blockquote>
<ul>
<li>View的postDelay方法，是先delay还是先post？</li>
</ul>
</blockquote>
<p><strong>需要执行的Runnable是先被post到消息队列中的，然后延迟delay时间之后执行。</strong></p>
<blockquote>
<ul>
<li>View的postDelay方法，有没有可能造成内存泄露？</li>
</ul>
</blockquote>
<p><strong>只要post之后进入消息队列中的Message一直在链表中，那么相关对象的引用都不会被释放，所以这里会造成内存泄露</strong></p>
<blockquote>
<ul>
<li>Handle有没有可能造成内存泄露？</li>
</ul>
</blockquote>
<p><strong>View的postDelay最终调用的就是Handler的postDelay，根据上面问题的答案就知道Handler也会造成内存泄露。</strong></p>
<p>最后一个问题还没有解决，所以我们还需要继续往下阅读哦^_^</p>
<h1 id="Looper的无线循环会使线程卡死么？"><a href="#Looper的无线循环会使线程卡死么？" class="headerlink" title="Looper的无线循环会使线程卡死么？"></a>Looper的无线循环会使线程卡死么？</h1><p><a href="https://dandanlove.blog.csdn.net/article/details/73730417" target="_blank" rel="noopener">又一年对Android消息机制（Handler&amp;Looper）的思考</a>  这一篇文章中我们讲了 <code>Looper.loop</code> 方法和  <code>MessageQueue.next</code> 方法。在调用 <code>Looper.loop</code> 方法的过程中 <code>MessageQueue.next</code> 方法可能会产生阻塞，这个在源码的注释上都有。</p>
<p><img src="https://img-blog.csdnimg.cn/2019102516235598.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kYW5kYW5sb3ZlLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="MessageQueue-nativePollOnce和nativeWake"><a href="#MessageQueue-nativePollOnce和nativeWake" class="headerlink" title="MessageQueue.nativePollOnce和nativeWake"></a>MessageQueue.nativePollOnce和nativeWake</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MessageQueue.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativePollOnce</span><span class="params">(<span class="keyword">long</span> ptr, <span class="keyword">int</span> timeoutMillis)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeWake</span><span class="params">(<span class="keyword">long</span> ptr)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>nativePollOnce</code> 是一个 <code>C</code> 实现的方法，<a href="https://dandanlove.blog.csdn.net/article/details/97624137" target="_blank" rel="noopener">从JNI_OnLoad看so的加载</a> 这篇文章讲述了 <code>native方法的动态注册</code> 。</p>
<p>有睡眠就有唤醒，所以这里我们 <code>pollOnce</code> 和 <code>wake</code> 一起做分析。</p>
<h3 id="pollOnce和wake的native方法注册"><a href="#pollOnce和wake的native方法注册" class="headerlink" title="pollOnce和wake的native方法注册"></a>pollOnce和wake的native方法注册</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AndroidRuntime.cpp</span></span><br><span class="line"><span class="comment">//启动AndroidRuntime运行时环境</span></span><br><span class="line"><span class="keyword">void</span> AndroidRuntime::start(<span class="keyword">const</span> <span class="keyword">char</span>* className, <span class="keyword">const</span> Vector&lt;String8&gt;&amp; options, <span class="keyword">bool</span> zygote);</span><br><span class="line"><span class="comment">//向VM注册Android的native方法</span></span><br><span class="line"><span class="keyword">int</span> AndroidRuntime::startReg(JNIEnv* env);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * gRegJNI，它是一个常量数组，里面是注册native方法的。</span></span><br><span class="line"><span class="comment"> * s这个方法循环遍历这个gRegJNI数组，依次调用数组中的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">register_jni_procs</span><span class="params">(<span class="keyword">const</span> RegJNIRec <span class="built_in">array</span>[], <span class="keyword">size_t</span> count, JNIEnv* env)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">//mProc是注册的方法的函数指针</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[i].mProc(env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NDEBUG</span></span><br><span class="line">            ALOGD(<span class="string">"----------!!! %s failed to load\n"</span>, <span class="built_in">array</span>[i].mName);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//android_os_MessageQueue.cpp</span></span><br><span class="line"><span class="comment">//需要注册的native方法以及Java端对应的方法名称以及函数的参数和返回值</span></span><br><span class="line"><span class="keyword">static</span> JNINativeMethod gMessageQueueMethods[] = &#123;</span><br><span class="line">    <span class="comment">/* name, signature, funcPtr */</span></span><br><span class="line">    &#123; <span class="string">"nativeInit"</span>, <span class="string">"()J"</span>, (<span class="keyword">void</span>*)android_os_MessageQueue_nativeInit &#125;,</span><br><span class="line">    &#123; <span class="string">"nativeDestroy"</span>, <span class="string">"(J)V"</span>, (<span class="keyword">void</span>*)android_os_MessageQueue_nativeDestroy &#125;,</span><br><span class="line">    &#123; <span class="string">"nativePollOnce"</span>, <span class="string">"(JI)V"</span>, (<span class="keyword">void</span>*)android_os_MessageQueue_nativePollOnce &#125;,</span><br><span class="line">    &#123; <span class="string">"nativeWake"</span>, <span class="string">"(J)V"</span>, (<span class="keyword">void</span>*)android_os_MessageQueue_nativeWake &#125;,</span><br><span class="line">    &#123; <span class="string">"nativeIsIdling"</span>, <span class="string">"(J)Z"</span>, (<span class="keyword">void</span>*)android_os_MessageQueue_nativeIsIdling &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//静态注册到gRegJNI数组中的方法，被在register_jni_procs中执行</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">register_android_os_MessageQueue</span><span class="params">(JNIEnv* env)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注册gMessageQueueMethods数组中的方法</span></span><br><span class="line">    <span class="keyword">int</span> res = jniRegisterNativeMethods(env, <span class="string">"android/os/MessageQueue"</span>,</span><br><span class="line">            gMessageQueueMethods, NELEM(gMessageQueueMethods));</span><br><span class="line">    LOG_FATAL_IF(res &lt; <span class="number">0</span>, <span class="string">"Unable to register native methods."</span>);</span><br><span class="line">	  <span class="comment">//对应的java端的类为android/os/MessageQueue</span></span><br><span class="line">    jclass clazz;</span><br><span class="line">    FIND_CLASS(clazz, <span class="string">"android/os/MessageQueue"</span>);</span><br><span class="line">		<span class="comment">//对应的java端的类android/os/MessageQueue中的mPtr对应的变量为J</span></span><br><span class="line">    GET_FIELD_ID(gMessageQueueClassInfo.mPtr, clazz,<span class="string">"mPtr"</span>, <span class="string">"J"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pollOnce和wake的native方法调用"><a href="#pollOnce和wake的native方法调用" class="headerlink" title="pollOnce和wake的native方法调用"></a>pollOnce和wake的native方法调用</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//android_os_MessageQueue.cpp</span></span><br><span class="line"><span class="comment">//&#123; "nativePollOnce", "(JI)V", (void*)android_os_MessageQueue_nativePollOnce &#125;,</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_MessageQueue_nativePollOnce</span><span class="params">(JNIEnv* env, jclass clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">        jlong ptr, jint timeoutMillis)</span> </span>&#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    nativeMessageQueue-&gt;pollOnce(env, timeoutMillis);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//&#123; "nativeWake", "(J)V", (void*)android_os_MessageQueue_nativeWake &#125;</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_MessageQueue_nativeWake</span><span class="params">(JNIEnv* env, jclass clazz, jlong ptr)</span> </span>&#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    <span class="keyword">return</span> nativeMessageQueue-&gt;wake();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NativeMessageQueue</span> :</span> <span class="keyword">public</span> MessageQueue &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NativeMessageQueue();</span><br><span class="line">    <span class="keyword">virtual</span> ~NativeMessageQueue();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">raiseException</span><span class="params">(JNIEnv* env, <span class="keyword">const</span> <span class="keyword">char</span>* msg, jthrowable exceptionObj)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pollOnce</span><span class="params">(JNIEnv* env, <span class="keyword">int</span> timeoutMillis)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wake</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> mInCallback;</span><br><span class="line">    jthrowable mExceptionObj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> NativeMessageQueue::wake() &#123;</span><br><span class="line">    mLooper-&gt;wake();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> NativeMessageQueue::pollOnce(JNIEnv* env, <span class="keyword">int</span> timeoutMillis) &#123;</span><br><span class="line">    mInCallback = <span class="literal">true</span>;</span><br><span class="line">    mLooper-&gt;pollOnce(timeoutMillis);</span><br><span class="line">    mInCallback = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (mExceptionObj) &#123;</span><br><span class="line">        env-&gt;Throw(mExceptionObj);</span><br><span class="line">        env-&gt;DeleteLocalRef(mExceptionObj);</span><br><span class="line">        mExceptionObj = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到 <code>nativePollOnce</code> 对中调用的是 <code>nativeMessageQueue-&gt;pollOnce</code> 方法最终调用 <code>Looper。pollOnce</code>，<code>nativeWake</code> 对中调用的是 <code>nativeMessageQueue-&gt;wake</code> 方法最终调用 <code>Looper.wake</code> 。</p>
<h3 id="pollOnce和wake方法的声明"><a href="#pollOnce和wake方法的声明" class="headerlink" title="pollOnce和wake方法的声明"></a>pollOnce和wake方法的声明</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Looper.h</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Waits for events to be available, with optional timeout in milliseconds.</span></span><br><span class="line"><span class="comment"> * Invokes callbacks for all file descriptors on which an event occurred.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the timeout is zero, returns immediately without blocking.</span></span><br><span class="line"><span class="comment"> * If the timeout is negative, waits indefinitely until an event appears.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns POLL_WAKE if the poll was awoken using wake() before</span></span><br><span class="line"><span class="comment"> * the timeout expired and no callbacks were invoked and no other file</span></span><br><span class="line"><span class="comment"> * descriptors were ready.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns POLL_CALLBACK if one or more callbacks were invoked.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns POLL_TIMEOUT if there was no data before the given</span></span><br><span class="line"><span class="comment"> * timeout expired.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns POLL_ERROR if an error occurred.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns a value &gt;= 0 containing an identifier if its file descriptor has data</span></span><br><span class="line"><span class="comment"> * and it has no callback function (requiring the caller here to handle it).</span></span><br><span class="line"><span class="comment"> * In this (and only this) case outFd, outEvents and outData will contain the poll</span></span><br><span class="line"><span class="comment"> * events and data associated with the fd, otherwise they will be set to NULL.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This method does not return until it has finished invoking the appropriate callbacks</span></span><br><span class="line"><span class="comment"> * for all file descriptors that were signalled.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pollOnce</span><span class="params">(<span class="keyword">int</span> timeoutMillis, <span class="keyword">int</span>* outFd, <span class="keyword">int</span>* outEvents, <span class="keyword">void</span>** outData)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Wakes the poll asynchronously.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This method can be called on any thread.</span></span><br><span class="line"><span class="comment"> * This method returns immediately.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wake</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>在这里的阅读代码的文档就对理解方法有很大的帮助，下面的源码分析中不懂的可以参考上面的文档。</p>
<h3 id="pollOnce和wake方法的实现"><a href="#pollOnce和wake方法的实现" class="headerlink" title="pollOnce和wake方法的实现"></a>pollOnce和wake方法的实现</h3><p>下边内容会涉及到一些Linux内核所提供的一种文件系统变化通知机制 <code>Epoll</code> 相关的知识点 ，<a href="https://www.kancloud.cn/alex_wsc/android-deep3/416419" target="_blank" rel="noopener">深入理解Android劵III-INofity与Epoll</a> 这篇文章讲的非常详细，建议大家阅读。</p>
<p><strong>pollOnce</strong>和<strong>wake</strong>都是 <code>Looper</code> 的成员方法，那么在将具体方法之前我们先看看 <code>Looper</code> 的构造方法。</p>
<h4 id="Looper的构造"><a href="#Looper的构造" class="headerlink" title="Looper的构造"></a>Looper的构造</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Looper.cpp</span></span><br><span class="line">Looper::Looper(<span class="keyword">bool</span> allowNonCallbacks) :</span><br><span class="line">        mAllowNonCallbacks(allowNonCallbacks), mSendingMessage(<span class="literal">false</span>),</span><br><span class="line">        mResponseIndex(<span class="number">0</span>), mNextMessageUptime(LLONG_MAX) &#123;</span><br><span class="line">    <span class="comment">//两个文件描述符引用，一个表示读端，一个表示写端</span></span><br><span class="line">    <span class="keyword">int</span> wakeFds[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">//调用pipe系统函数创建一个管道，</span></span><br><span class="line">    <span class="keyword">int</span> result = pipe(wakeFds);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not create wake pipe.  errno=%d"</span>, errno);</span><br><span class="line">    <span class="comment">//掌握着管道的写端</span></span><br><span class="line">    mWakeReadPipeFd = wakeFds[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//掌握着管道的读端</span></span><br><span class="line">    mWakeWritePipeFd = wakeFds[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//设置给mWakeReadPipeFd描述符状态非阻塞I/O标志</span></span><br><span class="line">    result = fcntl(mWakeReadPipeFd, F_SETFL, O_NONBLOCK);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not make wake read pipe non-blocking.  errno=%d"</span>,errno);</span><br><span class="line">    <span class="comment">//设置给mWakeWritePipeFd描述符状态非阻塞I/O标志</span></span><br><span class="line">    result = fcntl(mWakeWritePipeFd, F_SETFL, O_NONBLOCK);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not make wake write pipe non-blocking.  errno=%d"</span>,errno);</span><br><span class="line">    mIdling = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//创建一个epoll对象的描述符，之后对epoll的操作均使用这个描述符完成。EPOLL_SIZE_HINT表示了此epoll对象可以监听的描述符的最大数量。</span></span><br><span class="line">    <span class="comment">// Allocate the epoll instance and register the wake pipe.</span></span><br><span class="line">    mEpollFd = epoll_create(EPOLL_SIZE_HINT);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(mEpollFd &lt; <span class="number">0</span>, <span class="string">"Could not create epoll instance.  errno=%d"</span>, errno);</span><br><span class="line">    <span class="comment">//struct epoll_event &#123;</span></span><br><span class="line">    <span class="comment">//  __uint32_tevents; /* 事件掩码，指明了需要监听的事件种类*/</span></span><br><span class="line">    <span class="comment">//  epoll_data_t data; /* 使用者自定义的数据，当此事件发生时该数据将原封不动地返回给使用者 */</span></span><br><span class="line">    <span class="comment">//&#125;;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">eventItem</span>;</span></span><br><span class="line">    <span class="comment">//将epoll_event类型结构的eventItem字段初始化为0</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp; eventItem, <span class="number">0</span>, <span class="keyword">sizeof</span>(epoll_event)); <span class="comment">// zero out unused members of data field union</span></span><br><span class="line">    <span class="comment">//EPOLLIN（可读），EPOLLOUT（可写），EPOLLERR（描述符发生错误），EPOLLHUP（描述符被挂起）</span></span><br><span class="line">    eventItem.events = EPOLLIN;</span><br><span class="line">    <span class="comment">//eventItem需要监听的文件描述符mWakeReadPipeFd</span></span><br><span class="line">    eventItem.data.fd = mWakeReadPipeFd;</span><br><span class="line">    <span class="comment">//将事件监听添加到epoll对象中去</span></span><br><span class="line">    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp; eventItem);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not add wake read pipe to epoll instance.  errno=%d"</span>,errno);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>epoll_create(int max_fds)：创建一个epoll对象的描述符，之后对epoll的操作均使用这个描述符完成。max_fds参数表示了此epoll对象可以监听的描述符的最大数量。</p>
<p>epoll_ctl (int epfd, int op,int fd, struct epoll_event *event)：用于管理注册事件的函数。这个函数可以增加/删除/修改事件的注册。</p>
</blockquote>
<p>这里需要注意的是：我们往创建的 <code>mEpollFd</code> 添加的事件的 <code>events</code> 为 <code>EPOLLIN</code>  、 <code>data.fd</code> 是 <code>mWakeReadPipeFd</code>  ，这些东西我们后面会用到。</p>
<h4 id="pollOnce"><a href="#pollOnce" class="headerlink" title="pollOnce"></a>pollOnce</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Looper.cpp</span></span><br><span class="line"><span class="keyword">int</span> Looper::pollOnce(<span class="keyword">int</span> timeoutMillis, <span class="keyword">int</span>* outFd, <span class="keyword">int</span>* outEvents, <span class="keyword">void</span>** outData) &#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//处理eventItems中除过mWakeReadPipeFd之外的事件</span></span><br><span class="line">    <span class="comment">//(调用Looper::addFd方法添加的事件）队列mResponses中需要处理的事件</span></span><br><span class="line">    <span class="comment">//比如NativeDisplayEventReceiver的initialize方法，添加的文件描述符的ident=0</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">while</span> (mResponseIndex &lt; mResponses.size()) &#123;</span><br><span class="line">            <span class="keyword">const</span> Response&amp; response = mResponses.itemAt(mResponseIndex++);</span><br><span class="line">            <span class="keyword">int</span> ident = response.request.ident;</span><br><span class="line">            <span class="comment">//inent&gt;=0标识需要回调的事件，比如输入事件</span></span><br><span class="line">            <span class="keyword">if</span> (ident &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> fd = response.request.fd;</span><br><span class="line">                <span class="keyword">int</span> events = response.events;</span><br><span class="line">                <span class="keyword">void</span>* data = response.request.data;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_POLL_AND_WAKE</span></span><br><span class="line">                ALOGD(<span class="string">"%p ~ pollOnce - returning signalled identifier %d: "</span></span><br><span class="line">                        <span class="string">"fd=%d, events=0x%x, data=%p"</span>,</span><br><span class="line">                        <span class="keyword">this</span>, ident, fd, events, data);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                <span class="keyword">if</span> (outFd != <span class="literal">NULL</span>) *outFd = fd;</span><br><span class="line">                <span class="keyword">if</span> (outEvents != <span class="literal">NULL</span>) *outEvents = events;</span><br><span class="line">                <span class="keyword">if</span> (outData != <span class="literal">NULL</span>) *outData = data;</span><br><span class="line">                <span class="keyword">return</span> ident;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//表示已经唤醒，或超时，或出错，或执行了消息回调</span></span><br><span class="line">        <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_POLL_AND_WAKE</span></span><br><span class="line">            ALOGD(<span class="string">"%p ~ pollOnce - returning result %d"</span>, <span class="keyword">this</span>, result);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            <span class="keyword">if</span> (outFd != <span class="literal">NULL</span>) *outFd = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (outEvents != <span class="literal">NULL</span>) *outEvents = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (outData != <span class="literal">NULL</span>) *outData = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//poll epool内部实现，方法会进行等待</span></span><br><span class="line">        result = pollInner(timeoutMillis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>先处理 <code>mResponses</code> 中需要返回结果的事件；</li>
<li>判断当前是否已经唤醒，或超时，或出错，或执行了消息回调，否则进行等待；</li>
</ul>
<h4 id="pollnner"><a href="#pollnner" class="headerlink" title="pollnner"></a>pollnner</h4><p>这个方法比较长，请耐心阅读^_^。这个方法是正真调用 <code>epoll_wait</code> 方法进行等待事件的地方。</p>
<blockquote>
<p>int epoll_wait(int epfd, structepoll_event * events, int maxevents, int timeout)：用于等待事件的到来。当此函数返回时，events数组参数中将会包含产生事件的文件描述符。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> Looper::pollInner(<span class="keyword">int</span> timeoutMillis) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_POLL_AND_WAKE</span></span><br><span class="line">    ALOGD(<span class="string">"%p ~ pollOnce - waiting: timeoutMillis=%d"</span>, <span class="keyword">this</span>, timeoutMillis);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">//根据下一条消息的到期时间调整超时,</span></span><br><span class="line">    <span class="comment">// Adjust the timeout based on when the next message is due.</span></span><br><span class="line">    <span class="comment">//如果唤醒时间不等于0，而且下一条mMessageEnvelopes队列顶部消息的执行时间不为LLONG_MAX</span></span><br><span class="line">    <span class="comment">//mMessageEnvelopes相当于Java层的MessageQueue链表队列，队列中MessageEnvelope执行时间由小到大</span></span><br><span class="line">    <span class="keyword">if</span> (timeoutMillis != <span class="number">0</span> &amp;&amp; mNextMessageUptime != LLONG_MAX) &#123;</span><br><span class="line">        <span class="comment">//获取当前时间戳</span></span><br><span class="line">        <span class="keyword">nsecs_t</span> now = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">        <span class="comment">//判断当前时间与下一条消息的执行时间的时间间隔，这里称为delay时间。</span></span><br><span class="line">        <span class="keyword">int</span> messageTimeoutMillis = toMillisecondTimeoutDelay(now, mNextMessageUptime);</span><br><span class="line">        <span class="comment">//如果下一条消息的delay时间在现在之后</span></span><br><span class="line">        <span class="comment">//而且本地休眠不需要唤醒（timeoutMillis &lt; 0）或者下一条消息的delay时间比这次需要唤醒的时间靠前，那么修改本次唤醒时间</span></span><br><span class="line">        <span class="comment">//比如说这次休眠不需要唤醒，或者下一条消息是1s后唤醒，这次消息需要2s后唤醒，那么将唤醒时间修改为1s</span></span><br><span class="line">        <span class="keyword">if</span> (messageTimeoutMillis &gt;= <span class="number">0</span></span><br><span class="line">                &amp;&amp; (timeoutMillis &lt; <span class="number">0</span> || messageTimeoutMillis &lt; timeoutMillis)) &#123;</span><br><span class="line">            timeoutMillis = messageTimeoutMillis;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_POLL_AND_WAKE</span></span><br><span class="line">        ALOGD(<span class="string">"%p ~ pollOnce - next message in %lldns, adjusted timeout: timeoutMillis=%d"</span>,</span><br><span class="line">                <span class="keyword">this</span>, mNextMessageUptime - now, timeoutMillis);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始唤醒或等待唤醒</span></span><br><span class="line">    <span class="comment">// Poll.</span></span><br><span class="line">    <span class="keyword">int</span> result = POLL_WAKE;</span><br><span class="line">    <span class="comment">//回调容器清空，索引重置</span></span><br><span class="line">    mResponses.clear();</span><br><span class="line">    mResponseIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// We are about to idle.</span></span><br><span class="line">    mIdling = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//eventItems为mEpollFd注册的时间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">eventItems</span>[<span class="title">EPOLL_MAX_EVENTS</span>];</span></span><br><span class="line">    <span class="comment">//陷入等待状态，直到其注册的事件之一发生之后才会返回，并且携带了刚刚发生的事件的详细信息。</span></span><br><span class="line">    <span class="keyword">int</span> eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</span><br><span class="line">    <span class="comment">// No longer idling.</span></span><br><span class="line">    mIdling = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// Acquire lock.</span></span><br><span class="line">    mLock.lock();</span><br><span class="line">    <span class="comment">//epoll_wait返回值小于0表示错误</span></span><br><span class="line">    <span class="comment">// Check for poll error.</span></span><br><span class="line">    <span class="keyword">if</span> (eventCount &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">            <span class="keyword">goto</span> Done;</span><br><span class="line">        &#125;</span><br><span class="line">        ALOGW(<span class="string">"Poll failed with an unexpected error, errno=%d"</span>, errno);</span><br><span class="line">        result = POLL_ERROR;</span><br><span class="line">        <span class="keyword">goto</span> Done;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//epoll_wait返回值等于0表示没有任何事件需要处理</span></span><br><span class="line">    <span class="comment">// Check for poll timeout.</span></span><br><span class="line">    <span class="keyword">if</span> (eventCount == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_POLL_AND_WAKE</span></span><br><span class="line">        ALOGD(<span class="string">"%p ~ pollOnce - timeout"</span>, <span class="keyword">this</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        result = POLL_TIMEOUT;</span><br><span class="line">        <span class="keyword">goto</span> Done;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//epoll_wait返回值大于0，处理eventCount个事件</span></span><br><span class="line">    <span class="comment">// Handle all events.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_POLL_AND_WAKE</span></span><br><span class="line">    ALOGD(<span class="string">"%p ~ pollOnce - handling events from %d fds"</span>, <span class="keyword">this</span>, eventCount);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; eventCount; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> fd = eventItems[i].data.fd;</span><br><span class="line">        <span class="keyword">uint32_t</span> epollEvents = eventItems[i].events;</span><br><span class="line">        <span class="comment">//判断是否是在构造函数中添加到epoll对象中的表示</span></span><br><span class="line">        <span class="keyword">if</span> (fd == mWakeReadPipeFd) &#123;</span><br><span class="line">            <span class="comment">//管道中已经有了可读数据</span></span><br><span class="line">            <span class="keyword">if</span> (epollEvents &amp; EPOLLIN) &#123;</span><br><span class="line">                <span class="comment">//进行读数据唤醒线程，清理管道，以便于下一次管道写入信息进行唤醒looper</span></span><br><span class="line">                awoken();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ALOGW(<span class="string">"Ignoring unexpected epoll events 0x%x on wake read pipe."</span>, epollEvents);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//其他事件(调用Looper::addFd方法添加的事件）添加到</span></span><br><span class="line">            <span class="keyword">ssize_t</span> requestIndex = mRequests.indexOfKey(fd);</span><br><span class="line">            <span class="keyword">if</span> (requestIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> events = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// EPOLLIN ：可读（包括对端SOCKET正常关闭）；</span></span><br><span class="line">                <span class="comment">// EPOLLOUT：可写；</span></span><br><span class="line">                <span class="comment">// EPOLLERR：错误；</span></span><br><span class="line">                <span class="comment">// EPOLLHUP：中断；</span></span><br><span class="line">                <span class="comment">// EPOLLPRI：高优先级的可读（这里应该表示有带外数据到来）；</span></span><br><span class="line">                <span class="comment">// EPOLLET： 将EPOLL设为边缘触发模式，这是相对于水平触发来说的。</span></span><br><span class="line">                <span class="comment">// EPOLLONESHOT：只监听一次事件，当监听完这次事件之后就不再监听该事件</span></span><br><span class="line">                <span class="keyword">if</span> (epollEvents &amp; EPOLLIN) events |= EVENT_INPUT;</span><br><span class="line">                <span class="keyword">if</span> (epollEvents &amp; EPOLLOUT) events |= EVENT_OUTPUT;</span><br><span class="line">                <span class="keyword">if</span> (epollEvents &amp; EPOLLERR) events |= EVENT_ERROR;</span><br><span class="line">                <span class="keyword">if</span> (epollEvents &amp; EPOLLHUP) events |= EVENT_HANGUP;</span><br><span class="line">                <span class="comment">//将events添加到mResponses队列中</span></span><br><span class="line">                pushResponse(events, mRequests.valueAt(requestIndex));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ALOGW(<span class="string">"Ignoring unexpected epoll events 0x%x on fd %d that is "</span></span><br><span class="line">                        <span class="string">"no longer registered."</span>, epollEvents, fd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">Done: ;</span><br><span class="line">    <span class="comment">//调用挂起的消息回调</span></span><br><span class="line">    <span class="comment">// Invoke pending message callbacks.</span></span><br><span class="line">    mNextMessageUptime = LLONG_MAX;</span><br><span class="line">    <span class="keyword">while</span> (mMessageEnvelopes.size() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//获取当先时间</span></span><br><span class="line">        <span class="keyword">nsecs_t</span> now = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">        <span class="comment">//获取链表顶部的MessageEnvelope对象</span></span><br><span class="line">        <span class="keyword">const</span> MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.itemAt(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//如果该MessageEnvelope的执行时间比现在要早或是现在，那么处理这个MessageEnvelope，并移除这个MessageEnvelope</span></span><br><span class="line">        <span class="keyword">if</span> (messageEnvelope.uptime &lt;= now) &#123;</span><br><span class="line">            <span class="comment">// Remove the envelope from the list.</span></span><br><span class="line">            <span class="comment">// We keep a strong reference to the handler until the call to handleMessage</span></span><br><span class="line">            <span class="comment">// finishes.  Then we drop it so that the handler can be deleted *before*</span></span><br><span class="line">            <span class="comment">// we reacquire our lock.</span></span><br><span class="line">            &#123; <span class="comment">// obtain handler</span></span><br><span class="line">                sp&lt;MessageHandler&gt; handler = messageEnvelope.handler;</span><br><span class="line">                Message message = messageEnvelope.message;</span><br><span class="line">                <span class="comment">//移除这个消息</span></span><br><span class="line">                mMessageEnvelopes.removeAt(<span class="number">0</span>);</span><br><span class="line">                mSendingMessage = <span class="literal">true</span>;</span><br><span class="line">                mLock.unlock();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_POLL_AND_WAKE || DEBUG_CALLBACKS</span></span><br><span class="line">                ALOGD(<span class="string">"%p ~ pollOnce - sending message: handler=%p, what=%d"</span>,</span><br><span class="line">                        <span class="keyword">this</span>, handler.get(), message.what);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                <span class="comment">//处理这个消息</span></span><br><span class="line">                handler-&gt;handleMessage(message);</span><br><span class="line">            &#125; <span class="comment">// release handler</span></span><br><span class="line">            mLock.lock();</span><br><span class="line">            mSendingMessage = <span class="literal">false</span>;</span><br><span class="line">            result = POLL_CALLBACK;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//直到顶部的MessageEnvelope的执行时间比现在晚</span></span><br><span class="line">            <span class="comment">//设置mNextMessageUptime为mMessageEnvelopes顶部消息的执行时间</span></span><br><span class="line">            <span class="comment">// The last message left at the head of the queue determines the next wakeup time.</span></span><br><span class="line">            mNextMessageUptime = messageEnvelope.uptime;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Release lock.</span></span><br><span class="line">    mLock.unlock();</span><br><span class="line">    <span class="comment">//调用所有响应回调。 </span></span><br><span class="line">    <span class="comment">// Invoke all response callbacks.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mResponses.size(); i++) &#123;</span><br><span class="line">        Response&amp; response = mResponses.editItemAt(i);</span><br><span class="line">        <span class="comment">//如果当前的Response不需要callback那么现在执行</span></span><br><span class="line">        <span class="keyword">if</span> (response.request.ident == POLL_CALLBACK) &#123;</span><br><span class="line">            <span class="keyword">int</span> fd = response.request.fd;</span><br><span class="line">            <span class="keyword">int</span> events = response.events;</span><br><span class="line">            <span class="keyword">void</span>* data = response.request.data;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_POLL_AND_WAKE || DEBUG_CALLBACKS</span></span><br><span class="line">            ALOGD(<span class="string">"%p ~ pollOnce - invoking fd event callback %p: fd=%d, events=0x%x, data=%p"</span>,</span><br><span class="line">                    <span class="keyword">this</span>, response.request.callback.get(), fd, events, data);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            <span class="comment">//处理所有回调的相应时间</span></span><br><span class="line">            <span class="keyword">int</span> callbackResult = response.request.callback-&gt;handleEvent(fd, events, data);</span><br><span class="line">            <span class="comment">//如果事件属于单次执行那么从mResponses删除这个文件描述符</span></span><br><span class="line">            <span class="keyword">if</span> (callbackResult == <span class="number">0</span>) &#123;</span><br><span class="line">                removeFd(fd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">////立即清除响应结构中的回调引用，因为在下一次轮询之前不会清除响应向量本身。</span></span><br><span class="line">            <span class="comment">// Clear the callback reference in the response structure promptly because we</span></span><br><span class="line">            <span class="comment">// will not clear the response vector itself until the next poll.</span></span><br><span class="line">            response.request.callback.clear();</span><br><span class="line">            <span class="comment">//需要回调响应</span></span><br><span class="line">            result = POLL_CALLBACK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进行读数据唤醒线程，清理管道，以便于下一次管道写入信息进行唤醒looper</span></span><br><span class="line"><span class="keyword">void</span> Looper::awoken() &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_POLL_AND_WAKE</span></span><br><span class="line">    ALOGD(<span class="string">"%p ~ awoken"</span>, <span class="keyword">this</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">16</span>];</span><br><span class="line">    <span class="comment">//成功返回读取的字节数，出错返回-1并设置errno</span></span><br><span class="line">    <span class="keyword">ssize_t</span> nRead;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        nRead = read(mWakeReadPipeFd, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">    &#125; <span class="keyword">while</span> ((nRead == <span class="number">-1</span> &amp;&amp; errno == EINTR) || nRead == <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好吧，方法真长。让我们继续 <code>fuck the source code</code> ，用我们自己的语言叙述一下这个方法。</p>
<ul>
<li>调整唤醒的超时时间，判断这个唤醒时间与 <code>MessageQueue</code> 链表头部消息的唤醒时间；</li>
<li>清除<code>mResponses</code> 内容重置索引，开始陷入等待事件中；</li>
<li>epoll_wait返回值小于0，result = POLL_ERROR;</li>
<li>epoll_wait返回值等于0，result = POLL_TIMEOUT;</li>
<li>epoll_wait返回值大于0，处理已经发生的事件；</li>
<li><ul>
<li>如果文件描述符是 <code>mWakeReadPipeFd</code> 而且事件为 <code>EPOLLIN</code> ，这个标识管道有数据写入，唤醒线程。需要的操作是清楚管道数据，等待下一次被唤醒；</li>
<li>否则将这个已经发送的事件添加到 <code>mResponses</code> 队列当中；</li>
</ul>
</li>
<li>处理<strong>C层</strong>消息队列 <code>mMessageEnvelopes</code> 中执行时间已经到期的消息；</li>
<li>处理 <code>mResponses</code> 数组中不需要信息返回的事件；</li>
</ul>
<h4 id="wake"><a href="#wake" class="headerlink" title="wake"></a>wake</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Looper.cpp</span></span><br><span class="line"><span class="keyword">void</span> Looper::wake() &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_POLL_AND_WAKE</span></span><br><span class="line">    ALOGD(<span class="string">"%p ~ wake"</span>, <span class="keyword">this</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">//写入文档的字节数（成功）；-1（出错）</span></span><br><span class="line">    <span class="keyword">ssize_t</span> nWrite;</span><br><span class="line">    <span class="comment">//Linux中系统调用的错误都存储于errno中</span></span><br><span class="line">    <span class="comment">//#define EPERM        1  /* Operation not permitted */</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        nWrite = write(mWakeWritePipeFd, <span class="string">"W"</span>, <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (nWrite == <span class="number">-1</span> &amp;&amp; errno == EINTR);</span><br><span class="line">    <span class="keyword">if</span> (nWrite != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//#define EAGAIN      11  /* Try again */</span></span><br><span class="line">        <span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">            ALOGW(<span class="string">"Could not write wake signal, errno=%d"</span>, errno);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当管道中写入数据的时候，管道的另一端就可以进行读操作，所以添加到 <code>Epoll</code> 中的事件就会进行处理从而唤起当前的线程。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在 <code>Looper</code> 的循环中我们由消息就处理消息，没有消息使用 <code>epoll_wait</code> 挂起当前的线程，这个时候是不会消耗 <code>CPU</code> 资源（或者说消耗的非常少）。</p>
<p>所以<strong>Looper的无线循环会使线程卡死么？</strong>这个问题的答案我们已经得到了不是么~！</p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Handler</tag>
        <tag>Looper</tag>
        <tag>postDelayed</tag>
        <tag>pollOnce</tag>
      </tags>
  </entry>
  <entry>
    <title>Java版的7种单例模式</title>
    <url>/2019/09/30/java-singleton/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><center><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMzE5ODc5LTljZjJhNGI0ZGVkMDYzZjEuanBlZw?x-oss-process=image/format,png" alt="宗介-波妞"></center>

<p>今天看到某一篇文章的一句话 <code>单例DCL</code> 前面加 <code>V</code> 。就这句话让我把 <code>单例模式</code> 又仔细看了一遍。</p>
<p><code>Java</code> 中的 <code>单例模式</code> 是我们一直且经常使用的设计模式之一，大家都很熟悉，所以这篇文章仅仅做我自己记忆。</p>
<p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p><code>单例模式</code> 涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<blockquote>
<ul>
<li>单例类只能有一个实例。</li>
<li>单例类必须自己创建自己的唯一实例。</li>
<li>单例类必须给所有其他对象提供这一实例。</li>
</ul>
</blockquote>
<h2 id="Java版七种单例模式写法"><a href="#Java版七种单例模式写法" class="headerlink" title="Java版七种单例模式写法"></a>Java版七种单例模式写法</h2><h2 id="一：懒汉，线程不安全"><a href="#一：懒汉，线程不安全" class="headerlink" title="一：懒汉，线程不安全"></a>一：懒汉，线程不安全</h2><blockquote>
<p>这种写法lazy loading很明显，但是致命的是在多线程不能正常工作。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="二：懒汉，线程安全"><a href="#二：懒汉，线程安全" class="headerlink" title="二：懒汉，线程安全"></a>二：懒汉，线程安全</h2><blockquote>
<p>这种写法能够在多线程中很好的工作，而且看起来它也具备很好的lazy loading，但是，遗憾的是，效率很低，99%情况下不需要同步。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="三：饿汉"><a href="#三：饿汉" class="headerlink" title="三：饿汉"></a>三：饿汉</h2><blockquote>
<p>这种方式基于classloder机制避免了多线程的同步问题，不过，instance在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用getInstance方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化instance显然没有达到lazy loading的效果。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="四：饿汉，变种"><a href="#四：饿汉，变种" class="headerlink" title="四：饿汉，变种"></a>四：饿汉，变种</h2><blockquote>
<p>表面上看起来差别挺大，其实更第三种方式差不多，都是在类初始化即实例化instance。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="五：静态内部类"><a href="#五：静态内部类" class="headerlink" title="五：静态内部类"></a>五：静态内部类</h2><blockquote>
<p>这种方式同样利用了classloder的机制来保证初始化instance时只有一个线程，它跟第三种和第四种方式不同的是（很细微的差别）：第三种和第四种方式是只要Singleton类被装载了，那么instance就会被实例化（没有达到lazy loading效果），而这种方式是Singleton类被装载了，instance不一定被初始化。因为SingletonHolder类没有被主动使用，只有显示通过调用getInstance方法时，才会显示装载SingletonHolder类，从而实例化instance。想象一下，如果实例化instance很消耗资源，我想让他延迟加载，另外一方面，我不希望在Singleton类加载时就实例化，因为我不能确保Singleton类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化instance显然是不合适的。这个时候，这种方式相比第三和第四种方式就显得很合理。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>似乎静态内部类看起来已经是最完美的方法了，其实不是，可能还存在反射攻击或者反序列化攻击。且看如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Singleton singleton = Singleton.getInstance();</span><br><span class="line">    Constructor&lt;Singleton&gt; constructor = Singleton.class.getDeclaredConstructor();</span><br><span class="line">    constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Singleton newSingleton = constructor.newInstance();</span><br><span class="line">    System.out.println(singleton == newSingleton);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="六：枚举"><a href="#六：枚举" class="headerlink" title="六：枚举"></a>六：枚举</h2><blockquote>
<p>这种方式是Effective Java作者Josh Bloch 提倡的方式，最佳的单例实现模式就是枚举模式。利用枚举的特性，让JVM来帮我们保证线程安全和单一实例的问题，而且还能防止反序列化重新创建新的对象。除此之外，写法还特别简单。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过反编译我们看到，枚举是在 <code>static</code> 块中进行的对象的创建。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">loadclass</span>.<span class="title">test</span>.<span class="title">Singleton</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Enum</span>&lt;<span class="title">com</span>.<span class="title">loadclass</span>.<span class="title">test</span>.<span class="title">Singleton</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> com.loadclass.test.Singleton INSTANCE;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> com.loadclass.test.Singleton[] values();</span><br><span class="line">    Code:</span><br><span class="line">       0: getstatic     #1                  // Field $VALUES:[Lcom/loadclass/test/Singleton;</span><br><span class="line">       3: invokevirtual #2                  // Method "[Lcom/loadclass/test/Singleton;".clone:()Ljava/lang/Object;</span><br><span class="line">       6: checkcast     #3                  // class "[Lcom/loadclass/test/Singleton;"</span><br><span class="line">       <span class="number">9</span>: areturn</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> com.loadclass.test.<span class="function">Singleton <span class="title">valueOf</span><span class="params">(java.lang.String)</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: ldc           #4                  // class com/loadclass/test/Singleton</span><br><span class="line">       <span class="number">2</span>: aload_0</span><br><span class="line">       3: invokestatic  #5                  // Method java/lang/Enum.valueOf:(Ljava/lang/Class;Ljava/lang/String;)Ljava/lang/Enum;</span><br><span class="line">       6: checkcast     #4                  // class com/loadclass/test/Singleton</span><br><span class="line">       <span class="number">9</span>: areturn</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       3: ldc           #8                  // String</span><br><span class="line">       5: invokevirtual #9                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">       <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">    Code:</span><br><span class="line">       0: new           #4                  // class com/loadclass/test/Singleton</span><br><span class="line">       <span class="number">3</span>: dup</span><br><span class="line">       4: ldc           #10                 // String INSTANCE</span><br><span class="line">       <span class="number">6</span>: iconst_0</span><br><span class="line">       7: invokespecial #11                 // Method "&lt;init&gt;":(Ljava/lang/String;I)V</span><br><span class="line">      10: putstatic     #12                 // Field INSTANCE:Lcom/loadclass/test/Singleton;</span><br><span class="line">      <span class="number">13</span>: iconst_1</span><br><span class="line">      14: anewarray     #4                  // class com/loadclass/test/Singleton</span><br><span class="line">      <span class="number">17</span>: dup</span><br><span class="line">      <span class="number">18</span>: iconst_0</span><br><span class="line">      19: getstatic     #12                 // Field INSTANCE:Lcom/loadclass/test/Singleton;</span><br><span class="line">      <span class="number">22</span>: aastore</span><br><span class="line">      23: putstatic     #1                  // Field $VALUES:[Lcom/loadclass/test/Singleton;</span><br><span class="line">      <span class="number">26</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="七：双重校验锁（-DCL：double-checked-locking"><a href="#七：双重校验锁（-DCL：double-checked-locking" class="headerlink" title="七：双重校验锁（ DCL：double-checked locking)"></a>七：双重校验锁（ DCL：double-checked locking)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// jdk1.6及之后，只要定义为private volatile static SingleTon instance 就可解决DCL失效问题。</span></span><br><span class="line">    <span class="comment">// volatile确保instance每次均在主内存中读取，这样虽然会牺牲一点效率，但也无伤大雅。</span></span><br><span class="line">    <span class="comment">// volatile可以保证即使java虚拟机对代码执行了指令重排序，也会保证它的正确性。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DCL及解决办法-amp-说明："><a href="#DCL及解决办法-amp-说明：" class="headerlink" title="DCL及解决办法&amp;说明："></a>DCL及解决办法&amp;说明：</h3><p>针对延迟加载法的同步实现所产生的性能低的问题，可以采用DCL，即双重检查加锁（Double Check Lock）的方法来避免每次调用getInstance()方法时都同步。</p>
<p>Double-Checked Locking看起来是非常完美的。但是很遗憾，根据Java的语言规范，上面的代码是不可靠的。<br> 出现上述问题, 最重要的2个原因如下:</p>
<blockquote>
<ul>
<li>编译器优化了程序指令, 以加快cpu处理速度.</li>
<li>多核cpu动态调整指令顺序, 以加快并行运算能力.</li>
</ul>
</blockquote>
<p> 问题出现的顺序:</p>
<blockquote>
<ul>
<li>线程A, 发现对象未实例化, 准备开始实例化</li>
<li>由于编译器优化了程序指令, 允许对象在构造函数未调用完前, 将共享变量的引用指向部分构造的对象, 虽然对象未完全实例化, 但已经不为null了.</li>
<li>线程B, 发现部分构造的对象已不是null, 则直接返回了该对象.</li>
</ul>
</blockquote>
<p> 解决办法:<br>    可以将instance声明为volatile，即 private volatile static Singleton instance<br>    在线程B读一个volatile变量后，线程A在写这个volatile变量之前，所有可见的共享变量的值都将立即变得对线程B可见。</p>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><blockquote>
<ul>
<li>如果单例由不同的类装载器装入，那便有可能存在多个单例类的实例。假定不是远端存取，例如一些servlet容器对每个servlet使用完全不同的类  装载器，这样的话如果有两个servlet访问一个单例类，它们就都会有各自的实例。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Class <span class="title">getClass</span><span class="params">(String classname)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">    <span class="keyword">if</span> (classLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">        classLoader = Singleton.class.getClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (classLoader.loadClass(classname));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>如果Singleton实现了java.io.Serializable接口，那么这个类的实例就可能被序列化和复原。不管怎样，如果你序列化一个单例类的对象，接下来复原多个那个对象，那你就会有多个单例类的实例。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//ObjectInputStream.readObject调用</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Dart和Java通信源码分析和实践</title>
    <url>/2019/08/01/dart_channel_java_source/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Dart</code> 和 <code>Java</code> 通信这块的知识点涵盖了 <code>Dart&amp;C</code> 以及 <code>Java&amp;C</code> 的通信，我们先有简单的业务组件的定义再到底层实现原理进行分析，我们现在从Flutter定义的三种 <code>Channel</code> 中的 <code>MethodChannel</code> 使用进行剖析。</p>
<center><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMzE5ODc5LWZmMzEzMDNjNTE2MWZjYWQucG5n" alt="面无表情的我.png"></center>


<h1 id="Dart和Java通信的实践"><a href="#Dart和Java通信的实践" class="headerlink" title="Dart和Java通信的实践"></a>Dart和Java通信的实践</h1><h2 id="Java端ChannelPlugin的创建"><a href="#Java端ChannelPlugin的创建" class="headerlink" title="Java端ChannelPlugin的创建"></a>Java端ChannelPlugin的创建</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileProviderPlugin</span> <span class="keyword">implements</span> <span class="title">MethodChannel</span>.<span class="title">MethodCallHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String NAME = <span class="string">"plugins.flutter.io/file_plugin"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Registrar mRegistrar;</span><br><span class="line">    <span class="keyword">private</span> Context application;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileProviderPlugin</span><span class="params">(Registrar mRegistrar, Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mRegistrar = mRegistrar;</span><br><span class="line">        <span class="keyword">this</span>.application = context.getApplicationContext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerWith</span><span class="params">(Registrar registrar, Context context)</span> </span>&#123;</span><br><span class="line">        MethodChannel channel =</span><br><span class="line">                <span class="keyword">new</span> MethodChannel(registrar.messenger(), NAME);</span><br><span class="line">        FileProviderPlugin instance = <span class="keyword">new</span> FileProviderPlugin(registrar, context);</span><br><span class="line">        channel.setMethodCallHandler(instance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TargetApi</span>(Build.VERSION_CODES.FROYO)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMethodCall</span><span class="params">(MethodCall methodCall, Result result)</span> </span>&#123;</span><br><span class="line">        String path;</span><br><span class="line">        <span class="keyword">switch</span> (methodCall.method) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"getExternalStoragePublicDirectory"</span>:</span><br><span class="line">                path = Environment.getExternalStoragePublicDirectory(methodCall.arguments.toString()).getAbsolutePath();</span><br><span class="line">                result.success(path);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Java端ChannelPlugin的注册"><a href="#Java端ChannelPlugin的注册" class="headerlink" title="Java端ChannelPlugin的注册"></a>Java端ChannelPlugin的注册</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">FlutterActivity</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    GeneratedPluginRegistrant.registerWith(<span class="keyword">this</span>);</span><br><span class="line">    FileProviderPlugin.registerWith(<span class="keyword">this</span>.registrarFor(FileProviderPlugin.NAME), <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Dart端ChannelPlugin的创建"><a href="#Dart端ChannelPlugin的创建" class="headerlink" title="Dart端ChannelPlugin的创建"></a>Dart端ChannelPlugin的创建</h2><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/services.dart'</span>;</span><br><span class="line"><span class="keyword">const</span> MethodChannel _channel = <span class="keyword">const</span> MethodChannel(<span class="string">'plugins.flutter.io/file_plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">String</span> DIRECTORY_DCIM = <span class="string">"DCIM"</span>;</span><br><span class="line">Future&lt;Directory&gt; getExternalStoragePublicDirectory(<span class="built_in">String</span> type) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (Platform.isIOS)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedError(<span class="string">"Functionality not available on iOS"</span>);</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> path = <span class="keyword">await</span> _channel.invokeMethod(<span class="string">'getExternalStoragePublicDirectory'</span>, type);</span><br><span class="line">  <span class="keyword">if</span> (path == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Directory(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Dart端ChannelPlugin的使用"><a href="#Dart端ChannelPlugin的使用" class="headerlink" title="Dart端ChannelPlugin的使用"></a>Dart端ChannelPlugin的使用</h2><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Page</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span></span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(title: Text(<span class="string">'Reading and Writing Files'</span>)),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Text(<span class="string">"this page name is test"</span>),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        onPressed: _click,</span><br><span class="line">        tooltip: <span class="string">'Increment'</span>,</span><br><span class="line">        child: Icon(Icons.add),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _click() &#123;</span><br><span class="line">    _getExternalStoragePublicDirectory(FileUtils.DIRECTORY_DCIM).then((path) &#123;</span><br><span class="line">      <span class="built_in">print</span>(path);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">//获取存储图片和视频文件目录</span></span><br><span class="line">  Future&lt;<span class="built_in">String</span>&gt; _getExternalStoragePublicDirectory(<span class="built_in">String</span> s) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> directory = <span class="keyword">await</span> FileUtils.getExternalStoragePublicDirectory(s);</span><br><span class="line">    <span class="keyword">return</span> directory.path;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结果输出"><a href="#结果输出" class="headerlink" title="结果输出"></a>结果输出</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">I/flutter (<span class="number">16780</span>): /storage/emulated/<span class="number">0</span>/DCIM</span><br></pre></td></tr></table></figure>
<h1 id="源代码分析"><a href="#源代码分析" class="headerlink" title="源代码分析"></a>源代码分析</h1><h2 id="Dart端代码"><a href="#Dart端代码" class="headerlink" title="Dart端代码"></a>Dart端代码</h2><h3 id="MethodChannel信息的封装"><a href="#MethodChannel信息的封装" class="headerlink" title="MethodChannel信息的封装"></a>MethodChannel信息的封装</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodChannel</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> MethodChannel(<span class="keyword">this</span>.name, [<span class="keyword">this</span>.codec = <span class="keyword">const</span> StandardMethodCodec()]);</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> name;</span><br><span class="line">  <span class="keyword">final</span> MethodCodec codec;</span><br><span class="line">  <span class="meta">@optionalTypeArgs</span></span><br><span class="line">  Future&lt;T&gt; invokeMethod&lt;T&gt;(<span class="built_in">String</span> method, [<span class="keyword">dynamic</span> arguments]) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">assert</span>(method != <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">final</span> ByteData result = <span class="keyword">await</span> BinaryMessages.send(</span><br><span class="line">      name,</span><br><span class="line">      <span class="comment">//构造一个MethodCall对象，并调用StandardMethodCodec的encode将其写入一个ByteData中。</span></span><br><span class="line">      codec.encodeMethodCall(MethodCall(method, arguments)),</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> MissingPluginException(<span class="string">'No implementation found for method $method on channel $name'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> T typedResult = codec.decodeEnvelope(result);</span><br><span class="line">    <span class="keyword">return</span> typedResult;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/******部分代码省略******/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//MethodCall对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodCall</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> MethodCall(<span class="keyword">this</span>.method, [<span class="keyword">this</span>.arguments]): <span class="keyword">assert</span>(method != <span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> method;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">dynamic</span> arguments;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> toString() =&gt; <span class="string">'$runtimeType($method, $arguments)'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//默认的对函数进行编解码工具</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StandardMethodCodec</span> <span class="keyword">implements</span> <span class="title">MethodCodec</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> StandardMethodCodec([<span class="keyword">this</span>.messageCodec = <span class="keyword">const</span> StandardMessageCodec()]);</span><br><span class="line">  <span class="keyword">final</span> StandardMessageCodec messageCodec;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  ByteData encodeMethodCall(MethodCall call) &#123;</span><br><span class="line">    <span class="keyword">final</span> WriteBuffer buffer = WriteBuffer();</span><br><span class="line">    messageCodec.writeValue(buffer, call.method);</span><br><span class="line">    messageCodec.writeValue(buffer, call.arguments);</span><br><span class="line">    <span class="keyword">return</span> buffer.done();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/******部分代码省略******/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//默认的对数据信息编解码工具</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StandardMessageCodec</span> <span class="keyword">implements</span> <span class="title">MessageCodec</span>&lt;<span class="title">dynamic</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> StandardMessageCodec();</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">int</span> _valueNull = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">int</span> _valueTrue = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">int</span> _valueFalse = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">int</span> _valueInt32 = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">int</span> _valueInt64 = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">int</span> _valueLargeInt = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">int</span> _valueFloat64 = <span class="number">6</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">int</span> _valueString = <span class="number">7</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">int</span> _valueUint8List = <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">int</span> _valueInt32List = <span class="number">9</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">int</span> _valueInt64List = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">int</span> _valueFloat64List = <span class="number">11</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">int</span> _valueList = <span class="number">12</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">int</span> _valueMap = <span class="number">13</span>;</span><br><span class="line">  <span class="comment">//数据转化</span></span><br><span class="line">  <span class="keyword">void</span> writeValue(WriteBuffer buffer, <span class="keyword">dynamic</span> value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">      buffer.putUint8(_valueNull);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">is</span> <span class="built_in">bool</span>) &#123;</span><br><span class="line">      buffer.putUint8(value ? _valueTrue : _valueFalse);</span><br><span class="line">    &#125;<span class="comment">/******部分代码省略******/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="信息传到C层"><a href="#信息传到C层" class="headerlink" title="信息传到C层"></a>信息传到C层</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryMessages</span> </span>&#123;</span><br><span class="line">  BinaryMessages._();</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, _MessageHandler&gt; _handlers =</span><br><span class="line">      &lt;<span class="built_in">String</span>, _MessageHandler&gt;&#123;&#125;;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, _MessageHandler&gt; _mockHandlers =</span><br><span class="line">      &lt;<span class="built_in">String</span>, _MessageHandler&gt;&#123;&#125;;</span><br><span class="line">  <span class="keyword">static</span> Future&lt;ByteData&gt; send(<span class="built_in">String</span> channel, ByteData message) &#123;</span><br><span class="line">    <span class="keyword">final</span> _MessageHandler handler = _mockHandlers[channel];</span><br><span class="line">    <span class="keyword">if</span> (handler != <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">return</span> handler(message);</span><br><span class="line">    <span class="keyword">return</span> _sendPlatformMessage(channel, message);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> Future&lt;ByteData&gt; _sendPlatformMessage(<span class="built_in">String</span> channel, ByteData message) &#123;</span><br><span class="line">    <span class="keyword">final</span> Completer&lt;ByteData&gt; completer = Completer&lt;ByteData&gt;();</span><br><span class="line">    ui.<span class="built_in">window</span>.sendPlatformMessage(channel, message, (ByteData reply) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        completer.complete(reply);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (exception, stack) &#123;</span><br><span class="line">        FlutterError.reportError(FlutterErrorDetails(</span><br><span class="line">          exception: exception,</span><br><span class="line">          stack: stack,</span><br><span class="line">          <span class="keyword">library</span>: <span class="string">'services library'</span>,</span><br><span class="line">          context: <span class="string">'during a platform message response callback'</span>,</span><br><span class="line">        ));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> completer.future;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/******部分代码省略******/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> </span>&#123;</span><br><span class="line">  Window._();</span><br><span class="line">  <span class="comment">/******部分代码省略******/</span></span><br><span class="line">  <span class="keyword">void</span> sendPlatformMessage(<span class="built_in">String</span> name,</span><br><span class="line">                           ByteData data,</span><br><span class="line">                           PlatformMessageResponseCallback callback) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">String</span> error =</span><br><span class="line">        _sendPlatformMessage(name, _zonedPlatformMessageResponseCallback(callback), data);</span><br><span class="line">    <span class="keyword">if</span> (error != <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Exception(error);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">String</span> _sendPlatformMessage(<span class="built_in">String</span> name,</span><br><span class="line">                              PlatformMessageResponseCallback callback,</span><br><span class="line">                              ByteData data) native <span class="string">'Window_sendPlatformMessage'</span>;</span><br><span class="line">  <span class="comment">/******部分代码省略******/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C层代码分析"><a href="#C层代码分析" class="headerlink" title="C层代码分析"></a>C层代码分析</h2><h3 id="Window-sendPlatformMessage方法"><a href="#Window-sendPlatformMessage方法" class="headerlink" title="Window_sendPlatformMessage方法"></a>Window_sendPlatformMessage方法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//engine/lib/ui/window/window.cc</span></span><br><span class="line"><span class="keyword">void</span> Window::RegisterNatives(tonic::DartLibraryNatives *natives) &#123; </span><br><span class="line">    natives-&gt;Register(&#123;</span><br><span class="line">        &#123;<span class="string">"Window_defaultRouteName"</span>, DefaultRouteName, <span class="number">1</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Window_scheduleFrame"</span>, ScheduleFrame, <span class="number">1</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Window_sendPlatformMessage"</span>, _SendPlatformMessage, <span class="number">4</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Window_respondToPlatformMessage"</span>, _RespondToPlatformMessage, <span class="number">3</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Window_render"</span>, Render, <span class="number">2</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Window_updateSemantics"</span>, UpdateSemantics, <span class="number">2</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Window_setIsolateDebugName"</span>, SetIsolateDebugName, <span class="number">2</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Window_reportUnhandledException"</span>, ReportUnhandledException, <span class="number">2</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Window_setNeedsReportTimings"</span>, SetNeedsReportTimings, <span class="number">2</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">    &#125;); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _SendPlatformMessage(Dart_NativeArguments args)&#123;</span><br><span class="line">    <span class="comment">//由DART_NATIVE_CALLBACK_STATIC宏生成的方法调用；</span></span><br><span class="line">  	<span class="comment">//详见：/fuchsia/tonic/dart_binding_macros.h</span></span><br><span class="line">    tonic::DartCallStatic(&amp;SendPlatformMessage, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Dart_Handle <span class="title">SendPlatformMessage</span><span class="params">(Dart_Handle window, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, Dart_Handle callback, Dart_Handle data_handle)</span></span>&#123;</span><br><span class="line">    UIDartState *dart_state = UIDartState::Current();</span><br><span class="line">    <span class="comment">//判断当前的window对象</span></span><br><span class="line">    <span class="keyword">if</span> (!dart_state-&gt;window())&#123;</span><br><span class="line">        <span class="keyword">return</span> tonic::ToDart(<span class="string">"Platform messages can only be sent from the main isolate"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果需要返回值构造返回体(PlatformMessageResponseDart),再向dart端做数据返回的时候需要</span></span><br><span class="line">    fml::RefPtr&lt;PlatformMessageResponse&gt; response;</span><br><span class="line">    <span class="keyword">if</span> (!Dart_IsNull(callback))&#123;</span><br><span class="line">        response = fml::MakeRefCounted&lt;PlatformMessageResponseDart&gt;(tonic::DartPersistentValue(dart_state, callback), dart_state-&gt;GetTaskRunners().GetUITaskRunner());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用window的client对象的HandlePlatformMessage方法处理消息</span></span><br><span class="line">  	<span class="comment">//window=&gt;WindowClient=&gt;RuntimeController(RuntimeDelegate=&gt;Engine).</span></span><br><span class="line">    <span class="comment">//所以最终调用的是Engine.HandlePlatformMessage</span></span><br><span class="line">    <span class="keyword">if</span> (Dart_IsNull(data_handle))&#123;</span><br><span class="line">        dart_state-&gt;window()-&gt;client()-&gt;HandlePlatformMessage(fml::MakeRefCounted&lt;PlatformMessage&gt;(name, response));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        tonic::DartByteData data(data_handle);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">uint8_t</span> *buffer = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span> *&gt;(data.data());</span><br><span class="line">        dart_state-&gt;window()-&gt;client()-&gt;HandlePlatformMessage(fml::MakeRefCounted&lt;PlatformMessage&gt;(name, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uint8_t</span>&gt;(buffer, buffer + data.length_in_bytes()), response));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Dart_Null();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Engine-HandlePlatformMessage"><a href="#Engine-HandlePlatformMessage" class="headerlink" title="Engine.HandlePlatformMessage"></a>Engine.HandlePlatformMessage</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//engine/shell/common/engine.h</span></span><br><span class="line"><span class="keyword">private</span>:Engine::Delegate&amp; delegate_;</span><br><span class="line"><span class="comment">//engine/shell/common/engine.cc</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">char</span> kAssetChannel[] = <span class="string">"flutter/assets"</span>;</span><br><span class="line"><span class="keyword">void</span> Engine::HandlePlatformMessage(fml::RefPtr&lt;PlatformMessage&gt; message)&#123;</span><br><span class="line">    <span class="comment">//判断当前的channel是不是flutter/assets</span></span><br><span class="line">    <span class="keyword">if</span> (message-&gt;channel() == kAssetChannel)&#123;</span><br><span class="line">        HandleAssetPlatformMessage(<span class="built_in">std</span>::move(message));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        delegate_.OnEngineHandlePlatformMessage(<span class="built_in">std</span>::move(message));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Engine对象的delegate"><a href="#Engine对象的delegate" class="headerlink" title="Engine对象的delegate_"></a>Engine对象的delegate_</h3><p><code>Shell</code> 作为 <code>Engine::Delegate</code> 的子类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//engine/shell/common/shell.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shell</span> <span class="title">final</span> :</span> <span class="keyword">public</span> PlatformView::Delegate, </span><br><span class="line">                    <span class="keyword">public</span> Animator::Delegate, </span><br><span class="line">                    <span class="keyword">public</span> Engine::Delegate, </span><br><span class="line">                    <span class="keyword">public</span> Rasterizer::Delegate, </span><br><span class="line">                    <span class="keyword">public</span> ServiceProtocol::Handler&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******部分代码省略********/</span></span><br><span class="line">    <span class="comment">// |Engine::Delegate|</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnEngineHandlePlatformMessage</span><span class="params">(fml::RefPtr&lt;PlatformMessage&gt; message)</span> override</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="OnEngineHandlePlatformMessage方法实现"><a href="#OnEngineHandlePlatformMessage方法实现" class="headerlink" title="OnEngineHandlePlatformMessage方法实现"></a>OnEngineHandlePlatformMessage方法实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sengine/hell/common/shell.cc</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">char</span> kSkiaChannel[] = <span class="string">"flutter/skia"</span>;</span><br><span class="line"><span class="comment">// |Engine::Delegate|</span></span><br><span class="line"><span class="keyword">void</span> Shell::OnEngineHandlePlatformMessage(</span><br><span class="line">    fml::RefPtr&lt;PlatformMessage&gt; message)&#123;</span><br><span class="line">    <span class="comment">//判断Shell是不是进行过setup</span></span><br><span class="line">    FML_DCHECK(is_setup_);</span><br><span class="line">    FML_DCHECK(task_runners_.GetUITaskRunner()-&gt;RunsTasksOnCurrentThread());</span><br><span class="line">    <span class="comment">//判断当前的channel是不是flutter/skia</span></span><br><span class="line">    <span class="keyword">if</span> (message-&gt;channel() == kSkiaChannel)&#123;</span><br><span class="line">        HandleEngineSkiaMessage(<span class="built_in">std</span>::move(message));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在主线程中post一个task</span></span><br><span class="line">    task_runners_.GetPlatformTaskRunner()-&gt;PostTask(</span><br><span class="line">        <span class="comment">//platform_view_是shell创建时候传过来的，也就是在Flutterview进行attach的时候出现的</span></span><br><span class="line">        <span class="comment">//在这里的PlatformView是PlatformViewAndroid</span></span><br><span class="line">        [view = platform_view_-&gt;GetWeakPtr(), message = <span class="built_in">std</span>::move(message)]() &#123;</span><br><span class="line">            <span class="keyword">if</span> (view)&#123;</span><br><span class="line">                view-&gt;HandlePlatformMessage(<span class="built_in">std</span>::move(message));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="PlatformView"><a href="#PlatformView" class="headerlink" title="PlatformView"></a>PlatformView</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// engine/shell/platform/android/platform_view_android.cc</span></span><br><span class="line"><span class="comment">// |PlatformView|</span></span><br><span class="line"><span class="keyword">void</span> PlatformViewAndroid::HandlePlatformMessage(</span><br><span class="line">    fml::RefPtr&lt;flutter::PlatformMessage&gt; message)&#123;</span><br><span class="line">    JNIEnv *env = fml::jni::AttachCurrentThread();</span><br><span class="line">    fml::jni::ScopedJavaLocalRef&lt;jobject&gt; view = java_object_.get(env);</span><br><span class="line">    <span class="keyword">if</span> (view.is_null())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> response_id = <span class="number">0</span>;</span><br><span class="line">  	<span class="comment">//如果需要相应</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> response = message-&gt;response())&#123;</span><br><span class="line">        response_id = next_response_id_++;</span><br><span class="line">      	<span class="comment">//将当前的response_id存储在pending_responses_</span></span><br><span class="line">        pending_responses_[response_id] = response;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> java_channel = fml::jni::StringToJavaString(env, message-&gt;channel());</span><br><span class="line">    <span class="comment">//带参数</span></span><br><span class="line">    <span class="keyword">if</span> (message-&gt;hasData())&#123;</span><br><span class="line">        fml::jni::ScopedJavaLocalRef&lt;jbyteArray&gt; message_array(</span><br><span class="line">            env, env-&gt;NewByteArray(message-&gt;data().size()));</span><br><span class="line">        env-&gt;SetByteArrayRegion(</span><br><span class="line">            message_array.obj(), <span class="number">0</span>, message-&gt;data().size(),</span><br><span class="line">            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> jbyte *&gt;(message-&gt;data().data()));</span><br><span class="line">        message = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// This call can re-enter in InvokePlatformMessageXxxResponseCallback.</span></span><br><span class="line">        FlutterViewHandlePlatformMessage(env, view.obj(), java_channel.obj(),</span><br><span class="line">                                         message_array.obj(), response_id);</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123; <span class="comment">// 不带参数</span></span><br><span class="line">        message = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// This call can re-enter in InvokePlatformMessageXxxResponseCallback.</span></span><br><span class="line">        FlutterViewHandlePlatformMessage(env, view.obj(), java_channel.obj(), <span class="literal">nullptr</span>, response_id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="JNI-OnLoad"><a href="#JNI-OnLoad" class="headerlink" title="JNI_OnLoad"></a>JNI_OnLoad</h3><p>在 <code>Android</code> 程序中  <code>so</code> 的加载都会调用 <code>so</code> 中的 <code>JNI_OnLoad</code> 方法， 详细的知识点可以从 <a href="https://www.jianshu.com/p/4c0f72233f65" target="_blank" rel="noopener">从JNI_OnLoad看so的加载</a> 这篇文章中学习。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//engine/shell/platform/android/library_loader.cc</span></span><br><span class="line"><span class="function">JNIEXPORT jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM *vm, <span class="keyword">void</span> *reserved)</span></span>&#123;</span><br><span class="line">    <span class="comment">// Initialize the Java VM.</span></span><br><span class="line">    fml::jni::InitJavaVM(vm);</span><br><span class="line">    JNIEnv *env = fml::jni::AttachCurrentThread();</span><br><span class="line">    <span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// Register FlutterMain.</span></span><br><span class="line">    result = flutter::FlutterMain::Register(env);</span><br><span class="line">    FML_CHECK(result);</span><br><span class="line">    <span class="comment">// Register PlatformView</span></span><br><span class="line">    result = flutter::PlatformViewAndroid::Register(env);</span><br><span class="line">    FML_CHECK(result);</span><br><span class="line">    <span class="comment">// Register VSyncWaiter.</span></span><br><span class="line">    result = flutter::VsyncWaiterAndroid::Register(env);</span><br><span class="line">    FML_CHECK(result);</span><br><span class="line">    <span class="keyword">return</span> JNI_VERSION_1_4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="FlutterMain-Register"><a href="#FlutterMain-Register" class="headerlink" title="FlutterMain::Register"></a>FlutterMain::Register</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// engine/shell/platform/android/platform_view_android_jni.cc</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FlutterViewHandlePlatformMessage</span><span class="params">(JNIEnv *env,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      jobject obj,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      jstring channel,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      jobject message,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      jint responseId)</span></span>&#123;</span><br><span class="line">    <span class="comment">//即调用FlutterJNI.handlePlatformMessage方法</span></span><br><span class="line">    env-&gt;CallVoidMethod(obj, g_handle_platform_message_method, channel, message,</span><br><span class="line">                        responseId);</span><br><span class="line">    FML_CHECK(CheckException(env));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RegisterApi</span><span class="params">(JNIEnv *env)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*******部分代码省略********/</span></span><br><span class="line">    <span class="comment">//这里的g_handle_platform_message_method为io/flutter/embedding/engine/FlutterJNI</span></span><br><span class="line">    g_handle_platform_message_method =</span><br><span class="line">        env-&gt;GetMethodID(g_flutter_jni_class-&gt;obj(), <span class="string">"handlePlatformMessage"</span>,</span><br><span class="line">                         <span class="string">"(Ljava/lang/String;[BI)V"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="PlatformViewAndroid-Register"><a href="#PlatformViewAndroid-Register" class="headerlink" title="PlatformViewAndroid::Register"></a>PlatformViewAndroid::Register</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//engine/shell/platform/android/flutter_main.cc</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;FlutterMain&gt; g_flutter_main;</span><br><span class="line"><span class="keyword">void</span> FlutterMain::Init(JNIEnv *env,</span><br><span class="line">                       jclass clazz,</span><br><span class="line">                       jobject context,</span><br><span class="line">                       jobjectArray jargs,</span><br><span class="line">                       jstring kernelPath,</span><br><span class="line">                       jstring appStoragePath,</span><br><span class="line">                       jstring engineCachesPath)&#123;</span><br><span class="line">    <span class="comment">/*******部分代码省略********/</span></span><br><span class="line">    g_flutter_main.reset(<span class="keyword">new</span> FlutterMain(<span class="built_in">std</span>::move(settings)));</span><br><span class="line">    g_flutter_main-&gt;SetupObservatoryUriCallback(env);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> FlutterMain::SetupObservatoryUriCallback(JNIEnv *env)&#123;</span><br><span class="line">    <span class="comment">/*******部分代码省略********/</span></span><br><span class="line">    g_flutter_jni_class = <span class="keyword">new</span> fml::jni::ScopedJavaGlobalRef&lt;jclass&gt;(</span><br><span class="line">        env, env-&gt;FindClass(<span class="string">"io/flutter/embedding/engine/FlutterJNI"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Java端代码"><a href="#Java端代码" class="headerlink" title="Java端代码"></a>Java端代码</h2><p>从上面我们看到了最终调用到了 <code>FlutterJNI.handlePlatformMessage</code> 方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//engine/shell/platform/android/io/flutter/embedding/engine/FlutterJNI.java</span></span><br><span class="line"><span class="comment">// Called by native.</span></span><br><span class="line"><span class="comment">// TODO(mattcarroll): determine if message is nonull or nullable</span></span><br><span class="line">@SuppressWarnings(<span class="string">"unused"</span>) </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handlePlatformMessage</span><span class="params">(@NonNull final String channel, byte[] message, final <span class="keyword">int</span> replyId)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (platformMessageHandler != null)&#123;</span><br><span class="line">        platformMessageHandler.handleMessageFromDart(channel, message, replyId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@UiThread </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPlatformMessageHandler</span><span class="params">(@Nullable PlatformMessageHandler platformMessageHandler)</span></span>&#123;</span><br><span class="line">    ensureRunningOnMainThread();</span><br><span class="line">    <span class="keyword">this</span>.platformMessageHandler = platformMessageHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们现在找到 <code>FlutterJNI</code> 中的 <code>platformMessageHandler</code> 实例就行。</p>
<h3 id="FlutterActivity中FlutterView的创建"><a href="#FlutterActivity中FlutterView的创建" class="headerlink" title="FlutterActivity中FlutterView的创建"></a>FlutterActivity中FlutterView的创建</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlutterActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">Provider</span>, <span class="title">PluginRegistry</span>, <span class="title">ViewFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"FlutterActivity"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FlutterActivityDelegate delegate = <span class="keyword">new</span> FlutterActivityDelegate(<span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FlutterActivityEvents eventDelegate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Provider viewProvider;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PluginRegistry pluginRegistry;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FlutterActivity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.eventDelegate = <span class="keyword">this</span>.delegate;</span><br><span class="line">        <span class="keyword">this</span>.viewProvider = <span class="keyword">this</span>.delegate;</span><br><span class="line">        <span class="keyword">this</span>.pluginRegistry = <span class="keyword">this</span>.delegate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*******部分代码省略********/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>FlutterActivityDelegate</code> 中的委托实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FlutterActivityDelegate</span> <span class="keyword">implements</span> <span class="title">FlutterActivityEvents</span>, <span class="title">Provider</span>, <span class="title">PluginRegistry</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*******部分代码省略********/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*******部分代码省略********/</span></span><br><span class="line">        String[] args = getArgsFromIntent(<span class="keyword">this</span>.activity.getIntent());</span><br><span class="line">        FlutterMain.ensureInitializationComplete(<span class="keyword">this</span>.activity.getApplicationContext(), args);</span><br><span class="line">        <span class="keyword">this</span>.flutterView = <span class="keyword">this</span>.viewFactory.createFlutterView(<span class="keyword">this</span>.activity);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.flutterView == <span class="keyword">null</span>) &#123;</span><br><span class="line">            FlutterNativeView nativeView = <span class="keyword">this</span>.viewFactory.createFlutterNativeView();</span><br><span class="line">            <span class="keyword">this</span>.flutterView = <span class="keyword">new</span> FlutterView(<span class="keyword">this</span>.activity, (AttributeSet)<span class="keyword">null</span>, nativeView);</span><br><span class="line">            <span class="keyword">this</span>.flutterView.setLayoutParams(matchParent);</span><br><span class="line">            <span class="keyword">this</span>.activity.setContentView(<span class="keyword">this</span>.flutterView);</span><br><span class="line">            <span class="keyword">this</span>.launchView = <span class="keyword">this</span>.createLaunchView();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.launchView != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.addLaunchView();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*******部分代码省略********/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*******部分代码省略********/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="FlutterNativeView中platformMessageHandler的注册"><a href="#FlutterNativeView中platformMessageHandler的注册" class="headerlink" title="FlutterNativeView中platformMessageHandler的注册"></a>FlutterNativeView中platformMessageHandler的注册</h3><p>在 <code>FlutterNativeView</code> 构造函数中我们直接看到 了往 <code>FlutterJNI</code> 中注册的是 <code>FlutterNativeView.PlatformMessageHandlerImpl</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlutterNativeView</span> <span class="keyword">implements</span> <span class="title">BinaryMessenger</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*******部分代码省略********/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FlutterNativeView</span><span class="params">(Context context, <span class="keyword">boolean</span> isBackgroundView)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mNextReplyId = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.mPendingReplies = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">this</span>.mContext = context;</span><br><span class="line">        <span class="keyword">this</span>.mPluginRegistry = <span class="keyword">new</span> FlutterPluginRegistry(<span class="keyword">this</span>, context);</span><br><span class="line">        <span class="keyword">this</span>.mFlutterJNI = <span class="keyword">new</span> FlutterJNI();</span><br><span class="line">        <span class="keyword">this</span>.mFlutterJNI.setRenderSurface(<span class="keyword">new</span> FlutterNativeView.RenderSurfaceImpl());</span><br><span class="line">        <span class="keyword">this</span>.mFlutterJNI.setPlatformMessageHandler(<span class="keyword">new</span> FlutterNativeView.PlatformMessageHandlerImpl());</span><br><span class="line">        <span class="keyword">this</span>.mFlutterJNI.addEngineLifecycleListener(<span class="keyword">new</span> FlutterNativeView.EngineLifecycleListenerImpl());</span><br><span class="line">        <span class="keyword">this</span>.attach(<span class="keyword">this</span>, isBackgroundView);</span><br><span class="line">        <span class="keyword">this</span>.assertAttached();</span><br><span class="line">        <span class="keyword">this</span>.mMessageHandlers = <span class="keyword">new</span> HashMap();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*******部分代码省略********/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="FlutterNativeView-PlatformMessageHandlerImpl"><a href="#FlutterNativeView-PlatformMessageHandlerImpl" class="headerlink" title="FlutterNativeView.PlatformMessageHandlerImpl"></a>FlutterNativeView.PlatformMessageHandlerImpl</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PlatformMessageHandlerImpl</span> <span class="keyword">implements</span> <span class="title">PlatformMessageHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*******部分代码省略********/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessageFromDart</span><span class="params">(<span class="keyword">final</span> String channel, <span class="keyword">byte</span>[] message, <span class="keyword">final</span> <span class="keyword">int</span> replyId)</span> </span>&#123;</span><br><span class="line">        FlutterNativeView.<span class="keyword">this</span>.assertAttached();</span><br><span class="line">        <span class="comment">//通过channel获取注册的BinaryMessageHandler</span></span><br><span class="line">        BinaryMessageHandler handler = (BinaryMessageHandler)FlutterNativeView.<span class="keyword">this</span>.mMessageHandlers.get(channel);</span><br><span class="line">        <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ByteBuffer buffer = message == <span class="keyword">null</span> ? <span class="keyword">null</span> : ByteBuffer.wrap(message);</span><br><span class="line">                <span class="comment">//调用BinaryMessageHandler的onMessage方法</span></span><br><span class="line">                handler.onMessage(buffer, <span class="keyword">new</span> BinaryReply() &#123;</span><br><span class="line">                    <span class="comment">/*******部分代码省略********/</span></span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">/*******部分代码省略********/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*******部分代码省略********/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面根据 <code>channel</code>  获取对应的 <code>BinaryMessagehandler</code> 实例，那么这个实现是通过什么方式在 <code>FlutterNativeView</code> 中的 <code>mMessageHandlers</code> 注册的呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//FlutterNativeView</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessageHandler</span><span class="params">(String channel, BinaryMessageHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.mMessageHandlers.remove(channel);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.mMessageHandlers.put(channel, handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现是在调用 <code>FlutterNativeView</code> 的 <code>setMessageHandler</code> 方法往 <code>mMessageHandlers</code> 添加 <code>BinaryMessageHandler</code> 。</p>
<h3 id="BinaryMessagehandler的注册"><a href="#BinaryMessagehandler的注册" class="headerlink" title="BinaryMessagehandler的注册"></a>BinaryMessagehandler的注册</h3><p>我们先回头看一下我们自定的 <code>FileProviderPlugin</code> 的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileProviderPlugin</span> <span class="keyword">implements</span> <span class="title">MethodChannel</span>.<span class="title">MethodCallHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String NAME = <span class="string">"plugins.flutter.io/file_plugin"</span>;</span><br><span class="line"> 		<span class="comment">/*******部分代码省略********/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerWith</span><span class="params">(Registrar registrar, Context context)</span> </span>&#123;</span><br><span class="line">        MethodChannel channel =</span><br><span class="line">                <span class="keyword">new</span> MethodChannel(registrar.messenger(), NAME);</span><br><span class="line">        FileProviderPlugin instance = <span class="keyword">new</span> FileProviderPlugin(registrar, context);</span><br><span class="line">        channel.setMethodCallHandler(instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//FlutterActivity</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Registrar <span class="title">registrarFor</span><span class="params">(String pluginKey)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//pluginRegistry的实例是FlutterActivityDelegate对象</span></span><br><span class="line">  	<span class="keyword">return</span> <span class="keyword">this</span>.pluginRegistry.registrarFor(pluginKey);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//FlutterActivityDelegate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Registrar <span class="title">registrarFor</span><span class="params">(String pluginKey)</span> </span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> <span class="keyword">this</span>.flutterView.getPluginRegistry().registrarFor(pluginKey);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//FlutterNativeView</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FlutterPluginRegistry <span class="title">getPluginRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> <span class="keyword">this</span>.mPluginRegistry;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//FlutterPluginRegistry</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Registrar <span class="title">registrarFor</span><span class="params">(String pluginKey)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.mPluginMap.containsKey(pluginKey)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Plugin key "</span> + pluginKey + <span class="string">" is already in use"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.mPluginMap.put(pluginKey, (Object)<span class="keyword">null</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> FlutterPluginRegistry.FlutterRegistrar(pluginKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//FlutterPluginRegistry.FlutterRegistrar</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">FlutterRegistrar</span> <span class="keyword">implements</span> <span class="title">Registrar</span> </span>&#123;</span><br><span class="line">  	<span class="function"><span class="keyword">public</span> BinaryMessenger <span class="title">messenger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> FlutterPluginRegistry.<span class="keyword">this</span>.mNativeView;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//MethodChannel</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodChannel</span> </span>&#123;</span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMethodCallHandler</span><span class="params">(@Nullable MethodChannel.MethodCallHandler handler)</span> </span>&#123;</span><br><span class="line">      	<span class="comment">//FlutterNativeView.setMessageHandler</span></span><br><span class="line">        <span class="keyword">this</span>.messenger.setMessageHandler(<span class="keyword">this</span>.name, handler == <span class="keyword">null</span> ? <span class="keyword">null</span> : <span class="keyword">new</span> MethodChannel.IncomingMethodCallHandler(handler));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BinaryMessageHandler-onMessage"><a href="#BinaryMessageHandler-onMessage" class="headerlink" title="BinaryMessageHandler.onMessage"></a>BinaryMessageHandler.onMessage</h3><p>我们找到了 <code>BinaryMessageHandler</code> 的实例对象为 <code>MethodChannel.IncomingMethodCallHandler</code> :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">IncomingMethodCallHandler</span> <span class="keyword">implements</span> <span class="title">BinaryMessageHandler</span></span>&#123;</span><br><span class="line">  	<span class="comment">//这里的Handler为我们定义的FileProviderPlugin</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MethodChannel.MethodCallHandler handler;</span><br><span class="line">    IncomingMethodCallHandler(MethodChannel.MethodCallHandler handler) &#123;</span><br><span class="line">      	<span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(ByteBuffer message, <span class="keyword">final</span> BinaryReply reply)</span> </span>&#123;</span><br><span class="line">	    MethodCall call = MethodChannel.<span class="keyword">this</span>.codec.decodeMethodCall(message);</span><br><span class="line">  	    <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//FileProviderPlugin的onMethodCall方法</span></span><br><span class="line">    	    <span class="keyword">this</span>.handler.onMethodCall(call, <span class="keyword">new</span> MethodChannel.Result() &#123;</span><br><span class="line">        	  	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">success</span><span class="params">(Object result)</span> </span>&#123;</span><br><span class="line">                    reply.reply(MethodChannel.<span class="keyword">this</span>.codec.encodeSuccessEnvelope(result));</span><br><span class="line">        		&#125;</span><br><span class="line">			    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(String errorCode, String errorMessage, Object errorDetails)</span> </span>&#123;</span><br><span class="line">                    reply.reply(MethodChannel.<span class="keyword">this</span>.codec.encodeErrorEnvelope(errorCode, errorMessage, errorDetails));</span><br><span class="line">          		&#125;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notImplemented</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    reply.reply((ByteBuffer)<span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException var5) &#123;</span><br><span class="line">            Log.e(<span class="string">"MethodChannel#"</span> + MethodChannel.<span class="keyword">this</span>.name, <span class="string">"Failed to handle method call"</span>, var5);</span><br><span class="line">            reply.reply(MethodChannel.<span class="keyword">this</span>.codec.encodeErrorEnvelope(<span class="string">"error"</span>, var5.getMessage(), (Object)<span class="keyword">null</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="消息回传到Dart端"><a href="#消息回传到Dart端" class="headerlink" title="消息回传到Dart端"></a>消息回传到Dart端</h2><p>我们 <code>Java</code> 在进行事件响应后执行 <code>MethodChannel.Result</code> 的 <code>success</code> 或者 <code>error</code> 方法将结果传递给 <code>Dart</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//FileProviderPlugin的onMethodCall方法</span></span><br><span class="line"><span class="keyword">this</span>.handler.onMethodCall(call, <span class="keyword">new</span> MethodChannel.Result() &#123;</span><br><span class="line">	  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">success</span><span class="params">(Object result)</span> </span>&#123;</span><br><span class="line">  	  reply.reply(MethodChannel.<span class="keyword">this</span>.codec.encodeSuccessEnvelope(result));</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(String errorCode, String errorMessage, Object errorDetails)</span> </span>&#123;</span><br><span class="line">    	reply.reply(MethodChannel.<span class="keyword">this</span>.codec.encodeErrorEnvelope(errorCode, errorMessage, errorDetails));</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notImplemented</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	reply.reply((ByteBuffer)<span class="keyword">null</span>);</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中我们看到最终调用的是 <code>BinaryReply</code> 的 <code>reply</code> 方法：</p>
<p>而 <code>BinaryReply</code> 是我们在消息传递过程中 <code>FlutterNativeView.PlatformMessageHandlerImpl</code> 调用 <code>handleMessageFromDart</code> 方法中产生的实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessageFromDart</span><span class="params">(<span class="keyword">final</span> String channel, <span class="keyword">byte</span>[] message, <span class="keyword">final</span> <span class="keyword">int</span> replyId)</span> </span>&#123;</span><br><span class="line">    FlutterNativeView.<span class="keyword">this</span>.assertAttached();</span><br><span class="line">    BinaryMessageHandler handler = (BinaryMessageHandler)FlutterNativeView.<span class="keyword">this</span>.mMessageHandlers.get(channel);</span><br><span class="line">    <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ByteBuffer buffer = message == <span class="keyword">null</span> ? <span class="keyword">null</span> : ByteBuffer.wrap(message);</span><br><span class="line">            handler.onMessage(buffer, <span class="keyword">new</span> BinaryReply() &#123;</span><br><span class="line">                <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean done = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reply</span><span class="params">(ByteBuffer reply)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (!FlutterNativeView.<span class="keyword">this</span>.isAttached()) &#123;</span><br><span class="line">                        Log.d(<span class="string">"FlutterNativeView"</span>, <span class="string">"handleMessageFromDart replying ot a detached view, channel="</span> + channel);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.done.getAndSet(<span class="keyword">true</span>)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Reply already submitted"</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (reply == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            FlutterNativeView.<span class="keyword">this</span>.mFlutterJNI.invokePlatformMessageEmptyResponseCallback(replyId);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            FlutterNativeView.<span class="keyword">this</span>.mFlutterJNI.invokePlatformMessageResponseCallback(replyId, reply, reply.position());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">/*******部分代码省略********/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到当 <code>replay</code> 不为空的时候我们调用的是 <code>FlutterNativeView.this.mFlutterJNI.invokePlatformMessageResponseCallback</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@UiThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokePlatformMessageResponseCallback</span><span class="params">(<span class="keyword">int</span> responseId)</span> </span>&#123;</span><br><span class="line">  	<span class="keyword">this</span>.ensureAttachedToNative();</span><br><span class="line">  	<span class="keyword">this</span>.nativeInvokePlatformMessageResponseCallback(<span class="keyword">this</span>.nativePlatformViewId, responseId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从而调用 <code>native</code> 的 <code>nativeInvokePlatformMessageEmptyResponseCallback</code>  ，这个方法在 <code>flutter</code> 的 <code>so</code> 加载的时候已经被注册了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//engine/shell/platform/android/platform_view_android_jni.cc</span></span><br><span class="line">&#123;</span><br><span class="line">  .name = <span class="string">"nativeInvokePlatformMessageResponseCallback"</span>,</span><br><span class="line">  .signature = <span class="string">"(JI)V"</span>,</span><br><span class="line">  .fnPtr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(</span><br><span class="line">    &amp;InvokePlatformMessageResponseCallback),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的 <code>C++</code> 的方法是 <code>InvokePlatformMessageEmptyResponseCallback</code> 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//engine/shell/platform/android/platform_view_android_jni.cc</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InvokePlatformMessageResponseCallback</span><span class="params">(JNIEnv* env,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  jobject jcaller,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  jlong shell_holder,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  jint responseId,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  jobject message,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  jint position)</span> </span>&#123;</span><br><span class="line">  ANDROID_SHELL_HOLDER-&gt;GetPlatformView()</span><br><span class="line">      -&gt;InvokePlatformMessageResponseCallback(env,         <span class="comment">//</span></span><br><span class="line">                                              responseId,  <span class="comment">//</span></span><br><span class="line">                                              message,     <span class="comment">//</span></span><br><span class="line">                                              position     <span class="comment">//</span></span><br><span class="line">      );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法有调用 <code>PlatfromView</code> 的 <code>InvokePlatformMessageResponseCallback</code> 方法，也就是:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//engine/shell/platform/android/platform_view_android.cc</span></span><br><span class="line"><span class="keyword">void</span> PlatformViewAndroid::InvokePlatformMessageResponseCallback(</span><br><span class="line">    JNIEnv* env,</span><br><span class="line">    jint response_id,</span><br><span class="line">    jobject java_response_data,</span><br><span class="line">    jint java_response_position) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!response_id)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">//找到存储在pending_responses_当中的PlatformMessageResponse</span></span><br><span class="line">  <span class="keyword">auto</span> it = pending_responses_.find(response_id);</span><br><span class="line">  <span class="keyword">if</span> (it == pending_responses_.end())</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">uint8_t</span>* response_data =</span><br><span class="line">      <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>*&gt;(env-&gt;GetDirectBufferAddress(java_response_data));</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uint8_t</span>&gt; response = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uint8_t</span>&gt;(</span><br><span class="line">      response_data, response_data + java_response_position);</span><br><span class="line">  <span class="keyword">auto</span> message_response = <span class="built_in">std</span>::move(it-&gt;second);</span><br><span class="line">  <span class="comment">//删除pending_responses_当中的PlatformMessageResponse</span></span><br><span class="line">  pending_responses_.erase(it);</span><br><span class="line">  <span class="comment">//调用PlatformMessageResponse的Complete方法</span></span><br><span class="line">  message_response-&gt;Complete(</span><br><span class="line">      <span class="built_in">std</span>::make_unique&lt;fml::DataMapping&gt;(<span class="built_in">std</span>::move(response)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面降到过我们在调用 <code>Engine.HandlePlatformMessage</code>  方法时构造的是 <code>PlatformMessageResponse</code> 对象是的 <code>PlatformMessageResponseDart</code> 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//engine/lib/ui/window/platform_message_response_dart.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlatformMessageResponseDart</span> :</span> <span class="keyword">public</span> PlatformMessageResponse &#123;</span><br><span class="line">  FML_FRIEND_MAKE_REF_COUNTED(PlatformMessageResponseDart);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Callable on any thread.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Complete</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;fml::Mapping&gt; data)</span> override</span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">CompleteEmpty</span><span class="params">()</span> override</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">PlatformMessageResponseDart</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      tonic::DartPersistentValue callback,</span></span></span><br><span class="line"><span class="function"><span class="params">      fml::RefPtr&lt;fml::TaskRunner&gt; ui_task_runner)</span></span>;</span><br><span class="line">  ~PlatformMessageResponseDart() override;</span><br><span class="line"></span><br><span class="line">  tonic::DartPersistentValue callback_;</span><br><span class="line">  fml::RefPtr&lt;fml::TaskRunner&gt; ui_task_runner_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//engine/lib/ui/window/platform_message_response_dart.cc</span></span><br><span class="line"><span class="keyword">void</span> PlatformMessageResponseDart::Complete(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;fml::Mapping&gt; data) &#123;</span><br><span class="line">  <span class="comment">//判断在构造PlatformMessageResponseDart时的callback是否为空</span></span><br><span class="line">  <span class="keyword">if</span> (callback_.is_empty())</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  FML_DCHECK(!is_complete_);</span><br><span class="line">  is_complete_ = <span class="literal">true</span>;</span><br><span class="line">  ui_task_runner_-&gt;PostTask(fml::MakeCopyable(</span><br><span class="line">      [callback = <span class="built_in">std</span>::move(callback_), data = <span class="built_in">std</span>::move(data)]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;tonic::DartState&gt; dart_state =</span><br><span class="line">            callback.dart_state().lock();</span><br><span class="line">        <span class="keyword">if</span> (!dart_state)</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        tonic::DartState::Scope scope(dart_state);</span><br><span class="line">        Dart_Handle byte_buffer = WrapByteData(<span class="built_in">std</span>::move(data));</span><br><span class="line">        <span class="comment">//带着byte_buffer参数调用callback方法，回调到dart端</span></span><br><span class="line">        tonic::DartInvoke(callback.Release(), &#123;byte_buffer&#125;);</span><br><span class="line">      &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>事件由 <code>dart</code> 到 <code>C</code> 再到 <code>Java</code> ，相应由 <code>Java</code> 到 <code>C</code> 再到 <code>dart</code> 的过程可以简单用一下步骤叙述：</p>
<blockquote>
<p>1、Application启动的时候加载flutter的so文件；<br>2、在加载so的时候注册了一系列的相关平台的函数以及操作类；<br>3、dart调用C层的方法顺便将数据传递给C层；<br>4、C层调用相关平台的注册的类的对应方法，<br>5、对应平台进行数据处理并返回数据；<br>6、事件到达系统底层之后找到事件的相应的句柄进行回调；</p>
</blockquote>
<p>在整个源码分析过程不免想了解到系统的更底层，结果引出我也解决不了的问题。哈哈尴尬^_^~!</p>
<p>真的很头痛。。。。</p>
<h2 id="问题一：tonic"><a href="#问题一：tonic" class="headerlink" title="问题一：tonic"></a>问题一：tonic</h2><p>为什么要弄这样的宏定义？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//tonic/dart_class_library.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DART_NATIVE_CALLBACK_STATIC(CLASS, METHOD)          \</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> CLASS##_##METHOD(Dart_NativeArguments args) &#123; \</span><br><span class="line">    tonic::DartCallStatic(&amp;CLASS::METHOD, args);            \</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//tonic/dart_args.h</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Sig&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DartCallStatic</span><span class="params">(Sig func, Dart_NativeArguments args)</span> </span>&#123;</span><br><span class="line">  <span class="function">DartArgIterator <span class="title">it</span><span class="params">(args, <span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="keyword">using</span> Indices = <span class="keyword">typename</span> IndicesForSignature&lt;Sig&gt;::type;</span><br><span class="line">  DartDispatcher&lt;Indices, Sig&gt; decoder(&amp;it);</span><br><span class="line">  <span class="keyword">if</span> (it.had_exception())</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  decoder.Dispatch(func);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="问题二：Dart-handle-amp-DartInvoke"><a href="#问题二：Dart-handle-amp-DartInvoke" class="headerlink" title="问题二：Dart_handle&amp;DartInvoke"></a>问题二：Dart_handle&amp;DartInvoke</h2><p><code>DartInvoke</code> 调用 <code>Dart_Handle</code> 方法就能执行 <code>dart</code> 的函数？<code>Dart_handle</code> 到底在 <code>C</code> 这一层是一个什么样的结构体，它的作用有什么？ </p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//tonic/logging/dart_invoke.cc</span></span><br><span class="line">Dart_Handle DartInvoke(Dart_Handle closure,</span><br><span class="line">                       std::initializer_list&lt;Dart_Handle&gt; args) &#123;</span><br><span class="line">  <span class="built_in">int</span> argc = args.size();</span><br><span class="line">  Dart_Handle* argv = const_cast&lt;Dart_Handle*&gt;(args.begin());</span><br><span class="line">  Dart_Handle handle = Dart_InvokeClosure(closure, argc, argv);</span><br><span class="line">  LogIfError(handle);</span><br><span class="line">  <span class="keyword">return</span> handle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sdk/runtime/include/dart_api.h</span></span><br><span class="line">DART_EXPORT DART_WARN_UNUSED_RESULT Dart_Handle</span><br><span class="line">Dart_InvokeClosure(Dart_Handle closure,</span><br><span class="line">                   <span class="built_in">int</span> number_of_arguments,</span><br><span class="line">                   Dart_Handle* arguments);</span><br><span class="line"></span><br><span class="line"><span class="comment">//dart/sdk/runtime/vm/dart_api_impl.cc</span></span><br><span class="line">DART_EXPORT Dart_Handle Dart_InvokeClosure(Dart_Handle closure,</span><br><span class="line">                                           <span class="built_in">int</span> number_of_arguments,</span><br><span class="line">                                           Dart_Handle* arguments) &#123;</span><br><span class="line">  DARTSCOPE(Thread::Current());</span><br><span class="line">  API_TIMELINE_DURATION(T);</span><br><span class="line">  CHECK_CALLBACK_STATE(T);</span><br><span class="line">  <span class="keyword">const</span> Instance&amp; closure_obj = Api::UnwrapInstanceHandle(Z, closure);</span><br><span class="line">  <span class="keyword">if</span> (closure_obj.IsNull() || !closure_obj.IsCallable(NULL)) &#123;</span><br><span class="line">    RETURN_TYPE_ERROR(Z, closure, Instance);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (number_of_arguments &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> Api::NewError(</span><br><span class="line">        <span class="string">"%s expects argument 'number_of_arguments' to be non-negative."</span>,</span><br><span class="line">        CURRENT_FUNC);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set up arguments to include the closure as the first argument.</span></span><br><span class="line">  <span class="keyword">const</span> Array&amp; args = Array::Handle(Z, Array::New(number_of_arguments + <span class="number">1</span>));</span><br><span class="line">  <span class="built_in">Object</span>&amp; obj = <span class="built_in">Object</span>::Handle(Z);</span><br><span class="line">  args.SetAt(<span class="number">0</span>, closure_obj);</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; number_of_arguments; i++) &#123;</span><br><span class="line">    obj = Api::UnwrapHandle(arguments[i]);</span><br><span class="line">    <span class="keyword">if</span> (!obj.IsNull() &amp;&amp; !obj.IsInstance()) &#123;</span><br><span class="line">      RETURN_TYPE_ERROR(Z, arguments[i], Instance);</span><br><span class="line">    &#125;</span><br><span class="line">    args.SetAt(i + <span class="number">1</span>, obj);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Now try to invoke the closure.</span></span><br><span class="line">  <span class="keyword">return</span> Api::NewHandle(T, DartEntry::InvokeClosure(args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>ChannelPlugin</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter路由管理和页面参数的传递（源码分析）</title>
    <url>/2019/07/20/flutter_router_source/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇 <a href="http://dandanlove.com/2019/07/20/flutter_router_fix_param/" target="_blank" rel="noopener">Flutter路由管理和页面参数的传递（获取&amp;返回）</a> 文章中我们讲述了这么用代码实现 <code>Flutter</code> 中页面参数的传递，这一篇我们用源码分析一下 <code>Navigator</code> 为什么可以进行页面参数传递。</p>
<p>从页面跳转入口的代码进行分析：</p>
<p><code>Navigator.of(context).pushNamed(&#39;/route1&#39;);</code></p>
<h1 id="Navigator-的获取"><a href="#Navigator-的获取" class="headerlink" title="Navigator 的获取"></a>Navigator 的获取</h1><p><code>Navigator</code> 对应的 <code>State</code> 是 <code>NavigatorState</code> ，所以实际上我们需要获取的是 <code>NavigatorState</code> 。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Navigator</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">/******部分代码省略*****/</span></span><br><span class="line">  <span class="keyword">static</span> NavigatorState of(</span><br><span class="line">    BuildContext context, &#123;</span><br><span class="line">      <span class="built_in">bool</span> rootNavigator = <span class="keyword">false</span>,</span><br><span class="line">      <span class="built_in">bool</span> nullOk = <span class="keyword">false</span>,</span><br><span class="line">    &#125;) &#123;</span><br><span class="line">    <span class="keyword">final</span> NavigatorState navigator = rootNavigator</span><br><span class="line">      ? context.rootAncestorStateOfType(<span class="keyword">const</span> TypeMatcher&lt;NavigatorState&gt;())</span><br><span class="line">      : context.ancestorStateOfType(<span class="keyword">const</span> TypeMatcher&lt;NavigatorState&gt;());</span><br><span class="line">    <span class="keyword">assert</span>(() &#123;</span><br><span class="line">      <span class="keyword">if</span> (navigator == <span class="keyword">null</span> &amp;&amp; !nullOk) &#123;</span><br><span class="line">        <span class="keyword">throw</span> FlutterError(</span><br><span class="line">          <span class="string">'Navigator operation requested with a context that does not include a Navigator.\n'</span></span><br><span class="line">          <span class="string">'The context used to push or pop routes from the Navigator must be that of a '</span></span><br><span class="line">          <span class="string">'widget that is a descendant of a Navigator widget.'</span></span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;());</span><br><span class="line">    <span class="keyword">return</span> navigator;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们从源看到 <code>NavigatorState</code> 的获取实际是获取的 <code>context.ancestorStateOfType</code> 。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Element</span> <span class="keyword">extends</span> <span class="title">DiagnosticableTree</span> <span class="keyword">implements</span> <span class="title">BuildContext</span> </span>&#123;</span><br><span class="line">  <span class="comment">/******部分代码省略*****/</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State ancestorStateOfType(TypeMatcher matcher) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(_debugCheckStateIsActiveForAncestorLookup());</span><br><span class="line">    <span class="built_in">Element</span> ancestor = _parent;</span><br><span class="line">    <span class="keyword">while</span> (ancestor != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//从当前的Element节点一直向上寻找到匹配的StatefulElement</span></span><br><span class="line">      <span class="keyword">if</span> (ancestor <span class="keyword">is</span> StatefulElement &amp;&amp; matcher.check(ancestor.state))</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      ancestor = ancestor._parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> StatefulElement statefulAncestor = ancestor;</span><br><span class="line">    <span class="comment">//返回匹配的StatefulElement的state</span></span><br><span class="line">    <span class="keyword">return</span> statefulAncestor?.state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>循环遍历向上寻找 <code>Navigato</code>r 的 <code>state</code> ，这里就是 <code>NavigatorState</code> 。</p>
<h1 id="Navigator的生成"><a href="#Navigator的生成" class="headerlink" title="Navigator的生成"></a>Navigator的生成</h1><p><code>Navigator</code> 的 <code>Widget</code> 是是什么时候添加到视图树中的呢？我们从 <code>Flutter</code> 应用程序的入口开始一步一步跟进代码的执行：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(...);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>MaterialApp</code> 传入 <code>routes</code> 和 <code>onGenerateRoute</code> 等参数，<code>MaterialApp</code> 的 <code>state</code> 是 <code>_MaterialAppState</code>  它构建的是 <code>WidgetsApp</code>  类型的 <code>Widget</code> ，同时 <code>routes</code> 和 <code>onGenerateRoute</code> 等参数也进行了透传。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaterialApp</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> MaterialApp(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="keyword">this</span>.navigatorKey,</span><br><span class="line">    <span class="keyword">this</span>.home,</span><br><span class="line">    <span class="keyword">this</span>.routes = <span class="keyword">const</span> &lt;<span class="built_in">String</span>, WidgetBuilder&gt;&#123;&#125;,</span><br><span class="line">    <span class="keyword">this</span>.initialRoute,</span><br><span class="line">    <span class="keyword">this</span>.onGenerateRoute,</span><br><span class="line">    <span class="keyword">this</span>.onUnknownRoute,</span><br><span class="line">    <span class="comment">/******部分代码省略*****/</span></span><br><span class="line">  &#125;)</span><br><span class="line">    <span class="comment">/******部分代码省略*****/</span></span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    _MaterialAppState createState() =&gt; _MaterialAppState();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MaterialAppState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MaterialApp</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">/******部分代码省略*****/</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    Widget result = WidgetsApp(</span><br><span class="line">      key: GlobalObjectKey(<span class="keyword">this</span>),</span><br><span class="line">      navigatorKey: widget.navigatorKey,</span><br><span class="line">      navigatorObservers: _navigatorObservers,</span><br><span class="line">      pageRouteBuilder: &lt;T&gt;(RouteSettings settings, WidgetBuilder builder) =&gt;</span><br><span class="line">      MaterialPageRoute&lt;T&gt;(settings: settings, builder: builder),</span><br><span class="line">      home: widget.home,</span><br><span class="line">      routes: widget.routes,</span><br><span class="line">      initialRoute: widget.initialRoute,</span><br><span class="line">      onGenerateRoute: widget.onGenerateRoute,</span><br><span class="line">      onUnknownRoute: widget.onUnknownRoute,</span><br><span class="line">      <span class="comment">/******部分代码省略*****/</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>我们再看看 <code>WidgetsApp</code> 对应的 <code>State</code> 的 <code>_WidgetsAppState</code> 。在<code>_WidgetsAppState</code> 的 <code>Widget build(BuildContext context)</code> 方法中我们找到了管理路由的 <code>Navigator</code> 的构造时机。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetsApp</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  WidgetsApp(&#123; <span class="comment">// can't be const because the asserts use methods on Iterable :-(</span></span><br><span class="line">    Key key,</span><br><span class="line">    <span class="keyword">this</span>.navigatorKey,</span><br><span class="line">    <span class="keyword">this</span>.onGenerateRoute,</span><br><span class="line">    <span class="keyword">this</span>.onUnknownRoute,</span><br><span class="line">    <span class="keyword">this</span>.navigatorObservers = <span class="keyword">const</span> &lt;NavigatorObserver&gt;[],</span><br><span class="line">    <span class="keyword">this</span>.initialRoute,</span><br><span class="line">    <span class="keyword">this</span>.pageRouteBuilder,</span><br><span class="line">    <span class="keyword">this</span>.home,</span><br><span class="line">    <span class="keyword">this</span>.routes = <span class="keyword">const</span> &lt;<span class="built_in">String</span>, WidgetBuilder&gt;&#123;&#125;,</span><br><span class="line">    <span class="comment">/******部分代码省略*****/</span></span><br><span class="line">    );</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    _WidgetsAppState createState() =&gt; _WidgetsAppState();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_WidgetsAppState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">WidgetsApp</span>&gt; <span class="keyword">implements</span> <span class="title">WidgetsBindingObserver</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    Widget navigator;</span><br><span class="line">    <span class="keyword">if</span> (_navigator != <span class="keyword">null</span>) &#123;</span><br><span class="line">      navigator = Navigator(</span><br><span class="line">        key: _navigator,</span><br><span class="line">        <span class="comment">// If window.defaultRouteName isn't '/', we should assume it was set</span></span><br><span class="line">        <span class="comment">// intentionally via `setInitialRoute`, and should override whatever</span></span><br><span class="line">        <span class="comment">// is in [widget.initialRoute].</span></span><br><span class="line">        initialRoute: WidgetsBinding.instance.<span class="built_in">window</span>.defaultRouteName != 		Navigator.defaultRouteName</span><br><span class="line">            ? WidgetsBinding.instance.<span class="built_in">window</span>.defaultRouteName</span><br><span class="line">            : widget.initialRoute ?? WidgetsBinding.instance.<span class="built_in">window</span>.defaultRouteName,</span><br><span class="line">        onGenerateRoute: _onGenerateRoute,</span><br><span class="line">        onUnknownRoute: _onUnknownRoute,</span><br><span class="line">        observers: widget.navigatorObservers,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    Widget result;</span><br><span class="line">    <span class="keyword">if</span> (widget.builder != <span class="keyword">null</span>) &#123;</span><br><span class="line">      result = Builder(</span><br><span class="line">        builder: (BuildContext context) &#123;</span><br><span class="line">          <span class="keyword">return</span> widget.builder(context, navigator);</span><br><span class="line">        &#125;,</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">assert</span>(navigator != <span class="keyword">null</span>);</span><br><span class="line">      result = navigator;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/******部分代码省略*****/</span></span><br><span class="line">    <span class="comment">/**上面经过多次的操作之后，navigator变为result的某个子孙节点上的child**/</span></span><br><span class="line">    Widget title;</span><br><span class="line">    <span class="keyword">if</span> (widget.onGenerateTitle != <span class="keyword">null</span>) &#123;</span><br><span class="line">      title = Builder(</span><br><span class="line">        <span class="comment">// This Builder exists to provide a context below the Localizations widget.</span></span><br><span class="line">        <span class="comment">// The onGenerateTitle callback can refer to Localizations via its context</span></span><br><span class="line">        <span class="comment">// parameter.</span></span><br><span class="line">        builder: (BuildContext context) &#123;</span><br><span class="line">          <span class="keyword">final</span> <span class="built_in">String</span> title = widget.onGenerateTitle(context);</span><br><span class="line">          <span class="keyword">assert</span>(title != <span class="keyword">null</span>, <span class="string">'onGenerateTitle must return a non-null String'</span>);</span><br><span class="line">          <span class="keyword">return</span> Title(</span><br><span class="line">            title: title,</span><br><span class="line">            color: widget.color,</span><br><span class="line">            child: result,</span><br><span class="line">          );</span><br><span class="line">        &#125;,</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      title = Title(</span><br><span class="line">        title: widget.title,</span><br><span class="line">        color: widget.color,</span><br><span class="line">        child: result,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/******部分代码省略*****/</span></span><br><span class="line">    <span class="comment">/**上面经过多次的操作之后，result变为title的某个子孙节点上的child**/</span></span><br><span class="line">    <span class="keyword">return</span> MediaQuery(</span><br><span class="line">      data: MediaQueryData.fromWindow(WidgetsBinding.instance.<span class="built_in">window</span>),</span><br><span class="line">      child: Localizations(</span><br><span class="line">        locale: appLocale,</span><br><span class="line">        delegates: _localizationsDelegates.toList(),</span><br><span class="line">        <span class="comment">//将title作为child视图，也就是说navigator变为其中的某个子孙节点视图</span></span><br><span class="line">        child: title,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在构建的 MediaQuery 就存在我们需要的 <code>Navigator</code> 。<br><img src="https://upload-images.jianshu.io/upload_images/1319879-79075fdee2f218d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Navigator.png"></p>
<p>这张图是程序运行时候使用（<a href="https://flutter.dev/docs/testing/debugging" target="_blank" rel="noopener">DevTools</a>）进行的页面元素分析，也证明了 <code>Navigator</code> 是在页面的 <code>Widget</code> 元素路径上的。</p>
<h1 id="pushNamed方法解析"><a href="#pushNamed方法解析" class="headerlink" title="pushNamed方法解析"></a>pushNamed方法解析</h1><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="meta">@optionalTypeArgs</span></span><br><span class="line"><span class="keyword">static</span> Future&lt;T&gt; pushNamed&lt;T <span class="keyword">extends</span> <span class="built_in">Object</span>&gt;(</span><br><span class="line">  BuildContext context,</span><br><span class="line">  <span class="built_in">String</span> routeName, &#123;</span><br><span class="line">  <span class="built_in">Object</span> arguments,</span><br><span class="line">  &#125;) &#123;</span><br><span class="line">  <span class="keyword">return</span> Navigator.of(context).pushNamed&lt;T&gt;(routeName, arguments: arguments);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@optionalTypeArgs</span></span><br><span class="line">Future&lt;T&gt; pushNamed&lt;T <span class="keyword">extends</span> <span class="built_in">Object</span>&gt;(</span><br><span class="line">  <span class="built_in">String</span> routeName, &#123;</span><br><span class="line">  <span class="built_in">Object</span> arguments,</span><br><span class="line">&#125;) &#123;</span><br><span class="line">  <span class="keyword">return</span> push&lt;T&gt;(_routeNamed&lt;T&gt;(routeName, arguments: arguments));</span><br><span class="line">&#125;</span><br><span class="line">Route&lt;T&gt; _routeNamed&lt;T&gt;(<span class="built_in">String</span> name, &#123; <span class="meta">@required</span> <span class="built_in">Object</span> arguments, <span class="built_in">bool</span> allowNull = <span class="keyword">false</span> &#125;) &#123;</span><br><span class="line">  <span class="keyword">assert</span>(!_debugLocked);</span><br><span class="line">  <span class="keyword">assert</span>(name != <span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">final</span> RouteSettings settings = RouteSettings(</span><br><span class="line">    name: name,</span><br><span class="line">    isInitialRoute: _history.isEmpty,</span><br><span class="line">    arguments: arguments,</span><br><span class="line">  );</span><br><span class="line">  Route&lt;T&gt; route = widget.onGenerateRoute(settings);</span><br><span class="line">  <span class="keyword">if</span> (route == <span class="keyword">null</span> &amp;&amp; !allowNull) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(() &#123;</span><br><span class="line">      <span class="keyword">if</span> (widget.onUnknownRoute == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> FlutterError(...);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;());</span><br><span class="line">    route = widget.onUnknownRoute(settings);</span><br><span class="line">    <span class="keyword">assert</span>(() &#123;</span><br><span class="line">      <span class="keyword">if</span> (route == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> FlutterError(...);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> route;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到是调用了 <code>widget.onGenerateRoute(settings)</code> 生成路由， 这里的 <code>onGenerateRoute</code> 在 <code>Navigator</code> 在构造的时候传入的 <code>onGenerateRoute</code> 。</p>
<h1 id="onGenerateRoute"><a href="#onGenerateRoute" class="headerlink" title="onGenerateRoute"></a>onGenerateRoute</h1><p><code>Navigator</code> 在构造的时候如果我们细心就会发现 <code>onGenerateRoute</code> 现在改为了 <code>_onGenerateRoute</code> 。</p>
<p>也就是 <code>_WidgetsAppState</code> 的 <code>_onGenerateRoute</code> 方法实现：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Route&lt;<span class="keyword">dynamic</span>&gt; _onGenerateRoute(RouteSettings settings) &#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> name = settings.name;</span><br><span class="line">  <span class="comment">//从widget注册的路由中获取name对应的WidgetBuilder</span></span><br><span class="line">  <span class="keyword">final</span> WidgetBuilder pageContentBuilder = name == Navigator.defaultRouteName &amp;&amp; widget.home != <span class="keyword">null</span></span><br><span class="line">      ? (BuildContext context) =&gt; widget.home</span><br><span class="line">      : widget.routes[name];</span><br><span class="line">  <span class="comment">//如果pageContentBuilder不为空，那么和RouteSettings一起执行widget.pageRouteBuilder构造一个route</span></span><br><span class="line">  <span class="keyword">if</span> (pageContentBuilder != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(widget.pageRouteBuilder != <span class="keyword">null</span>,</span><br><span class="line">      <span class="string">'The default onGenerateRoute handler for WidgetsApp must have a '</span></span><br><span class="line">      <span class="string">'pageRouteBuilder set if the home or routes properties are set.'</span>);</span><br><span class="line">    <span class="keyword">final</span> Route&lt;<span class="keyword">dynamic</span>&gt; route = widget.pageRouteBuilder&lt;<span class="keyword">dynamic</span>&gt;(</span><br><span class="line">      settings,</span><br><span class="line">      pageContentBuilder,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">assert</span>(route != <span class="keyword">null</span>,</span><br><span class="line">      <span class="string">'The pageRouteBuilder for WidgetsApp must return a valid non-null Route.'</span>);</span><br><span class="line">    <span class="keyword">return</span> route;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果pageContentBuilder为空，那么执行widget.onGenerateRoute的方法</span></span><br><span class="line">  <span class="keyword">if</span> (widget.onGenerateRoute != <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> widget.onGenerateRoute(settings);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>widget.pageRouteBuilder</code> 的方法，我们在生成 <code>WidgetsApp</code>可以看到是：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">pageRouteBuilder: &lt;T&gt;(RouteSettings settings, WidgetBuilder builder) =&gt;</span><br><span class="line">            MaterialPageRoute&lt;T&gt;(settings: settings, builder: builder)</span><br></pre></td></tr></table></figure>
<p>所以最终我们通过在 <code>MaterialApp</code> 注册 <code>routes</code> 生成了一个 <code>MaterialPageRoute</code> 用来进行页面跳转。</p>
<p>最后如果 <code>routes</code> 为空的话，我们执行 <code>widget.onGenerateRoute</code> 。这个解释了在  <a href="http://dandanlove.com/2019/07/20/flutter_router_fix_param/" target="_blank" rel="noopener">Flutter路由管理和页面参数的传递（获取&amp;返回）</a>  这篇文章末尾说的 <code>onGenerateRoute</code> 方式进行的参数传递，必须不能进行 <code>routers</code> 的注册。</p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>flutter传参</tag>
        <tag>路由管理</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter路由管理和页面参数的传递（获取和返回）</title>
    <url>/2019/07/20/flutter_router_fix_param/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在做 <code>Flutter</code> 开发的时候所有的页面以及页面上的元素都变成了 <code>Widget</code> ，创建一个页面或者视图直接 <code>new</code> 一个新的 <code>widget</code> 就可以，相关的参数我们可以直接通过构造函数直接传递。</p>
<p>我们做 <code>Android</code> 开发的人员都知道 <code>Android</code> 应用程序在进行页面跳转的时候可以利用Intent进行参数传递，那么再开发 <code>Flutter</code> 的时候有类似的方式可以进行参数传递么？答案当然是有。</p>
<p><a href="https://flutterchina.club/cookbook/navigation/navigation-basics/" target="_blank" rel="noopener">Flutter中文网</a> 中有一段话，大多数应用程序包含多个页面。例如，我们可能有一个显示产品的页面，然后，用户可以点击产品，跳到该产品的详情页。</p>
<p>在Android中，页面对应的是Activity，在iOS中是ViewController。而在Flutter中，页面只是一个widget！</p>
<p>在Flutter中，我们那么我们可以使用<a href="https://docs.flutter.io/flutter/widgets/Navigator-class.html" target="_blank" rel="noopener"><code>Navigator</code></a>在页面之间跳转。</p>
<p>所以我们下边讲述 <code>widget</code> 的参数传递，从简单到简便：</p>
<blockquote>
<p>widget构造参数传递</p>
<p>route参数传递</p>
<p>上面两种方式进混合（onGenerateRoute）</p>
</blockquote>
<h1 id="widget构造参数传递"><a href="#widget构造参数传递" class="headerlink" title="widget构造参数传递"></a>widget构造参数传递</h1><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Page</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span></span>&#123;</span><br><span class="line">  Page(&#123;<span class="keyword">this</span>.arguments&#125;);</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Map</span> arguments;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Material(</span><br><span class="line">      child: Center(</span><br><span class="line">        child: Text(<span class="string">"this page name is <span class="subst">$&#123;arguments != <span class="keyword">null</span> ? arguments[<span class="string">'name'</span>] : <span class="string">'null'</span>&#125;</span>"</span>),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是一个简单的 <code>Flutter</code> 的视图组件，我们在使用参数 <code>arguments</code> 的时候只需要将其传入到 <code>Page({this.arguments})</code> 的构造函数中。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Flutter Demo'</span>,</span><br><span class="line">      home: Page(arguments: &#123;<span class="string">"name"</span>: <span class="string">'Flutter Demo Home Page'</span>&#125;),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式进行的参数传递只能单向往下一个页面传递，不能像Android的 <code>setResult</code> 一样往上一级页面传递数据。</p>
<h1 id="Route"><a href="#Route" class="headerlink" title="Route"></a>Route</h1><p>在讲 <code>Route</code> 传参的时候，我们先讲讲 <code>Flutter</code> 中 <code>Route</code> 相关的知识点。</p>
<p>路由( <code>Route</code> )在移动开发中通常指页面（ <code>Page</code> ），这跟 <code>web</code> 开发中单页应用的 <code>Route</code> 概念意义是相同的，<code>Route</code> 在<code>Android</code> 中通常指一个 <code>Activity</code> ，在 <code>iOS</code> 中指一个 <code>ViewController</code> 。所谓路由管理，就是管理页面之间如何跳转，通常也可被称为导航管理。这和原生开发类似，无论是 <code>Android</code> 还是 <code>iOS</code> ，导航管理都会维护一个路由栈，路由入栈( <code>push</code> )操作对应打开一个新页面，路由出栈( <code>pop</code>)操作对应页面关闭操作，而路由管理主要是指如何来管理路由栈。</p>
<h2 id="MaterialPageRoute"><a href="#MaterialPageRoute" class="headerlink" title="MaterialPageRoute"></a>MaterialPageRoute</h2><p><code>MaterialPageRoute</code> 是我们使用最为广泛的路由类，它继承自 <code>PageRoute</code> 类， <code>PageRoute</code> 类是一个抽象类继承抽象类 <code>ModalRoute</code>，下面我们介绍一下 <code>MaterialPageRoute</code>  构造函数的各个参数的意义：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">MaterialPageRoute(&#123;</span><br><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.builder,</span><br><span class="line">  RouteSettings settings,</span><br><span class="line">  <span class="keyword">this</span>.maintainState = <span class="keyword">true</span>,</span><br><span class="line">  <span class="built_in">bool</span> fullscreenDialog = <span class="keyword">false</span>,</span><br><span class="line">&#125;) : <span class="keyword">assert</span>(builder != <span class="keyword">null</span>),</span><br><span class="line">      <span class="keyword">assert</span>(maintainState != <span class="keyword">null</span>),</span><br><span class="line">      <span class="keyword">assert</span>(fullscreenDialog != <span class="keyword">null</span>),</span><br><span class="line">      <span class="keyword">assert</span>(opaque),</span><br><span class="line">      <span class="keyword">super</span>(settings: settings, fullscreenDialog: fullscreenDialog);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>builder</code> 是一个WidgetBuilder类型的回调函数，它的作用是构建路由页面的具体内容，返回值是一个widget。我们通常要实现此回调，返回新路由的实例。</li>
<li><code>settings</code> 包含路由的配置信息，如路由名称、路由参数、是否初始路由（首页）。</li>
<li><code>maintainState</code>：默认情况下，当入栈一个新路由时，原来的路由仍然会被保存在内存中，如果想在路由没用的时候释放其所占用的所有资源，可以设置<code>maintainState</code>为false。</li>
<li><code>fullscreenDialog</code>表示新的路由页面是否是一个全屏的模态对话框，在iOS中，如果<code>fullscreenDialog</code>为<code>true</code>，新页面将会从屏幕底部滑入（而不是水平方向）。</li>
</ul>
<blockquote>
<p>如果想自定义路由切换动画，可以自己继承PageRoute来实现，我们将在后面介绍动画时，实现一个自定义的路由Widget。</p>
</blockquote>
<h2 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h2><p>所谓命名路由（Named Route）即给路由起一个名字，然后可以通过路由名字直接打开新的路由。这为路由管理带来了一种直观、简单的方式。和 <code>Android</code> 中的 <code>ARrouter</code> 页面跳转框架所定义的 <code>path</code> 非常的类似。</p>
<h2 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h2><p>要想使用命名路由，我们必须先提供并注册一个路由表（routing table），这样应用程序才知道哪个名称与哪个路由Widget对应。路由表的定义是一个 <code>Map&lt;String, WidgetBuilder&gt;</code> 结构的 <code>Map</code> ， key 为路由的名称，是个字符串；value是个builder回调函数，用于生成相应的路由Widget。我们在通过路由名称入栈新路由时，应用会根据路由名称在路由表中找到对应的WidgetBuilder回调函数，然后调用该回调函数生成路由widget并返回。</p>
<p>我们在创建 <code>MaterialApp</code> 的时候就有一个 <code>routes</code> 构造参数：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MaterialApp(&#123;</span><br><span class="line">  Key key,</span><br><span class="line">  <span class="keyword">this</span>.navigatorKey,</span><br><span class="line">  <span class="keyword">this</span>.home,</span><br><span class="line">  <span class="keyword">this</span>.routes = <span class="keyword">const</span> &lt;<span class="built_in">String</span>, WidgetBuilder&gt;&#123;&#125;,</span><br><span class="line">  <span class="keyword">this</span>.initialRoute,</span><br><span class="line">  <span class="keyword">this</span>.onGenerateRoute,</span><br><span class="line">  <span class="keyword">this</span>.onUnknownRoute,</span><br><span class="line">  <span class="keyword">this</span>.navigatorObservers = <span class="keyword">const</span> &lt;NavigatorObserver&gt;[],</span><br><span class="line">  <span class="comment">/***********/</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="Navigator"><a href="#Navigator" class="headerlink" title="Navigator"></a>Navigator</h2><p> <code>Navigator</code>是一个路由管理的widget，它通过一个栈来管理一个路由widget集合。通常当前屏幕显示的页面就是栈顶的路由。<code>Navigator</code>提供了一系列方法来管理路由栈，我们主要使用 <code>push</code> 和 <code>pop</code> 连个操作进行页面的入栈和出栈。</p>
<h3 id="push"><a href="#push" class="headerlink" title="push"></a>push</h3><p>将给定的路由入栈（即打开新的页面），返回值是一个<code>Future</code>对象，用以接收新路由出栈（即关闭）时的返回数据。</p>
<p><code>push</code>  我们主要使用两个方法一个是直接 <code>push</code> 一个路由，另外一个是 <code>pushNamed</code> 一个命名路由地址（PS：要想使用命名路由必须提供并注册一个路由表，这后面会讲到）。</p>
<h4 id="push方法源码"><a href="#push方法源码" class="headerlink" title="push方法源码"></a>push方法源码</h4><p>下边是 <code>Navigator.push</code> 的源码，入参的 <code>Route</code> 对象中有一个 <code>RouteSettings</code> 成员变量，我们可以在构造 <code>Route</code> 对象的时候将需要传递的参数放在 <code>RouteSettings</code> 中。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="meta">@optionalTypeArgs</span></span><br><span class="line"><span class="keyword">static</span> Future&lt;T&gt; push&lt;T <span class="keyword">extends</span> <span class="built_in">Object</span>&gt;(BuildContext context, Route&lt;T&gt; route) &#123;</span><br><span class="line">  <span class="keyword">return</span> Navigator.of(context).push(route);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="push方法使用"><a href="#push方法使用" class="headerlink" title="push方法使用"></a>push方法使用</h4><p>我们可以将参数放在 <code>SecondScreen</code> 的构造函数中，也可以放在构造的 <code>MaterialPageRoute</code> 的 <code>RouteSettings</code> 中。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Navigator.push(</span><br><span class="line">  context,</span><br><span class="line">  <span class="keyword">new</span> MaterialPageRoute(builder: (context) =&gt; <span class="keyword">new</span> SecondScreen()),</span><br><span class="line">).then((data)&#123;</span><br><span class="line">  <span class="comment">//接受返回的参数</span></span><br><span class="line">  <span class="built_in">print</span>(data.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="pushNamed方法源码"><a href="#pushNamed方法源码" class="headerlink" title="pushNamed方法源码"></a>pushNamed方法源码</h3><p>第二种方式最终的实现也是调用的 <code>push</code> 方法，这中方法直接暴露了参数 <code>Object arguments</code> 。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="meta">@optionalTypeArgs</span></span><br><span class="line"><span class="keyword">static</span> Future&lt;T&gt; pushNamed&lt;T <span class="keyword">extends</span> <span class="built_in">Object</span>&gt;(</span><br><span class="line">  BuildContext context,</span><br><span class="line">  <span class="built_in">String</span> routeName, &#123;</span><br><span class="line">  <span class="built_in">Object</span> arguments,</span><br><span class="line">  &#125;) &#123;</span><br><span class="line">  <span class="keyword">return</span> Navigator.of(context).pushNamed&lt;T&gt;(routeName, arguments: arguments);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@optionalTypeArgs</span></span><br><span class="line">Future&lt;T&gt; pushNamed&lt;T <span class="keyword">extends</span> <span class="built_in">Object</span>&gt;(</span><br><span class="line">  <span class="built_in">String</span> routeName, &#123;</span><br><span class="line">  <span class="built_in">Object</span> arguments,</span><br><span class="line">&#125;) &#123;</span><br><span class="line">  <span class="keyword">return</span> push&lt;T&gt;(_routeNamed&lt;T&gt;(routeName, arguments: arguments));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="pushNamed方法使用"><a href="#pushNamed方法使用" class="headerlink" title="pushNamed方法使用"></a>pushNamed方法使用</h4><p>使用前提是 <code>/route1</code> 已经被注册到路由表中：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Navigator.of(context)</span><br><span class="line">  .pushNamed(</span><br><span class="line">    <span class="string">'/route1'</span>,</span><br><span class="line">    arguments: &#123;</span><br><span class="line">      <span class="string">"name"</span>: <span class="string">'hello'</span></span><br><span class="line">    &#125;</span><br><span class="line">	).then((data)&#123;</span><br><span class="line">  	<span class="comment">//接受返回的参数</span></span><br><span class="line">  	<span class="built_in">print</span>(data.toString());</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h3><p>将栈顶路由出栈，入参为一个 <code>object</code> 类型的对象为当前页面关闭时返回给上一个页面的数据。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="meta">@optionalTypeArgs</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">bool</span> pop&lt;T <span class="keyword">extends</span> <span class="built_in">Object</span>&gt;(BuildContext context, [ T result ]) &#123;</span><br><span class="line">  <span class="keyword">return</span> Navigator.of(context).pop&lt;T&gt;(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用非常简单：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Navigator.of(context).pop(<span class="string">"ok~!"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="页面参数的传输、获取以及结果返回"><a href="#页面参数的传输、获取以及结果返回" class="headerlink" title="页面参数的传输、获取以及结果返回"></a>页面参数的传输、获取以及结果返回</h3><h4 id="参数传输"><a href="#参数传输" class="headerlink" title="参数传输"></a>参数传输</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Navigator.of(context).pushNamed(<span class="string">'/route1'</span>, arguments: &#123;<span class="string">"name"</span>: <span class="string">'hello'</span>&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="参数获取"><a href="#参数获取" class="headerlink" title="参数获取"></a>参数获取</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Page</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span></span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">dynamic</span> obj = ModalRoute.of(context).settings.arguments;</span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="keyword">null</span> &amp;&amp; isNotEmpty(obj[<span class="string">"name"</span>])) &#123;</span><br><span class="line">      name = obj[<span class="string">"name"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Material(</span><br><span class="line">      child: Center(</span><br><span class="line">        child: Text(<span class="string">"this page name is <span class="subst">$&#123;name&#125;</span>"</span>),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="参数返回"><a href="#参数返回" class="headerlink" title="参数返回"></a>参数返回</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//页面返回参数</span></span><br><span class="line">Navigator.of(context).pop(<span class="string">"ok~!"</span>);</span><br><span class="line"><span class="comment">//上一个页面接收参数</span></span><br><span class="line">Navigator.of(context)</span><br><span class="line">  .pushNamed(</span><br><span class="line">    <span class="string">'/route1'</span>,</span><br><span class="line">    arguments: &#123;</span><br><span class="line">      <span class="string">"name"</span>: <span class="string">'hello'</span></span><br><span class="line">    &#125;</span><br><span class="line">	).then((data)&#123;</span><br><span class="line">  	<span class="comment">//接受返回的参数</span></span><br><span class="line">  	<span class="built_in">print</span>(data.toString());</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="onGenerateRoute构建路由"><a href="#onGenerateRoute构建路由" class="headerlink" title="onGenerateRoute构建路由"></a>onGenerateRoute构建路由</h1><p>在说 <code>onGenerateRoute</code> 构建路由之前，我们得先了解他。前面 <code>MaterialApp</code> 的的构造函数中我们看到过它出现， <code>MaterialApp</code> 有一个参数类型为 <code>Function</code> 类型的 <code>onGenerateRoute</code> 。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span><br><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, WidgetBuilder&gt; routers = &#123;<span class="string">'/route1'</span>: (context, &#123;arguments&#125;) =&gt; Page(arguments: arguments)&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">// This widget is the root of your application.</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Flutter Demo'</span>,</span><br><span class="line">      <span class="comment">// 处理Named页面跳转 传递参数</span></span><br><span class="line">      onGenerateRoute: (RouteSettings settings) &#123;</span><br><span class="line">        <span class="comment">// 统一处理</span></span><br><span class="line">        <span class="keyword">final</span> <span class="built_in">String</span> name = settings.name;</span><br><span class="line">        <span class="keyword">final</span> <span class="built_in">Function</span> pageContentBuilder = routers[name];</span><br><span class="line">        <span class="keyword">if</span> (pageContentBuilder != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">final</span> Route route =</span><br><span class="line">          MaterialPageRoute(</span><br><span class="line">                builder: (context) &#123;</span><br><span class="line">                  <span class="comment">//将RouteSettings中的arguments参数取出来，通过构造函数传入</span></span><br><span class="line">                  <span class="keyword">return</span> pageContentBuilder(context, arguments: settings.arguments);</span><br><span class="line">                &#125;,</span><br><span class="line">                settings: settings,</span><br><span class="line">            );</span><br><span class="line">          <span class="keyword">return</span> route;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      theme: ThemeData(</span><br><span class="line">        primarySwatch: Colors.blue,</span><br><span class="line">      ),</span><br><span class="line">      home: MyHomePage(name: <span class="string">'Flutter Demo Home Page'</span>),</span><br><span class="line">      <span class="comment">//routes优先执行，所以必须注释掉，否则onGenerateRoute方法不会调用</span></span><br><span class="line">      <span class="comment">//routes: routers,</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Page</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span></span>&#123;</span><br><span class="line">  Page(&#123;<span class="keyword">this</span>.arguments&#125;);</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Map</span> arguments;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Material(</span><br><span class="line">      child: Center(</span><br><span class="line">        child: Text(<span class="string">"this page name is <span class="subst">$&#123;arguments != <span class="keyword">null</span> ? arguments[<span class="string">'name'</span>] : <span class="string">'null'</span>&#125;</span>"</span>),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>这种方式统一处理了页面的 <code>arguments</code> 参数，所以必须保证 <code>Map&lt;String, WidgetBuilder&gt; routers</code> 当中注册的所有 <code>Widget</code> 的构造函数中都有一个 <code>Map</code> 类型并且名为 <code>arguments</code> 的参数。</li>
<li>这种方法同时也传递了 <code>RouteSettings</code> ，所以在下一个页面我们也可以通过 <code>ModalRoute.of(context).settings.arguments</code> 方式获取参数。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>这种方式可以自定义 <code>PageRoute</code> 的类型，比如自带 <code>IOS</code> 侧滑返回效果的 <code>CupertinoPageRoute</code> 等。之前通过在  <code>WidgetsApp</code> 注册<code>routes</code> 的方式默认生成的 <code>PageRoute</code> 类型为 <code>MaterialPageRoute</code> 。</li>
</ul>
</blockquote>
<p>源码分析传送门：<a href="http://dandanlove.com/2019/07/20/flutter_router_source/" target="_blank" rel="noopener">Flutter路由管理和页面参数的传递（源码分析）</a></p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>flutter传参</tag>
        <tag>路由管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter混合开发：启动黑屏处理</title>
    <url>/2019/07/20/flutter_blank_screen_fix/</url>
    <content><![CDATA[<p>上一篇 <a href="http://dandanlove.com/2019/07/20/flutter_with_android_dev/" target="_blank" rel="noopener">Flutter混合开发：Android接入Flutter</a> 我们讲到在 <code>Flutter混合开发</code> 中主要有、有 <code>addView</code> （页面局部Flutter） 和 <code>setContentView</code> （整个页面Flutter）两种方式。这两种方式在启动页面的时候都会遇到 <code>FlutterView</code> 出现黑屏的情况。</p>
<h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>延迟 <code>FlutterView</code> 的加载时间。</p>
<h2 id="setContentView"><a href="#setContentView" class="headerlink" title="setContentView"></a>setContentView</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        View flutterView = Flutter.createView(MainActivity.<span class="keyword">this</span>, getLifecycle(), <span class="string">"root1"</span>);</span><br><span class="line">        FrameLayout.LayoutParams layout = <span class="keyword">new</span> FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT);</span><br><span class="line">        setContentView(flutterView, layout);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这中方式目前没有找到一种很好的方式推迟 <code>FlutterView</code> 的加载时间。</p>
<h2 id="addView"><a href="#addView" class="headerlink" title="addView"></a>addView</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        FrameLayout frameLayout = findViewById(R.id.flutter_root);</span><br><span class="line">        View flutterView = Flutter.createView(MainActivity.<span class="keyword">this</span>, getLifecycle(), <span class="string">"root1"</span>);</span><br><span class="line">        FrameLayout.LayoutParams layout = <span class="keyword">new</span> FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT);</span><br><span class="line">        frameLayout.addView(flutterView, layout);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种情况我们可以使用多种方式进行 <code>FlutterView</code> 加载的延迟。</p>
<h3 id="检测FlutterView的第一帧"><a href="#检测FlutterView的第一帧" class="headerlink" title="检测FlutterView的第一帧"></a>检测FlutterView的第一帧</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">      setContentView(R.layout.activity_main);</span><br><span class="line">      FrameLayout frameLayout = findViewById(R.id.flutter_root);</span><br><span class="line">      frameLayout.setVisibility(View.INVISIBLE);</span><br><span class="line">      FlutterView flutterView = Flutter.createView(MainActivity.<span class="keyword">this</span>, getLifecycle(), <span class="string">"root"</span>);</span><br><span class="line">      FrameLayout.LayoutParams layout = <span class="keyword">new</span> FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT);</span><br><span class="line"></span><br><span class="line">      FlutterView.FirstFrameListener listeners = () -&gt; frameLayout.setVisibility(View.VISIBLE);</span><br><span class="line">      flutterView.addFirstFrameListener(listeners);</span><br><span class="line">      frameLayout.addView(flutterView, layout);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在View的post方法中延迟执行FlutterView的添加"><a href="#在View的post方法中延迟执行FlutterView的添加" class="headerlink" title="在View的post方法中延迟执行FlutterView的添加"></a>在View的post方法中延迟执行FlutterView的添加</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">      setContentView(R.layout.activity_main);</span><br><span class="line">      FrameLayout frameLayout = findViewById(R.id.flutter_root);</span><br><span class="line">      FlutterView flutterView = Flutter.createView(MainActivity.<span class="keyword">this</span>, getLifecycle(), <span class="string">"root"</span>);</span><br><span class="line">      FrameLayout.LayoutParams layout = <span class="keyword">new</span> FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT);</span><br><span class="line">      getWindow().getDecorView().post(() -&gt; frameLayout.addView(flutterView, layout));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>flutter问题</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter混合开发：Android接入Flutter</title>
    <url>/2019/07/20/flutter_with_android_dev/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><center><img src="https://upload-images.jianshu.io/upload_images/1319879-de2f5f1d8891d703.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="Flutter.png"></center>

<p><code>Flutter</code> Google推出已经已经一年多了，单个 <code>Flutter</code> 项目的开发流程已经很成熟了。对与个人开发者来说使用 <code>Flutter</code> 开发一个跨平台的App挺有意思。但是对于现有的项目改造来说还是不建议，<code>Flutter</code> 中的控件还没有完全能满足我们的要求，我们需要解决这个问题会消耗我们大量的研发资源。</p>
<p>虽然 <code>Flutter</code> 无法接入我们的项目，但是我们可以尝试者去模仿 <code>Flutter</code> 在项目中的使用场景。下边我讲讲我在 <code>Android</code> 和 <code>Flutter</code> 的混合开发实践的躺坑之旅。</p>
<h2 id="官方指导"><a href="#官方指导" class="headerlink" title="官方指导"></a>官方指导</h2><p><a href="[https://github.com/flutter/flutter/wiki/Add-Flutter-to-existing-apps](https://github.com/flutter/flutter/wiki/Add-Flutter-to-existing-apps">Add Flutter to existing apps</a></p>
<h2 id="实践："><a href="#实践：" class="headerlink" title="实践："></a>实践：</h2><h3 id="创建Flutter模块"><a href="#创建Flutter模块" class="headerlink" title="创建Flutter模块"></a>创建Flutter模块</h3><p>如果你存在一个 <code>Android app</code> 的路径是 <code>some/path/MyApp</code> ，你希望创建你的 <code>Flutter</code> 项目作为子模块：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> cd some/path/</span><br><span class="line"><span class="meta">#</span> flutter create my_flutter是创建纯Flutter项目的命令</span><br><span class="line"><span class="meta">$</span> flutter create -t module my_flutter</span><br></pre></td></tr></table></figure>
<p>你能得到一个创建好的 <code>some/path/my_flutter</code> 的 <code>Flutter</code> 项目，它包含了一部分<code>Dart</code> 的代码。其中有一个 <code>.android/</code> 的隐藏的子文件夹，它包装了Android库中的模块项目。</p>
<h3 id="使主app依赖Flutter模块"><a href="#使主app依赖Flutter模块" class="headerlink" title="使主app依赖Flutter模块"></a>使主app依赖Flutter模块</h3><p>在主App的 <code>setting.gradle</code> 文件中包含 <code>Flutter</code> 模块作为子模块。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MyApp/settings.gradle</span></span><br><span class="line">include <span class="string">':app'</span>                                     <span class="comment">// assumed existing content</span></span><br><span class="line">setBinding(<span class="keyword">new</span> Binding([gradle: <span class="keyword">this</span>]))                                 <span class="comment">// new</span></span><br><span class="line">evaluate(<span class="keyword">new</span> File(                                                      <span class="comment">// new</span></span><br><span class="line">  settingsDir.parentFile,                                               <span class="comment">// new</span></span><br><span class="line">  <span class="string">'my_flutter/.android/include_flutter.groovy'</span>                          <span class="comment">// new</span></span><br><span class="line">))</span><br></pre></td></tr></table></figure>
<p>这个绑定和脚本评估允许 <code>Flutter</code> 模块可以包含自己（作为<code>:flutter</code>），在你自己的 <code>setting.gradle</code> 文件中， 任何 <code>Flutter</code> 插件可以作为模块使用（作为 <code>:package_info</code> , <code>:video_player</code> 等）。</p>
<p>在你的app采用 <code>implementation</code> 方式依赖 <code>Flutter</code> 模块：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MyApp/app/build.gradle</span></span><br><span class="line">:</span><br><span class="line">dependencies &#123;</span><br><span class="line">  <span class="function">implementation <span class="title">project</span><span class="params">(<span class="string">':flutter'</span>)</span></span></span><br><span class="line"><span class="function">  :</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="在你的Java代码中使用Flutter模块"><a href="#在你的Java代码中使用Flutter模块" class="headerlink" title="在你的Java代码中使用Flutter模块"></a>在你的Java代码中使用Flutter模块</h3><p>使用 <code>Flutter</code> 模块的Java接口  <code>Flutter.createView</code>  ，可以在你的app中添加 <code>Flutter View</code> 。</p>
<h4 id="addView"><a href="#addView" class="headerlink" title="addView"></a>addView</h4><center><img src="https://upload-images.jianshu.io/upload_images/1319879-a22ee322f894f259.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/620" alt="add.png"></center>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MyApp/app/src/main/java/some/package/MainActivity.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        FrameLayout frameLayout = findViewById(R.id.flutter_root);</span><br><span class="line">        View flutterView = Flutter.createView(MainActivity.<span class="keyword">this</span>, getLifecycle(), <span class="string">"root1"</span>);</span><br><span class="line">        FrameLayout.LayoutParams layout = <span class="keyword">new</span> FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT);</span><br><span class="line">        frameLayout.addView(flutterView, layout);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="setContentView"><a href="#setContentView" class="headerlink" title="setContentView"></a>setContentView</h4><p><center><img src="https://upload-images.jianshu.io/upload_images/1319879-beb144b6387966f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/620" alt="all.png"></center><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MyApp/app/src/main/java/some/package/MainActivity.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        View flutterView = Flutter.createView(MainActivity.<span class="keyword">this</span>, getLifecycle(), <span class="string">"root1"</span>);</span><br><span class="line">        FrameLayout.LayoutParams layout = <span class="keyword">new</span> FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT);</span><br><span class="line">        setContentView(flutterView, layout);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="fragment"><a href="#fragment" class="headerlink" title="fragment"></a>fragment</h4><p>也可以创建一个负责管理自己生命周期的FlutterFragment。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//io.flutter.facade.Flutter.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FlutterFragment <span class="title">createFragment</span><span class="params">(String initialRoute)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> FlutterFragment fragment = <span class="keyword">new</span> FlutterFragment();</span><br><span class="line">    <span class="keyword">final</span> Bundle args = <span class="keyword">new</span> Bundle();</span><br><span class="line">    args.putString(FlutterFragment.ARG_ROUTE, initialRoute);</span><br><span class="line">    fragment.setArguments(args);</span><br><span class="line">    <span class="keyword">return</span> fragment;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//io.flutter.facade.FlutterFragment.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlutterFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ARG_ROUTE = <span class="string">"route"</span>;</span><br><span class="line">    <span class="keyword">private</span> String mRoute = <span class="string">"/"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="keyword">if</span> (getArguments() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mRoute = getArguments().getString(ARG_ROUTE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInflate</span><span class="params">(Context context, AttributeSet attrs, Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onInflate(context, attrs, savedInstanceState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FlutterView <span class="title">onCreateView</span><span class="params">(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Flutter.createView(getActivity(), getLifecycle(), mRoute);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="dart代码交互"><a href="#dart代码交互" class="headerlink" title="dart代码交互"></a>dart代码交互</h3><p>上面我们使用了 <code>&quot;route1&quot;</code> 字符串告诉 <code>Flutter</code> 模块中的  <code>Dart</code> 代码展示那个 <code>widget</code> 。在 <code>Flutter</code> 模块项目的模板文件 <code>lib/main.dart</code> 中的可以使用<code>window。defaultRouteName</code> 作为提供路由选择的字符串，通过 <code>runApp</code> 决定创建那个 <code>widget</code> 。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:ui'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(_widgetForRoute(<span class="built_in">window</span>.defaultRouteName));</span><br><span class="line"></span><br><span class="line">Widget _widgetForRoute(<span class="built_in">String</span> route) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (route) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'route1'</span>:</span><br><span class="line">      <span class="keyword">return</span> SomeWidget(...);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'route2'</span>:</span><br><span class="line">      <span class="keyword">return</span> SomeOtherWidget(...);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> Center(</span><br><span class="line">        child: Text(<span class="string">'Unknown route: $route'</span>, textDirection: TextDirection.ltr),</span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构建和运行你的app"><a href="#构建和运行你的app" class="headerlink" title="构建和运行你的app"></a>构建和运行你的app</h3><p>一般在使用 <code>Android Studio</code> 中，你可以构建和运行 <code>Myapp</code> ，完全和在添加Flutter模块依赖项之前相同。也可以同样的进行代码的编辑、调试和分析。</p>
<h2 id="报错和解决"><a href="#报错和解决" class="headerlink" title="报错和解决"></a>报错和解决</h2><p>整个接入的过程一般是不会有问题的，但是呢？我们不按照官方提供的文档上自己一顿操作可能会产生其他的问题。</p>
<h3 id="关联项目报错"><a href="#关联项目报错" class="headerlink" title="关联项目报错"></a>关联项目报错</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">AILURE: Build failed with an exception.</span><br><span class="line"></span><br><span class="line">* Where:</span><br><span class="line">Settings file '/Users/tanzx/AndroidStudioWorkSapce/GitHub/MyApp/settings.gradle' line: 6</span><br><span class="line"></span><br><span class="line">* What went wrong:</span><br><span class="line">A problem occurred evaluating settings 'MyApp'.</span><br><span class="line"><span class="meta">&gt;</span> /Users/tanzx/AndroidStudioWorkSapce/GitHub/MyApp/my_flutter/.android/include_flutter.groovy (/Users/tanzx/AndroidStudioWorkSapce/GitHub/MyApp/my_flutter/.android/include_flutter.groovy)</span><br><span class="line"></span><br><span class="line">* Try:</span><br><span class="line">Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.</span><br><span class="line"></span><br><span class="line">* Get more help at https://help.gradle.org</span><br><span class="line"></span><br><span class="line">BUILD FAILED in 0s</span><br></pre></td></tr></table></figure>
<h4 id="报错原因："><a href="#报错原因：" class="headerlink" title="报错原因："></a>报错原因：</h4><p>将创建的 <code>Flutter</code> 模块放在了 <code>MyApp</code> 文件夹的内部，地址搞错。</p>
<h4 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h4><ul>
<li>将 <code>Flutter</code> 放在 <code>MyApp</code> 的外层；</li>
<li>将 <code>setting.gradle</code> 配置文件中的， <code>&#39;my_flutter/.android/include_flutter.groovy&#39;</code> 改为 <code>&#39;MyApp/my_flutter/.android/include_flutter.groovy&#39;</code> ；</li>
</ul>
<p>作为Android开发人员学习 <code>Flutter</code> 的第一步我们已经完成了，虽然后续的需要了解和学习的还有很多 <code>良好的开始是成功的一半</code> ，加油~！</p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>混合开发</tag>
      </tags>
  </entry>
  <entry>
    <title>细说InputStream和OutputStream</title>
    <url>/2019/06/14/inputstream/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们进行Android开发的时候经常会遇到各种 <code>io</code> 操作， 比如网络请求，文件操作，数据传输等。</p>
<p>Java中的 <code>InputStream</code> 和 <code>OutputStream</code> 都是 <code>io</code> 包中面向字节操作的顶级抽象类，关于java同步 <code>io</code>字节流的操作都是基于这两个的。</p>
<blockquote>
<ul>
<li>网络数据传输：<code>SocketInputStream</code> 和 <code>SocketOutputStream</code></li>
<li>文件操作：<code>FileInputStream</code> 和 <code>FileOutputStream</code></li>
<li>字节数据操作：<code>DataInputStream</code> 和 <code>DataOutputStream</code></li>
</ul>
</blockquote>
<h1 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.io;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStream</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//MAX_SKIP_BUFFER_SIZE用于确定最大缓冲区大小</span></span><br><span class="line">    <span class="comment">//在跳过时使用  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SKIP_BUFFER_SIZE = <span class="number">2048</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从输入流中读取下一个byte的数据，返回的是一个0~255之间的int类型数。</span></span><br><span class="line">    <span class="comment">//如果已经到了流的末尾没有byte数据那么返回-1。</span></span><br><span class="line">    <span class="comment">//此方法阻塞，直到输入数据可用、检测到流的末尾或抛出异常。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从输入流中读取一些字节，并将其存储到缓冲区数组b。</span></span><br><span class="line">    <span class="comment">//实际读取的字节数是以整数形式返回。此方法将阻塞，知道输入数据为止可用，检测到文件结尾，或抛出异常。</span></span><br><span class="line">    <span class="comment">//如果b的长度为0，则不读取任何字节，返回0。如果没有可用的字节，因为流是在文件结尾，返回值-1.</span></span><br><span class="line">    <span class="comment">//读取的字节数是：最多读取b的长度。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> read(b, <span class="number">0</span>, b.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从输入流中读取长度len的byte数据到一个数组中。</span></span><br><span class="line">    <span class="comment">//尝试尽可能的读取len长度的byte，但是可能读取较小的长度内荣，返回的是实际获取到的数据长度。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (off &lt; <span class="number">0</span> || len &lt; <span class="number">0</span> || len &gt; b.length - off) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> c = read();</span><br><span class="line">        <span class="keyword">if</span> (c == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        b[off] = (<span class="keyword">byte</span>)c;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; len ; i++) &#123;</span><br><span class="line">                c = read();</span><br><span class="line">                <span class="keyword">if</span> (c == -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                b[off + i] = (<span class="keyword">byte</span>)c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ee) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从输入流中跳过和丢弃n个byte数据。</span></span><br><span class="line">    <span class="comment">//返回实际丢弃的数据长度。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> remaining = n;</span><br><span class="line">        <span class="keyword">int</span> nr;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> size = (<span class="keyword">int</span>)Math.min(MAX_SKIP_BUFFER_SIZE, remaining);</span><br><span class="line">        <span class="keyword">byte</span>[] skipBuffer = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">        <span class="keyword">while</span> (remaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            nr = read(skipBuffer, <span class="number">0</span>, (<span class="keyword">int</span>)Math.min(size, remaining));</span><br><span class="line">            <span class="keyword">if</span> (nr &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            remaining -= nr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n - remaining;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//估计可以读取（或跳过的）字节数,下一次调用可能是同一个线程或另一个线程。</span></span><br><span class="line">    <span class="comment">//单个读取或跳过此操作许多字节不会阻塞，但可能会读取或跳过更少的字节。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">available</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭此输入流，并释放与这个流有关的任何系统资源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//标记输入流当前的位置，随后调用reset放在在最后的标记位置重新定位，以便后续读取相同的字节。</span></span><br><span class="line">    <span class="comment">//readlimit 参数标识此输入流允许在标记失效为止之前获取的字节数。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> readlimit)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将此输入流重新定位到上次调用mark方法标记的地方。</span></span><br><span class="line">    <span class="comment">//如果markSupported方法返回true，或者自从上次标记之后从该输入流中读取的数据大于标记的长度可能会抛出IOException。</span></span><br><span class="line">    <span class="comment">//如果markSupported方法返回false,那么调用改方法可能抛出IOException。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"mark/reset not supported"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试这个输入流是否支持标记和充值。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">markSupported</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>
<h1 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">OutputStream</span> <span class="keyword">implements</span> <span class="title">Closeable</span>, <span class="title">Flushable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将指定的字节写入输出流中，一般来说要写入的这个字节是参数的低8位，高24位忽略。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从指定的byte数组中写入到该输出流</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        write(b, <span class="number">0</span>, b.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从byte数组的off开始，想输出流中写入len长度的数据。可能空指针和数据越界异常。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((off &lt; <span class="number">0</span>) || (off &gt; b.length) || (len &lt; <span class="number">0</span>) ||</span><br><span class="line">                   ((off + len) &gt; b.length) || ((off + len) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; i++) &#123;</span><br><span class="line">            write(b[off + i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空输出流，强制将缓冲器的输出的数据被写入。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭此输出流并释放所有系统资源 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>因为 <code>InputStream</code> 和 <code>OutputStream</code> 的 <code>io</code> 操作中的‘输入’和‘输出’是不可靠的，发生的异常是不受程序控制。都会有 <code>IOExcepiton</code> 异常抛出，所以我们在使用的时候需要进行 <code>try/catch</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream in = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  in = <span class="keyword">new</span> ByteArrayInputStream(bytes)；</span><br><span class="line">  <span class="comment">//部分代码省略</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">  <span class="comment">//部分代码省略</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">      in.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">     <span class="comment">//部分代码省略</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>java7支持<code>try-with-resources</code>方式关闭流，实现了<code>java.lang.AutoCloseable</code>接口的对象支持用下边的方式进行流的关闭：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printFileJava7</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(FileInputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"file.txt"</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> data = input.read();</span><br><span class="line">        <span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>) data);</span><br><span class="line">            data = input.read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也支持一次性关闭多个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printFileJava7</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>(  FileInputStream     input         = <span class="keyword">new</span> FileInputStream(<span class="string">"file.txt"</span>);</span><br><span class="line">          BufferedInputStream bufferedInput = <span class="keyword">new</span> BufferedInputStream(input)</span><br><span class="line">    ) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> data = bufferedInput.read();</span><br><span class="line">        <span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>) data);</span><br><span class="line">    data = bufferedInput.read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="相关实现类"><a href="#相关实现类" class="headerlink" title="相关实现类"></a>相关实现类</h1><center><img src="https://upload-images.jianshu.io/upload_images/1319879-3dd7958bdc726ea8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Closeable.png"></center>



<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>inputstream</tag>
        <tag>outputstream</tag>
      </tags>
  </entry>
  <entry>
    <title>byte和0XFF的基础</title>
    <url>/2019/06/14/byte-0xff/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在做代码相关的优化，找到了一个二进制转十六进制的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二进制转16进制</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 16进制字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">asHex</span><span class="params">(<span class="keyword">byte</span>[] bin)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//一个byte为8位，一个十六进制为4位，所以长度乘以2</span></span><br><span class="line">    StringBuilder bfHex = <span class="keyword">new</span> StringBuilder(bin.length * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; bin.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (((<span class="keyword">int</span>) bin[i] &amp; <span class="number">0xff</span>) &lt; <span class="number">0x10</span>)</span><br><span class="line">            <span class="comment">//如果小于10，那么转化为16进制需要往前面加0，凑足两位</span></span><br><span class="line">            bfHex.append(<span class="string">"0"</span>);</span><br><span class="line">        <span class="comment">//转为为16进制字符串</span></span><br><span class="line">        bfHex.append(Integer.toString((<span class="keyword">int</span>) bin[i] &amp; <span class="number">0xff</span>, <span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bfHex.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="为什么byte转int需要与0XFF"><a href="#为什么byte转int需要与0XFF" class="headerlink" title="为什么byte转int需要与0XFF"></a>为什么byte转int需要与0XFF</h1><blockquote>
<p>0XFF = {[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[1,1,1,1,1,1,1,1]};</p>
</blockquote>
<ul>
<li>一个 <code>int</code> 类型的数字 <code>&amp;0XFF</code> ，就是将这个数字的高24位全部置为0；</li>
</ul>
<h2 id="byte转化为一个int类型直接强转不行么？"><a href="#byte转化为一个int类型直接强转不行么？" class="headerlink" title="byte转化为一个int类型直接强转不行么？"></a>byte转化为一个int类型直接强转不行么？</h2><ul>
<li>一个<code>byte</code> 转化为32位的 <code>int</code> 类型，它的数值大小不会发生任何变化；</li>
<li>如果是正数那么高位自动补充 <code>0</code>；</li>
<li>如果是负数那么高位补充的是 <code>1</code> ；</li>
</ul>
<p>我们先看一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(Integer.toBinaryString(<span class="number">1</span>));</span><br><span class="line">    System.out.println(Integer.toBinaryString(-<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">11111111111111111111111111111111</span><br></pre></td></tr></table></figure>
<ul>
<li>学习计算机原理的时候我们知道计算机都是采用补码存储数据的；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 = byte[00000001] = int &#123;000000000000000000000000000000001&#125; = 0x1</span><br><span class="line">-1 = byte[11111111] = int &#123;11111111111111111111111111111111&#125; = 0xffffffff</span><br></pre></td></tr></table></figure>
<p>我们在做二进制转16进制的时候，需要的是数据的正确性而不是数值的正确性。所以我们进行 <code>0XFF</code> 的时候抹掉了高24位，确保了数据二进制补码的完整新（同时也解释了转化的16进制如果小于10需要在前面加0的原因）。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1319879-c6e40d69e7d6c673.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="byte&amp;0xff.png"></p>
<p>我们从 <code>BufferedInputStream.java</code> 源代码中都可以找到获取下一个字节的方法 <code>int read()</code> ，最后的得到的字节也是需要 <code>&amp;0xff</code> 转化为 <code>int</code> 类型进行返回的，这样才能保证数据的完整性。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="源码、反码、补码"><a href="#源码、反码、补码" class="headerlink" title="源码、反码、补码"></a>源码、反码、补码</h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[+1]原 = 0000 0001</span><br><span class="line">[-1]原 = 1000 0001</span><br></pre></td></tr></table></figure>
<p>原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值.;</p>
<h3 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[+1] = [00000001]原 = [00000001]反</span><br><span class="line">[-1] = [10000001]原 = [11111110]反</span><br></pre></td></tr></table></figure>
<p>正数的反码是其本身;<br>负数的反码是在其原码的基础上, 符号位不变，其余各个位取反;</p>
<h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[+1] = [00000001]原 = [00000001]反 = [00000001]补</span><br><span class="line">[-1] = [10000001]原 = [11111110]反 = [11111111]补</span><br></pre></td></tr></table></figure>
<p>正数的补码就是其本身;<br>负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1);</p>
<p>补码的设计有意识的引用了模运算在数理上对符号位的自动处理，利用模的自动丢弃实现了符号位的自然处理，仅仅通过编码的改变就可以在不更改机器物理架构的基础上完成的预期的要求（将减法变为加法），所以补码沿用至今。</p>
<h2 id="计算机巧妙地把符号位参与运算-并且将减法变成了加法-背后蕴含了怎样的数学原理呢"><a href="#计算机巧妙地把符号位参与运算-并且将减法变成了加法-背后蕴含了怎样的数学原理呢" class="headerlink" title="计算机巧妙地把符号位参与运算, 并且将减法变成了加法, 背后蕴含了怎样的数学原理呢?"></a>计算机巧妙地把符号位参与运算, 并且将减法变成了加法, 背后蕴含了怎样的数学原理呢?</h2><p>将钟表想象成是一个1位的12进制数. 如果当前时间是6点, 我希望将时间设置成4点, 需要怎么做呢?我们可以:</p>
<blockquote>
<ol>
<li>往回拨2个小时: 6 - 2 = 4</li>
<li>往前拨10个小时: (6 + 10) mod 12 = 4</li>
<li>往前拨10+12=22个小时: (6+22) mod 12 =4</li>
</ol>
</blockquote>
<p>2,3方法中的mod是指取模操作, 16 mod 12 =4 即用16除以12后的余数是4。 <a href="https://baike.baidu.com/item/%E5%90%8C%E4%BD%99%E5%AE%9A%E7%90%86/1212360?fromtitle=%E5%90%8C%E4%BD%99&amp;fromid=1432545" target="_blank" rel="noopener">同余定理</a><br>所以钟表往回拨(减法)的结果可以用往前拨(加法)替代!</p>
<p>首先要确定二进制中模到底是多少。</p>
<blockquote>
<p>在二进制加法运算中膜有0~127，膜为128（128个数），即为2的n次方。<br>2的n次方减一 = A + A[反]<br>2的n次方 = A + A[反] + 1<br>A[补] = A[反] + 1<br>2的n次方 = A + A[补]</p>
</blockquote>
<p>所以可以将负数用补码方式进行变化进行 <code>加操作</code> ，符号为也可以参与运算。</p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>计算机&amp;网络</category>
      </categories>
      <tags>
        <tag>byte</tag>
        <tag>255</tag>
        <tag>补码</tag>
      </tags>
  </entry>
  <entry>
    <title>解决6.5.16及以上版本微信内部M页不能唤起APP</title>
    <url>/2019/02/21/weixin-app-scheme/</url>
    <content><![CDATA[<h1 id="个人博客地址-http-dandanlove-com"><a href="#个人博客地址-http-dandanlove-com" class="headerlink" title="个人博客地址 http://dandanlove.com/"></a><a href="http://dandanlove.com/" target="_blank" rel="noopener">个人博客地址 http://dandanlove.com/</a></h1><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><center><img src="https://upload-images.jianshu.io/upload_images/1319879-d96e81fff0ce1659.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/620" alt="深夜放毒"></center>


<p>最近微信唤起app的数据急速下降，产品同学告诉我们大事来了，微信不能唤起Android的App了~！~！</p>
<h1 id="微信语录"><a href="#微信语录" class="headerlink" title="微信语录"></a>微信语录</h1><p>为提升微信 webivew 中网页打开其他应用的体验，防止诱导点击、强制跳出等不合理行为， 我们的“唤起外部客户端”的能力统一调整为:</p>
<blockquote>
<ul>
<li>1、 在 6.5.16 及以上版本的微信客户端中，贵方网页将只能使用 launchApplication 接口，打<br>开其他应用。该接口会在唤起前要求用户接受弹窗确认。</li>
<li>2、 在 6.5.16 以下版本的微信客户端中，贵方网页可以继续使用现有方式，打开其他应用。</li>
</ul>
</blockquote>
<h1 id="解决版本"><a href="#解决版本" class="headerlink" title="解决版本"></a>解决版本</h1><p>我们在接入微信的 <code>opensdk</code> 的时候会在自己项目代码中包含 <code>xxx.xxx.xxx.wxapi.WXEntryActivity</code> 这个页面。<br>在 6.5.16 及以上版本的微信客户端中，微信首先唤起的是 <code>xxx.xxx.xxx.wxapi.WXEntryActivity</code> 这个页面，将参数放在 <code>extInfo</code> 字段中，由第三方 APP 自行解析处理 ShowMessageFromWX.Req 的微信回调。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WXEntryActivity</span> <span class="keyword">extends</span> <span class="title">WXCallBack</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReq</span><span class="params">(BaseReq req)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onReq(req);</span><br><span class="line">        <span class="keyword">if</span> (req != <span class="keyword">null</span> &amp;&amp; req <span class="keyword">instanceof</span> ShowMessageFromWX.Req) &#123;</span><br><span class="line">            ShowMessageFromWX.Req request = (ShowMessageFromWX.Req) req;</span><br><span class="line">            <span class="keyword">if</span> (request.message != <span class="keyword">null</span> &amp;&amp; request.message.mediaObject != <span class="keyword">null</span></span><br><span class="line">                    &amp;&amp; request.message.mediaObject <span class="keyword">instanceof</span> WXAppExtendObject) &#123;</span><br><span class="line">                WXAppExtendObject appExtendObject = (WXAppExtendObject) request.message.mediaObject;</span><br><span class="line">                <span class="comment">//唤起app的启动页面，将scheme协议中的数据进行透传</span></span><br><span class="line">                Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, LaunchActivity.class);</span><br><span class="line">                intent.setData(Uri.parse(appExtendObject.extInfo));</span><br><span class="line">                startActivity(intent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>微信官方具体描述我们可以参见： <a href="https://download.csdn.net/download/stven_king/10969400" target="_blank" rel="noopener">微信webview唤起外部客户端接入说明2018版</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>微信这样做，将微信与其下游的app的之前的影响继续加强。虽然我们做了不同的适配，但是同时能得到微信唤起app的成功或者失败的数据。在互联网产品竞争激烈的今天我们不仅仅要做好用户产品也好做好技术产品。</p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>weixin</tag>
      </tags>
  </entry>
  <entry>
    <title>小明要吃冰淇淋之RxJava:lift原理</title>
    <url>/2019/01/14/rx_lift/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我接触Rxjava是在2015年底，已经过去4年的时间了。</p>
<p>2016年学习过一阵子<code>RxJava</code>的操作符也做过一些笔记，我们项目的网络请求框架也替换成了<code>Okhttp+Retrofit</code>，所以使用<code>RxJava</code>做线程间切换就非常好用。</p>
<p>一开始接触<code>RxJava</code>感觉除了线程切换之外很能发现其实际的作用，因为我感觉自己响应式编程的思想，很难实际运用到开发需求当中去。但我身边有一位前辈使用Rxjava非常溜，他一般做需求的时候写的都是流式的代码。</p>
<p>2017年<code>Kotlin</code>语言Google举行的I/O开发者大会上宣布，将<code>Kotlin</code>语言作为安卓开发的一级编程语言，所以自己又看了看了<code>Kotlin</code>语言。</p>
<p><code>RxJava</code>在我们项目中还是静静的躺着，因为自己懒的思考，懒的在代码结构上做更新，懒的对<code>RxJava</code>做研究。有时候感觉自己就算会了<code>RxJava</code>也不会将其使用在项目当中，因为自己什么业务场景之下使用<code>Rxjava</code>更加方便。</p>
<p>2018就这么有一下没一下的使用<code>RxJava</code>，最近在做需求开发的时候用的<code>RxJava</code>比较多了，一些业务场景也逐渐思考使用响应式编程。思考这样写的好处，以及怎么将之前的代码结构转化为流式结构。</p>
<p>感觉有时候思维观念的转变是一个漫长的过程，但有时候又会很快。凡事都可以熟能生巧，我们使用<code>RxJava</code>多了之后再笨也会思考。之前想不到<code>RxJava</code>的使用场景是因为自己见的、写的代码还不够多。</p>
<p>今天回过头来从代码的角度看看一次<code>RxJava</code> 的基础操作，事件订阅到触发的过程。</p>
<p>这里推荐一篇<code>RxJava</code>的入门的文章 <a href="https://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="noopener">给 Android 开发者的 RxJava 详解</a> 。</p>
<p>读完本篇文章希望所有读者能明白<code>RxJava</code>的观察者与java的观察者模式有什么不同，以及<code>Rxjava</code>的观察者模式的代码运行过程。至于怎么具体的使用 <code>Rxjava</code> 那么就需要更多学习和实践了。</p>
<h1 id="Java的观察者模式"><a href="#Java的观察者模式" class="headerlink" title="Java的观察者模式"></a>Java的观察者模式</h1><p>观察者：<code>Observer</code></p>
<p>被观察者：<code>Observable</code></p>
<blockquote>
<p>被观察者提供添加（注册）观察者的方法；</p>
<p>被观察者更新的同时可以主动通知注册它观察者更新；</p>
</blockquote>
<p>观察者模式面向的需求是：收音机听广播，电台是被观察者，收音机是观察者。收音机调频到广播的波段（注册），广播发送信息（被观察者更新数据，通知所有的观察者）收音机接受信息从而播放声音（观察者数据更新）。</p>
<h1 id="RxJava的观察者模式"><a href="#RxJava的观察者模式" class="headerlink" title="RxJava的观察者模式"></a>RxJava的观察者模式</h1><p>可观察者（被观察者）：<code>Observalbe</code></p>
<p>观察者：<code>Observer</code></p>
<p>订阅操作：<code>subscribe()</code></p>
<p>订阅：<code>Subscription</code></p>
<p>订阅者：<code>Subscriber</code> ，实现 <code>Observer</code> 和 <code>Subscription</code></p>
<p>发布： <code>OnSubscribe</code></p>
<blockquote>
<p><code>Observable</code> 和 <code>Subscriber</code> 通过 <code>subscribe()</code> 方法实现订阅关系，从而 <code>Observable</code> 在被订阅之后就会触发 <code>OnSubscribe.call</code> 进行发布事件来通知 <code>Subscriber</code>。</p>
</blockquote>
<center><img src="https://upload-images.jianshu.io/upload_images/1319879-399d99f474b65019.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RxJavaObservable.png"></center>



<h1 id="分析源代码"><a href="#分析源代码" class="headerlink" title="分析源代码"></a>分析源代码</h1><p>我们先看一个简单的打印数据的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>)</span><br><span class="line">    .subscribe(<span class="keyword">new</span> Subscriber&lt;Object&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"onCompleted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"onError"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"onNext"</span>);</span><br><span class="line">            System.out.println(Integer.valueOf(o.toString()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p><code>RxJava</code> 的版本已经更新到2了，我们现在还用的是版本1。版本1中1.0和1.3这两个版本用的比较多。但这两个<code>RxJava</code> 版本之前改动不是很大，我们来分析分析最初始的版本，主要看看其中的设计思想啥的~！</p>
<h2 id="谁触发了被观察者"><a href="#谁触发了被观察者" class="headerlink" title="谁触发了被观察者"></a>谁触发了被观察者</h2><p>我们进行了 <code>subscribe</code> 之后就会触发 <code>Observable</code> 的执行动作，然后将执行结果传输给订阅它的 <code>Subscriber</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无参的subscribe</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Subscription <span class="title">subscribe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> subscribe(<span class="keyword">new</span> Subscriber&lt;T&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;<span class="keyword">throw</span> <span class="keyword">new</span> OnErrorNotImplementedException(e);&#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T args)</span> </span>&#123;&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***部分代码省略***/</span></span><br><span class="line"><span class="comment">//onnext、onerror、oncomplete参数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Subscription <span class="title">subscribe</span><span class="params">(<span class="keyword">final</span> Action1&lt;? <span class="keyword">super</span> T&gt; onNext, <span class="keyword">final</span> Action1&lt;Throwable&gt; onError, <span class="keyword">final</span> Action0 onComplete)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (onNext == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"onNext can not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (onError == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"onError can not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (onComplete == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"onComplete can not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> subscribe(<span class="keyword">new</span> Subscriber&lt;T&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;onComplete.call();&#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;onError.call(e);&#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T args)</span> </span>&#123;onNext.call(args);&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//observer参数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Subscription <span class="title">subscribe</span><span class="params">(<span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> subscribe(<span class="keyword">new</span> Subscriber&lt;T&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;observer.onCompleted();&#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;observer.onError(e);&#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;observer.onNext(t);&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Subscriber参数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Subscription <span class="title">subscribe</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; subscriber)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (subscriber == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"observer can not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (onSubscribe == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"onSubscribe function can not be null."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用订阅者的start方法</span></span><br><span class="line">    subscriber.onStart();</span><br><span class="line">    <span class="keyword">if</span> (!(subscriber <span class="keyword">instanceof</span> SafeSubscriber)) &#123;</span><br><span class="line">        subscriber = <span class="keyword">new</span> SafeSubscriber&lt;T&gt;(subscriber);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//Observable的OnSubscribe调用call方法</span></span><br><span class="line">        hook.onSubscribeStart(<span class="keyword">this</span>, onSubscribe).call(subscriber);</span><br><span class="line">        <span class="keyword">return</span> hook.onSubscribeReturn(subscriber);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        Exceptions.throwIfFatal(e);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//调用订阅者的onError方法</span></span><br><span class="line">            subscriber.onError(hook.onSubscribeError(e));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (OnErrorNotImplementedException e2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e2) &#123;</span><br><span class="line">            RuntimeException r = <span class="keyword">new</span> RuntimeException(<span class="string">"Error occurred attempting to subscribe ["</span> + e.getMessage() + <span class="string">"] and then again while trying to pass to onError."</span>, e2);</span><br><span class="line">            hook.onSubscribeError(r);</span><br><span class="line">            <span class="keyword">throw</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Subscriptions.unsubscribed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RxJavaObservableExecutionHook hook = RxJavaPlugins.getInstance().getObservableExecutionHook();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RxJavaObservableExecutionHookDefault</span> <span class="keyword">extends</span> <span class="title">RxJavaObservableExecutionHook</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RxJavaObservableExecutionHookDefault INSTANCE = <span class="keyword">new</span> RxJavaObservableExecutionHookDefault();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RxJavaObservableExecutionHook <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RxJavaObservableExecutionHook</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">OnSubscribe&lt;T&gt; <span class="title">onSubscribeStart</span><span class="params">(Observable&lt;? extends T&gt; observableInstance, <span class="keyword">final</span> OnSubscribe&lt;T&gt; onSubscribe)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// pass-thru by default</span></span><br><span class="line">        <span class="keyword">return</span> onSubscribe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 <code>RxJavaObservableExecutionHookonSubscribeStart</code>  可以看出  <code>hook.onSubscribeStart(this, onSubscribe).call(subscriber);</code>  实际是 <code>onSubscribe.call(subscirber)</code> 。</p>
<h2 id="开始你的表演：Observable-OnSubscribe-call"><a href="#开始你的表演：Observable-OnSubscribe-call" class="headerlink" title="开始你的表演：Observable.OnSubscribe.call"></a>开始你的表演：Observable.OnSubscribe.call</h2><p>刚才我们了解到通过 <code>subscirbe</code> 可以通知被观察者进行 <code>call</code> 操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Observable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Observable</span><span class="params">(OnSubscribe&lt;T&gt; f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.onSubscribe = f;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">just</span><span class="params">(<span class="keyword">final</span> T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ScalarSynchronousObservable.create(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ScalarSynchronousObservable</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Observable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> &lt;T&gt; <span class="function">ScalarSynchronousObservable&lt;T&gt; <span class="title">create</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ScalarSynchronousObservable&lt;T&gt;(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T t;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">ScalarSynchronousObservable</span><span class="params">(<span class="keyword">final</span> T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">new</span> OnSubscribe&lt;T&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; s)</span> </span>&#123;</span><br><span class="line">                s.onNext(t);</span><br><span class="line">                s.onCompleted();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们最后看到 <code>Observable.just(1)</code> 生成的 <code>Observable</code> 实际是 <code>ScalarSynchronousObservable</code> 实例。  <code>Observable.OnSubscribe</code>  实际上是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> OnSubscribe&lt;T&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; s)</span> </span>&#123;</span><br><span class="line">        s.onNext(t);</span><br><span class="line">        s.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以 <code>onSubscribe.call(subscirber)</code>  最终调用的是了 <code>subscirber</code> 的 <code>onNext和onCompleted</code> 方法。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于Android开发人员开发来说 <code>RxJava</code> 是一个很好用的库，但是需要我们转化平时的对代码结构设计的思想，能很好的去使用到大部分的业务场景之中。只有对 <code>RxJava</code> 有了足够的了解我们才能灵活、熟练的使用。</p>
<p>本篇文章只是一个 <code>RxJava</code> 简单的基础开篇，<code>观察者：Observer</code>  、 <code>订阅操作：subscribe()</code>  、<code>订阅：Subscription</code> 、<code>订阅者：Subscriber</code>  以及 <code>Observer</code> 和 <code>Subscription</code> 的订阅关系，之后我会慢慢的学习和分享关于 <code>RxJava</code> 更多的知识。</p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>lift</tag>
      </tags>
  </entry>
  <entry>
    <title>一次Observable的empty和never方法的rx源码笔记</title>
    <url>/2019/01/11/observable-empty-never/</url>
    <content><![CDATA[<p>我们在用 <code>RxJava</code> 的时候，如果需要在某个地方需要中断事件流，那么直接返回一个 <code>Observable.empty()</code>  ，与它有类似功能的有 <code>Observable.never</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">    .flatMap((Func1&lt;Integer, Observable&lt;Object&gt;&gt;) integer -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (integer &gt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Observable.empty();</span><br><span class="line">            <span class="comment">//return Observable.never();</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Observable.just(integer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribe(<span class="keyword">new</span> Subscriber&lt;Object&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"onCompleted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"onError"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"onNext"</span>);</span><br><span class="line">            System.out.println(Integer.valueOf(o.toString()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p><code>Observable.never</code> 的输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">onNext</span><br><span class="line">1</span><br><span class="line">onNext</span><br><span class="line">2</span><br><span class="line">onNext</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p><code>Observable.empty</code> 的输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">onNext</span><br><span class="line">1</span><br><span class="line">onNext</span><br><span class="line">2</span><br><span class="line">onNext</span><br><span class="line">3</span><br><span class="line">onCompleted</span><br></pre></td></tr></table></figure>
<p>从结果可以看出来， <code>Observable.empty</code> 会执行 <code>订阅者</code> 的 <code>onCompleted</code> 方法， 而 <code>Observable.never</code> 方法则是立即终止整个流程。</p>
<p>源码分析（RxJava1.3.0）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Observable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">never</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> NeverObservableHolder.instance();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> EmptyObservableHolder.instance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EmptyObservableHolder implements OnSubscribe&lt;Object&gt; &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Observable&lt;Object&gt; EMPTY = Observable.unsafeCreate(INSTANCE);</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Observable&lt;T&gt;)EMPTY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Object&gt; child)</span> </span>&#123;</span><br><span class="line">        child.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> NeverObservableHolder implements OnSubscribe&lt;Object&gt; &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Observable&lt;Object&gt; NEVER = Observable.unsafeCreate(INSTANCE);</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Observable&lt;T&gt;)NEVER;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Object&gt; child)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// deliberately no op</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <code>Observable.empty()</code>  和 <code>Observable.never</code>  我们从源码实现就可以看出来两者的功能。</p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>Observable</tag>
      </tags>
  </entry>
  <entry>
    <title>Android：Base64生产Bitmap压缩和转byte[]</title>
    <url>/2019/01/11/bitmap-base64-byte/</url>
    <content><![CDATA[<p>最近在做微信分享的时候遇到了分享图片的大小限制问题，需要对图片进行压缩。在过程中遇到几个有趣的地方在此记录。</p>
<blockquote>
<p>Bitmap.getByteCount的大小和转化为byte[]的大小差很多不是8倍，而是几十倍，我自测的为67倍</p>
</blockquote>
<blockquote>
<p>压缩Bitmap直接根据长宽比进行调用 <code>createScaledBitmap(@NonNull Bitmap src, int dstWidth, int dstHeight, boolean filter)</code> 方法进行缩放，只能保证长宽不能保证质量。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitmapUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取bitmap转化为字节的大小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bitmap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getBitmapByteSize</span><span class="params">(Bitmap bitmap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bitmap == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            bitmap.compress(Bitmap.CompressFormat.JPEG, <span class="number">100</span>, baos);</span><br><span class="line">            <span class="keyword">int</span> size = baos.toByteArray().length;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                baos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据压缩图片到固定的大小,因为会进行多次压缩可能会比较耗时，建议在异步线程调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bitmap    原始图片</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxSize   压缩后的大小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> needRecycle   是否需要回收被压的图片</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] compressBitmap(Bitmap bitmap, <span class="keyword">double</span> maxSize, <span class="keyword">boolean</span> needRecycle) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bitmap == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> width = bitmap.getWidth();</span><br><span class="line">            <span class="keyword">int</span> height = bitmap.getHeight();</span><br><span class="line">            <span class="comment">//计算等比缩放</span></span><br><span class="line">            <span class="keyword">double</span> x = Math.sqrt(maxSize / (width * height));</span><br><span class="line">            Bitmap tmp = Bitmap.createScaledBitmap(bitmap, (<span class="keyword">int</span>) Math.floor(width * x), (<span class="keyword">int</span>) Math.floor(height * x), <span class="keyword">true</span>);</span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> options = <span class="number">100</span>;</span><br><span class="line">            <span class="comment">//生产byte[]</span></span><br><span class="line">            tmp.compress(Bitmap.CompressFormat.JPEG, options, baos);</span><br><span class="line">            <span class="comment">//判断byte[]与上线存储空间的大小</span></span><br><span class="line">            <span class="keyword">if</span> (baos.toByteArray().length &gt; maxSize) &#123;</span><br><span class="line">                <span class="comment">//根据内存大小的比例，进行质量的压缩</span></span><br><span class="line">                options = (<span class="keyword">int</span>) Math.ceil((maxSize / baos.toByteArray().length) * <span class="number">100</span>);</span><br><span class="line">                baos.reset();</span><br><span class="line">                tmp.compress(Bitmap.CompressFormat.JPEG, options, baos);</span><br><span class="line">                <span class="comment">//循环压缩</span></span><br><span class="line">                <span class="keyword">while</span> (baos.toByteArray().length &gt; maxSize) &#123;</span><br><span class="line">                    baos.reset();</span><br><span class="line">                    options -= <span class="number">1.5</span>;</span><br><span class="line">                    tmp.compress(Bitmap.CompressFormat.JPEG, options, baos);</span><br><span class="line">                &#125;</span><br><span class="line">                recycle(tmp);</span><br><span class="line">                <span class="keyword">if</span> (needRecycle) &#123;</span><br><span class="line">                    recycle(bitmap);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">byte</span>[] data = baos.toByteArray();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                baos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 回收Bitmap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> thumbBmp  需要被回收的bitmap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">(Bitmap thumbBmp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (thumbBmp != <span class="keyword">null</span> &amp;&amp; !thumbBmp.isRecycled()) &#123;</span><br><span class="line">            thumbBmp.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * base64数据转byte[]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> imageUrl</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] getImageDataWithBase64(String imageUrl) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] data;</span><br><span class="line">        <span class="keyword">if</span> (TextUtils.isEmpty(imageUrl)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (imageUrl.startsWith(<span class="string">"data:image"</span>)) &#123;</span><br><span class="line">            data = android.util.Base64.decode(imageUrl.split(<span class="string">","</span>)[<span class="number">1</span>], Base64.DEFAULT);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            data = android.util.Base64.decode(imageUrl, Base64.DEFAULT);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Bitmap</tag>
        <tag>base64</tag>
        <tag>byte</tag>
      </tags>
  </entry>
  <entry>
    <title>关于RxJava的基础心法解析</title>
    <url>/2019/01/07/rx_init/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我接触Rxjava是在2015年底，已经过去4年的时间了。</p>
<p>2016年学习过一阵子<code>RxJava</code>的操作符也做过一些笔记，我们项目的网络请求框架也替换成了<code>Okhttp+Retrofit</code>，所以使用<code>RxJava</code>做线程间切换就非常好用。</p>
<p>一开始接触<code>RxJava</code>感觉除了线程切换之外很能发现其实际的作用，因为我感觉自己响应式编程的思想，很难实际运用到开发需求当中去。但我身边有一位前辈使用Rxjava非常溜，他一般做需求的时候写的都是流式的代码。</p>
<p>2017年<code>Kotlin</code>语言Google举行的I/O开发者大会上宣布，将<code>Kotlin</code>语言作为安卓开发的一级编程语言，所以自己又看了看了<code>Kotlin</code>语言。</p>
<p><code>RxJava</code>在我们项目中还是静静的躺着，因为自己懒的思考，懒的在代码结构上做更新，懒的对<code>RxJava</code>做研究。有时候感觉自己就算会了<code>RxJava</code>也不会将其使用在项目当中，因为自己什么业务场景之下使用<code>Rxjava</code>更加方便。</p>
<p>2018就这么有一下没一下的使用<code>RxJava</code>，最近在做需求开发的时候用的<code>RxJava</code>比较多了，一些业务场景也逐渐思考使用响应式编程。思考这样写的好处，以及怎么将之前的代码结构转化为流式结构。</p>
<p>感觉有时候思维观念的转变是一个漫长的过程，但有时候又会很快。凡事都可以熟能生巧，我们使用<code>RxJava</code>多了之后再笨也会思考。之前想不到<code>RxJava</code>的使用场景是因为自己见的、写的代码还不够多。</p>
<p>今天回过头来从代码的角度看看一次<code>RxJava</code> 的基础操作，事件订阅到触发的过程。</p>
<p>这里推荐一篇<code>RxJava</code>的入门的文章 <a href="https://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="noopener">给 Android 开发者的 RxJava 详解</a> 。</p>
<p>读完本篇文章希望所有读者能明白<code>RxJava</code>的观察者与java的观察者模式有什么不同，以及<code>Rxjava</code>的观察者模式的代码运行过程。至于怎么具体的使用 <code>Rxjava</code> 那么就需要更多学习和实践了。</p>
<h1 id="Java的观察者模式"><a href="#Java的观察者模式" class="headerlink" title="Java的观察者模式"></a>Java的观察者模式</h1><p>观察者：<code>Observer</code></p>
<p>被观察者：<code>Observable</code></p>
<blockquote>
<p>被观察者提供添加（注册）观察者的方法；</p>
<p>被观察者更新的同时可以主动通知注册它观察者更新；</p>
</blockquote>
<p>观察者模式面向的需求是：收音机听广播，电台是被观察者，收音机是观察者。收音机调频到广播的波段（注册），广播发送信息（被观察者更新数据，通知所有的观察者）收音机接受信息从而播放声音（观察者数据更新）。</p>
<h1 id="RxJava的观察者模式"><a href="#RxJava的观察者模式" class="headerlink" title="RxJava的观察者模式"></a>RxJava的观察者模式</h1><p>可观察者（被观察者）：<code>Observalbe</code></p>
<p>观察者：<code>Observer</code></p>
<p>订阅操作：<code>subscribe()</code></p>
<p>订阅：<code>Subscription</code></p>
<p>订阅者：<code>Subscriber</code> ，实现 <code>Observer</code> 和 <code>Subscription</code></p>
<p>发布： <code>OnSubscribe</code></p>
<blockquote>
<p><code>Observable</code> 和 <code>Subscriber</code> 通过 <code>subscribe()</code> 方法实现订阅关系，从而 <code>Observable</code> 在被订阅之后就会触发 <code>OnSubscribe.call</code> 进行发布事件来通知 <code>Subscriber</code>。</p>
</blockquote>
<center><img src="https://upload-images.jianshu.io/upload_images/1319879-399d99f474b65019.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RxJavaObservable.png"></center>



<h1 id="分析源代码"><a href="#分析源代码" class="headerlink" title="分析源代码"></a>分析源代码</h1><p>我们先看一个简单的打印数据的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>)</span><br><span class="line">    .subscribe(<span class="keyword">new</span> Subscriber&lt;Object&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"onCompleted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"onError"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"onNext"</span>);</span><br><span class="line">            System.out.println(Integer.valueOf(o.toString()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p><code>RxJava</code> 的版本已经更新到2了，我们现在还用的是版本1。版本1中1.0和1.3这两个版本用的比较多。但这两个<code>RxJava</code> 版本之前改动不是很大，我们来分析分析最初始的版本，主要看看其中的设计思想啥的~！</p>
<h2 id="谁触发了被观察者"><a href="#谁触发了被观察者" class="headerlink" title="谁触发了被观察者"></a>谁触发了被观察者</h2><p>我们进行了 <code>subscribe</code> 之后就会触发 <code>Observable</code> 的执行动作，然后将执行结果传输给订阅它的 <code>Subscriber</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无参的subscribe</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Subscription <span class="title">subscribe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> subscribe(<span class="keyword">new</span> Subscriber&lt;T&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;<span class="keyword">throw</span> <span class="keyword">new</span> OnErrorNotImplementedException(e);&#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T args)</span> </span>&#123;&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***部分代码省略***/</span></span><br><span class="line"><span class="comment">//onnext、onerror、oncomplete参数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Subscription <span class="title">subscribe</span><span class="params">(<span class="keyword">final</span> Action1&lt;? <span class="keyword">super</span> T&gt; onNext, <span class="keyword">final</span> Action1&lt;Throwable&gt; onError, <span class="keyword">final</span> Action0 onComplete)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (onNext == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"onNext can not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (onError == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"onError can not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (onComplete == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"onComplete can not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> subscribe(<span class="keyword">new</span> Subscriber&lt;T&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;onComplete.call();&#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;onError.call(e);&#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T args)</span> </span>&#123;onNext.call(args);&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//observer参数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Subscription <span class="title">subscribe</span><span class="params">(<span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> subscribe(<span class="keyword">new</span> Subscriber&lt;T&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;observer.onCompleted();&#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;observer.onError(e);&#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;observer.onNext(t);&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Subscriber参数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Subscription <span class="title">subscribe</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; subscriber)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (subscriber == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"observer can not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (onSubscribe == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"onSubscribe function can not be null."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用订阅者的start方法</span></span><br><span class="line">    subscriber.onStart();</span><br><span class="line">    <span class="keyword">if</span> (!(subscriber <span class="keyword">instanceof</span> SafeSubscriber)) &#123;</span><br><span class="line">        subscriber = <span class="keyword">new</span> SafeSubscriber&lt;T&gt;(subscriber);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//Observable的OnSubscribe调用call方法</span></span><br><span class="line">        hook.onSubscribeStart(<span class="keyword">this</span>, onSubscribe).call(subscriber);</span><br><span class="line">        <span class="keyword">return</span> hook.onSubscribeReturn(subscriber);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        Exceptions.throwIfFatal(e);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//调用订阅者的onError方法</span></span><br><span class="line">            subscriber.onError(hook.onSubscribeError(e));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (OnErrorNotImplementedException e2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e2) &#123;</span><br><span class="line">            RuntimeException r = <span class="keyword">new</span> RuntimeException(<span class="string">"Error occurred attempting to subscribe ["</span> + e.getMessage() + <span class="string">"] and then again while trying to pass to onError."</span>, e2);</span><br><span class="line">            hook.onSubscribeError(r);</span><br><span class="line">            <span class="keyword">throw</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Subscriptions.unsubscribed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RxJavaObservableExecutionHook hook = RxJavaPlugins.getInstance().getObservableExecutionHook();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RxJavaObservableExecutionHookDefault</span> <span class="keyword">extends</span> <span class="title">RxJavaObservableExecutionHook</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RxJavaObservableExecutionHookDefault INSTANCE = <span class="keyword">new</span> RxJavaObservableExecutionHookDefault();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RxJavaObservableExecutionHook <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RxJavaObservableExecutionHook</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">OnSubscribe&lt;T&gt; <span class="title">onSubscribeStart</span><span class="params">(Observable&lt;? extends T&gt; observableInstance, <span class="keyword">final</span> OnSubscribe&lt;T&gt; onSubscribe)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// pass-thru by default</span></span><br><span class="line">        <span class="keyword">return</span> onSubscribe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 <code>RxJavaObservableExecutionHookonSubscribeStart</code>  可以看出  <code>hook.onSubscribeStart(this, onSubscribe).call(subscriber);</code>  实际是 <code>onSubscribe.call(subscirber)</code> 。</p>
<h2 id="开始你的表演：Observable-OnSubscribe-call"><a href="#开始你的表演：Observable-OnSubscribe-call" class="headerlink" title="开始你的表演：Observable.OnSubscribe.call"></a>开始你的表演：Observable.OnSubscribe.call</h2><p>刚才我们了解到通过 <code>subscirbe</code> 可以通知被观察者进行 <code>call</code> 操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Observable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Observable</span><span class="params">(OnSubscribe&lt;T&gt; f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.onSubscribe = f;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">just</span><span class="params">(<span class="keyword">final</span> T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ScalarSynchronousObservable.create(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ScalarSynchronousObservable</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Observable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> &lt;T&gt; <span class="function">ScalarSynchronousObservable&lt;T&gt; <span class="title">create</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ScalarSynchronousObservable&lt;T&gt;(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T t;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">ScalarSynchronousObservable</span><span class="params">(<span class="keyword">final</span> T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">new</span> OnSubscribe&lt;T&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; s)</span> </span>&#123;</span><br><span class="line">                s.onNext(t);</span><br><span class="line">                s.onCompleted();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们最后看到 <code>Observable.just(1)</code> 生成的 <code>Observable</code> 实际是 <code>ScalarSynchronousObservable</code> 实例。  <code>Observable.OnSubscribe</code>  实际上是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> OnSubscribe&lt;T&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; s)</span> </span>&#123;</span><br><span class="line">        s.onNext(t);</span><br><span class="line">        s.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以 <code>onSubscribe.call(subscirber)</code>  最终调用的是了 <code>subscirber</code> 的 <code>onNext和onCompleted</code> 方法。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于Android开发人员开发来说 <code>RxJava</code> 是一个很好用的库，但是需要我们转化平时的对代码结构设计的思想，能很好的去使用到大部分的业务场景之中。只有对 <code>RxJava</code> 有了足够的了解我们才能灵活、熟练的使用。</p>
<p>本篇文章只是一个 <code>RxJava</code> 简单的基础开篇，<code>观察者：Observer</code>  、 <code>订阅操作：subscribe()</code>  、<code>订阅：Subscription</code> 、<code>订阅者：Subscriber</code>  以及 <code>Observer</code> 和 <code>Subscription</code> 的订阅关系，之后我会慢慢的学习和分享关于 <code>RxJava</code> 更多的知识。</p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>Observable</tag>
        <tag>Observer</tag>
      </tags>
  </entry>
  <entry>
    <title>Okhttp拦截器Interceptor学习和使用</title>
    <url>/2018/11/25/okhttp-interceptor/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前年的这个时候我们项目将网络框架替换为<code>okhttp+retrofit</code> ，然后我对 <code>retrofit</code> 源码进行了学习和分享，写了几篇相关的文章同时更新了项目的网络框架。</p>
<p> <a href="https://blog.csdn.net/stven_king/article/details/51839537" target="_blank" rel="noopener">Android网络之Retrofit2.0使用和解析</a><br> <a href="https://blog.csdn.net/stven_king/article/details/52372172" target="_blank" rel="noopener">Retrofit2.0中注解使用套路</a><br> <a href="https://blog.csdn.net/stven_king/article/details/52577248" target="_blank" rel="noopener">Retrofit2.0+Okhttp不依赖服务端的数据缓存</a></p>
<p>需求是推动任何事物向前发展的动力，这次我们项目需要对网络接口进行加密了，开发过程涉及到了okhttp的网路层的处理，所以我又将其源码翻了一番。</p>
<p>回顾一下我们曾经学习过的因特网五层协议栈：</p>
<blockquote>
<ul>
<li>网络请求发出时：应用层-&gt;传输层-&gt;网络层-&gt;连接层-&gt;物理层 </li>
<li>收到响应后：物理层-&gt;连接层-&gt;网络层-&gt;传输层-&gt;应用层</li>
</ul>
</blockquote>
<p>这个很像我们这次要讲的 <code>okhttp</code> 中的<code>interceptor</code> 的责任链模式。</p>
<h1 id="Interceptor"><a href="#Interceptor" class="headerlink" title="Interceptor"></a>Interceptor</h1><p><a href="https://github.com/square/okhttp/wiki/Interceptors" target="_blank" rel="noopener">Interceptor的wiki</a></p>
<p>按照以往的惯例我们先上图，然后在对每个步骤进行详细的讲述。</p>
<center><br><img src="https://img-blog.csdnimg.cn/20181125171234514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0dmVuX2tpbmc=,size_16,color_FFFFFF,t_70" alt="okhttp-interceptors"><br></center>

<h2 id="为什么会有拦截器"><a href="#为什么会有拦截器" class="headerlink" title="为什么会有拦截器"></a>为什么会有拦截器</h2><p>我们在进行应用开发的时候都会在请求中增加一些我们应用需要和服务端交互的通用信息，比如在 <code>header</code> 中增加用户的登录态信息等等。或者像  <a href="https://blog.csdn.net/stven_king/article/details/52577248" target="_blank" rel="noopener">Retrofit2.0+Okhttp不依赖服务端的数据缓存</a> 这篇文章中不依赖服务端的缓存，在请求的过程中我们自己修改一些请求的 <code>request</code> 和 <code>response</code> 。</p>
<p>这个时候拦截器就是我们的强大的助力。</p>
<h2 id="okhttp中的拦截器"><a href="#okhttp中的拦截器" class="headerlink" title="okhttp中的拦截器"></a>okhttp中的拦截器</h2><p>我们从 <code>okhttp</code> 处理一条普通的url请求的代码执行过程中观察 <code>interceptors</code> 的工作。</p>
<p>下边的代码是从 <a href="//http://square.github.io/okhttp/">okhttp官网</a> 摘的一段示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">run</span><span class="params">(String url)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .url(url)</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  Response response = client.newCall(request).execute();</span><br><span class="line">  <span class="keyword">return</span> response.body().string();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们跟进 <code>okhttpclient.newcall</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OkHttpClient</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Call</span>.<span class="title">Factory</span>, <span class="title">WebSocket</span>.<span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Prepares the &#123;<span class="doctag">@code</span> request&#125; to be executed at some point in the future.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Call <span class="title">newCall</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> RealCall(<span class="keyword">this</span>, request, <span class="keyword">false</span> <span class="comment">/* for web socket */</span>);</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取一个真正用来进行请求的Call <code>RealCall.execute</code> :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RealCall</span> <span class="keyword">implements</span> <span class="title">Call</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> RetryAndFollowUpInterceptor retryAndFollowUpInterceptor;</span><br><span class="line">	RealCall(OkHttpClient client, Request originalRequest, <span class="keyword">boolean</span> forWebSocket) &#123;</span><br><span class="line">	    <span class="keyword">final</span> EventListener.Factory eventListenerFactory = client.eventListenerFactory();</span><br><span class="line">	    <span class="keyword">this</span>.client = client;</span><br><span class="line">	    <span class="keyword">this</span>.originalRequest = originalRequest;</span><br><span class="line">	    <span class="keyword">this</span>.forWebSocket = forWebSocket;</span><br><span class="line">	    <span class="keyword">this</span>.retryAndFollowUpInterceptor = <span class="keyword">new</span> RetryAndFollowUpInterceptor(client, forWebSocket);</span><br><span class="line">	    <span class="comment">// TODO(jwilson): this is unsafe publication and not threadsafe.</span></span><br><span class="line">	    <span class="keyword">this</span>.eventListener = eventListenerFactory.create(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">	    	<span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</span><br><span class="line">	      	executed = <span class="keyword">true</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	    captureCallStackTrace();</span><br><span class="line">	    <span class="keyword">try</span> &#123;</span><br><span class="line">	        <span class="comment">//进行网络请求</span></span><br><span class="line">	      	client.dispatcher().executed(<span class="keyword">this</span>);</span><br><span class="line">	      	<span class="comment">//经过一层层网络拦截器之后，获取网络请求的返回值</span></span><br><span class="line">	      	Response result = getResponseWithInterceptorChain();</span><br><span class="line">	      	<span class="keyword">if</span> (result == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">	      	<span class="keyword">return</span> result;</span><br><span class="line">	    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	      	client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">	  &#125;</span><br><span class="line">	  <span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	    <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">	    List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	    <span class="comment">//Application拦截器</span></span><br><span class="line">	    interceptors.addAll(client.interceptors());</span><br><span class="line">	    <span class="comment">//重定向和失败后重新请求拦截器</span></span><br><span class="line">	    interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">	    <span class="comment">//网桥拦截器，顾名思义client和Server之前的桥梁</span></span><br><span class="line">	    interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar()));</span><br><span class="line">	    <span class="comment">//缓存处理拦截器</span></span><br><span class="line">	    interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));</span><br><span class="line">	    <span class="comment">//Socket层的握手链接</span></span><br><span class="line">	    interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client));</span><br><span class="line">	    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">	    	<span class="comment">//网络烂拦截器</span></span><br><span class="line">	    	interceptors.addAll(client.networkInterceptors());</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="comment">//client和Server之前的读写操作</span></span><br><span class="line">	    interceptors.add(<span class="keyword">new</span> CallServerInterceptor(forWebSocket));</span><br><span class="line">		<span class="comment">//责任链开始执行</span></span><br><span class="line">	    Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(</span><br><span class="line">	        interceptors, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>, originalRequest);</span><br><span class="line">	    <span class="keyword">return</span> chain.proceed(originalRequest);</span><br><span class="line">	  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Interceptor介绍"><a href="#Interceptor介绍" class="headerlink" title="Interceptor介绍"></a>Interceptor介绍</h2><p>我们先看拦截器的接口定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">	<span class="comment">//拦截处理</span></span><br><span class="line">	<span class="function">Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">	<span class="class"><span class="keyword">interface</span> <span class="title">Chain</span> </span>&#123;</span><br><span class="line">		<span class="comment">//获取请求的request</span></span><br><span class="line">	  	<span class="function">Request <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="comment">//处理request获取response</span></span><br><span class="line">	    <span class="function">Response <span class="title">proceed</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">	</span><br><span class="line">	    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	     * Returns the connection the request will be executed on. This is only available in the chains</span></span><br><span class="line"><span class="comment">	     * of network interceptors; for application interceptors this is always null.</span></span><br><span class="line"><span class="comment">	     */</span></span><br><span class="line">	    <span class="meta">@Nullable</span> <span class="function">Connection <span class="title">connection</span><span class="params">()</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我们跟踪源码的执行的过程我们回忆下最开始的时候的流程图，涉及到的拦截器以及他们各自的位置和在网络请求的作用。</p>
<blockquote>
<p>Application Interceptor</p>
</blockquote>
<p>我们可以自定义设置 <code>Okhttp</code> 的拦截器之一。</p>
<p>从流程图中我们可以看到一次网络请求它只会执行一次拦截，而且它是第一个触发拦截的，这里拦截到的url请求的信息都是最原始的信息。所以我们可以在该拦截器中添加一些我们请求中需要的通用信息，打印一些我们需要的日志。</p>
<p>当然我们可以定义多个这样的拦截器，一个处理 <code>header</code> 信息，一个处理 <code>接口请求的 加解密</code>  。</p>
<blockquote>
<p>NetwrokInterceptor</p>
</blockquote>
<p><code>NetwrokInterceptor</code> 也是我们可以自定义的拦截器之一。 </p>
<p>它位于倒数第二层，会经过 <code>RetryAndFollowIntercptor</code> 进行重定向并且也会通过 <code>BridgeInterceptor</code> 进行 <code>request</code>请求头和 响应 <code>resposne</code> 的处理，因此这里可以得到的是更多的信息。在打印结果可以看到它内部重定向操作和失败重试，这里会有比 <code>Application Interceptor</code> 更多的日志。</p>
<blockquote>
<p>RetryAndFollowInterceptor</p>
</blockquote>
<p><code>RetryAndFollowUpInterceptor</code> 的作用，看到该拦截器的名称就知道，它就是一个负责失败重连的拦截器。它是 <code>Okhttp</code> 内置的第一个拦截器，通过 <code>while (true)</code> 的死循环来进行对异常结果或者响应结果判断是否要进行重新请求。</p>
<blockquote>
<p>BridgeInterceptor</p>
</blockquote>
<p><code>BridgeInterceptor</code> 为用户构建的一个 Request 请求转化为能够进行网络访问的请求，同时将网络请求回来的响应 Response 转化为用户可用的 Response。比如，涉及的网络文件的类型和网页的编码，返回的数据的解压处理等等。</p>
<blockquote>
<p>CacheInterceptor</p>
</blockquote>
<p><code>CacheInterceptor</code> 根据 <code>OkHttpClient</code> 对象的配置以及缓存策略对请求值进行缓存。</p>
<blockquote>
<p>ConnectInterceptor</p>
</blockquote>
<p><code>ConnectInterceptor</code> 在 OKHTTP 底层是通过 SOCKET 的方式于服务端进行连接的，并且在连接建立之后会通过 OKIO 获取通向 server 端的输入流 Source 和输出流 Sink。</p>
<blockquote>
<p>CallServerInterceptor</p>
</blockquote>
<p><code>CallServerInterceptor</code> 在 <code>ConnectInterceptor</code> 拦截器的功能就是负责与服务器建立 Socket 连接，并且创建了一个 HttpStream 它包括通向服务器的输入流和输出流。而接下来的 <code>CallServerInterceptor</code> 拦截器的功能使用 HttpStream 与服务器进行数据的读写操作的。</p>
<p>有关每个拦截器的具体代码分析：<a href="https://www.jianshu.com/u/8173f323f5bb" target="_blank" rel="noopener">https://www.jianshu.com/u/8173f323f5bb</a></p>
<h2 id="拦截器中的骚操作"><a href="#拦截器中的骚操作" class="headerlink" title="拦截器中的骚操作"></a>拦截器中的骚操作</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HttpUrl httpurl = request.url();</span><br><span class="line"><span class="comment">//获取request中的原始url地址</span></span><br><span class="line">String requestUrl = httpurl.url().toString();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取url中的参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> httpUrl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Map&lt;String, String&gt; <span class="title">getHttpUrlParams</span><span class="params">(HttpUrl httpUrl)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; paramsSet = httpUrl.queryParameterNames();</span><br><span class="line">    Map&lt;String, String&gt; paramMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (paramsSet != <span class="keyword">null</span> &amp;&amp; paramsSet.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String s: paramsSet) &#123;</span><br><span class="line">            paramMap.put(s, httpUrl.queryParameter(s));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> paramMap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一般POST请求参数都是放在RequestBody中,使用时需要判断RequestBody是否为子类FormBody的实例</span></span><br><span class="line">RequestBody requestBody = request.body();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取请求form中的参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> formBody</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Map&lt;String, String&gt; <span class="title">getHttpUrlParams</span><span class="params">(FormBody formBody)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; paramMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (formBody != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; formBody.size(); i++) &#123;</span><br><span class="line">            paramMap.put(formBody.name(i), formBody.value(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> paramMap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造新的POST表单</span></span><br><span class="line">FormBody.Builder formBuilder = <span class="keyword">new</span> FormBody.Builder();</span><br><span class="line"><span class="keyword">for</span> (String key: map.keySet()) &#123;</span><br><span class="line">    formBuilder.add(key, map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造新的HttpUrl，动态修改请求url地址</span></span><br><span class="line">HttpUrl httpUrl = HttpUrl.parse(requestUrlTrue);</span><br><span class="line"><span class="comment">//构造新的request请求</span></span><br><span class="line">request = request.newBuilder()</span><br><span class="line">        .method(POST, formBuilder.build())</span><br><span class="line">        .url(httpUrl)</span><br><span class="line">        .build();</span><br><span class="line"><span class="comment">//获取相应体对应的请求体，请求和返回一一对应</span></span><br><span class="line">Request request = response.request()</span><br><span class="line"><span class="comment">//获取请求的相应体</span></span><br><span class="line">ResponseBody responseBody = response.body();</span><br><span class="line"><span class="comment">//获取返回值类型</span></span><br><span class="line">MediaType mediaType = responseBody.contentType();</span><br><span class="line"><span class="comment">//获取相应体重的数据流，只能获取一次，在获取之后数据流会关闭，再次获取会有异常抛出</span></span><br><span class="line"><span class="keyword">byte</span>[] responseBytes = responseBytes = responseBody.bytes();</span><br><span class="line"><span class="comment">//利用修改后的返回值，构造新的相应体</span></span><br><span class="line">response = response.newBuilder()</span><br><span class="line">        .body(ResponseBody.create(mediaType, responseBytes))</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>interceptor</tag>
        <tag>okhttp</tag>
      </tags>
  </entry>
  <entry>
    <title>Android更新资源文件浅思考</title>
    <url>/2018/10/27/hotfix-source/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在看 <a href="http://p3ry9qsas.bkt.clouddn.com/Android_hotfix.pdf" target="_blank" rel="noopener">《深入探索Android热修复技术原理7.3Q.pdf》</a> 时，遇到一个之前没有注意过的问题：关于资源修更新的Android的版本兼容？作为程序员我们需要非常严谨的思路，是什么导致了资源的修复更新需要做版本兼容？</p>
<p>这个问题是使我写下这边文章的原因，下边我们带着问题来找答案~！~！~！</p>
<p>这个问题的解释网上答案比较少,在滴滴的插件化框架相关文章 <a href="https://www.notion.so/VirtualAPK-1fce1a910c424937acde9528d2acd537" target="_blank" rel="noopener">VirtualAPK 资源篇</a> 和 <a href="https://www.aliyun.com/product/hotfix?spm=a2c4e.11153940.blogcont96378.11.18b377dcTy4deX" target="_blank" rel="noopener">阿里云移动热修复(Sophix)</a> 相关文章<br><a href="https://yq.aliyun.com/articles/96378" target="_blank" rel="noopener">Android热修复升级探索——资源更新之新思路</a> 中 都有一句概括性质的话语：</p>
<blockquote>
<p>AndroidL之后资源在初始化之后可以加载，而在AndroidL之前是不可以的。因为在Android KK及以下版本，addAssetPath只是把补丁包的路径添加到了mAssetPath中，而真正解析的资源包的逻辑是在app第一次执行AssetManager::getResTable的时候。</p>
</blockquote>
<h1 id="FTSC"><a href="#FTSC" class="headerlink" title="FTSC"></a>FTSC</h1><p>为了比较完整的对前面提出的问题做解答，下边我在老罗写的 <a href="https://blog.csdn.net/luoshengyang/article/details/8791064" target="_blank" rel="noopener">Android应用程序资源管理器（Asset Manager）的创建过程分析</a>  这篇文章的基础上分析。</p>
<h2 id="跟踪getResourceText"><a href="#跟踪getResourceText" class="headerlink" title="跟踪getResourceText"></a>跟踪getResourceText</h2><p>我们都知道在Android中获取资源调用的 <code>Resources.getText(int id)</code> 内部都是在调用 <code>AssetManager.getResourceText(id)</code> 真正对资源进行管理的是 <code>AssetManager</code>。</p>
<p>下边我们就以 <code>getResourceText</code> 方法的调用顺序引子查找：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AssetManager</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/*package*/</span> <span class="keyword">static</span> AssetManager sSystem = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">boolean</span> isSystem)</span></span>;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AssetManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            ......</span><br><span class="line">            init(<span class="keyword">false</span>);</span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">//每个AssetManager实例都会初始化系统的资源</span></span><br><span class="line">            ensureSystemAssets();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ensureSystemAssets</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (sSync) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sSystem == <span class="keyword">null</span>) &#123;</span><br><span class="line">                AssetManager system = <span class="keyword">new</span> AssetManager(<span class="keyword">true</span>);</span><br><span class="line">                system.makeStringBlocks(<span class="keyword">false</span>);</span><br><span class="line">                sSystem = system;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//添加资源路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">addAssetPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> res = addAssetPathNative(path);</span><br><span class="line">            <span class="keyword">if</span> (mStringBlocks != <span class="keyword">null</span>) &#123;</span><br><span class="line">                makeStringBlocks(mStringBlocks);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">addAssetPathNative</span><span class="params">(String path)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*package*/</span> <span class="function"><span class="keyword">final</span> CharSequence <span class="title">getResourceText</span><span class="params">(<span class="keyword">int</span> ident)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            TypedValue tmpValue = mValue;</span><br><span class="line">            <span class="keyword">int</span> block = loadResourceValue(ident, (<span class="keyword">short</span>) <span class="number">0</span>, tmpValue, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (block &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tmpValue.type == TypedValue.TYPE_STRING) &#123;</span><br><span class="line">                    <span class="keyword">return</span> mStringBlocks[block].get(tmpValue.data);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> tmpValue.coerceToString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查找并加载资源</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">loadResourceValue</span><span class="params">(<span class="keyword">int</span> ident, <span class="keyword">short</span> density, TypedValue outValue,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> resolve)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AssetManager.init方法的C层实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/jni/android_util_AssetManager.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_content_AssetManager_init</span><span class="params">(JNIEnv* env, jobject clazz, jboolean isSystem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isSystem) &#123;</span><br><span class="line">        verifySystemIdmaps();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造C++层的AssetManager的对象</span></span><br><span class="line">    AssetManager* am = <span class="keyword">new</span> AssetManager();</span><br><span class="line">    <span class="keyword">if</span> (am == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        jniThrowException(env, <span class="string">"java/lang/OutOfMemoryError"</span>, <span class="string">""</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加系统资源</span></span><br><span class="line">    am-&gt;addDefaultAssets();</span><br><span class="line">    ALOGV(<span class="string">"Created AssetManager %p for Java object %p\n"</span>, am, clazz);</span><br><span class="line">    env-&gt;SetLongField(clazz, gAssetManagerOffsets.mObject, <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(am));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AssetManager.loadResourceValue方法的C层实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//frameworks/base/core/jni/android_util_AssetManager.cpp</span><br><span class="line">static jint android_content_AssetManager_loadResourceValue(JNIEnv* env, jobject clazz, jint ident, jshort density, jobject outValue, jboolean resolve)</span><br><span class="line">&#123;</span><br><span class="line">    /***部分代码省略***/</span><br><span class="line">    //这行代码最重要，通过获取C层的AssetManager的成员变量ResTable来获取资源</span><br><span class="line">    const ResTable&amp; res(am-&gt;getResources());</span><br><span class="line">    Res_value value;</span><br><span class="line">    ResTable_config config;</span><br><span class="line">    uint32_t typeSpecFlags;</span><br><span class="line">    ssize_t block = res.getResource(ident, &amp;value, false, density, &amp;typeSpecFlags, &amp;config);</span><br><span class="line">    /***部分代码省略***/</span><br><span class="line">    if (block &gt;= 0) &#123;</span><br><span class="line">        return copyValue(env, outValue, &amp;res, value, ref, block, typeSpecFlags, &amp;config);</span><br><span class="line">    &#125;</span><br><span class="line">    return static_cast&lt;jint&gt;(block);</span><br><span class="line">&#125;</span><br><span class="line">//getResources实际获取的是ResTable</span><br><span class="line">const ResTable&amp; AssetManager::getResources(bool required) const</span><br><span class="line">&#123;</span><br><span class="line">    const ResTable* rt = getResTable(required);</span><br><span class="line">    return *rt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到获取资源实际是在操作 <code>C层的AssetManager的成员变量ResTable</code> 。如果没有将资源加入到 <code>ResTable</code> 那么是无法获取到的。下边我们分别看看AndroidL和AndroidL之前 <code>addAssetPath</code> 方法的实现。</p>
<h2 id="ResTable的构造"><a href="#ResTable的构造" class="headerlink" title="ResTable的构造"></a>ResTable的构造</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/libs/androidfw/AssetManager.cpp</span></span><br><span class="line"><span class="keyword">const</span> ResTable* AssetManager::getResTable(<span class="keyword">bool</span> required) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    ResTable* rt = mResources;</span><br><span class="line">    <span class="keyword">if</span> (rt) &#123;</span><br><span class="line">        <span class="keyword">return</span> rt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> N = mAssetPaths.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">        <span class="comment">//遍历mAssetPaths将其ResTable中</span></span><br><span class="line">        <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果已经创建那么直接返回，如果没有那么将 <code>mAssetPaths</code> 集合中的资源路径全部添加到 <code>ResTable</code> 中后返回。下边我们继续看看资源的路径是怎么被插入到 <code>mAssetPaths</code> 中的，或者是怎么被直接插入到 <code>ResTable</code> 中的。</p>
<h2 id="addAssetPath的差异"><a href="#addAssetPath的差异" class="headerlink" title="addAssetPath的差异"></a>addAssetPath的差异</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/libs/androidfw/AssetManager.cpp</span></span><br><span class="line"><span class="keyword">bool</span> AssetManager::addDefaultAssets()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* root = getenv(<span class="string">"ANDROID_ROOT"</span>);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(root == <span class="literal">NULL</span>, <span class="string">"ANDROID_ROOT not set"</span>);</span><br><span class="line">    <span class="function">String8 <span class="title">path</span><span class="params">(root)</span></span>;</span><br><span class="line">    path.appendPath(kSystemAssets);</span><br><span class="line">    <span class="function">String8 <span class="title">pathCM</span><span class="params">(root)</span></span>;</span><br><span class="line">    pathCM.appendPath(kCMSDKAssets);</span><br><span class="line">    <span class="keyword">return</span> addAssetPath(path, <span class="literal">NULL</span>) &amp; addAssetPath(pathCM, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> AssetManager::addAssetPath(<span class="keyword">const</span> String8&amp; path, <span class="keyword">int32_t</span>* cookie)</span><br><span class="line">&#123;</span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line">    asset_path ap;</span><br><span class="line">    <span class="function">String8 <span class="title">realPath</span><span class="params">(path)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (kAppZipName) &#123;</span><br><span class="line">        realPath.appendPath(kAppZipName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="comment">//将path添加到mAssetPaths中</span></span><br><span class="line">    mAssetPaths.add(ap);</span><br><span class="line">    <span class="keyword">if</span> (mResources != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> index = mAssetPaths.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//添加到ResTable中</span></span><br><span class="line">        appendPathToResTable(ap, &amp;index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// new paths are always added at the end</span></span><br><span class="line">    <span class="keyword">if</span> (cookie) &#123;</span><br><span class="line">        *cookie = <span class="keyword">static_cast</span>&lt;<span class="keyword">int32_t</span>&gt;(mAssetPaths.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上是Android5.1的源码，我们发现无论是否初始化过 <code>ResTable</code> 我们都可以直接调用 <code>addAssetPath</code> 是可以添加资源。</p>
<p>下边我们看看Android4.4的源码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/libs/androidfw/AssetManager.cpp</span></span><br><span class="line"><span class="keyword">bool</span> AssetManager::addAssetPath(<span class="keyword">const</span> String8&amp; path, <span class="keyword">void</span>** cookie)</span><br><span class="line">&#123;</span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line">    asset_path ap;</span><br><span class="line">    <span class="function">String8 <span class="title">realPath</span><span class="params">(path)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (kAppZipName) &#123;</span><br><span class="line">        realPath.appendPath(kAppZipName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="comment">//将path添加到mAssetPaths中</span></span><br><span class="line">    mAssetPaths.add(ap);</span><br><span class="line">    <span class="comment">// new paths are always added at the end</span></span><br><span class="line">    <span class="keyword">if</span> (cookie) &#123;</span><br><span class="line">        *cookie = (<span class="keyword">void</span>*)mAssetPaths.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现 <code>addAssetPath</code> 只是将 <code>path</code> 添加到了 <code>mAssetPaths</code> 里面，但是并没法添加到 <code>ResTable</code> 中。<br>如果AndroidL之前调用 <code>addAssetPath</code> 没有初始化 <code>ResTable</code> 那么这次添加就是有效的，否则添加无效。下边我们接着看看 <code>ResTable</code> 的初始化时机。</p>
<h2 id="ResTable的初始化时机"><a href="#ResTable的初始化时机" class="headerlink" title="ResTable的初始化时机"></a>ResTable的初始化时机</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AssetManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//静态变量</span></span><br><span class="line">    <span class="keyword">static</span> AssetManager sSystem = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AssetManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            ......</span><br><span class="line">            init(<span class="keyword">false</span>);</span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">//每个AssetManager实例都会初始化系统的资源</span></span><br><span class="line">            ensureSystemAssets();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ensureSystemAssets</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (sSync) &#123;</span><br><span class="line">            <span class="comment">//当sSystem不为空时，所以下边这块代码只会走一次</span></span><br><span class="line">            <span class="keyword">if</span> (sSystem == <span class="keyword">null</span>) &#123;</span><br><span class="line">                AssetManager system = <span class="keyword">new</span> AssetManager(<span class="keyword">true</span>);</span><br><span class="line">                <span class="comment">//初始化系统的字符串块</span></span><br><span class="line">                system.makeStringBlocks(<span class="keyword">false</span>);</span><br><span class="line">                sSystem = system;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*package*/</span> <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">makeStringBlocks</span><span class="params">(StringBlock[] seed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> seedNum = (seed != <span class="keyword">null</span>) ? seed.length : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> num = getStringBlockCount();</span><br><span class="line">        mStringBlocks = <span class="keyword">new</span> StringBlock[num];</span><br><span class="line">        <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">"Making string blocks for "</span> + <span class="keyword">this</span></span><br><span class="line">                + <span class="string">": "</span> + num);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;num; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; seedNum) &#123;</span><br><span class="line">                mStringBlocks[i] = seed[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mStringBlocks[i] = <span class="keyword">new</span> StringBlock(getNativeStringBlock(i), <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getStringBlockCount</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>避免大家往上翻看，我又将 <code>AssetManager</code> 的沟通方法摘出来放大家看看。我们在初始化系统的资源时调用了 <code>AssetManager</code> 的 <code>makeStringBlocks</code> 方法，最后调用了 <code>C层</code> 的 <code>getStringBlockCount</code> 方法。</p>
<p>AssetManager.getStringBlockCount的C层的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/jni/android_util_AssetManager.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">android_content_AssetManager_getStringBlockCount</span><span class="params">(JNIEnv* env, jobject clazz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AssetManager* am = assetManagerForJavaObject(env, clazz);</span><br><span class="line">    <span class="keyword">if</span> (am == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//初次调用资源，进行初始化ResTable</span></span><br><span class="line">    <span class="keyword">return</span> am-&gt;getResources().getTableCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，我们找到了 <code>ResTable</code> 的时机，它是发生在java层的 <code>AssetManager</code> 构造的时候。</p>
<blockquote>
<p>看代码注释的朋友，都看到了重要的部分。并非所有的 <code>AssetManager</code> 的构造都会调用 <code>ResTable</code> ，只有第一个 <code>AssetManager</code> 对象产生的时候会调用，所以如果我们想要添加自己资源的时候可以自己创建 <code>AssetManager</code> 然后调用 <code>addAssetPath</code> 这个时候无论是在 <code>AndroidL</code> 之前还是之后都没有问题。</p>
</blockquote>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>以下结论需要大家结合文章来看，因为涉及到的 <code>Android</code> 不同版本的代码：</p>
<blockquote>
<ul>
<li>Android中进行资源管理的是 <code>AssetManager</code>；</li>
<li>资源由C层 <code>AssetManager</code> 的 <code>ResTable</code> 提供；</li>
<li><code>ResTable</code> 构造是遍历 <code>mAssetPaths</code> 中的资源路径；</li>
<li>AndroidL <code>addAssetPath</code> 方法可以直接将资源路添加到 <code>ResTable</code> 中使用；</li>
<li>AndroidL之前 <code>addAssetPath</code> 方法只是将资源路径添加到了<code>mAssetPaths</code> 中；</li>
<li><code>ResTable</code> 构造包含在Java层 <code>AssetManager</code> 的构造中的（PS:只有第一个<code>AssetManager</code> 的构造会执行）；</li>
</ul>
</blockquote>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>hotfix</tag>
        <tag>AssetManager</tag>
      </tags>
  </entry>
  <entry>
    <title>Multidex记录三：源码解析</title>
    <url>/2018/10/18/multidex3/</url>
    <content><![CDATA[<p><a href="http://dandanlove.com/2018/10/16/multidex1/" target="_blank" rel="noopener">Multidex记录一：介绍和使用</a><br><a href="http://dandanlove.com/2018/10/17/multidex2" target="_blank" rel="noopener">Multidex记录二：缺陷&amp;解决</a><br><a href="http://dandanlove.com/2018/10/18/multidex3" target="_blank" rel="noopener">Multidex记录三：源码解析</a></p>
<h1 id="记录Multidex源码解析"><a href="#记录Multidex源码解析" class="headerlink" title="记录Multidex源码解析"></a>记录Multidex源码解析</h1><p>为什么要用记录呢，因为我从开始接触Android时我们的项目就在65535的边缘。不久Google就出了multidex的解决方案。我们也已经接入multidex好多年，但我自己还没有接入，知其然而不知其所以然。出了问题只能自己找源码来分析。前两篇文章 <a href="https://www.jianshu.com/p/9d9c2dbba223" target="_blank" rel="noopener">Multidex记录一：介绍和使用</a> 和 <a href="https://www.jianshu.com/p/bf59ae5af9b9" target="_blank" rel="noopener">Multidex记录二：缺陷&amp;解决</a> 分别讲述了怎么接入和接入时遇到的问题，本博文只是对multidex源码学习过程中的分析和理解的记录。</p>
<p>关于<code>Multidex</code>的相关知识点前两章已经讲的差不多了，这篇文章只分析<code>Multidex</code>的安装。</p>
<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/736a295b4111a8c69f8aa2c6fa0dfd1c.png#pic_center" alt="multidex-flowchart.png"></p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>我们先来看看<code>MultiDex</code>的安装日志：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">I/MultiDex: VM with version <span class="number">1.6</span>.0 does not have multidex support</span><br><span class="line">    Installing application</span><br><span class="line">    MultiDexExtractor.load(/data/app/com.xxx.xxx-<span class="number">1</span>.apk, <span class="keyword">false</span>, )</span><br><span class="line">I/MultiDex: Blocking on lock /data/data/com.xxx.xxx/code_cache/secondary-dexes/MultiDex.lock</span><br><span class="line">    /data/data/com.xxx.xxx/code_cache/secondary-dexes/MultiDex.lock locked</span><br><span class="line">    Detected that extraction must be performed.</span><br><span class="line">I/MultiDex: Extraction is needed <span class="keyword">for</span> file /data/data/com.xxx.xxx/code_cache/secondary-dexes/com.xxx.xxx-<span class="number">1</span>.apk.classes2.zip</span><br><span class="line">    Extracting /data/data/com.xxx.xxx/code_cache/secondary-dexes/tmp-com.xxx.xxx-<span class="number">1</span>.apk.classes1415547735.zip</span><br><span class="line">I/MultiDex: Renaming to /data/data/com.xxx.xxx/code_cache/secondary-dexes/com.xxx.xxx-<span class="number">1</span>.apk.classes2.zip</span><br><span class="line">    Extraction succeeded - length /data/data/com.xxx.xxx/code_cache/secondary-dexes/com.xxx.xxx-<span class="number">1</span>.apk.classes2.zip: <span class="number">4238720</span> - crc: <span class="number">2971858359</span></span><br><span class="line">    Extraction is needed <span class="keyword">for</span> file /data/data/com.xxx.xxx/code_cache/secondary-dexes/com.xxx.xxx-<span class="number">1</span>.apk.classes3.zip</span><br><span class="line">    Extracting /data/data/com.xxx.xxx/code_cache/secondary-dexes/tmp-com.xxx.xxx-<span class="number">1</span>.apk.classes-<span class="number">1615165740</span>.zip</span><br><span class="line">I/MultiDex: Renaming to /data/data/com.xxx.xxx/code_cache/secondary-dexes/com.xxx.xxx-<span class="number">1</span>.apk.classes3.zip</span><br><span class="line">    Extraction succeeded - length /data/data/com.xxx.xxx/code_cache/secondary-dexes/com.xxx.xxx-<span class="number">1</span>.apk.classes3.zip: <span class="number">3106018</span> - crc: <span class="number">3138243730</span></span><br><span class="line">    Extraction is needed <span class="keyword">for</span> file /data/data/com.xxx.xxx/code_cache/secondary-dexes/com.xxx.xxx-<span class="number">1</span>.apk.classes4.zip</span><br><span class="line">    Extracting /data/data/com.xxx.xxx/code_cache/secondary-dexes/tmp-com.xxx.xxx-<span class="number">1</span>.apk.classes-<span class="number">469912688</span>.zip</span><br><span class="line">I/MultiDex: Renaming to /data/data/com.xxx.xxx/code_cache/secondary-dexes/com.xxx.xxx-<span class="number">1</span>.apk.classes4.zip</span><br><span class="line">    Extraction succeeded - length /data/data/com.xxx.xxx/code_cache/secondary-dexes/com.xxx.xxx-<span class="number">1</span>.apk.classes4.zip: <span class="number">2163715</span> - crc: <span class="number">1148318293</span></span><br><span class="line">    load found <span class="number">3</span> secondary dex files</span><br><span class="line">I/MultiDex: install done</span><br></pre></td></tr></table></figure>
<p>第二次启动时的日志：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">I/MultiDex: VM with version <span class="number">1.6</span>.0 does not have multidex support</span><br><span class="line">    Installing application</span><br><span class="line">    MultiDexExtractor.load(/data/app/com.xxx.xxx-<span class="number">1</span>.apk, <span class="keyword">false</span>, )</span><br><span class="line">    Blocking on lock /data/data/com.xxx.xxx/code_cache/secondary-dexes/MultiDex.lock</span><br><span class="line">    /data/data/com.xxx.xxx/code_cache/secondary-dexes/MultiDex.lock locked</span><br><span class="line">I/MultiDex: loading existing secondary dex files</span><br><span class="line">    load found <span class="number">3</span> secondary dex files</span><br><span class="line">    install done</span><br></pre></td></tr></table></figure>
<h3 id="初始化信息"><a href="#初始化信息" class="headerlink" title="初始化信息"></a>初始化信息</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiDex</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MultiDex"</span>;</span><br><span class="line">    <span class="comment">//老版本dex文件存放路径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String OLD_SECONDARY_FOLDER_NAME = <span class="string">"secondary-dexes"</span>;</span><br><span class="line">    <span class="comment">//dex文件存放路径 code_cache/secondary-dexes</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SECONDARY_FOLDER_NAME;</span><br><span class="line">    <span class="comment">//Multidex最高支持的版本，大于20Android系统已支持</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SUPPORTED_SDK_VERSION = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">//Multidex最低支持的版本</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_SDK_VERSION = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">//vm的版本信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VM_WITH_MULTIDEX_VERSION_MAJOR = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VM_WITH_MULTIDEX_VERSION_MINOR = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//apk路径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; installedApk;</span><br><span class="line">    <span class="comment">//是否支持Multidex</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> IS_VM_MULTIDEX_CAPABLE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">    	<span class="comment">//SECONDARY_FOLDER_NAME=code_cache/secondary-dexes</span></span><br><span class="line">        SECONDARY_FOLDER_NAME = <span class="string">"code_cache"</span> + File.separator + <span class="string">"secondary-dexes"</span>;</span><br><span class="line">        installedApk = <span class="keyword">new</span> HashSet();</span><br><span class="line">        <span class="comment">//VM是否已经支持自动Multidex</span></span><br><span class="line">        IS_VM_MULTIDEX_CAPABLE = isVMMultidexCapable(System.getProperty(<span class="string">"java.vm.version"</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Multidex安装"><a href="#Multidex安装" class="headerlink" title="Multidex安装"></a>Multidex安装</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">install</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//VM是否已经支持自动Multidex</span></span><br><span class="line">    <span class="keyword">if</span> (IS_VM_MULTIDEX_CAPABLE) &#123;</span><br><span class="line">        Log.i(<span class="string">"MultiDex"</span>, <span class="string">"VM has multidex support, MultiDex support library is disabled."</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (VERSION.SDK_INT &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="comment">//Multidex最低支持的版本</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Multi dex installation failed. SDK "</span> + VERSION.SDK_INT + <span class="string">" is unsupported. Min SDK version is "</span> + <span class="number">4</span> + <span class="string">"."</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/***部分代码省略***/</span></span><br><span class="line">            <span class="comment">//多线程锁</span></span><br><span class="line">            <span class="keyword">synchronized</span>(installedApk) &#123;</span><br><span class="line">                <span class="comment">//apkPath = data/data/com.xxx.xxx/</span></span><br><span class="line">                String apkPath = applicationInfo.sourceDir;</span><br><span class="line">                <span class="keyword">if</span> (installedApk.contains(apkPath)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                installedApk.add(apkPath);</span><br><span class="line">                <span class="comment">/***部分代码省略***/</span></span><br><span class="line">                <span class="comment">//清除 /data/data/com.xxx.xxx/files/secondary-dexes 目录下的文件</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    clearOldDexDir(context);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable var8) &#123;</span><br><span class="line">                    Log.w(<span class="string">"MultiDex"</span>, <span class="string">"Something went wrong when trying to clear old MultiDex extraction, continuing without cleaning."</span>, var8);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//data/data/com.xxx.xxx/code_cache/secondary-dexes</span></span><br><span class="line">                File dexDir = <span class="keyword">new</span> File(applicationInfo.dataDir, SECONDARY_FOLDER_NAME);</span><br><span class="line">                <span class="comment">//解压apk，获得dex的zip文件列表</span></span><br><span class="line">                List&lt;File&gt; files = MultiDexExtractor.load(context, applicationInfo, dexDir, <span class="keyword">false</span>);</span><br><span class="line">                <span class="comment">//校验zip文件</span></span><br><span class="line">                <span class="keyword">if</span> (checkValidZipFiles(files)) &#123;</span><br><span class="line">                    <span class="comment">//安装dex文件</span></span><br><span class="line">                    installSecondaryDexes(loader, dexDir, files);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//校验失败，重新执行解压（解压失败直接抛出异常）和安装</span></span><br><span class="line">                    Log.w(<span class="string">"MultiDex"</span>, <span class="string">"Files were not valid zip files.  Forcing a reload."</span>);</span><br><span class="line">                    files = MultiDexExtractor.load(context, applicationInfo, dexDir, <span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">if</span> (!checkValidZipFiles(files)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Zip files were not valid."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    installSecondaryDexes(loader, dexDir, files);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Multidex获取dex文件"><a href="#Multidex获取dex文件" class="headerlink" title="Multidex获取dex文件"></a>Multidex获取dex文件</h3><p>加载dex文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> applicationInfo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dexDir /data/data/com.xxx.xxx/code_cache/secondary-dexes/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> forceReload 是否强制重新加载</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含dex的zip文件列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> *             if an error occurs when writing the file.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> List&lt;File&gt; <span class="title">load</span><span class="params">(Context context, ApplicationInfo applicationInfo, File dexDir, <span class="keyword">boolean</span> forceReload)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//data/data/com.xxx.xxx/</span></span><br><span class="line">    File sourceApk = <span class="keyword">new</span> File(applicationInfo.sourceDir);</span><br><span class="line">    <span class="comment">//apk的循环冗余校验码</span></span><br><span class="line">    <span class="keyword">long</span> currentCrc = getZipCrc(sourceApk);</span><br><span class="line">    List files;</span><br><span class="line">    <span class="comment">//是否强制执行reload和是否已经解压过apk</span></span><br><span class="line">    <span class="keyword">if</span> (!forceReload &amp;&amp; !isModified(context, sourceApk, currentCrc)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//是否已存在zip文件</span></span><br><span class="line">            files = loadExistingExtractions(context, sourceApk, dexDir);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var9) &#123;</span><br><span class="line">            files = performExtractions(sourceApk, dexDir);</span><br><span class="line">            putStoredApkInfo(context, getTimeStamp(sourceApk), currentCrc, files.size() + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//获取apk中的classes2.dex并且压缩为zip文件</span></span><br><span class="line">        files = performExtractions(sourceApk, dexDir);</span><br><span class="line">        <span class="comment">//存储当前apk的信息，作为下次有效缓存的明证</span></span><br><span class="line">        putStoredApkInfo(context, getTimeStamp(sourceApk), currentCrc, files.size() + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> files;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeStamp apk的最后一次修改时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> crc apk的循环冗余校验码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> totalDexNumber apk中一共有几个dex</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putStoredApkInfo</span><span class="params">(Context context, <span class="keyword">long</span> timeStamp, <span class="keyword">long</span> crc, <span class="keyword">int</span> totalDexNumber)</span> </span>&#123;</span><br><span class="line">    SharedPreferences prefs = getMultiDexPreferences(context);</span><br><span class="line">    Editor edit = prefs.edit();</span><br><span class="line">    edit.putLong(<span class="string">"timestamp"</span>, timeStamp);</span><br><span class="line">    edit.putLong(<span class="string">"crc"</span>, crc);</span><br><span class="line">    edit.putInt(<span class="string">"dex.number"</span>, totalDexNumber);</span><br><span class="line">    apply(edit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取已经存在的dex的压缩包</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dexDir /data/data/com.xxx.xxx/code_cache/secondary-dexes/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceApk data/app/com.xxx.xxx-1.apk</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含dex的zip文件列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> *             if an error occurs when writing the file.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;File&gt; <span class="title">loadExistingExtractions</span><span class="params">(Context context, File sourceApk, File dexDir)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//extractedFilePrefix = com.xxx.xxx.apk.classes</span></span><br><span class="line">    String extractedFilePrefix = sourceApk.getName() + <span class="string">".classes"</span>;</span><br><span class="line">    <span class="comment">//totalDexNumber=apk中dex的数量</span></span><br><span class="line">    <span class="keyword">int</span> totalDexNumber = getMultiDexPreferences(context).getInt(<span class="string">"dex.number"</span>, <span class="number">1</span>);</span><br><span class="line">    List&lt;File&gt; files = <span class="keyword">new</span> ArrayList(totalDexNumber);</span><br><span class="line">    <span class="comment">//主dex已经加载过了，加载class2.dex,class3.dex......</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> secondaryNumber = <span class="number">2</span>; secondaryNumber &lt;= totalDexNumber; ++secondaryNumber) &#123;</span><br><span class="line">        <span class="comment">//fileName = com.xxx.xxx.apk.classes2.zip</span></span><br><span class="line">        String fileName = extractedFilePrefix + secondaryNumber + <span class="string">".zip"</span>;</span><br><span class="line">        <span class="comment">//extractedFile = data/data/com.xxx.xxx/code_cache/secondary-dexes/com.wuba.bangjob-1.apk.classes2.zip</span></span><br><span class="line">        File extractedFile = <span class="keyword">new</span> File(dexDir, fileName);</span><br><span class="line">        <span class="keyword">if</span> (!extractedFile.isFile()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Missing extracted secondary dex file '"</span> + extractedFile.getPath() + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        files.add(extractedFile);</span><br><span class="line">        <span class="comment">//校验zip文件是否完整</span></span><br><span class="line">        <span class="keyword">if</span> (!verifyZipFile(extractedFile)) &#123;</span><br><span class="line">            Log.i(<span class="string">"MultiDex"</span>, <span class="string">"Invalid zip file: "</span> + extractedFile);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Invalid ZIP file."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> files;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成dex的压缩zip文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceApk data/app/com.xxx.xxx-1.apk</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dexDir /data/data/com.xxx.xxx/code_cache/secondary-dexes/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含dex的zip文件列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> *             if an error occurs when writing the file.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;File&gt; <span class="title">performExtractions</span><span class="params">(File sourceApk, File dexDir)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//extractedFilePrefix = com.xxx.xxx.apk.classes</span></span><br><span class="line">    String extractedFilePrefix = sourceApk.getName() + <span class="string">".classes"</span>;</span><br><span class="line">    <span class="comment">//删除data/data/com.xxx.xxx/code_cache/secondary-dexes/目录下的文件</span></span><br><span class="line">    prepareDexDir(dexDir, extractedFilePrefix);</span><br><span class="line">    List&lt;File&gt; files = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    ZipFile apk = <span class="keyword">new</span> ZipFile(sourceApk);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//从class2.dex开始</span></span><br><span class="line">        <span class="keyword">int</span> secondaryNumber = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(ZipEntry dexFile = apk.getEntry(<span class="string">"classes"</span> + secondaryNumber + <span class="string">".dex"</span>); dexFile != <span class="keyword">null</span>; dexFile = apk.getEntry(<span class="string">"classes"</span> + secondaryNumber + <span class="string">".dex"</span>)) &#123;</span><br><span class="line">            <span class="comment">//fileName = com.xxx.xxx.apk.classes2.zip</span></span><br><span class="line">            String fileName = extractedFilePrefix + secondaryNumber + <span class="string">".zip"</span>;</span><br><span class="line">            File extractedFile = <span class="keyword">new</span> File(dexDir, fileName);</span><br><span class="line">            files.add(extractedFile);</span><br><span class="line">            <span class="comment">//最多三次尝试生成dex的zip文件</span></span><br><span class="line">            <span class="keyword">int</span> numAttempts = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//标识是否生成dex的zip文件</span></span><br><span class="line">            <span class="keyword">boolean</span> isExtractionSuccessful = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">while</span>(numAttempts &lt; <span class="number">3</span> &amp;&amp; !isExtractionSuccessful) &#123;</span><br><span class="line">                ++numAttempts;</span><br><span class="line">                extract(apk, dexFile, extractedFile, extractedFilePrefix);</span><br><span class="line">                <span class="comment">//校验压缩文件是否完整，否则删除重来</span></span><br><span class="line">                isExtractionSuccessful = verifyZipFile(extractedFile);</span><br><span class="line">                <span class="keyword">if</span> (!isExtractionSuccessful) &#123;</span><br><span class="line">                    extractedFile.delete();</span><br><span class="line">                    <span class="keyword">if</span> (extractedFile.exists()) &#123;</span><br><span class="line">                        Log.w(<span class="string">"MultiDex"</span>, <span class="string">"Failed to delete corrupted secondary dex '"</span> + extractedFile.getPath() + <span class="string">"'"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!isExtractionSuccessful) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Could not create zip file "</span> + extractedFile.getAbsolutePath() + <span class="string">" for secondary dex ("</span> + secondaryNumber + <span class="string">")"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ++secondaryNumber;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="keyword">return</span> files;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将classes2.dex放入zip文件中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> apk apk的压缩包</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dexFile apk中的classes2.dex文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> extractTo /data/data/com.xxx.xxx/code_cache/secondary-dexes/com.xxx.xxx.apk.classes2.zip</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> extractedFilePrefix  com.wuba.bangjob-1.apk.classes</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> *             if an error occurs when writing the file.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">extract</span><span class="params">(ZipFile apk, ZipEntry dexFile, File extractTo, String extractedFilePrefix)</span> <span class="keyword">throws</span> IOException, FileNotFoundException </span>&#123;</span><br><span class="line">    InputStream in = apk.getInputStream(dexFile);</span><br><span class="line">    ZipOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">///data/data/com.wuba.bangjob/code_cache/secondary-dexes/com.xxx.xxx.apk.classes1415547735.zip</span></span><br><span class="line">    File tmp = File.createTempFile(extractedFilePrefix, <span class="string">".zip"</span>, extractTo.getParentFile());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        out = <span class="keyword">new</span> ZipOutputStream(<span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(tmp)));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//将classes2.dex进行压缩内容名称为classes.dex</span></span><br><span class="line">            ZipEntry classesDex = <span class="keyword">new</span> ZipEntry(<span class="string">"classes.dex"</span>);</span><br><span class="line">            classesDex.setTime(dexFile.getTime());</span><br><span class="line">            out.putNextEntry(classesDex);</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">16384</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> length = in.read(buffer); length != -<span class="number">1</span>; length = in.read(buffer)) &#123;</span><br><span class="line">                out.write(buffer, <span class="number">0</span>, length);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            out.closeEntry();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//重命名文件为com.xxx.xxx.apk.classes2.zip</span></span><br><span class="line">        <span class="keyword">if</span> (!tmp.renameTo(extractTo)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Failed to rename \""</span> + tmp.getAbsolutePath() + <span class="string">"\" to \""</span> + extractTo.getAbsolutePath() + <span class="string">"\""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">/***部分代码省略***/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="dex文件的装载"><a href="#dex文件的装载" class="headerlink" title="dex文件的装载"></a>dex文件的装载</h3><p>将含有加载含有dex的压缩包进行夹杂，相关知识点参考：<a href="https://www.jianshu.com/p/4b4f1fa6633c" target="_blank" rel="noopener">Android类加载之PathClassLoader和DexClassLoader</a>。<br>为什么需要做版本的区分，就是因为版本见类加载的实现是有些差异的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loader</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dexDir /data/data/xxx.xxx.xxx/code_cache/secondary-dexes/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> files dex的压缩zip文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">installSecondaryDexes</span><span class="params">(ClassLoader loader, File dexDir, List&lt;File&gt; files)</span> <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException, NoSuchFieldException, InvocationTargetException, NoSuchMethodException, IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!files.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (VERSION.SDK_INT &gt;= <span class="number">19</span>) &#123;<span class="comment">//KitKat(19)</span></span><br><span class="line">            MultiDex.V19.install(loader, files, dexDir);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (VERSION.SDK_INT &gt;= <span class="number">14</span>) &#123;<span class="comment">//IceCreamSandwich(14,15),JellyBean(16,17,18)</span></span><br><span class="line">            MultiDex.V14.install(loader, files, dexDir);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            MultiDex.V4.install(loader, files);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.jianshu.com/p/4b4f1fa6633c" target="_blank" rel="noopener">Android类加载之PathClassLoader和DexClassLoader</a> 这篇文章将的是<code>VERSION.SDK_INT &gt;= 19</code> 那么我们先看看第一个case：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">V19</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">V19</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loader PathClassLoader</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> additionalClassPathEntries dex压缩包路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> optimizedDirectory opt之后的dex文件目录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">install</span><span class="params">(ClassLoader loader, List&lt;File&gt; additionalClassPathEntries, File optimizedDirectory)</span> <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException, NoSuchFieldException, InvocationTargetException, NoSuchMethodException </span>&#123;</span><br><span class="line">        <span class="comment">//PathClassLoader的DexPathList类型变量pathList</span></span><br><span class="line">        Field pathListField = MultiDex.findField(loader, <span class="string">"pathList"</span>);</span><br><span class="line">        Object dexPathList = pathListField.get(loader);</span><br><span class="line">        ArrayList&lt;IOException&gt; suppressedExceptions = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="comment">//进行dex的opt并合并dex的Element</span></span><br><span class="line">        MultiDex.expandFieldArray(dexPathList, <span class="string">"dexElements"</span>, makeDexElements(dexPathList, <span class="keyword">new</span> ArrayList(additionalClassPathEntries), optimizedDirectory, suppressedExceptions));</span><br><span class="line">        <span class="comment">//处理异常</span></span><br><span class="line">        <span class="keyword">if</span> (suppressedExceptions.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Iterator i$ = suppressedExceptions.iterator();</span><br><span class="line">            <span class="keyword">while</span>(i$.hasNext()) &#123;</span><br><span class="line">                IOException e = (IOException)i$.next();</span><br><span class="line">                Log.w(<span class="string">"MultiDex"</span>, <span class="string">"Exception in makeDexElement"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//一直感觉Google源码这块有些问题，loader应该改为dexPathList。因为dexElementsSuppressedExceptions变量是属于DexPathList的成员</span></span><br><span class="line">            Field suppressedExceptionsField = MultiDex.findField(loader, <span class="string">"dexElementsSuppressedExceptions"</span>);</span><br><span class="line">            IOException[] dexElementsSuppressedExceptions = (IOException[])((IOException[])suppressedExceptionsField.get(loader));</span><br><span class="line">            <span class="keyword">if</span> (dexElementsSuppressedExceptions == <span class="keyword">null</span>) &#123;</span><br><span class="line">                dexElementsSuppressedExceptions = (IOException[])suppressedExceptions.toArray(<span class="keyword">new</span> IOException[suppressedExceptions.size()]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                IOException[] combined = <span class="keyword">new</span> IOException[suppressedExceptions.size() + dexElementsSuppressedExceptions.length];</span><br><span class="line">                suppressedExceptions.toArray(combined);</span><br><span class="line">                System.arraycopy(dexElementsSuppressedExceptions, <span class="number">0</span>, combined, suppressedExceptions.size(), dexElementsSuppressedExceptions.length);</span><br><span class="line">                dexElementsSuppressedExceptions = combined;</span><br><span class="line">            &#125;</span><br><span class="line">            suppressedExceptionsField.set(loader, dexElementsSuppressedExceptions);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用DexPathList的makeDexElements方法进行dex的opt</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object[] makeDexElements(Object dexPathList, ArrayList&lt;File&gt; files, File optimizedDirectory, ArrayList&lt;IOException&gt; suppressedExceptions) <span class="keyword">throws</span> IllegalAccessException, InvocationTargetException, NoSuchMethodException &#123;</span><br><span class="line">        Method makeDexElements = MultiDex.findMethod(dexPathList, <span class="string">"makeDexElements"</span>, ArrayList.class, File.class, ArrayList.class);</span><br><span class="line">        <span class="keyword">return</span> (Object[])((Object[])makeDexElements.invoke(dexPathList, files, optimizedDirectory, suppressedExceptions));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>19 &gt; VERSION.SDK_INT &gt;= 14</code>的处理支持比<code>VERSION.SDK_INT &gt;= 19</code>少了异常处理。是因为DexPathList的<code>makeDexElements</code>方法有了修改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VERSION.SDK_INT &gt;= 19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Element[] makeDexElements(ArrayList&lt;File&gt; files, File optimizedDirectory,</span><br><span class="line">        ArrayList&lt;IOException&gt; suppressedExceptions);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 19 &gt; VERSION.SDK_INT &gt;= 14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Element[] makeDexElements(ArrayList&lt;File&gt; files,File optimizedDirectory);</span><br></pre></td></tr></table></figure>
<p><code>VERSION_SDK_INT &lt; 14</code> 的情况和前面的都不相同是因为<code>PathClassLoader</code>的是实现就不相同。。。。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VERSION.SDK_INT == 13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String path;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String libPath;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Parallel arrays for jar/apk files.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * (could stuff these into an object and have a single array;</span></span><br><span class="line"><span class="comment">     * improves clarity but adds overhead)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] mPaths;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> File[] mFiles;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ZipFile[] mZips;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DexFile[] mDexs;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="apk解压结果预览"><a href="#apk解压结果预览" class="headerlink" title="apk解压结果预览"></a>apk解压结果预览</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/6901bcd5d42eb0d96d26e40f77ab9a1a.png#pic_center" alt="image.png"></p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>multidex</tag>
      </tags>
  </entry>
  <entry>
    <title>Multidex记录二：缺陷和解决</title>
    <url>/2018/10/17/multidex2/</url>
    <content><![CDATA[<p><a href="http://dandanlove.com/2018/10/16/multidex1/" target="_blank" rel="noopener">Multidex记录一：介绍和使用</a><br><a href="http://dandanlove.com/2018/10/17/multidex2" target="_blank" rel="noopener">Multidex记录二：缺陷&amp;解决</a><br><a href="http://dandanlove.com/2018/10/18/multidex3" target="_blank" rel="noopener">Multidex记录三：源码解析</a></p>
<h1 id="记录Multidex缺陷-amp-解决"><a href="#记录Multidex缺陷-amp-解决" class="headerlink" title="记录Multidex缺陷&amp;解决"></a>记录Multidex缺陷&amp;解决</h1><p>为什么要用记录呢，因为我从开始接触Android时我们的项目就在65535的边缘。不久Google就出了multidex的解决方案。我们也已经接入multidex好多年，但我自己还没有接入，所以本博文只是作者自己对multidex接入中产生的问题以及解决方案做理解和记录。</p>
<h2 id="Multidex的缺陷"><a href="#Multidex的缺陷" class="headerlink" title="Multidex的缺陷"></a>Multidex的缺陷</h2><p><a href="https://www.jianshu.com/p/9d9c2dbba223" target="_blank" rel="noopener">Multidex介绍和使用</a> 中已经说了一部分<code>multidex</code>的局限性：</p>
<ul>
<li>1、在冷启动时因为需要安装DEX文件，如果DEX文件过大时，处理时间过长，很容易引发ANR（Application Not Responding）；</li>
<li>2、采用MultiDex方案的应用可能不能在低于Android 4.0 (API level 14) 机器上启动，这个主要是因为Dalvik linearAlloc的一个bug（问题 <a href="http://b.android.com/22586?hl=zh-cn" target="_blank" rel="noopener">22586</a>） ;</li>
<li>3、采用MultiDex方案的应用因为需要申请一个很大的内存，在运行时可能导致程序的崩溃，这个主要是因为Dalvik linearAlloc 的一个限制问题 <a href="http://b.android.com/78035?hl=zh-cn" target="_blank" rel="noopener">78035</a>），这个限制在 Android 4.0 (API level 14)已经增加了, 应用也有可能在低于 Android 5.0 (API level 21)版本的机器上触发这个限制。</li>
</ul>
<p>Google官方给解决办法就是混淆、混淆~！~！</p>
<h2 id="Dalvik-LinearAlloc"><a href="#Dalvik-LinearAlloc" class="headerlink" title="Dalvik LinearAlloc"></a>Dalvik LinearAlloc</h2><p>局限<code>2和3</code>都与<code>Dalvik LinearAlloc</code>，我们先来看一下<code>Dalvik LinearAlloc</code>是什么：</p>
<blockquote>
<p>线性内存分配器LinearAlloc的目的在于简单、快速地分配只写一次(write-once)的内存（即分配并完成初始化写入后一般不会再改变，保持只读性质）</p>
</blockquote>
<blockquote>
<p>LinearAlloc它主要用来管理Dalvik中类加载时的内存，因为类加载后通常是只读属性，而不需要去改变且在程序的整个运行周期都是有效的，同时它还有共享的特性，一个应用加载后其它进程可以共享使用这些已加载的类从而加快程序的启动和运行速度。</p>
</blockquote>
<p>在Android版本不同分别经历了<code>4M/5M/8M/16M</code>限制，目前主流4.2.x系统上可能都已到16M， 在<code>Gingerbread</code>或者以下系统LinearAllocHdr分配空间只有5M大小的， 高于<code>Gingerbread</code>的系统提升到了8M。Dalvik linearAlloc是一个固定大小的缓冲区。在应用的安装过程中，系统会运行一个名为dexopt的程序为该应用在当前机型中运行做准备。dexopt使用LinearAlloc来存储应用的方法信息。Android 2.2和2.3的缓冲区只有5MB，Android 4.x提高到了8MB或16MB。当方法数量过多导致超出缓冲区大小时，会造成dexopt崩溃。</p>
<h2 id="LinearAlloc解决方法"><a href="#LinearAlloc解决方法" class="headerlink" title="LinearAlloc解决方法"></a>LinearAlloc解决方法</h2><p>这个问题实质上是dex过大的问题，因为我们使用的<code>multidex</code>，dx命令就已经支持：–multi-dex 参数来直接自动分包。</p>
<p>我们查看<code>dx</code>命令：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/f0e3706a7f8ea86f362614f7190f7332.png#pic_center" alt="dx.png"></p>
<blockquote>
<p>multidex相关参数说明：</p>
<ul>
<li>–multi-dex：多 dex 打包的开关</li>
<li>–main-dex-list=<file>：参数是一个类列表的文件，在该文件中的类会被打包在第一个 dex 中</file></li>
<li>–minimal-main-dex：只有在–main-dex-list 文件中指定的类被打包在第一个 dex，其余的都在第二个 dex 文件中。</li>
</ul>
</blockquote>
<p>发现并没有控制<code>dex</code>中方法数的参数，那么继续查看<code>dx</code>的源码，我们找到一个<code>maxNumberOfIdxPerDex</code>变量用来指定<code>dex</code>的最大方法数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//65536</span><br><span class="line">private int maxNumberOfIdxPerDex = DexFormat.MAX_MEMBER_IDX + 1;</span><br></pre></td></tr></table></figure>
<p>同时又一个隐藏的<code>--set-max-idx-number</code>参数可以用来修改<code>maxNumberOfIdxPerDex</code> 的值：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/0db153026a99a18a63a185a2006e2e31.png#pic_center" alt="--set-max-idx-number=.png"></p>
<p>我们修改项目的<code>build.gradle</code>脚本：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android.applicationVariants.all &#123;</span><br><span class="line">    variant -&gt;</span><br><span class="line">        dex.doFirst&#123;</span><br><span class="line">            dex-&gt;</span><br><span class="line">            <span class="keyword">if</span> (dex.additionalParameters == <span class="literal">null</span>) &#123;</span><br><span class="line">                dex.additionalParameters = []</span><br><span class="line">            &#125;</span><br><span class="line">                dex.additionalParameters += <span class="string">'--set-max-idx-number=48000'</span></span><br><span class="line"> </span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>--set-max-idx-number=</code>用于控制每一个dex的最大方法个数，写小一点可以产生好几个dex。为了避免2.3机型runtime 的linearAlloclimit ,最好保持每一个dex体积&lt;4M ,刚才的的<code>value&lt;=48000</code>。</p>
<h2 id="Application-Not-Responding解决："><a href="#Application-Not-Responding解决：" class="headerlink" title="Application Not Responding解决："></a>Application Not Responding解决：</h2><p><code>Multidex</code>的安装是比较耗时的，所以如果放在主线程中就会产生ANR。</p>
<p>目前有两类解决办法：</p>
<blockquote>
<p>放在异步线程；<br>放在其他进程（我们使用的是第二种，下边详细讲解）；</p>
</blockquote>
<h3 id="异步线程执-MultiDex-install"><a href="#异步线程执-MultiDex-install" class="headerlink" title="异步线程执`MultiDex.install"></a>异步线程执`MultiDex.install</h3><p>最有名的是美团的方案：精简主dex+异步加载secondary.dex 。对异步化执行速度的不确定性，他们的解决方案是重写Instrumentation execStartActivity 方法，hook跳转Activity的总入口做判断，如果当前secondary.dex 还没有加载完成，就弹一个loading Activity等待加载完成，如果已经加载完成那最好不过了。</p>
<p>局限性：第一个dex必须包含所有可能启动之后ClassLoader的类，不然一定会产生<code>NoClassDefFoundError</code>异常。Application的启动入口有多重，点击桌面icon只不过是其中的一种，而且有些时候启动Application不一定会打开Activity。</p>
<h3 id="放在其他进程"><a href="#放在其他进程" class="headerlink" title="放在其他进程"></a>放在其他进程</h3><p>微信团队的方案：<br>流程图：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/012a5390a9c1da43bf34534ce41f6b9a.png#pic_center" alt="泡在网上的日子"></p>
<blockquote>
<ul>
<li>对现有代码改动量最小；</li>
<li>该方案不关注Application被哪个组件启动。Activity ，Service ，Receiver ，ContentProvider 都满足（与美团方案都相同的问题，假如打开的不是Activity。这个时候弹出一个过渡的Activity就非常尴尬）；</li>
<li>该方案不限制 Application ，Activity ，Service ，Receiver ，ContentProvider 继续新增业务；</li>
</ul>
</blockquote>
<p>实现代码：<br><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/1218/3789.html" target="_blank" rel="noopener">泡在网上的日子:其实你不知道MultiDex到底有多坑</a></p>
<p>单独说一下<code>waitForDexopt</code>这个方法，这里设置的10s（Honeycomb之前20s）的轮询之后执行了<code>MultiDex.install</code>。此时在<code>mini</code>进程中<code>Multidex</code>可能还未完成安装（我们项目目前一共3个dex，<code>Multidex</code>的安装耗时大概20s）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">waitForDexopt</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">    ComponentName componentName = <span class="keyword">new</span></span><br><span class="line">            ComponentName( <span class="string">"com.zongwu"</span>, LoadResActivity.class.getName());</span><br><span class="line">    intent.setComponent(componentName);</span><br><span class="line">    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">    base.startActivity(intent);</span><br><span class="line">    <span class="keyword">long</span> startWait = System.currentTimeMillis ();</span><br><span class="line">    <span class="keyword">long</span> waitTime = <span class="number">10</span> * <span class="number">1000</span> ;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.HONEYCOMB_MR1 ) &#123;</span><br><span class="line">        waitTime = <span class="number">20</span> * <span class="number">1000</span> ;<span class="comment">//实测发现某些场景下有些2.3版本有可能10s都不能完成optdex</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (needWait(base)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> nowWait = System.currentTimeMillis() - startWait;</span><br><span class="line">            LogUtils.d(<span class="string">"loadDex"</span> , <span class="string">"wait ms :"</span> + nowWait);</span><br><span class="line">            <span class="keyword">if</span> (nowWait &gt;= waitTime) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">200</span> );</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当启动<code>:mini</code>进程后，主进程就会切换为后台进程所以不存在ANR的问题。我们可以一直轮询<code>needWait</code>，直到<code>Multidex</code>加载完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">waitForDexopt</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="keyword">while</span> (needWait(base)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//long nowWait = System.currentTimeMillis() - startWait;</span></span><br><span class="line">            <span class="comment">//LogUtils.d("loadDex" , "wait ms :" + nowWait);</span></span><br><span class="line">            <span class="comment">//if (nowWait &gt;= waitTime) &#123;</span></span><br><span class="line">            <span class="comment">//    return;</span></span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line">            Thread.sleep(<span class="number">200</span> );</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/1218/3789.html" target="_blank" rel="noopener">泡在网上的日子:其实你不知道MultiDex到底有多坑</a><br><a href="https://blog.csdn.net/jiangwei0910410003/article/details/50799573" target="_blank" rel="noopener">尼古拉斯_赵四:Android关于Dex拆分(MultiDex)技术详解</a></p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>multidex</tag>
      </tags>
  </entry>
  <entry>
    <title>Multidex记录一：介绍和使用</title>
    <url>/2018/10/16/multidex1/</url>
    <content><![CDATA[<p><a href="http://dandanlove.com/2018/10/16/multidex1/" target="_blank" rel="noopener">Multidex记录一：介绍和使用</a><br><a href="http://dandanlove.com/2018/10/17/multidex2" target="_blank" rel="noopener">Multidex记录二：缺陷&amp;解决</a><br><a href="http://dandanlove.com/2018/10/18/multidex3" target="_blank" rel="noopener">Multidex记录三：源码解析</a></p>
<h1 id="记录Multidex介绍和使用"><a href="#记录Multidex介绍和使用" class="headerlink" title="记录Multidex介绍和使用"></a>记录Multidex介绍和使用</h1><p>为什么要用记录呢，因为我从开始接触Android时我们的项目就在65535的边缘。不久Google就出了multidex的解决方案。我们也已经接入multidex好多年，但我自己还没有接入，所以本博文只是作者自己对multidex接入整理记录其中大部分来源于<a href="https://developer.android.com/studio/build/multidex?hl=zh-cn" target="_blank" rel="noopener">Google官网</a>。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMzE5ODc5LTNhYjhmMTk3ZGY2ZTgxZTQucG5n?x-oss-process=image/format,png#pic_center" alt="image.png"></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>随着 Android 平台的持续成长，Android 应用的大小也在增加。当您的应用及其引用的库达到特定大小时，您会遇到构建错误，指明您的应用已达到 Android 应用构建架构的极限。早期版本的构建系统按如下方式报告这一错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Conversion to Dalvik format failed:Unable to execute dex: method ID not in [0, 0xffff]: 65536</span><br></pre></td></tr></table></figure>
<blockquote>
<p>超过最大方法数限制的问题，是由于DEX文件格式限制，一个DEX文件中method个数采用使用原生类型short来索引文件中的方法，也就是2个字节共计最多表达65536个method，field/class的个数也均有此限制。对于DEX文件，则是将工程所需全部class文件合并且压缩到一个DEX文件期间，也就是Android打包的DEX过程中， 单个DEX文件可被引用的方法总数（自己开发的代码以及所引用的Android框架、类库的代码）被限制为65536。</p>
</blockquote>
<p>Google官方：<a href="https://developer.android.com/studio/build/multidex?hl=zh-cn" target="_blank" rel="noopener">配置方法数超过 64K 的应用</a></p>
<h3 id="Android-5-0-之前版本的-Dalvik-可执行文件分包支持"><a href="#Android-5-0-之前版本的-Dalvik-可执行文件分包支持" class="headerlink" title="Android 5.0 之前版本的 Dalvik 可执行文件分包支持"></a>Android 5.0 之前版本的 Dalvik 可执行文件分包支持</h3><blockquote>
<p>Android 5.0（API 级别 21）之前的平台版本使用 Dalvik 运行时来执行应用代码。默认情况下，Dalvik 限制应用的每个 APK 只能使用单个 classes.dex 字节码文件。要想绕过这一限制，您可以使用<code>multidex</code>，然后管理对其他 DEX 文件及其所包含代码的访问。</p>
</blockquote>
<h3 id="Android-5-0-及更高版本的-Dalvik-可执行文件分包支持"><a href="#Android-5-0-及更高版本的-Dalvik-可执行文件分包支持" class="headerlink" title="Android 5.0 及更高版本的 Dalvik 可执行文件分包支持"></a>Android 5.0 及更高版本的 Dalvik 可执行文件分包支持</h3><blockquote>
<p>Android 5.0（API 级别 21）及更高版本使用名为 ART 的运行时，后者原生支持从 APK 文件加载多个 DEX 文件。ART 在应用安装时执行预编译，扫描 <code>classesN.dex</code> 文件，并将它们编译成单个 <code>.oat</code> 文件，供 Android 设备执行。因此，如果您的 <code>minSdkVersion</code>为 21 或更高值，则不需要 Dalvik 可执行文件分包支持库。</p>
</blockquote>
<p>现在的Android设备市场还有大部分的<code>Android5.0</code>一下的手机，所以我们要使用<code>multidex</code>来解决应用在这些设备上的<code>65535</code>。</p>
<h2 id="配置您的应用进行-Dalvik-可执行文件分包"><a href="#配置您的应用进行-Dalvik-可执行文件分包" class="headerlink" title="配置您的应用进行 Dalvik 可执行文件分包"></a>配置您的应用进行 Dalvik 可执行文件分包</h2><p>将您的应用项目设置为使用 Dalvik 可执行文件分包配置需要对您的应用项目进行以下修改，具体取决于应用支持的最低 Android 版本。</p>
<h3 id="修改gradle配置文件"><a href="#修改gradle配置文件" class="headerlink" title="修改gradle配置文件"></a>修改gradle配置文件</h3><p>如果您的<code>minSdkVersion</code> 设置为 21 或更高值，您只需在模块级 <code>build.gradle</code> 文件中将<code>multiDexEnabled</code> 设置为 true，如此处所示：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ...</span><br><span class="line">        minSdkVersion <span class="number">21</span> </span><br><span class="line">        targetSdkVersion <span class="number">26</span></span><br><span class="line">        multiDexEnabled <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，如果您的 minSdkVersion 设置为 20 或更低值，则Gradle 构建脚本依赖关系标识符如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile &apos;com.android.support:multidex:1.0.2&apos;</span><br></pre></td></tr></table></figure>
<h3 id="修改Application"><a href="#修改Application" class="headerlink" title="修改Application"></a>修改Application</h3><ul>
<li><p>如果您没有替换 <code>Application</code> 类，请编辑清单文件，按如下方式设置 <code>&lt;application&gt;</code> 标记中的 <code>android:name</code>:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">"com.example.myapp"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">"android.support.multidex.MultiDexApplication"</span> &gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果您替换了 <code>Application</code> 类，请按如下方式对其进行更改以扩展 <code>MultiDexApplication</code>（如果可能）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">MultiDexApplication</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>或者，如果您替换了 <code>Application</code> 类，但无法更改基本类，则可以改为替换 <code>attachBaseContext()</code>方法并调用 <code>MultiDex.install(this)</code>来启用 Dalvik 可执行文件分包：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">SomeOtherApplication</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">super</span>.attachBaseContext(base);</span><br><span class="line">     MultiDex.install(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>构建应用后，Android 构建工具会根据需要构建主 DEX 文件 (<code>classes.dex</code>) 和辅助 DEX 文件（<code>classes2.dex</code> 和 <code>classes3.dex</code> 等）。然后，构建系统会将所有 DEX 文件打包到您的 APK 中。</p>
<p>运行时，Dalvik 可执行文件分包 API 使用特殊的类加载器来搜索适用于您的方法的所有 DEX 文件（而不是仅在主 classes.dex 文件中搜索）。</p>
<h2 id="Dalvik-可执行文件分包支持库的局限性"><a href="#Dalvik-可执行文件分包支持库的局限性" class="headerlink" title="Dalvik 可执行文件分包支持库的局限性"></a>Dalvik 可执行文件分包支持库的局限性</h2><ul>
<li>在冷启动时因为需要安装DEX文件，如果DEX文件过大时，处理时间过长，很容易引发ANR（Application Not Responding）；</li>
<li>采用MultiDex方案的应用可能不能在低于Android 4.0 (API level 14) 机器上启动，这个主要是因为Dalvik linearAlloc的一个bug ;</li>
<li>采用MultiDex方案的应用因为需要申请一个很大的内存，在运行时可能导致程序的崩溃，这个主要是因为Dalvik linearAlloc 的一个限制，这个限制在 Android 4.0 (API level 14)已经增加了, 应用也有可能在低于 Android 5.0 (API level 21)版本的机器上触发这个限制。</li>
</ul>
<h2 id="java-lang-NoClassDefFoundError"><a href="#java-lang-NoClassDefFoundError" class="headerlink" title="java.lang.NoClassDefFoundError"></a>java.lang.NoClassDefFoundError</h2><p>为 Dalvik 可执行文件分包构建每个 DEX 文件时，构建工具会执行复杂的决策制定来确定主要 DEX 文件中需要的类，以便应用能够成功启动。如果启动期间需要的任何类未在主 DEX 文件中提供，那么您的应用将崩溃并出现错误 <code>java.lang.NoClassDefFoundError</code>。</p>
<p>该情况不应出现在直接从应用代码访问的代码上，因为构建工具能识别这些代码路径，但可能在代码路径可见性较低（如使用的库具有复杂的依赖项）时出现。例如，如果代码使用自检机制或从原生代码调用 Java 方法，那么这些类可能不会被识别为主 DEX 文件中的必需项。</p>
<p>因此，如果您收到 <code>java.lang.NoClassDefFoundError</code>，则必须使用构建类型中的 <code>multiDexKeepFile</code> 或 <code>multiDexKeepProguard</code> 属性声明它们，以手动将这些其他类指定为主 DEX 文件中的必需项。如果类在 <code>multiDexKeepFile</code> 或 <code>multiDexKeepProguard</code> 文件中匹配，则该类会添加至主 DEX 文件。</p>
<h3 id="multiDexKeepFile-属性"><a href="#multiDexKeepFile-属性" class="headerlink" title="multiDexKeepFile 属性"></a>multiDexKeepFile 属性</h3><p>您在 <code>multiDexKeepFile</code> 中指定的文件应该每行包含一个类，并且采用 <code>com/example/MyClass.class</code> 的格式。例如，您可以创建一个名为 <code>multidex-config.txt</code> 的文件，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com/example/MyClass.class</span><br><span class="line">com/example/MyOtherClass.class</span><br></pre></td></tr></table></figure>
<p>然后，您可以按以下方式针对构建类型声明该文件：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            multiDexKeepFile file <span class="string">'multidex-config.txt'</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请记住，Gradle 会读取相对于 build.gradle 文件的路径，因此如果 multidex-config.txt 与 build.gradle 文件在同一目录中，以上示例将有效。</p>
<h3 id="multiDexKeepProguard-属性"><a href="#multiDexKeepProguard-属性" class="headerlink" title="multiDexKeepProguard 属性"></a>multiDexKeepProguard 属性</h3><p><code>multiDexKeepProguard</code> 文件使用与 <code>Proguard</code> 相同的格式，并且支持整个 Proguard 语法。如需了解有关 `Proguard 格式和语法的详细信息，请参阅 Proguard 手册中的 <a href="http://proguard.sourceforge.net/manual/usage.html#keepoptions" target="_blank" rel="noopener">Keep Options</a> 一节。</p>
<p>您在 <code>multiDexKeepProguard</code> 中指定的文件应该在任何有效的 ProGuard 语法中包含 <code>-keep</code> 选项。例如，<code>-keep com.example.MyClass.class</code>。您可以创建一个名为 <code>multidex-config.pro</code> 的文件，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-keep class com.example.MyClass</span><br><span class="line">-keep class com.example.MyClassToo</span><br></pre></td></tr></table></figure>
<p>如果您想要指定包中的所有类，文件将如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-keep class com.example.** &#123; *; &#125; // All classes in the com.example package</span><br></pre></td></tr></table></figure>
<p>然后，您可以按以下方式针对构建类型声明该文件：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            multiDexKeepProguard <span class="string">'multidex-config.pro'</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>multidex</tag>
      </tags>
  </entry>
  <entry>
    <title>Android6.0动态权限适配&XMPermissions</title>
    <url>/2018/09/29/permissions/</url>
    <content><![CDATA[<h1 id="个人博客地址-http-dandanlove-com"><a href="#个人博客地址-http-dandanlove-com" class="headerlink" title="个人博客地址 http://dandanlove.com/"></a><a href="http://dandanlove.com/" target="_blank" rel="noopener">个人博客地址 http://dandanlove.com/</a></h1><h1 id="Android6-0动态权限适配-amp-XMPermissions"><a href="#Android6-0动态权限适配-amp-XMPermissions" class="headerlink" title="Android6.0动态权限适配&amp;XMPermissions"></a>Android6.0动态权限适配&amp;XMPermissions</h1><center><img src="https://upload-images.jianshu.io/upload_images/1319879-ef9fa001f5927064.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/420" alt="permission.jpg"></center>


<h1 id="Android6-0动态权限"><a href="#Android6-0动态权限" class="headerlink" title="Android6.0动态权限"></a>Android6.0动态权限</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>从 Android 6.0（API 级别 23）开始，用户开始在应用运行时向其授予权限，而不是在应用安装时授予。此方法可以简化应用安装过程，因为用户在安装或更新应用时不需要授予权限。它还让用户可以对应用的功能进行更多控制；例如，用户可以选择为相机应用提供相机访问权限，而不提供设备位置的访问权限。用户可以随时进入应用的“Settings”屏幕调用权限。摘自<a href="https://developer.android.com/training/permissions/requesting?hl=zh-cn" target="_blank" rel="noopener">Android官网:在运行时请求权限</a>。</p>
<h2 id="targetSdkVerion"><a href="#targetSdkVerion" class="headerlink" title="targetSdkVerion"></a>targetSdkVerion</h2><p>我们在开发的时候需要指定<code>minSdkVersion</code> 和  <code>targetSdkVerion</code>。</p>
<blockquote>
<ul>
<li><code>minSdkVersion</code>为app最低适配的版本，低于该版本的手机无法安装；</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><code>targetSdkVerion</code>简单来说就代表着你的App能够适配的系统版本，意味着你的App在这个版本的手机上做了充分的 前向 兼容性处理和实际测试。其实我们写代码时都是经常干这么一件事，就是 if(Build.VERSION.SDK_INT &gt;= 23) { … } ，这就是兼容性处理最典型的一个例子。如果你的target设置得越高，其实调用系统提供的API时，所得到的处理也是不一样的，甚至有些新的API是只有新的系统才有的;</li>
</ul>
</blockquote>
<h2 id="Android6-0特殊权限Special-Permissions"><a href="#Android6-0特殊权限Special-Permissions" class="headerlink" title="Android6.0特殊权限Special Permissions"></a>Android6.0特殊权限<a href="https://developer.android.com/guide/topics/permissions/overview" target="_blank" rel="noopener">Special Permissions</a></h2><p>看权限名就知道特殊权限比危险权限更危险，特殊权限需要在manifest中申请并且通过发送Intent让用户在设置界面进行勾。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SYSTEM_ALERT_WINDOW</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REQUEST_CODE = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">requestAlertWindowPermission</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION);</span><br><span class="line">    intent.setData(Uri.parse(<span class="string">"package:"</span>+ getPackageName()));</span><br><span class="line">    startActivityForResult(intent, REQUEST_CODE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(intrequestCode, intresultCode, Intent data)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">    <span class="keyword">if</span>(requestCode == REQUEST_CODE) &#123;</span><br><span class="line">        <span class="keyword">if</span>(Settings.canDrawOverlays(<span class="keyword">this</span>)) &#123;</span><br><span class="line">            Log.i(LOGTAG, <span class="string">"onActivityResult granted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//WRITE_SETTINGS 修改系统设置</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REQUEST_CODE_WRITE_SETTINGS = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">requestWriteSettings</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(Settings.ACTION_MANAGE_WRITE_SETTINGS);</span><br><span class="line">    intent.setData(Uri.parse(<span class="string">"package:"</span>+ getPackageName()));</span><br><span class="line">    startActivityForResult(intent, REQUEST_CODE_WRITE_SETTINGS );</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(intrequestCode, intresultCode, Intent data)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">    <span class="keyword">if</span>(requestCode == REQUEST_CODE_WRITE_SETTINGS) &#123;</span><br><span class="line">        <span class="keyword">if</span>(Settings.System.canWrite(<span class="keyword">this</span>)) &#123;</span><br><span class="line">            Log.i(LOGTAG, <span class="string">"onActivityResult write settings granted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Android6-0普通权限normal-permission"><a href="#Android6-0普通权限normal-permission" class="headerlink" title="Android6.0普通权限normal permission"></a>Android6.0普通权限<a href="https://developer.android.com/guide/topics/permissions/overview" target="_blank" rel="noopener">normal permission</a></h2><p>普通权限不会对用户的隐私和安全产生太大的风险，所以只需要在AndroidManifest.xml中声明即可.</p>
<h2 id="Android6-0危险权限dangerous-permission"><a href="#Android6-0危险权限dangerous-permission" class="headerlink" title="Android6.0危险权限dangerous permission"></a>Android6.0危险权限<a href="https://developer.android.com/guide/topics/permissions/overview" target="_blank" rel="noopener">dangerous permission</a></h2><ul>
<li>Normal Permission：写在xml文件里，那么App安装时就会默认获得这些权限，即使是在Android6.0系统的手机上，用户也无法在安装后动态取消这些normal权限，这和以前的权限系统是一样的，不变。</li>
<li>Dangerous Permission：还是得写在xml文件里，但是App安装时具体如果执行授权分以下几种情况：<ul>
<li>1、targetSDKVersion &lt; 23 &amp; API(手机系统) &lt; 6.0 ：安装时默认获得权限，且用户无法在安装App之后取消权限。</li>
<li>3、targetSDKVersion &lt; 23 &amp; API(手机系统) &gt;= 6.0 ：安装时默认获得权限，但是用户可以在安装App完成后动态取消授权（ 取消时手机会弹出提醒，告诉用户这个是为旧版手机打造的应用，让用户谨慎操作 ）。</li>
<li>2、targetSDKVersion &gt;= 23 &amp; API(手机系统) &lt; 6.0 ：安装时默认获得权限，且用户无法在安装App之后取消权限。</li>
<li>4、targetSDKVersion &gt;= 23 &amp; API(手机系统) &gt;= 6.0 ：安装时不会获得权限，可以在运行时向用户申请权限。用户授权以后仍然可以在设置界面中取消授权，用户主动在设置界面取消后，在app运行过程中可能会出现crash。</li>
</ul>
</li>
</ul>
<h2 id="Dangerous-permissions-and-permission-groups-危险权限和权限组"><a href="#Dangerous-permissions-and-permission-groups-危险权限和权限组" class="headerlink" title="Dangerous permissions and permission groups(危险权限和权限组)"></a>Dangerous permissions and permission groups(危险权限和权限组)</h2><blockquote>
<p>同一组的任何一个权限被授权了，其他权限也自动被授权。例如，一旦WRITE_CONTENTS被授权了，APP也有READ_CONTACTS和GET_ACCOUNTS了。</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">permission-group</th>
<th style="text-align:left">dangerous permissions</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CALENDAR(日历)</td>
<td style="text-align:left">READ_CALENDAR , WRITE_CALENDAR</td>
</tr>
<tr>
<td style="text-align:left">CAMERA(照相机)</td>
<td style="text-align:left">CAMERA</td>
</tr>
<tr>
<td style="text-align:left">CONTACTS(联系人)</td>
<td style="text-align:left">READ_CONTACTS , WRITE_CONTACTS , GET_ACCOUNTS</td>
</tr>
<tr>
<td style="text-align:left">LOCATION(位置)</td>
<td style="text-align:left">ACCESS_FINE_LOCATION (访问精细的位置)， ACCESS_COARSE_LOCATION(访问粗略的位置)</td>
</tr>
<tr>
<td style="text-align:left">MICROPHONE(麦克风)</td>
<td style="text-align:left">RECORD_AUDIO(录音)</td>
</tr>
<tr>
<td style="text-align:left">PHONE(手机)</td>
<td style="text-align:left">READ_PHONE_STATE ， CALL_PHONE ， READ_CALL_LOG ， WRITE_CALL_LOG ， ADD_VOICEMAIL(添加语音信箱) ， USE_SIP(使用SIP协议 ， PROCESS_OUTGOING_CALLS(程序拨出电话)</td>
</tr>
<tr>
<td style="text-align:left">SENSORS(传感器)</td>
<td style="text-align:left">BODY_SENSORS</td>
</tr>
<tr>
<td style="text-align:left">SMS</td>
<td style="text-align:left">SEND_SMS ， RECEIVE_SMS ， READ_SMS ， RECEIVE_WAP_PUSH ， RECEIVE_MMS</td>
</tr>
<tr>
<td style="text-align:left">TORAGE(存储)</td>
<td style="text-align:left">READ_EXTERNAL_STORAGE ，WRITE_EXTERNAL_STORAGE</td>
</tr>
</tbody>
</table>
<h2 id="如何开始动态申请权限"><a href="#如何开始动态申请权限" class="headerlink" title="如何开始动态申请权限"></a>如何开始动态申请权限</h2><h3 id="判断权限是否具有某项权限"><a href="#判断权限是否具有某项权限" class="headerlink" title="判断权限是否具有某项权限"></a>判断权限是否具有某项权限</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ContextCompat.checkSelfPermission(Context context,String permission);</span><br><span class="line">ActivityCompat.checkSelfPermission(Context context, String permission);</span><br><span class="line">activity.checkSelfPermission(String permission);</span><br></pre></td></tr></table></figure>
<h3 id="申请权限"><a href="#申请权限" class="headerlink" title="申请权限"></a>申请权限</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ActivityCompat.requestPermissions(Activity activity,String[] permissions,int requestCode);</span><br><span class="line">activity.requestPermissions(String[] permissions, int requestCode);</span><br><span class="line">//申请权限回调方法,在Activity或Fragment重写</span><br><span class="line">onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults)</span><br></pre></td></tr></table></figure>
<h3 id="是否要提示用户申请该权限的缘由，sdk小于23恒为false"><a href="#是否要提示用户申请该权限的缘由，sdk小于23恒为false" class="headerlink" title="是否要提示用户申请该权限的缘由，sdk小于23恒为false"></a>是否要提示用户申请该权限的缘由，sdk小于23恒为false</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ActivityCompat.shouldShowRequestPermissionRationale(Activity activity, String permission)</span><br><span class="line">0、之前没有拒绝过此权限的申请（第一次安装后请求权限前调用）：false</span><br><span class="line">1、曾经被拒绝过权限后再调用：true</span><br><span class="line">2、曾经被拒绝过权限且不再询问后再调用：false</span><br><span class="line">3、系统不允许任何程序获取该权限：false</span><br><span class="line">4、查看源码得知安卓6.0以下返回：false</span><br><span class="line">5、总是允许权限后再次调用：false</span><br></pre></td></tr></table></figure>
<h2 id="在APP使用过程中，从设置中更改权限"><a href="#在APP使用过程中，从设置中更改权限" class="headerlink" title="在APP使用过程中，从设置中更改权限"></a>在APP使用过程中，从设置中更改权限</h2><p>如果应用程序的某个业务逻辑需要使用权限，但用户没有选择开启。那么最好引导用户去设置界面修改应用程序的权限。</p>
<h1 id="XMPermissions"><a href="#XMPermissions" class="headerlink" title="XMPermissions"></a>XMPermissions</h1><h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p>如果我们应用需要动态申请危险权限，按照Google官方问档我们需要在<code>activity</code>或者<code>fragment</code>中的<code>onRequestPermissionsResult</code>方法进行回调处理。一个执行任务代码需要分开写在两处地方，这我们的代码会变得很不优雅。</p>
<p>有没有链式、流式或者注解的方式去解决这个问题？有而且很多，以下是我在<code>github</code> 上找的<code>start</code> 最多的开源库。</p>
<p><a href="https://github.com/tbruyelle/RxPermissions.git" target="_blank" rel="noopener">RxPermissions</a> RxJava流式用法；<br><a href="https://github.com/getActivity/XXPermissions.git" target="_blank" rel="noopener">XXPermissions</a> 链式用法；<br><a href="https://github.com/jokermonn/permissions4m.git" target="_blank" rel="noopener">permissions4m</a> 注解用法；</p>
<p>个人对注解使用不太感冒，而且项目有用到Rxjava的地方。<br>综上所述，我在<code>RxPermissions</code> 和 <code>XXPermissions</code> 基础上开发了 <a href="https://github.com/stven0king/XMPermission" target="_blank" rel="noopener">XMPermissions</a>。</p>
<h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">'com.tzx.lib:xmpermission:1.0.0'</span></span><br></pre></td></tr></table></figure>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnPermission</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 本次申请的权限全部通过</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hasPermission</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 本次申请的权限没有全部通过</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> granteds</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">noPermission</span><span class="params">(List&lt;PermissionState&gt; granteds)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RxJava"><a href="#RxJava" class="headerlink" title="RxJava"></a>RxJava</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XMPermissions.with(<span class="keyword">this</span>)</span><br><span class="line">    .request(Permission.Group.STORAGE, Permission.Group.PHONE)</span><br><span class="line">    .subscribe(<span class="keyword">new</span> SimpleSubscriber&lt;List&lt;PermissionState&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(List&lt;PermissionState&gt; permissionStates)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (PermissionState s: permissionStates) &#123;</span><br><span class="line">                Log.d(<span class="string">"tanzhenxing:"</span>, s.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XMPermissions.with(<span class="keyword">this</span>)</span><br><span class="line">                <span class="comment">//.constantRequest() //可设置被拒绝后继续申请，直到用户授权或者永久拒绝</span></span><br><span class="line">                .permission(Permission.Group.STORAGE, Permission.Group.CALENDAR) </span><br><span class="line">                .request(<span class="keyword">new</span> OnPermission() &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hasPermission</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"获取权限成功"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noPermission</span><span class="params">(List&lt;PermissionState&gt; granteds)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">for</span> (PermissionState s: granteds) &#123;</span><br><span class="line">                            Log.d(<span class="string">"tzx:"</span>, s.toString());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="跳转到应用权限设置页面"><a href="#跳转到应用权限设置页面" class="headerlink" title="跳转到应用权限设置页面"></a>跳转到应用权限设置页面</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XMPermissions.gotoPermissionSettings(content);</span><br></pre></td></tr></table></figure>
<h1 id="6-0动态权限适配总结"><a href="#6-0动态权限适配总结" class="headerlink" title="6.0动态权限适配总结"></a>6.0动态权限适配总结</h1><p>有了<a href="https://github.com/stven0king/XMPermission" target="_blank" rel="noopener">XMPermissions</a> 适配6.0动态权限就非常简单了。将<code>targetVersion</code>升级到<code>23</code>，然后每个使用<code>储存、定位、电话、相机、录音</code>等危险权限的地方做权限的<code>check</code>。</p>
<p>当然这么做非常麻烦像<code>储存、定位、电话</code>这三个权限我们几乎每次接口访问都需要获取，所以我们可以将一些权限申请在应用启动前置。</p>
<ul>
<li>转转：<code>储存、定位、电话</code>前置</li>
<li>58同城： <code>存储、电话</code>前置</li>
<li>京东： <code>定位、电话</code>前置</li>
<li>手机淘宝： <code>电话</code>前置</li>
<li>手机百度： <code>存储</code>前置</li>
</ul>
<blockquote>
<p>在进行短信发送和打电话时，不需要权限也可以哦~！我自己测试了4个主流厂商的8款手机。</p>
</blockquote>
<p>随着<code>Android</code>系统的不断更新，后续后问题会继续同步哒~！</p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Permission</tag>
      </tags>
  </entry>
  <entry>
    <title>Android平台JSON预览(JSON-handle)</title>
    <url>/2018/09/10/jsonhandleview/</url>
    <content><![CDATA[<h1 id="个人博客地址-http-dandanlove-com"><a href="#个人博客地址-http-dandanlove-com" class="headerlink" title="个人博客地址 http://dandanlove.com/"></a><a href="http://dandanlove.com/" target="_blank" rel="noopener">个人博客地址 http://dandanlove.com/</a></h1><h1 id="JSON-handle"><a href="#JSON-handle" class="headerlink" title="JSON-handle"></a>JSON-handle</h1><p>Chrome常用的插件<a href="https://chrome.google.com/webstore/detail/json-handle/iahnhfdhidomcpggpaimmmahffihkfnj" target="_blank" rel="noopener">JSON-handle</a>，用过的都知道。<br>最近在做接口加密，所有的数据（<code>request</code>和<code>response</code>）都是加密数据，无法沟通<code>fildder</code>或者<code>Charles</code>抓包查看。那么自己做一个查看<code>json`</code>格式的View`:支持动态的放大，缩小，支持所有数据格式~！</p>
<center><img src="https://upload-images.jianshu.io/upload_images/1319879-74b659c715cf5b13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/620" alt="json-handle.png"></center>

<p>效果图：</p>
<center><img src="https://upload-images.jianshu.io/upload_images/1319879-4abc3f14d2b77efe.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="json-handle.jpg"></center>

<p>GitHub地址： <a href="https://github.com/stven0king/JsonHandleView" target="_blank" rel="noopener">JsonHandleView</a></p>
<h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">implementation &apos;com.tzx.json:jsonhandleview:1.0.0&apos;</span><br></pre></td></tr></table></figure>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">FrameLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fillViewport</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.dandan.jsonhandleview.library.JsonViewLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/jsonView"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JsonViewLayout jsonViewLayout = findViewById(R.id.jsonView);</span><br><span class="line">jsonViewLayout.bindJson(<span class="string">"your json strings."</span> || JSONObject || JSONArray);</span><br></pre></td></tr></table></figure>
<h2 id="自定义风格"><a href="#自定义风格" class="headerlink" title="自定义风格"></a>自定义风格</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Color</span></span><br><span class="line">jsonViewLayout.setKeyColor()</span><br><span class="line">jsonViewLayout.setObjectKeyColor()</span><br><span class="line">jsonViewLayout.setValueTextColor()</span><br><span class="line">jsonViewLayout.setValueNumberColor()</span><br><span class="line">jsonViewLayout.setValueNullColor()</span><br><span class="line">jsonViewLayout.setValueBooleanColor()</span><br><span class="line">jsonViewLayout.setArrayLengthColor()</span><br><span class="line"></span><br><span class="line"><span class="comment">// TextSize</span></span><br><span class="line">jsonViewLayout.setTextSize()</span><br></pre></td></tr></table></figure>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title>InstantRun从2.0到3.0，历史解毒</title>
    <url>/2018/05/18/instant-run/</url>
    <content><![CDATA[<h1 id="个人博客地址-http-dandanlove-com"><a href="#个人博客地址-http-dandanlove-com" class="headerlink" title="个人博客地址 http://dandanlove.com/"></a><a href="http://dandanlove.com/" target="_blank" rel="noopener">个人博客地址 http://dandanlove.com/</a></h1><h1 id="InstantRun从2-0到3-0，历史解毒"><a href="#InstantRun从2-0到3-0，历史解毒" class="headerlink" title="InstantRun从2.0到3.0，历史解毒"></a>InstantRun从2.0到3.0，历史解毒</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><center><img src="https://upload-images.jianshu.io/upload_images/1319879-7358a6106f729d55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/620" alt=""></center>


<p><code>Instant Run</code>已经出来3年了，为什么现在会想写这篇文章。从<code>Instant Run</code> 发布就已经有文章做了详细的介绍，但主要分为两类：一类是讲其主要实现原理或是讲 <code>Instant Run2.0</code>中的 <code>Application</code> 和 <code>ClassLoader</code> 的替换，另一类就是两者结合。但是在<code>Instant Run2.0</code> 以后包括（<code>2.3和3.0</code>）虽然主要的实现原理没做改变，但都不再有  <code>Application</code> 和 <code>ClassLoader</code> 的替换了。</p>
<p>而恰恰我是从 <code>Instant Run3.0</code> 开始分析的，所以在读完网上相关文章后感觉和自己实践结果偏差，使我产生一系列的为什么。本文章就是认真寻找其原理之后的产物。</p>
<blockquote>
<p> 文章会将相同的代码分别在 gradle：<code>2.0</code>  ~ <code>2.3</code>  ~ <code>3.0</code> 上的运行结果做对比，以及从源码的角度分析其结果的形成的原理。</p>
</blockquote>
<h2 id="关于-Instant-Run"><a href="#关于-Instant-Run" class="headerlink" title="关于 Instant Run"></a>关于 Instant Run</h2><blockquote>
<p>Android Studio 2.0 中引入的 Instant Run 是 <strong>Run</strong> 和 <strong>Debug</strong> 命令的行为，可以大幅缩短应用更新的时间。尽管首次构建可能需要花费较长的时间，Instant Run 在向应用推送后续更新时则无需构建新的 APK，因此，这样可以更快地看到更改。原文<a href="https://developer.android.com/studio/run/#instant-run" target="_blank" rel="noopener">关于 Instant Run</a> 。</p>
</blockquote>
<h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><blockquote>
<p>普通构建整个<em>apk</em> → 部署<em>app</em> → <em>app</em>重启 → 重启<em>Activity</em><br>InstantRun<em>只构建修改的部分 → 部署修改的</em>dex<em>或资源 → 部署（热部署</em>|<em>温部署</em>|*冷部署）</p>
</blockquote>
<ul>
<li>热部署：更改现有方法的实现代码，无需重启app和Activity</li>
<li>温部署：app无需重启，但是activity需要重启，更改或移除现有资源。</li>
<li>冷部署：app需要重启，结构性的代码更改。</li>
</ul>
<h2 id="相关代码："><a href="#相关代码：" class="headerlink" title="相关代码："></a>相关代码：</h2><p>下边为整个文章中所涉及的源代码：</p>
<h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://github.com/stven0king/InstantRun-ApkParse.git" target="_blank" rel="noopener">源码以及反编译文件链接：https://github.com/stven0king/InstantRun-ApkParse.git</a></p>
<h3 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">file:<span class="number">2.2</span>.3<span class="comment">//apk-debug2.2.3.apk反编译源码</span></span><br><span class="line">file:<span class="number">2.3</span>.0<span class="comment">//apk-debug2.3.0.apk反编译源码</span></span><br><span class="line">file:<span class="number">3.0</span>.0<span class="comment">//apk-debug3.0.0.apk反编译源码</span></span><br><span class="line">file:reload0x0000<span class="comment">//reload0x0000-dex2jar.jar反编译源代码</span></span><br><span class="line">file:slice_4_2.2.3<span class="comment">//apk-debug2.2.3.apk分裂出的slice_4_2.3.0.apk的反编译文件</span></span><br><span class="line">file:slice_6_3.0.0<span class="comment">//apk-debug3.0.0.apk分裂出的split_lib_slice_6_apk的反编译文件</span></span><br></pre></td></tr></table></figure>
<h2 id="Gradle2-2-3版本"><a href="#Gradle2-2-3版本" class="headerlink" title="Gradle2.2.3版本"></a>Gradle2.2.3版本</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul>
<li>os:Windows7</li>
<li>AndroidStudio:2.2.3</li>
<li>gradle:2.2.3</li>
<li>Android:6.0</li>
<li><a href="https://github.com/stven0king/jadx" target="_blank" rel="noopener">反编译工具：jadx</a></li>
</ul>
<h3 id="反编译结果"><a href="#反编译结果" class="headerlink" title="反编译结果"></a>反编译结果</h3><center><img src="https://upload-images.jianshu.io/upload_images/1319879-f804a67fa70c5cdc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/820" alt="bootstrapApplication.png"></center>

<h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><p>解压完apk之后，可以看到比以往多了一个 <code>instant-run.zip</code> 的文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 2.2.3-zip git:(master) ✗ unzip instant-run.zip -d ./instant-run</span><br><span class="line">Archive:  instant-run.zip</span><br><span class="line">  inflating: ./instant-run/com.android.support-support-v4-25.2.0_5d13af6de4318d640c0f4476df51368768e7d685-classes.dex</span><br><span class="line">    inflating: ./instant-run/com.android.support-support-core-ui-25.2.0_ea8d7df920d33201f106dcb84c43d1eacaec7dd0-classes.dex</span><br><span class="line">  inflating: ./instant-run/support-annotations-25.2.0_a33da78f501c6f0028ab51cf7a4a072129b233d3-classes.dex</span><br><span class="line">  inflating: ./instant-run/com.android.support-support-vector-drawable-25.2.0_b68552cc8e884ffe451a9050485a027fab5221b6-classes.dex</span><br><span class="line">  inflating: ./instant-run/com.android.support-support-compat-25.2.0_a30aa766fa9eb8931d774a9877ee62e7922594ea-classes.dex</span><br><span class="line">  inflating: ./instant-run/com.android.support-support-core-utils-25.2.0_597f4e658a91af8509465a83255097ea293c4b0d-classes.dex</span><br><span class="line">  inflating: ./instant-run/com.android.support-animated-vector-drawable-25.2.0_cee6b6e2c44697f52b0c7ae341d1e644be24f407-classes.dex</span><br><span class="line">    inflating: ./instant-run/com.android.support-support-fragment-25.2.0_0b0115a9ee4c324b81c551aa7f986769013e71f8-classes.dex</span><br><span class="line">      inflating: ./instant-run/com.android.support-support-media-compat-25.2.0_d4100160e6cd1e6586fd37853817402c8b1324dd-classes.dex</span><br><span class="line">  inflating: ./instant-run/com.android.support-appcompat-v7-25.2.0_8ee0a5e1aed6951764492197789f674e0e0e9e51-classes.dex</span><br><span class="line">  inflating: ./instant-run/slice_9-classes.dex</span><br><span class="line">  inflating: ./instant-run/slice_8-classes.dex</span><br><span class="line">  inflating: ./instant-run/slice_7-classes.dex</span><br><span class="line">  inflating: ./instant-run/slice_6-classes.dex</span><br><span class="line">  inflating: ./instant-run/slice_5-classes.dex</span><br><span class="line">  inflating: ./instant-run/slice_4-classes.dex</span><br><span class="line">  inflating: ./instant-run/slice_3-classes.dex</span><br><span class="line">  inflating: ./instant-run/slice_2-classes.dex</span><br><span class="line">  inflating: ./instant-run/slice_1-classes.dex</span><br><span class="line">  inflating: ./instant-run/slice_0-classes.dex</span><br></pre></td></tr></table></figure>
<p><code>instant-run.zip</code> 文件解压之后为一些support包和slice的dex文件。</p>
<p>整体的包结构发生了一下变化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.android.</span><br><span class="line">------.---------.tools.fd.</span><br><span class="line">------.---------.-------.--.common.*</span><br><span class="line">------.---------.-------.--.dummy.*</span><br><span class="line">------.---------.-------.--.runtime.*</span><br><span class="line">------.---------.-------.ir.api.Disable.InstantRun</span><br><span class="line">------.tanzx.</span><br><span class="line">------.-------.instantrun</span><br><span class="line">------.-------.-------------.BuildConfig</span><br><span class="line">------.-------.-------------.InstantRunActivity</span><br><span class="line">------.-------.-------------.MyApplication</span><br><span class="line">------.-------.-------------.R</span><br><span class="line">------.-------.-------------.Utils</span><br></pre></td></tr></table></figure>
<p>多出了一个<code>com.android.tools.*</code>的目录结构，里面全部都是关于<code>instant-run</code>相关的代码。</p>
<h4 id="AndroidManifest-xml"><a href="#AndroidManifest-xml" class="headerlink" title="AndroidManifest.xml"></a>AndroidManifest.xml</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span> <span class="attr">android:versionCode</span>=<span class="string">"1"</span> <span class="attr">android:versionName</span>=<span class="string">"1.0"</span> <span class="attr">package</span>=<span class="string">"com.tanzx.instantrun"</span> <span class="attr">platformBuildVersionCode</span>=<span class="string">"25"</span> <span class="attr">platformBuildVersionName</span>=<span class="string">"7.1.1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-sdk</span> <span class="attr">android:minSdkVersion</span>=<span class="string">"15"</span> <span class="attr">android:targetSdkVersion</span>=<span class="string">"25"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span> <span class="attr">android:theme</span>=<span class="string">"@style/AppTheme"</span> </span></span><br><span class="line"><span class="tag">    	<span class="attr">android:label</span>=<span class="string">"@string/app_name"</span> </span></span><br><span class="line"><span class="tag">    	<span class="attr">android:icon</span>=<span class="string">"@mipmap/ic_launcher"</span> </span></span><br><span class="line"><span class="tag">    	<span class="attr">android:name</span>=<span class="string">"com.android.tools.fd.runtime.BootstrapApplication"</span> </span></span><br><span class="line"><span class="tag">    	<span class="attr">android:debuggable</span>=<span class="string">"true"</span> </span></span><br><span class="line"><span class="tag">    	<span class="attr">android:allowBackup</span>=<span class="string">"true"</span> </span></span><br><span class="line"><span class="tag">    	<span class="attr">android:supportsRtl</span>=<span class="string">"true"</span> </span></span><br><span class="line"><span class="tag">    	<span class="attr">name</span>=<span class="string">"com.tanzx.instantrun.MyAppication"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">"com.tanzx.instantrun.InstantRunActivity"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以看到应用程序的自定义 <code>MyApplication</code> 被 <code>BootstrapApplication</code> 替代了。</p>
<h4 id="java类的修改"><a href="#java类的修改" class="headerlink" title="java类的修改"></a>java类的修改</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstantRunActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="comment">//给所有的类增加IncrementalChange类型的$change静态变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">transient</span> <span class="comment">/* synthetic */</span> IncrementalChange $change;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">private</span> TextView textView;</span><br><span class="line">    <span class="comment">//增加类的构造方法，方便于修改类的任何构造方法</span></span><br><span class="line">    InstantRunActivity(Object[] objArr, InstantReloadException instantReloadException) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (((String) objArr[<span class="number">1</span>]).hashCode()) &#123;</span><br><span class="line">            <span class="keyword">case</span> -<span class="number">2089128195</span>:</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1403409127</span>:</span><br><span class="line">                <span class="keyword">this</span>();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InstantReloadException(String.format(<span class="string">"String switch could not find '%s' with hashcode %s in %s"</span>, <span class="keyword">new</span> Object[]&#123;(String) objArr[<span class="number">1</span>], Integer.valueOf(((String) objArr[<span class="number">1</span>]).hashCode()), <span class="string">"com/tanzx/instantrun/InstantRunActivity"</span>&#125;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//增加类的super方法调用，方便于修改类的任何super方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="comment">/* synthetic */</span> Object access$<span class="keyword">super</span>(InstantRunActivity instantRunActivity, String str, Object... objArr) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (str.hashCode()) &#123;</span><br><span class="line">            <span class="keyword">case</span> -<span class="number">2147180915</span>:</span><br><span class="line">                <span class="keyword">super</span>.onSaveInstanceState((Bundle) objArr[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">case</span> -<span class="number">2146661417</span>:</span><br><span class="line">                <span class="keyword">super</span>.showDialog(((Number) objArr[<span class="number">0</span>]).intValue());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">case</span> -<span class="number">2128160755</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.toString();</span><br><span class="line">            <span class="comment">/***各种父类方法的调用，与-2147180915类似***/</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InstantReloadException(String.format(<span class="string">"String switch could not find '%s' with hashcode %s in %s"</span>, <span class="keyword">new</span> Object[]&#123;str, Integer.valueOf(str.hashCode()), <span class="string">"com/tanzx/instantrun/InstantRunActivity"</span>&#125;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        IncrementalChange incrementalChange = $change;</span><br><span class="line">        <span class="comment">//如果$change变量不为null，则执行$change中的对于的方法</span></span><br><span class="line">        <span class="keyword">if</span> (incrementalChange != <span class="keyword">null</span>) &#123;</span><br><span class="line">            incrementalChange.access$dispatch(<span class="string">"onCreate.(Landroid/os/Bundle;)V"</span>, <span class="keyword">this</span>, savedInstanceState);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView((<span class="keyword">int</span>) R.layout.activity_main);</span><br><span class="line">        <span class="keyword">this</span>.textView = (TextView) findViewById(R.id.text);</span><br><span class="line">        <span class="keyword">this</span>.textView.setBackgroundResource(R.drawable.bg);</span><br><span class="line">        <span class="keyword">this</span>.textView.setText(BootstrapApplication.LOG_TAG);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InstantRunActivity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        IncrementalChange incrementalChange = $change;</span><br><span class="line">        <span class="comment">//如果$change变量不为null，则执行$change中的对于的方法</span></span><br><span class="line">        <span class="keyword">if</span> (incrementalChange != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Object[] objArr = (Object[]) incrementalChange.access$dispatch(<span class="string">"init$args.([Lcom/tanzx/instantrun/InstantRunActivity;[Ljava/lang/Object;)Ljava/lang/Object;"</span>, <span class="keyword">null</span>, <span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">            Object[] objArr2 = (Object[]) objArr[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">this</span>(objArr, <span class="keyword">null</span>);</span><br><span class="line">            objArr2[<span class="number">0</span>] = <span class="keyword">this</span>;</span><br><span class="line">            incrementalChange.access$dispatch(<span class="string">"init$body.(Lcom/tanzx/instantrun/InstantRunActivity;[Ljava/lang/Object;)V"</span>, objArr2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IncrementalChange</span> </span>&#123;</span><br><span class="line">    Object access$dispatch(String str, Object... objArr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面我只举例了一个空的 <code>Activity</code> 的修改，<code>Instant-run</code> 实际会对每个类都进行修改，包括匿名内部类。</p>
<ul>
<li>增加一种构造方法，方便于替换（或者修改）任何构造方法。</li>
<li>重写空构造方法，方便于替换该方法的实现。</li>
<li>增加 <code>access$super</code> 方法，方便于替换（或者修改）任何父类的方法。</li>
<li>所有的类（包括匿名内部类）都增加 <code>public static volatile transient IncrementalChange $change;</code> 成员变量。</li>
<li>在类的所有实现的方法都先判断 <code>$change</code> 是否为 <code>null</code> ，否则调用的是修复的类的方法。</li>
</ul>
<p>PS：具体修复的过程看 <strong><u>handleHotSwapPatch</u></strong> 部分。</p>
<h3 id="从Application替换开始"><a href="#从Application替换开始" class="headerlink" title="从Application替换开始"></a>从Application替换开始</h3><p>从 <code>AndroidManifest.xml</code> 中我们看到了<code>MyApplication</code> 被 <code>BootstrapApplication</code> 替代，那么我们可以想象当 <code>Application</code> 为 <code>Instant-run</code> 自己的时，那么它至少可以像加载插件一样在应用启动的时候（程序入口）加载替换自己的dex和资源文件，从而达到修改运行程序的目的。</p>
<p>接下来我们分析一下通过替换 <code>Application</code> 怎么加载自己的dex和资源文件。</p>
<h4 id="BootstrapApplication"><a href="#BootstrapApplication" class="headerlink" title="BootstrapApplication"></a>BootstrapApplication</h4><p><code>BootstrapApplication</code> 重写了两个 <code>Application</code> 方法，分别为 <code>attachBaseContext</code> 和 <code>onCreate</code> 。</p>
<center><img src="https://upload-images.jianshu.io/upload_images/1319879-1ffd45c5b44e4f8c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Context.jpg"></center>

<p><code>Application</code> 的基类为 <code>ContextWrapper</code> ，其真真的 <code>Context</code> 实现类为 <code>ContextImpl</code> 。</p>
<p><code>attachBaseContext</code> 方法就是将 <code>ContextImpl</code> 和 <code>Application</code>  绑定在一起。</p>
<p>关于分裂apk以及安装参考：<a href="https://developer.android.com/studio/build/configure-apk-splits" target="_blank" rel="noopener">Android Studio 配置构建变体</a> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// As of Marshmallow, we use APK splits and don't need to rely on</span></span><br><span class="line">    <span class="comment">// reflection to inject classes and resources for coldswap</span></span><br><span class="line">    <span class="comment">//noinspection PointlessBooleanExpression</span></span><br><span class="line">    <span class="comment">//是否使用了apk分裂安装</span></span><br><span class="line">    <span class="keyword">if</span> (!AppInfo.usingApkSplits) &#123;</span><br><span class="line">        String apkFile = context.getApplicationInfo().sourceDir;</span><br><span class="line">        <span class="keyword">long</span> apkModified = apkFile != <span class="keyword">null</span> ? <span class="keyword">new</span> File(apkFile).lastModified() : <span class="number">0L</span>;</span><br><span class="line">        <span class="comment">//判断资源resource.ap_是否进行了修改，将其路径保存在externalResourcePath</span></span><br><span class="line">        createResources(apkModified);</span><br><span class="line">        <span class="comment">//创建classloade</span></span><br><span class="line">        <span class="comment">//delegateClassLoader-&gt;PathClassLoader-&gt;IncrementalClassLoader-&gt;BootClassLoader</span></span><br><span class="line">        setupClassLoaders(context, context.getCacheDir().getPath(), apkModified);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建正真的Application</span></span><br><span class="line">    createRealApplication();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is called from ActivityThread#handleBindApplication() -&gt; LoadedApk#makeApplication().</span></span><br><span class="line">    <span class="comment">// Application#mApplication is changed right after this call, so we cannot do the monkey</span></span><br><span class="line">    <span class="comment">// patching here. So just forward this method to the real Application instance.</span></span><br><span class="line">    <span class="keyword">super</span>.attachBaseContext(context);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (realApplication != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method attachBaseContext =</span><br><span class="line">                    ContextWrapper.class.getDeclaredMethod(<span class="string">"attachBaseContext"</span>, Context.class);</span><br><span class="line">            attachBaseContext.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">//执行自己的Application的attachBaseContext方法</span></span><br><span class="line">            attachBaseContext.invoke(realApplication, context);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法的主要目的在于，创建自定义的 <code>ClassLoader</code> 和真真的 <code>Application</code>  实例。而 <code>BootstrapApplication</code> 只起到一个壳子的作用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// As of Marshmallow, we use APK splits and don't need to rely on</span></span><br><span class="line">        <span class="comment">// reflection to inject classes and resources for coldswap</span></span><br><span class="line">        <span class="comment">//noinspection PointlessBooleanExpression</span></span><br><span class="line">        <span class="keyword">if</span> (!AppInfo.usingApkSplits) &#123;</span><br><span class="line">            <span class="comment">//将BootstartApplication替换为realApplication</span></span><br><span class="line">            MonkeyPatcher.monkeyPatchApplication(</span><br><span class="line">                    BootstrapApplication.<span class="keyword">this</span>, BootstrapApplication.<span class="keyword">this</span>,</span><br><span class="line">                    realApplication, externalResourcePath);</span><br><span class="line">            MonkeyPatcher.monkeyPatchExistingResources(BootstrapApplication.<span class="keyword">this</span>,</span><br><span class="line">                    externalResourcePath, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// We still need to set the application instance in the LoadedApk etc</span></span><br><span class="line">            <span class="comment">// such that getApplication() returns the new application</span></span><br><span class="line">            MonkeyPatcher.monkeyPatchApplication(</span><br><span class="line">                    BootstrapApplication.<span class="keyword">this</span>, BootstrapApplication.<span class="keyword">this</span>,</span><br><span class="line">                    realApplication, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start server, unless we're in a multiprocess scenario and this isn't the</span></span><br><span class="line">        <span class="comment">// primary process</span></span><br><span class="line">        <span class="keyword">if</span> (AppInfo.applicationId != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">boolean</span> foundPackage = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">int</span> pid = Process.myPid();</span><br><span class="line">                ActivityManager manager = (ActivityManager) getSystemService(</span><br><span class="line">                        Context.ACTIVITY_SERVICE);</span><br><span class="line">                List&lt;RunningAppProcessInfo&gt; processes = manager.getRunningAppProcesses();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">boolean</span> startServer;</span><br><span class="line">                <span class="keyword">if</span> (processes != <span class="keyword">null</span> &amp;&amp; processes.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// Multiple processes: look at each, and if the process name matches</span></span><br><span class="line">                    <span class="comment">// the package name (for the current pid), it's the main process.</span></span><br><span class="line">                    startServer = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">for</span> (RunningAppProcessInfo processInfo : processes) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (AppInfo.applicationId.equals(processInfo.processName)) &#123;</span><br><span class="line">                            foundPackage = <span class="keyword">true</span>;</span><br><span class="line">                            <span class="keyword">if</span> (processInfo.pid == pid) &#123;</span><br><span class="line">                                startServer = <span class="keyword">true</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!startServer &amp;&amp; !foundPackage) &#123;</span><br><span class="line">                        <span class="comment">// Safety check: If for some reason we didn't even find the main package,</span></span><br><span class="line">                        <span class="comment">// start the server anyway. This safeguards against apps doing strange</span></span><br><span class="line">                        <span class="comment">// things with the process name.</span></span><br><span class="line">                        startServer = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (Log.isLoggable(LOG_TAG, Log.VERBOSE)) &#123;</span><br><span class="line">                            Log.v(LOG_TAG, <span class="string">"Multiprocess but didn't find process with package: "</span></span><br><span class="line">                                    + <span class="string">"starting server anyway"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// If there is only one process, start the server.</span></span><br><span class="line">                    startServer = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//开启sokcet监听</span></span><br><span class="line">                <span class="keyword">if</span> (startServer) &#123;</span><br><span class="line">                    Server.create(AppInfo.applicationId, BootstrapApplication.<span class="keyword">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Log.isLoggable(LOG_TAG, Log.VERBOSE)) &#123;</span><br><span class="line">                    Log.v(LOG_TAG, <span class="string">"Failed during multi process check"</span>, t);</span><br><span class="line">                &#125;</span><br><span class="line">                Server.create(AppInfo.applicationId, BootstrapApplication.<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//调用真正的Application的onCreate方法</span></span><br><span class="line">        <span class="keyword">if</span> (realApplication != <span class="keyword">null</span>) &#123;</span><br><span class="line">            realApplication.onCreate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>该方法的主要功能为，将运行时环境中的Application都替换为 <code>realApplication</code> 。然后开启 <code>Socket</code> 监听 <code>AndroidStudio</code>  是否有新的修改push给应用程序。</p>
<h5 id="创建资源文件"><a href="#创建资源文件" class="headerlink" title="创建资源文件"></a>创建资源文件</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createResources</span><span class="params">(<span class="keyword">long</span> apkModified)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Look for changes stashed in the inbox folder while the server was not running</span></span><br><span class="line">    <span class="comment">//校验是否有新的资源文件存储在inbox中</span></span><br><span class="line">    FileManager.checkInbox();</span><br><span class="line"></span><br><span class="line">    File file = FileManager.getExternalResourceFile();</span><br><span class="line">    <span class="comment">//外部导入的资源文件路径</span></span><br><span class="line">    externalResourcePath = file != <span class="keyword">null</span> ? file.getPath() : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(LOG_TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        Log.v(LOG_TAG, <span class="string">"Resource override is "</span> + externalResourcePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取文件的修改时间</span></span><br><span class="line">            <span class="keyword">long</span> resourceModified = file.lastModified();</span><br><span class="line">            <span class="keyword">if</span> (Log.isLoggable(LOG_TAG, Log.VERBOSE)) &#123;</span><br><span class="line">                Log.v(LOG_TAG, <span class="string">"Resource patch last modified: "</span> + resourceModified);</span><br><span class="line">                Log.v(LOG_TAG, <span class="string">"APK last modified: "</span> + apkModified + <span class="string">" "</span> +</span><br><span class="line">                        (apkModified &gt; resourceModified ? <span class="string">"&gt;"</span> : <span class="string">"&lt;"</span>) + <span class="string">" resource patch"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果没有修改，或者修改时间不大于apk的修改时间，那么相当于没有改变资源</span></span><br><span class="line">            <span class="keyword">if</span> (apkModified == <span class="number">0L</span> || resourceModified &lt;= apkModified) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Log.isLoggable(LOG_TAG, Log.VERBOSE)) &#123;</span><br><span class="line">                    Log.v(LOG_TAG, <span class="string">"Ignoring resource file, older than APK"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                externalResourcePath = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            Log.e(LOG_TAG, <span class="string">"Failed to check patch timestamps"</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="创建ClassLoader"><a href="#创建ClassLoader" class="headerlink" title="创建ClassLoader"></a>创建ClassLoader</h5><p>关于JVM的ClassLoader我们都是知道只在双亲委派机制的基础上实现的，那么 <code>instant-run</code> 也正是利用这一特点来创建加载自己指定的 <code>dex</code> 的 <code>ClassLoader</code> 。PS：忘掉的同学可以参数文章： <a href="http://dandanlove.com/2017/02/23/java-classloader/" target="_blank" rel="noopener">自定义ClassLoader和双亲委派机制</a> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setupClassLoaders</span><span class="params">(Context context, String codeCacheDir, <span class="keyword">long</span> apkModified)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//目录"/data/data/" + applicationId + "/files/instant-run/dex"下的文件列表</span></span><br><span class="line">    List&lt;String&gt; dexList = FileManager.getDexList(context, apkModified);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure class loader finds these</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>) Class&lt;Server&gt; server = Server.class;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>) Class&lt;MonkeyPatcher&gt; patcher = MonkeyPatcher.class;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dexList.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Log.isLoggable(LOG_TAG, Log.VERBOSE)) &#123;</span><br><span class="line">            Log.v(LOG_TAG, <span class="string">"Bootstrapping class loader with dex list "</span> + join(<span class="string">'\n'</span>, dexList));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//PathClassLoader</span></span><br><span class="line">        ClassLoader classLoader = BootstrapApplication.class.getClassLoader();</span><br><span class="line">        String nativeLibraryPath;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            nativeLibraryPath = (String) classLoader.getClass().getMethod(<span class="string">"getLdLibraryPath"</span>)</span><br><span class="line">                            .invoke(classLoader);</span><br><span class="line">            <span class="keyword">if</span> (Log.isLoggable(LOG_TAG, Log.VERBOSE)) &#123;</span><br><span class="line">                Log.v(LOG_TAG, <span class="string">"Native library path: "</span> + nativeLibraryPath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            Log.e(LOG_TAG, <span class="string">"Failed to determine native library path "</span> + t.getMessage());</span><br><span class="line">            <span class="comment">//目录"/data/data/" + applicationId + "/lib"</span></span><br><span class="line">            nativeLibraryPath = FileManager.getNativeLibraryFolder().getPath();</span><br><span class="line">        &#125;</span><br><span class="line">        IncrementalClassLoader.inject(</span><br><span class="line">                classLoader,</span><br><span class="line">                nativeLibraryPath,</span><br><span class="line">                codeCacheDir,</span><br><span class="line">                dexList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到主要是获取 <code>classloader</code> 、 <code>nativeLibraryPath</code>  和 <code>dexList</code> 再调用 <code>IncrementalClassLoader.inject</code> 方法。</p>
<p>我们接下来看创建的 <code>IncrementalClassLoader</code> :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IncrementalClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEBUG_CLASS_LOADING = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DelegateClassLoader delegateClassLoader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegateClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">DelegateClassLoader</span><span class="params">(String dexPath, File optimizedDirectory, String libraryPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(dexPath, optimizedDirectory, libraryPath, parent);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.findClass(name);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IncrementalClassLoader</span><span class="params">(ClassLoader original, String nativeLibraryPath, String codeCacheDir, List&lt;String&gt; dexes)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置为original的parent为IncrementalClassLoader的parent</span></span><br><span class="line">        <span class="comment">//即：IncrementalClassLoader为BootClassLoader</span></span><br><span class="line">        <span class="keyword">super</span>(original.getParent());</span><br><span class="line">        <span class="comment">//delegateClassLoader的parent为PathClassLoader</span></span><br><span class="line">        <span class="keyword">this</span>.delegateClassLoader = createDelegateClassLoader(nativeLibraryPath, codeCacheDir, dexes, original);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; findClass(String className) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.delegateClassLoader.findClass(className);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">inject</span><span class="params">(ClassLoader classLoader, String nativeLibraryPath, String codeCacheDir, List&lt;String&gt; dexes)</span> </span>&#123;</span><br><span class="line">        IncrementalClassLoader incrementalClassLoader = <span class="keyword">new</span> IncrementalClassLoader(classLoader, nativeLibraryPath, codeCacheDir, dexes);</span><br><span class="line">        <span class="comment">//设置incrementalClassLoader为PathClassLoader的parent</span></span><br><span class="line">        setParent(classLoader, incrementalClassLoader);</span><br><span class="line">        <span class="keyword">return</span> incrementalClassLoader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>IncrementalClassLoader</code> 继承 <code>ClassLoader</code>  ，但从其 <code>findClass</code>  的实现看出 <code>IncrementalClassLoader</code> 在进行 <code>class</code> 的加载时用的是内部类 <code>DelegateClassLoader</code> 。同时 <code>IncrementalClassLoader</code> 又作为 <code>PathClassLoader</code> 的parent。</p>
<p><code>DelegateClassLoader</code> 继承 <code>BaseDexClassLoader</code> 可以加载自定义路径下的 <code>dex</code> 和 <code>jar</code> 包中的 <code>class</code> 。PS：AndroidDexClassLoader相关文章可以参考：<a href="http://dandanlove.com/2017/02/23/pathclassloader-dexclassloader/" target="_blank" rel="noopener">Android类加载之PathClassLoader和DexClassLoader</a></p>
<center><img src="https://upload-images.jianshu.io/upload_images/1319879-64f06bfca42fdec1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/620" alt="classloader.png"></center>

<p>如上图所示：整个类加载机制建造起来之后 <code>DelegateClassLoader</code> 为加载应用程序的 <code>dex</code> 的类加载器。</p>
<h5 id="创建真正的Application"><a href="#创建真正的Application" class="headerlink" title="创建真正的Application"></a>创建真正的Application</h5><p><code>Instant-run</code> 的 <code>Appinfo.java</code> 文件为对Application的配置信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppInfo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String applicationClass = <span class="string">"com.tanzx.instantrun.MyAppication"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String applicationId = BuildConfig.APPLICATION_ID;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> token = -<span class="number">4151428381996933796L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> usingApkSplits = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看看 <code>BootstrapApplication</code> 中真正的Application的创建：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createRealApplication</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//是否有应用自己的Application</span></span><br><span class="line">    <span class="keyword">if</span> (AppInfo.applicationClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Log.isLoggable(LOG_TAG, Log.VERBOSE)) &#123;</span><br><span class="line">            Log.v(LOG_TAG, <span class="string">"About to create real application of class name = "</span> +</span><br><span class="line">                    AppInfo.applicationClass);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            Class&lt;? extends Application&gt; realClass =</span><br><span class="line">                    (Class&lt;? extends Application&gt;) Class.forName(AppInfo.applicationClass);</span><br><span class="line">            <span class="keyword">if</span> (Log.isLoggable(LOG_TAG, Log.VERBOSE)) &#123;</span><br><span class="line">                Log.v(LOG_TAG, <span class="string">"Created delegate app class successfully : "</span> + realClass +</span><br><span class="line">                        <span class="string">" with class loader "</span> + realClass.getClassLoader());</span><br><span class="line">            &#125;</span><br><span class="line">            Constructor&lt;? extends Application&gt; constructor = realClass.getConstructor();</span><br><span class="line">            <span class="comment">//自定的Application实例</span></span><br><span class="line">            realApplication = constructor.newInstance();</span><br><span class="line">            <span class="keyword">if</span> (Log.isLoggable(LOG_TAG, Log.VERBOSE)) &#123;</span><br><span class="line">                Log.v(LOG_TAG, <span class="string">"Created real app instance successfully :"</span> + realApplication);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//没有自定义，则创建原生的Application</span></span><br><span class="line">        realApplication = <span class="keyword">new</span> Application();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="替换Application"><a href="#替换Application" class="headerlink" title="替换Application"></a>替换Application</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonkeyPatcher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">monkeyPatchApplication</span><span class="params">(Context context, Application bootstrap, Application realApplication, String externalResourceFile)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; activityThread;</span><br><span class="line">        Class&lt;?&gt; loadedApkClass;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取ActivityThread实例</span></span><br><span class="line">            activityThread = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</span><br><span class="line">            Object currentActivityThread = getActivityThread(context, activityThread);</span><br><span class="line">            Field mInitialApplication = activityThread.getDeclaredField(<span class="string">"mInitialApplication"</span>);</span><br><span class="line">            mInitialApplication.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">//替换ActivityThread的mInitialApplication成员变量</span></span><br><span class="line">            Application initialApplication = (Application) mInitialApplication.get(currentActivityThread);</span><br><span class="line">            <span class="keyword">if</span> (realApplication != <span class="keyword">null</span> &amp;&amp; initialApplication == bootstrap) &#123;</span><br><span class="line">                mInitialApplication.set(currentActivityThread, realApplication);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//替换ActivityThread的mAllApplications队列中的BootstrapApplication为realApplication</span></span><br><span class="line">            <span class="keyword">if</span> (realApplication != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Field mAllApplications = activityThread.getDeclaredField(<span class="string">"mAllApplications"</span>);</span><br><span class="line">                mAllApplications.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                List&lt;Application&gt; allApplications = (List) mAllApplications.get(currentActivityThread);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; allApplications.size(); i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (allApplications.get(i) == bootstrap) &#123;</span><br><span class="line">                        allApplications.set(i, realApplication);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            loadedApkClass = Class.forName(<span class="string">"android.app.LoadedApk"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            loadedApkClass = Class.forName(<span class="string">"android.app.ActivityThread$PackageInfo"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e2) &#123;</span><br><span class="line">            IllegalStateException illegalStateException = <span class="keyword">new</span> IllegalStateException(e2);</span><br><span class="line">        &#125;</span><br><span class="line">        Field mApplication = loadedApkClass.getDeclaredField(<span class="string">"mApplication"</span>);</span><br><span class="line">        mApplication.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Field mResDir = loadedApkClass.getDeclaredField(<span class="string">"mResDir"</span>);</span><br><span class="line">        mResDir.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Field mLoadedApk = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mLoadedApk = Application.class.getDeclaredField(<span class="string">"mLoadedApk"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e3) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//final ArrayMap&lt;String, WeakReference&lt;LoadedApk&gt;&gt; mPackages</span></span><br><span class="line">        <span class="comment">//final ArrayMap&lt;String, WeakReference&lt;LoadedApk&gt;&gt; mResourcePackages</span></span><br><span class="line">        <span class="keyword">for</span> (String fieldName : <span class="keyword">new</span> String[]&#123;<span class="string">"mPackages"</span>, <span class="string">"mResourcePackages"</span>&#125;) &#123;</span><br><span class="line">            Field field = activityThread.getDeclaredField(fieldName);</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">for</span> (Entry&lt;String, WeakReference&lt;?&gt;&gt; entry : ((Map) field.get(currentActivityThread)).entrySet()) &#123;</span><br><span class="line">                Object loadedApk = ((WeakReference) entry.getValue()).get();</span><br><span class="line">                <span class="keyword">if</span> (loadedApk != <span class="keyword">null</span> &amp;&amp; mApplication.get(loadedApk) == bootstrap) &#123;</span><br><span class="line">                    <span class="comment">//将ActivityThread的mPackages|mResourcePackages的LoadedApk</span></span><br><span class="line">                    <span class="comment">//LoadedApk的成员变量mApplication的BootstrapApplication替换为realApplication</span></span><br><span class="line">                    <span class="keyword">if</span> (realApplication != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        mApplication.set(loadedApk, realApplication);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//LoadedApk的成员变量mResDir替换为externalResourceFile</span></span><br><span class="line">                    <span class="keyword">if</span> (externalResourceFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        mResDir.set(loadedApk, externalResourceFile);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//将realApplication的mLoadedApk替换为BootstrapApplication的mLoadedApk</span></span><br><span class="line">                    <span class="keyword">if</span> (!(realApplication == <span class="keyword">null</span> || mLoadedApk == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                        mLoadedApk.set(realApplication, loadedApk);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getActivityThread</span><span class="params">(Context context, Class&lt;?&gt; activityThread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (activityThread == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                activityThread = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取ActivityThread的静态变量sCurrentActivityThread</span></span><br><span class="line">        Method m = activityThread.getMethod(<span class="string">"currentActivityThread"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">        m.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object currentActivityThread = m.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (currentActivityThread != <span class="keyword">null</span> || context == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> currentActivityThread;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取BootstrapApplication的mLoadedApk</span></span><br><span class="line">        Field mLoadedApk = context.getClass().getField(<span class="string">"mLoadedApk"</span>);</span><br><span class="line">        mLoadedApk.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object apk = mLoadedApk.get(context);</span><br><span class="line">        Field mActivityThreadField = apk.getClass().getDeclaredField(<span class="string">"mActivityThread"</span>);</span><br><span class="line">        mActivityThreadField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//返回mLoadedApk的成员变量mActivityThread</span></span><br><span class="line">        <span class="keyword">return</span> mActivityThreadField.get(apk);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>获取ActivityThread实例<ul>
<li>先获取ActivityThread的静态变量sCurrentActivityThread；</li>
<li>否则获取Application对象的成员变mLoadedApk的成员对象mActivityThread；</li>
</ul>
</li>
<li>替换ActivityThread的mInitialApplication为realApplication</li>
<li>替换ActivityThread的mAllApplications中的所有的BootstrapApplication为realApplication</li>
<li>替换ActivityThread的mPackages,mResourcePackages中的mLoaderApk中的application为realApplication。</li>
<li>替换realApplication中的mLoadedApk为BootstrapApplication的MLoadedApk</li>
</ul>
<h5 id="替换资源文件"><a href="#替换资源文件" class="headerlink" title="替换资源文件"></a>替换资源文件</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">monkeyPatchExistingResources</span><span class="params">(Context context, String externalResourceFile, Collection&lt;Activity&gt; activities)</span> </span>&#123;</span><br><span class="line">    Field mResourcesImpl;</span><br><span class="line">    Object resourceImpl;</span><br><span class="line">    Field implAssets;</span><br><span class="line">    <span class="keyword">if</span> (externalResourceFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//构造自己的AssetManager</span></span><br><span class="line">        AssetManager newAssetManager = (AssetManager) AssetManager.class.getConstructor(<span class="keyword">new</span> Class[<span class="number">0</span>]).newInstance(<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">        Method mAddAssetPath = AssetManager.class.getDeclaredMethod(<span class="string">"addAssetPath"</span>, <span class="keyword">new</span> Class[]&#123;String.class&#125;);</span><br><span class="line">        mAddAssetPath.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//将当前的资源文件路径添加到AssetManager中</span></span><br><span class="line">        <span class="keyword">if</span> (((Integer) mAddAssetPath.invoke(newAssetManager, <span class="keyword">new</span> Object[]&#123;externalResourceFile&#125;)).intValue() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Could not create new AssetManager"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Resources resources;</span><br><span class="line">        Field mAssets;</span><br><span class="line">        Method mEnsureStringBlocks = AssetManager.class.getDeclaredMethod(<span class="string">"ensureStringBlocks"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">        mEnsureStringBlocks.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//进行资源初始化StringBlock对象</span></span><br><span class="line">        mEnsureStringBlocks.invoke(newAssetManager, <span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (activities != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">/***部分代码省略***/</span></span><br><span class="line">        &#125;</span><br><span class="line">        Field fMActiveResources;</span><br><span class="line">        Collection&lt;WeakReference&lt;Resources&gt;&gt; references;</span><br><span class="line">        <span class="comment">//获取当前JVM中的ResourcesManager的final ArrayMap&lt;ResourcesKey, WeakReference&lt;Resources&gt; &gt; mActiveResources</span></span><br><span class="line">        <span class="keyword">if</span> (VERSION.SDK_INT &gt;= <span class="number">19</span>) &#123;</span><br><span class="line">            Class&lt;?&gt; resourcesManagerClass = Class.forName(<span class="string">"android.app.ResourcesManager"</span>);</span><br><span class="line">            Method mGetInstance = resourcesManagerClass.getDeclaredMethod(<span class="string">"getInstance"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">            mGetInstance.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Object resourcesManager = mGetInstance.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fMActiveResources = resourcesManagerClass.getDeclaredField(<span class="string">"mActiveResources"</span>);</span><br><span class="line">                fMActiveResources.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                references = ((ArrayMap) fMActiveResources.get(resourcesManager)).values();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchFieldException e4) &#123;</span><br><span class="line">                Field mResourceReferences = resourcesManagerClass.getDeclaredField(<span class="string">"mResourceReferences"</span>);</span><br><span class="line">                mResourceReferences.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                references = (Collection) mResourceReferences.get(resourcesManager);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Class&lt;?&gt; activityThread = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</span><br><span class="line">            fMActiveResources = activityThread.getDeclaredField(<span class="string">"mActiveResources"</span>);</span><br><span class="line">            fMActiveResources.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            references = ((HashMap) fMActiveResources.get(getActivityThread(context, activityThread))).values();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环便利当前Resources，将其成员变量mAssets指向自定义的newAssetManager</span></span><br><span class="line">        <span class="keyword">for</span> (WeakReference&lt;Resources&gt; wr : references) &#123;</span><br><span class="line">            resources = (Resources) wr.get();</span><br><span class="line">            <span class="keyword">if</span> (resources != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    mAssets = Resources.class.getDeclaredField(<span class="string">"mAssets"</span>);</span><br><span class="line">                    mAssets.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    mAssets.set(resources, newAssetManager);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">                    mResourcesImpl = Resources.class.getDeclaredField(<span class="string">"mResourcesImpl"</span>);</span><br><span class="line">                    mResourcesImpl.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    resourceImpl = mResourcesImpl.get(resources);</span><br><span class="line">                    implAssets = resourceImpl.getClass().getDeclaredField(<span class="string">"mAssets"</span>);</span><br><span class="line">                    implAssets.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    implAssets.set(resourceImpl, newAssetManager);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//更新资源</span></span><br><span class="line">                resources.updateConfiguration(resources.getConfiguration(), resources.getDisplayMetrics());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Socket监听"><a href="#Socket监听" class="headerlink" title="Socket监听"></a>Socket监听</h4><p>执行完 <code>Application.onCreate</code> ，开启Socket监听。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(String packageName, Application application)</span> </span>&#123;</span><br><span class="line">    Server server = <span class="keyword">new</span> Server(packageName, application);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="run"><a href="#run" class="headerlink" title="run"></a>run</h5><p>我们分析Socket线程的主要的run方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketServerReplyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LocalSocket mSocket;</span><br><span class="line"></span><br><span class="line">    SocketServerReplyThread(LocalSocket socket) &#123;</span><br><span class="line">        <span class="keyword">this</span>.mSocket = socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DataInputStream input;</span><br><span class="line">        DataOutputStream output;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            input = <span class="keyword">new</span> DataInputStream(<span class="keyword">this</span>.mSocket.getInputStream());</span><br><span class="line">            output = <span class="keyword">new</span> DataOutputStream(<span class="keyword">this</span>.mSocket.getOutputStream());</span><br><span class="line">            <span class="comment">//分发消息</span></span><br><span class="line">            handle(input, output);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                input.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                output.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e2) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e3) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Log.isLoggable(BootstrapApplication.LOG_TAG, <span class="number">2</span>)) &#123;</span><br><span class="line">                Log.v(BootstrapApplication.LOG_TAG, <span class="string">"Fatal error receiving messages"</span>, e3);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                input.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e4) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                output.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e5) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/***部分代码省略***/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="handle"><a href="#handle" class="headerlink" title="handle"></a>handle</h5><p>根据不同的version，进行不同类型的消息处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(DataInputStream input, DataOutputStream output)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> magic = input.readLong();</span><br><span class="line">    <span class="keyword">if</span> (magic != ProtocolConstants.PROTOCOL_IDENTIFIER) &#123;</span><br><span class="line">        Log.w(BootstrapApplication.LOG_TAG, <span class="string">"Unrecognized header format "</span> + Long.toHexString(magic));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读取消息类型</span></span><br><span class="line">    <span class="keyword">int</span> version = input.readInt();</span><br><span class="line">    output.writeInt(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (version != <span class="number">4</span>) &#123;</span><br><span class="line">        Log.w(BootstrapApplication.LOG_TAG, <span class="string">"Mismatched protocol versions; app is using version 4 and tool is using version "</span> + version);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> message = input.readInt();</span><br><span class="line">        String path;</span><br><span class="line">        <span class="keyword">switch</span> (message) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> (authenticate(input)) &#123;</span><br><span class="line">                    List&lt;ApplicationPatch&gt; changes = ApplicationPatch.read(input);</span><br><span class="line">                    <span class="keyword">if</span> (changes == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">boolean</span> hasResources = Server.hasResources(changes);</span><br><span class="line">                    <span class="keyword">int</span> updateMode = Server.<span class="keyword">this</span>.handlePatches(changes, hasResources, input.readInt());</span><br><span class="line">                    <span class="keyword">boolean</span> showToast = input.readBoolean();</span><br><span class="line">                    output.writeBoolean(<span class="keyword">true</span>);</span><br><span class="line">                    Server.<span class="keyword">this</span>.restart(updateMode, hasResources, showToast);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">/***部分代码省略***/</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:<span class="comment">//消息结束发送</span></span><br><span class="line">                <span class="keyword">if</span> (Log.isLoggable(BootstrapApplication.LOG_TAG, <span class="number">2</span>)) &#123;</span><br><span class="line">                    Log.v(BootstrapApplication.LOG_TAG, <span class="string">"Received EOF from the IDE"</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">if</span> (Log.isLoggable(BootstrapApplication.LOG_TAG, <span class="number">6</span>)) &#123;</span><br><span class="line">                    Log.e(BootstrapApplication.LOG_TAG, <span class="string">"Unexpected message type: "</span> + message);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否为当前Application发送的信息</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">authenticate</span><span class="params">(DataInputStream input)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> token = input.readLong();</span><br><span class="line">    <span class="keyword">if</span> (token == AppInfo.token) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Log.w(BootstrapApplication.LOG_TAG, <span class="string">"Mismatched identity token from client; received "</span> + token + <span class="string">" and expected "</span> + AppInfo.token);</span><br><span class="line">    Server.access$<span class="number">208</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="处理服务端（AndroidStudio-IDE）消息"><a href="#处理服务端（AndroidStudio-IDE）消息" class="headerlink" title="处理服务端（AndroidStudio-IDE）消息"></a>处理服务端（AndroidStudio-IDE）消息</h3><h4 id="handlePatches"><a href="#handlePatches" class="headerlink" title="handlePatches"></a>handlePatches</h4><p>根据发送过来的文件进行不同的操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">handlePatches</span><span class="params">(List&lt;ApplicationPatch&gt; changes, <span class="keyword">boolean</span> hasResources, <span class="keyword">int</span> updateMode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hasResources) &#123;</span><br><span class="line">        FileManager.startUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (ApplicationPatch change : changes) &#123;</span><br><span class="line">        String path = change.getPath();</span><br><span class="line">        <span class="comment">//文件以“.dex”结尾</span></span><br><span class="line">        <span class="keyword">if</span> (path.endsWith(FileManager.CLASSES_DEX_SUFFIX)) &#123;</span><br><span class="line">            <span class="comment">//冷交换</span></span><br><span class="line">            handleColdSwapPatch(change);</span><br><span class="line">            <span class="keyword">boolean</span> canHotSwap = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (ApplicationPatch c : changes) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c.getPath().equals(Paths.RELOAD_DEX_FILE_NAME)) &#123;</span><br><span class="line">                    canHotSwap = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!canHotSwap) &#123;</span><br><span class="line">                updateMode = <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (path.equals(Paths.RELOAD_DEX_FILE_NAME)) &#123;<span class="comment">//文件名为“classes.dex.3”</span></span><br><span class="line">            <span class="comment">//热交换</span></span><br><span class="line">            updateMode = handleHotSwapPatch(updateMode, change);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isResourcePath(path)) &#123;</span><br><span class="line">            <span class="comment">//资源交换(温部署)</span></span><br><span class="line">            updateMode = handleResourcePatch(updateMode, change, path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hasResources) &#123;</span><br><span class="line">        FileManager.finishUpdate(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> updateMode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isResourcePath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断文件是否为“resources.ap_”，或者文件以“res/"开头</span></span><br><span class="line">    <span class="keyword">return</span> path.equals(Paths.RESOURCE_FILE_NAME) || path.startsWith(<span class="string">"res/"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="handleColdSwapPatch"><a href="#handleColdSwapPatch" class="headerlink" title="handleColdSwapPatch"></a>handleColdSwapPatch</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleColdSwapPatch</span><span class="params">(ApplicationPatch patch)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果文件地址以”slice-“开头</span></span><br><span class="line">    <span class="comment">//那么将其写入到”data/data/applicationid/files/instant-run/dex“目录下</span></span><br><span class="line">    <span class="keyword">if</span> (patch.path.startsWith(Paths.DEX_SLICE_PREFIX)) &#123;</span><br><span class="line">        File file = FileManager.writeDexShard(patch.getBytes(), patch.path);</span><br><span class="line">        <span class="keyword">if</span> (Log.isLoggable(BootstrapApplication.LOG_TAG, <span class="number">2</span>)) &#123;</span><br><span class="line">            Log.v(BootstrapApplication.LOG_TAG, <span class="string">"Received dex shard "</span> + file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CLASSES_DEX_SUFFIX = <span class="string">".dex"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FILE_NAME_ACTIVE = <span class="string">"active"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FOLDER_NAME_LEFT = <span class="string">"left"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FOLDER_NAME_RIGHT = <span class="string">"right"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RELOAD_DEX_PREFIX = <span class="string">"reload"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RESOURCE_FILE_NAME = <span class="string">"resources.ap_"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RESOURCE_FOLDER_NAME = <span class="string">"resources"</span>;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> File <span class="title">writeDexShard</span><span class="params">(<span class="keyword">byte</span>[] bytes, String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建或获取“data/data/applicationid/files/instant-run/dex”文件</span></span><br><span class="line">        File dexFolder = getDexFileFolder(getDataFolder(), <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (dexFolder == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        File file = <span class="keyword">new</span> File(dexFolder, name);</span><br><span class="line">        writeRawBytes(file, bytes);</span><br><span class="line">        <span class="keyword">return</span> file;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> File <span class="title">getDexFileFolder</span><span class="params">(File base, <span class="keyword">boolean</span> createIfNecessary)</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(base, Paths.DEX_DIRECTORY_NAME);</span><br><span class="line">        <span class="keyword">if</span> (!createIfNecessary || file.isDirectory() || file.mkdirs()) &#123;</span><br><span class="line">            <span class="keyword">return</span> file;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.e(BootstrapApplication.LOG_TAG, <span class="string">"Failed to create directory "</span> + file);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> File <span class="title">getDataFolder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//“data/data/applicationid/files/instant-run”</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> File(Paths.getDataDirectory(AppInfo.applicationId));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center><img src="https://upload-images.jianshu.io/upload_images/1319879-1dc9a510ce9df174.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="slice-.png"></center>

<p>当然在替换完dex之后，应用就会在重启后加载新的dex。</p>
<h4 id="handleHotSwapPatch"><a href="#handleHotSwapPatch" class="headerlink" title="handleHotSwapPatch"></a>handleHotSwapPatch</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">handleHotSwapPatch</span><span class="params">(<span class="keyword">int</span> updateMode, ApplicationPatch patch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(BootstrapApplication.LOG_TAG, <span class="number">2</span>)) &#123;</span><br><span class="line">        Log.v(BootstrapApplication.LOG_TAG, <span class="string">"Received incremental code patch"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建data/data/applicationid/files/instant-run/dex-temp/reloadxxxx.dex文件</span></span><br><span class="line">        String dexFile = FileManager.writeTempDexFile(patch.getBytes());</span><br><span class="line">        <span class="keyword">if</span> (dexFile == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Log.e(BootstrapApplication.LOG_TAG, <span class="string">"No file to write the code to"</span>);</span><br><span class="line">            <span class="keyword">return</span> updateMode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Log.isLoggable(BootstrapApplication.LOG_TAG, <span class="number">2</span>)) &#123;</span><br><span class="line">            Log.v(BootstrapApplication.LOG_TAG, <span class="string">"Reading live code from "</span> + dexFile);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//反射构造AppPatchesLoaderImpl实例</span></span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">"com.android.tools.fd.runtime.AppPatchesLoaderImpl"</span>, <span class="keyword">true</span>, <span class="keyword">new</span> DexClassLoader(dexFile, <span class="keyword">this</span>.mApplication.getCacheDir().getPath(), FileManager.getNativeLibraryFolder().getPath(), getClass().getClassLoader()));</span><br><span class="line">        <span class="keyword">if</span> (Log.isLoggable(BootstrapApplication.LOG_TAG, <span class="number">2</span>)) &#123;</span><br><span class="line">            Log.v(BootstrapApplication.LOG_TAG, <span class="string">"Got the patcher class "</span> + aClass);</span><br><span class="line">        &#125;</span><br><span class="line">        PatchesLoader loader = (PatchesLoader) aClass.newInstance();</span><br><span class="line">        <span class="keyword">if</span> (Log.isLoggable(BootstrapApplication.LOG_TAG, <span class="number">2</span>)) &#123;</span><br><span class="line">            Log.v(BootstrapApplication.LOG_TAG, <span class="string">"Got the patcher instance "</span> + loader);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取热修复所要替换的类的classname</span></span><br><span class="line">        String[] getPatchedClasses = (String[]) aClass.getDeclaredMethod(<span class="string">"getPatchedClasses"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]).invoke(loader, <span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (Log.isLoggable(BootstrapApplication.LOG_TAG, <span class="number">2</span>)) &#123;</span><br><span class="line">            Log.v(BootstrapApplication.LOG_TAG, <span class="string">"Got the list of classes "</span>);</span><br><span class="line">            <span class="keyword">for</span> (String getPatchedClass : getPatchedClasses) &#123;</span><br><span class="line">                Log.v(BootstrapApplication.LOG_TAG, <span class="string">"class "</span> + getPatchedClass);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//执行AppPatchesLoaderImpl的load方法进行类修复</span></span><br><span class="line">        <span class="keyword">if</span> (!loader.load()) &#123;</span><br><span class="line">            updateMode = <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> updateMode;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Log.e(BootstrapApplication.LOG_TAG, <span class="string">"Couldn't apply code changes"</span>, e);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        updateMode = <span class="number">3</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e2) &#123;</span><br><span class="line">        Log.e(BootstrapApplication.LOG_TAG, <span class="string">"Couldn't apply code changes"</span>, e2);</span><br><span class="line">        updateMode = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CLASSES_DEX_SUFFIX = <span class="string">".dex"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FILE_NAME_ACTIVE = <span class="string">"active"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FOLDER_NAME_LEFT = <span class="string">"left"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FOLDER_NAME_RIGHT = <span class="string">"right"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RELOAD_DEX_PREFIX = <span class="string">"reload"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RESOURCE_FILE_NAME = <span class="string">"resources.ap_"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RESOURCE_FOLDER_NAME = <span class="string">"resources"</span>;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">writeTempDexFile</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        File file = getTempDexFile();</span><br><span class="line">        <span class="keyword">if</span> (file != <span class="keyword">null</span>) &#123;</span><br><span class="line">            writeRawBytes(file, bytes);</span><br><span class="line">            <span class="keyword">return</span> file.getPath();</span><br><span class="line">        &#125;</span><br><span class="line">        Log.e(BootstrapApplication.LOG_TAG, <span class="string">"No file to write temp dex content to"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> File <span class="title">getTempDexFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//“data/data/applicationid/files/instant-run”</span></span><br><span class="line">        File dataFolder = getDataFolder();</span><br><span class="line">        <span class="comment">//“data/data/applicationid/files/instant-run/dex-temp”</span></span><br><span class="line">        File dexFolder = getTempDexFileFolder(dataFolder);</span><br><span class="line">        <span class="keyword">if</span> (dexFolder.exists()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!sHavePurgedTempDexFolder) &#123;</span><br><span class="line">                <span class="comment">//删除之前的</span></span><br><span class="line">                purgeTempDexFiles(dataFolder);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dexFolder.mkdirs()) &#123;</span><br><span class="line">            sHavePurgedTempDexFolder = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Log.e(BootstrapApplication.LOG_TAG, <span class="string">"Failed to create directory "</span> + dexFolder);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        File[] files = dexFolder.listFiles();</span><br><span class="line">        <span class="keyword">int</span> max = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (files != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">                String name = file.getName();</span><br><span class="line">                <span class="comment">//文件以“reload"开头，以".dex"结尾</span></span><br><span class="line">                <span class="keyword">if</span> (name.startsWith(RELOAD_DEX_PREFIX) &amp;&amp; name.endsWith(CLASSES_DEX_SUFFIX)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//获取中间版本，取最高版本</span></span><br><span class="line">                        <span class="keyword">int</span> version = Integer.decode(name.substring(RELOAD_DEX_PREFIX.length(), name.length() - CLASSES_DEX_SUFFIX.length())).intValue();</span><br><span class="line">                        <span class="keyword">if</span> (version &gt; max) &#123;</span><br><span class="line">                            max = version;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建版本号+1的reloadxxx.dex文件</span></span><br><span class="line">        File file2 = <span class="keyword">new</span> File(dexFolder, String.format(<span class="string">"%s0x%04x%s"</span>, <span class="keyword">new</span> Object[]&#123;RELOAD_DEX_PREFIX, Integer.valueOf(max + <span class="number">1</span>), CLASSES_DEX_SUFFIX&#125;));</span><br><span class="line">        <span class="keyword">if</span> (!Log.isLoggable(BootstrapApplication.LOG_TAG, <span class="number">2</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> file2;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.v(BootstrapApplication.LOG_TAG, <span class="string">"Writing new dex file: "</span> + file2);</span><br><span class="line">        <span class="keyword">return</span> file2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center><img src="https://upload-images.jianshu.io/upload_images/1319879-ae7247613c2cf6d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="reloadxxx.dex.png"></center>

<center><img src="https://upload-images.jianshu.io/upload_images/1319879-7c628a81f9b5df76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="reload0x0000-dex2jar.png"></center>

<p>我们在写入完 <code>reload0x0000.dex</code> 文件后，执行 <code>AppPatchesLoaderImpl</code> 的 <code>load</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractPatchesLoaderImpl</span> <span class="keyword">implements</span> <span class="title">PatchesLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String[] getPatchedClasses();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//调用getPatchedClasses，获取需要修复的classname</span></span><br><span class="line">            <span class="keyword">for</span> (String className : getPatchedClasses()) &#123;</span><br><span class="line">                <span class="comment">//反射机制，构造出用来修复的类，类为classname+$override</span></span><br><span class="line">                ClassLoader cl = getClass().getClassLoader();</span><br><span class="line">                Object o = cl.loadClass(className + <span class="string">"$override"</span>).newInstance();</span><br><span class="line">                <span class="comment">//读取需要修复的类的$change字段</span></span><br><span class="line">                Field changeField = cl.loadClass(className).getDeclaredField(<span class="string">"$change"</span>);</span><br><span class="line">                changeField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                Object previous = changeField.get(<span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Field isObsolete = previous.getClass().getDeclaredField(<span class="string">"$obsolete"</span>);</span><br><span class="line">                    <span class="keyword">if</span> (isObsolete != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        isObsolete.set(<span class="keyword">null</span>, Boolean.valueOf(<span class="keyword">true</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将构造出用来修复的类(classname$override),赋值给需要修复类的$change成员变量</span></span><br><span class="line">                changeField.set(<span class="keyword">null</span>, o);</span><br><span class="line">                <span class="keyword">if</span> (Log.logging != <span class="keyword">null</span> &amp;&amp; Log.logging.isLoggable(Level.FINE)) &#123;</span><br><span class="line">                    Log.logging.log(Level.FINE, String.format(<span class="string">"patched %s"</span>, <span class="keyword">new</span> Object[]&#123;className&#125;));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Log.logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Log.logging.log(Level.SEVERE, String.format(<span class="string">"Exception while patching %s"</span>, <span class="keyword">new</span> Object[]&#123;<span class="string">"foo.bar"</span>&#125;), e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在前面 <strong><u>反编译结果-java类的修改</u></strong> 部分中我们讲到了每个类中都有的 <code>IncrementalChange</code> 类型的 <code>$change</code> 字段。</p>
<p>在第一次运行的时候 <code>$change</code> 的值都是 <code>null</code> 。</p>
<p>先用 <code>InstantRunActivity$1$override</code> 来举个例子， <code>InstantRunActivity$1$override</code>  是 <code>Activity</code> 中的一个 <code>Button</code> 的点击事件处理类，即：<code>View.OnClickListener</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstantRunActivity</span>$1$<span class="title">override</span></span></span><br><span class="line"><span class="class">  <span class="keyword">implements</span> <span class="title">IncrementalChange</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Object init$args(InstantRunActivity.1[] paramArrayOf1, InstantRunActivity paramInstantRunActivity, Object[] paramArrayOfObject)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Object[] &#123; &#123; paramArrayOf1, paramInstantRunActivity, <span class="keyword">new</span> Object[<span class="number">0</span>] &#125;, <span class="string">"java/lang/Object.()V"</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> init$body(InstantRunActivity.1 param1, InstantRunActivity paramInstantRunActivity, Object[] paramArrayOfObject) &#123;&#125;</span><br><span class="line">  <span class="comment">//第一个参数为OnClickListern持有的Activity的成员变量</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(InstantRunActivity<span class="number">.1</span> param1, View paramView)</span></span>&#123;</span><br><span class="line">    Log.d(<span class="string">"xxxxxx"</span>, <span class="string">""</span> + InstantRunActivity.access$<span class="number">008</span>((InstantRunActivity)AndroidInstantRuntime.getPrivateField(param1, InstantRunActivity.1.class, <span class="string">"this$0"</span>)) * <span class="number">2</span>);</span><br><span class="line">    InstantRunActivity.access$<span class="number">100</span>((InstantRunActivity)AndroidInstantRuntime.getPrivateField(param1, InstantRunActivity.1.class, <span class="string">"this$0"</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//分发事件</span></span><br><span class="line">  <span class="keyword">public</span> Object access$dispatch(String paramString, Object... paramVarArgs)&#123;</span><br><span class="line">    <span class="keyword">switch</span> (paramString.hashCode())&#123;</span><br><span class="line">    <span class="keyword">default</span>: </span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InstantReloadException(String.format(<span class="string">"String switch could not find '%s' with hashcode %s in %s"</span>, <span class="keyword">new</span> Object[] &#123; paramString, Integer.valueOf(paramString.hashCode()), <span class="string">"com/example/tzx/changeskin/InstantRunActivity$1"</span> &#125;));</span><br><span class="line">    <span class="keyword">case</span> -<span class="number">1912803358</span>: <span class="comment">//执行修改后的onClick方法</span></span><br><span class="line">      onClick((InstantRunActivity.1)paramVarArgs[<span class="number">0</span>], (View)paramVarArgs[<span class="number">1</span>]);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">case</span> -<span class="number">451173209</span>: </span><br><span class="line">      init$body((InstantRunActivity.1)paramVarArgs[<span class="number">0</span>], (InstantRunActivity)paramVarArgs[<span class="number">1</span>], (Object[])paramVarArgs[<span class="number">2</span>]);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> init$args((InstantRunActivity.1[])paramVarArgs[<span class="number">0</span>], (InstantRunActivity)paramVarArgs[<span class="number">1</span>], (Object[])paramVarArgs[<span class="number">2</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就这样通过动态的修改 <code>$change</code> 的值，在运行的过程改变函数的调用逻辑，实现内容的修复。 </p>
<h4 id="handleResourcePatch"><a href="#handleResourcePatch" class="headerlink" title="handleResourcePatch"></a>handleResourcePatch</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">handleResourcePatch</span><span class="params">(<span class="keyword">int</span> updateMode, ApplicationPatch patch, String path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(BootstrapApplication.LOG_TAG, <span class="number">2</span>)) &#123;</span><br><span class="line">        Log.v(BootstrapApplication.LOG_TAG, <span class="string">"Received resource changes ("</span> + path + <span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    FileManager.writeAaptResources(path, patch.getBytes());</span><br><span class="line">    <span class="keyword">return</span> Math.max(updateMode, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Restart"><a href="#Restart" class="headerlink" title="Restart"></a>Restart</h3><p>一般通过现象看本质，而通过程序的运行判断修复的类型却不一定是正确的。</p>
<center><img src="https://upload-images.jianshu.io/upload_images/1319879-cad075fe9c2ea6f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="on-code-change.png"></center>

<p>比如在 <code>AndroidStudio</code> 的 <code>Instant Run</code> 选项中勾选了 <code>Restart activity on code changes</code> 的话，无论什么样的类型修复都至少会重启当前的 <code>Activity</code> 。</p>
<p>下边列举我实际测试的结果：</p>
<ul>
<li>修改java方法的代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">I/Toast: Show toast from OpPackageName:com.tanzx.instantrun, PackageName:com.tanzx.instantrun, content:Applied code changes without activity restart</span><br><span class="line">V/RenderScript: <span class="number">0xa0f7d000</span> <span class="function">Launching <span class="title">thread</span><span class="params">(s)</span>, CPUs 4</span></span><br><span class="line"><span class="function">Hot swapped changes, activity not restarted</span></span><br></pre></td></tr></table></figure>
<ul>
<li>资源文件的修改</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hot swapped changes, activity restarted</span><br><span class="line">I/Toast: Show toast from OpPackageName:com.tanzx.instantrun, PackageName:com.tanzx.instantrun, content:Applied changes, restarted activity</span><br></pre></td></tr></table></figure>
<p><code>AndroidStudio</code> 有更友好的提示：</p>
<center><img src="https://upload-images.jianshu.io/upload_images/1319879-e2d7112964aab63d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="add_class_quote.png"></center>

<center><img src="https://upload-images.jianshu.io/upload_images/1319879-fbe2913b0ffa58bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="class_add.png"></center>

<center><img src="https://upload-images.jianshu.io/upload_images/1319879-60255458580e8a68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="code_changes.png"></center>

<center><img src="https://upload-images.jianshu.io/upload_images/1319879-2cbe66d2a1a1e5e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="field_added.png"></center>

<center><img src="https://upload-images.jianshu.io/upload_images/1319879-10e6ae27668f30bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="method_add.png"></center>

<center><img src="https://upload-images.jianshu.io/upload_images/1319879-9e3ff2f78634840b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="R_class_changes.png"></center>

<center><img src="https://upload-images.jianshu.io/upload_images/1319879-1614810692a6591e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="static_init_change.png"></center>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>我们将以上的所有内容梳理一下：</p>
<ul>
<li>修改源代码，每个类增加 <code>$change</code> 字段；</li>
<li>替换 <code>Application</code> ；</li>
<li>创建自己的类加载器，修改正常的类加载器的加载顺序；</li>
<li>开启 <code>Socket</code> 监听 <code>AndroidStudio</code> 推送的消息；</li>
<li>处理消息（热、温、冷）<ul>
<li>热：给类的 <code>$change</code> 字段赋值，改变运行逻辑；</li>
<li>温：替换加载新的资源，重启当前 <code>Activity</code> 生效；</li>
<li>冷：写入新的 <code>dex</code> 文件，重新加载新的 <code>dex</code>;</li>
</ul>
</li>
</ul>
<h2 id="Gradle2-3-0版本"><a href="#Gradle2-3-0版本" class="headerlink" title="Gradle2.3.0版本"></a>Gradle2.3.0版本</h2><h3 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h3><p>我们在 <code>gradle2.2.3</code> 小结中发现其实我们只是需要做到以下几点就可以进行热修复：</p>
<ul>
<li>开启 <code>Socket</code> 监听 <code>AndroidStudio</code> 推送的消息；</li>
<li>处理消息：给类的 <code>$change</code> 字段赋值，改变运行逻辑；</li>
</ul>
<h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><p><code>Gradle2.3.0</code> 在  <code>Gradle2.2.3</code> 的基础之上进行了一定的修改，那么我们接下来只对比两个版本之间的不同点：</p>
<ul>
<li>去掉了 <code>BootstrapApplication</code>  替换，直接启动一个 <code>InstantRunService</code> 用来启动 <code>Socket</code> 与 <code>Android Studio</code> 进行信息传递；</li>
</ul>
<p>AndroidManifest.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span> <span class="attr">android:theme</span>=<span class="string">"@style/AppTheme"</span> </span></span><br><span class="line"><span class="tag">             <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span> </span></span><br><span class="line"><span class="tag">             <span class="attr">android:icon</span>=<span class="string">"@mipmap/ic_launcher"</span> </span></span><br><span class="line"><span class="tag">             <span class="attr">android:name</span>=<span class="string">"com.example.instantrun.MyApplication"</span> </span></span><br><span class="line"><span class="tag">             <span class="attr">android:debuggable</span>=<span class="string">"true"</span> </span></span><br><span class="line"><span class="tag">             <span class="attr">android:allowBackup</span>=<span class="string">"true"</span> </span></span><br><span class="line"><span class="tag">             <span class="attr">android:supportsRtl</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">"com.example.instantrun.MainActivity"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">"com.android.tools.fd.runtime.InstantRunService"</span> 							<span class="attr">android:exported</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>InstantRunService:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstantRunService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Server server;</span><br><span class="line">	<span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.i(Logging.LOG_TAG, <span class="string">"Starting Instant Run Server for "</span> + getPackageName());</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        <span class="keyword">if</span> (AppInfo.applicationId != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> foundPackage = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">boolean</span> startServer;</span><br><span class="line">                <span class="keyword">int</span> pid = Process.myPid();</span><br><span class="line">                List&lt;RunningAppProcessInfo&gt; processes = ((ActivityManager) getSystemService(<span class="string">"activity"</span>)).getRunningAppProcesses();</span><br><span class="line">                <span class="keyword">if</span> (processes == <span class="keyword">null</span> || processes.size() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                    startServer = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    startServer = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">for</span> (RunningAppProcessInfo processInfo : processes) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (AppInfo.applicationId.equals(processInfo.processName)) &#123;</span><br><span class="line">                            foundPackage = <span class="keyword">true</span>;</span><br><span class="line">                            <span class="keyword">if</span> (processInfo.pid == pid) &#123;</span><br><span class="line">                                startServer = <span class="keyword">true</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!(startServer || foundPackage)) &#123;</span><br><span class="line">                        startServer = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (Log.isLoggable(Logging.LOG_TAG, <span class="number">2</span>)) &#123;</span><br><span class="line">                            Log.v(Logging.LOG_TAG, <span class="string">"Multiprocess but didn't find process with package: starting server anyway"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (startServer) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.server = Server.create(<span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Log.isLoggable(Logging.LOG_TAG, <span class="number">2</span>)) &#123;</span><br><span class="line">                    Log.v(Logging.LOG_TAG, <span class="string">"In secondary process: Not starting server"</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Log.isLoggable(Logging.LOG_TAG, <span class="number">2</span>)) &#123;</span><br><span class="line">                    Log.v(Logging.LOG_TAG, <span class="string">"Failed during multi process check"</span>, t);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>.server = Server.create(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.server = Server.create(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.server != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Log.i(Logging.LOG_TAG, <span class="string">"Stopping Instant Run Server for "</span> + getPackageName());</span><br><span class="line">            <span class="keyword">this</span>.server.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>去掉了所谓的冷启动（<code>handleColdSwapPatch</code>），需要冷启动的时候直接进行碎片安装重启不就好了；</p>
<p>PS：分裂apk以及安装参考：<a href="https://developer.android.com/studio/build/configure-apk-splits" target="_blank" rel="noopener">Android Studio 配置构建变体</a> </p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">handlePatches</span><span class="params">(List&lt;ApplicationPatch&gt; changes, <span class="keyword">boolean</span> hasResources, <span class="keyword">int</span> updateMode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hasResources) &#123;</span><br><span class="line">        FileManager.startUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (ApplicationPatch change : changes) &#123;</span><br><span class="line">        String path = change.getPath();</span><br><span class="line">        <span class="keyword">if</span> (path.equals(Paths.RELOAD_DEX_FILE_NAME)) &#123;</span><br><span class="line">            updateMode = handleHotSwapPatch(updateMode, change);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isResourcePath(path)) &#123;</span><br><span class="line">            updateMode = handleResourcePatch(updateMode, change, path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hasResources) &#123;</span><br><span class="line">        FileManager.finishUpdate(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> updateMode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>在 <code>Gradle2.3.0</code> 版本上进行试验的时候，我一直没有找到 <code>InstantRunService</code> 是怎么启动的。结果：每一次都是执行的是 <code>install-multiple</code> ，然后重新启动。</p>
<p>在网上找了些资料发现好多用 <code>Gradle2.3.0</code> 的朋友有相关的报错：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Launching app</span><br><span class="line"><span class="meta">$</span><span class="bash"> adb shell am startservice kang.yi.zhi.tan.tanzhiyikang/com.android.tools.fd.runtime.InstantRunService</span></span><br><span class="line">Error while executing: am startservice kang.yi.zhi.tan.tanzhiyikang/com.android.tools.fd.runtime.InstantRunService</span><br><span class="line">Starting service: Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=kang.yi.zhi.tan.tanzhiyikang/com.android.tools.fd.runtime.InstantRunService &#125;</span><br><span class="line">Error: Not found; no service started.</span><br></pre></td></tr></table></figure>
<p>从这个错误可以看处理，是 <code>AndroidStudio</code> 执行了 <code>adb</code> 命令启动了 <code>InstantRunService</code> 。</p>
<h2 id="Gralde3-0-0版本"><a href="#Gralde3-0-0版本" class="headerlink" title="Gralde3.0.0版本"></a>Gralde3.0.0版本</h2><h3 id="相同点：-1"><a href="#相同点：-1" class="headerlink" title="相同点："></a>相同点：</h3><p>我们在 <code>gradle2.2.3</code> 和 <code>gralde2.3.0</code> 中发现其实我们只是需要做到以下几点就可以进行热修复：</p>
<ul>
<li>开启 <code>Socket</code> 监听 <code>AndroidStudio</code> 推送的消息；</li>
<li>处理消息：给类的 <code>$change</code> 字段赋值，改变运行逻辑；</li>
</ul>
<h3 id="不同点-1"><a href="#不同点-1" class="headerlink" title="不同点"></a>不同点</h3><p><code>Gradle3.0.0</code> 在  <code>Gradle2.3.0</code> 的基础之上进行了一定的修改，那么我们接下来只对比两个版本之间的不同点：</p>
<ul>
<li>去掉了 <code>InstantRunService</code> ，而通过用 <code>ContentProvider</code> 来启动 <code>Socket</code> 与 <code>Android Studio</code> 进行信息传递，因为 <code>ContentProvider</code> 在应用启动的时候就行创建；</li>
</ul>
<p>AndroidManifest.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span> <span class="attr">android:theme</span>=<span class="string">"@style/AppTheme"</span> <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span> <span class="attr">android:icon</span>=<span class="string">"@mipmap/ic_launcher"</span> <span class="attr">android:name</span>=<span class="string">"com.example.tzx.changeskin.MyApplication"</span> <span class="attr">android:debuggable</span>=<span class="string">"true"</span> <span class="attr">android:testOnly</span>=<span class="string">"true"</span> <span class="attr">android:allowBackup</span>=<span class="string">"true"</span> <span class="attr">android:supportsRtl</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">"com.example.tzx.changeskin.InstantRunActivity"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">provider</span> <span class="attr">android:name</span>=<span class="string">"com.android.tools.ir.server.InstantRunContentProvider"</span> <span class="attr">android:multiprocess</span>=<span class="string">"true"</span> <span class="attr">android:authorities</span>=<span class="string">"com.example.tzx.changeskin.com.android.tools.ir.server.InstantRunContentProvider"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>InstantRunContentProvider：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InstantRunContentProvider</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isMainProcess()) &#123;</span><br><span class="line">            Log.i(Logging.LOG_TAG, <span class="string">"starting instant run server: is main process"</span>);</span><br><span class="line">            Server.create(getContext());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Log.i(Logging.LOG_TAG, <span class="string">"not starting instant run server: not main process"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isMainProcess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isMainProcess = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (AppInfo.applicationId == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> foundPackage = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> pid = Process.myPid();</span><br><span class="line">        <span class="keyword">for</span> (RunningAppProcessInfo processInfo : ((ActivityManager) getContext().getSystemService(<span class="string">"activity"</span>)).getRunningAppProcesses()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (AppInfo.applicationId.equals(processInfo.processName)) &#123;</span><br><span class="line">                foundPackage = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (processInfo.pid == pid) &#123;</span><br><span class="line">                    isMainProcess = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isMainProcess || foundPackage) &#123;</span><br><span class="line">            <span class="keyword">return</span> isMainProcess;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.w(Logging.LOG_TAG, <span class="string">"considering this process main process:no process with this package found?!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h3><p>和预期的相同，进行部分代码修改的时候只需要重新启动当前的 <code>Activity</code> ，进行资源替换或类的结构修改的时候需要重新启动 <code>Application</code> ；否则进行新的 <code>install-multiple</code> 安装增量apk。</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ul>
<li><code>InstantRun</code> 相关的所有内容都讲述完了，其核心的就是在于编译时给每个类进行  <code>$change</code> 的插入，修复的时候再给类的 <code>$change</code> 赋值；</li>
<li>不同 <code>Gradle</code> 版本之间主要是触发 <code>Socket</code> 启动的姿势不同；</li>
<li>中间穿插的讲述了 <code>Application</code> 的替换、<code>ClassLoader</code> 的创建和类加载器顺序的修改。</li>
</ul>
<p>除过以上内容外还有 <code>gradle</code> 在编译打包的时候对类文件和<br><code>AndroidManifest.xml</code> 的修改，以及每次使用 <code>instant-run</code> 时差异包的生产、下发和处理都是我们做插件化或者热修复可以借鉴和学习的。</p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>hotfix</tag>
        <tag>instant-run</tag>
        <tag>classloader</tag>
      </tags>
  </entry>
  <entry>
    <title>Android动画绘制原理（源码解析）</title>
    <url>/2018/05/02/Android-animation-source/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Android 平台提供了三类动画，一类是 Tween 动画-Animation，即通过对场景里的对象不断做图像变换 ( 平移、缩放、旋转 ) 产生动画效果；第二类是 Frame 动画，即顺序播放事先做好的图像，跟电影类似。最后一种就是3.0之后才出现的属性动画PropertyAnimator（在下文我们讲帧动画和补间动画统一称为View动画）。如果有人对ViewGroup内部View使用过View动画的还知道有layout-animation。</p>
<p>大家对这三种动画基本都能熟练的使用，那么……?</p>
<ul>
<li>想知道动画与界面渲染与屏幕刷新有着什么样的关系？</li>
<li>想知道属性动画为什么会发生内存泄露么？</li>
</ul>
<p>因为本文章中会有一些屏幕刷新、Vsync信号相关的知识点，读过我写的 <a href="http://dandanlove.com/2018/04/13/android-16ms/" target="_blank" rel="noopener">Android的16ms和垂直同步以及三重缓存</a> 和<a href="http://dandanlove.com/2018/04/25/android-source-choreographer/" target="_blank" rel="noopener">Android系统的编舞者Choreographer</a> 这两篇文章的同学会可能会更容易了解本文章。</p>
<p>接下来拿起我们的键盘、鼠标和显示器，我们将探索从Android源码（android-23）的角度去探索动画的实现~！</p>
<h1 id="动画的介绍"><a href="#动画的介绍" class="headerlink" title="动画的介绍"></a>动画的介绍</h1><h2 id="Drawable-Animation"><a href="#Drawable-Animation" class="headerlink" title="Drawable Animation"></a>Drawable Animation</h2><blockquote>
<p>也就是所谓的帧动画，Frame动画。指通过指定每一帧的图片和播放时间，有序的进行播放而形成动画效果。</p>
</blockquote>
<h2 id="Tween-Animation"><a href="#Tween-Animation" class="headerlink" title="Tween Animation"></a>Tween Animation</h2><blockquote>
<p>视图动画，也就是所谓补间动画，Tween动画。指通过指定View的初始状态、变化时间、方式，通过一系列的算法去进行图形变换，从而形成动画效果，主要有Alpha、Scale、Translate、Rotate四种效果。注意：只是在视图层实现了动画效果，并没有真正改变View的属性。</p>
</blockquote>
<h2 id="Property-Animation"><a href="#Property-Animation" class="headerlink" title="Property Animation"></a>Property Animation</h2><blockquote>
<p>属性动画,通过不断的改变View的属性，不断的重绘而形成动画效果。相比于视图动画，View的属性是真正改变了。注意：Android 3.0(API 11)以上才支持。</p>
</blockquote>
<p>接下来我们按照倒叙来揭开一个一个动画的神秘面纱^_^。</p>
<h1 id="Property-Animation-1"><a href="#Property-Animation-1" class="headerlink" title="Property Animation"></a>Property Animation</h1><h2 id="属性动画的优点"><a href="#属性动画的优点" class="headerlink" title="属性动画的优点"></a>属性动画的优点</h2><ul>
<li>属性动画顾名思义就是改变了View的属性，而不仅仅是绘制的位置。</li>
<li>属性动画可以操作的属性相比于补间动画大大增加，除了常用的平移、旋转、缩放、透明度还有颜色等,基本上能通过View.setXX来设置的属性,属性动画都可以操作,这大大增加了我们在使用动画时的灵活性。</li>
<li>属性动画分为ObjectAnimator和ValueAnimator，其中ObjectAnimator是继承于ValueAnimator。</li>
</ul>
<h2 id="ValueAnimator"><a href="#ValueAnimator" class="headerlink" title="ValueAnimator"></a>ValueAnimator</h2><blockquote>
<p>ValueAnimator并不会改变属性的大小，他只是在一段时间生成某些值。我们需要做的是监听这些值得改变从而该改变View的属性，进而产生动画效果。</p>
</blockquote>
<p>下边的动画就是对mView进行平移：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ValueAnimator animator = ValueAnimator.ofFloat(<span class="number">0</span>, <span class="number">1000</span>);  </span><br><span class="line">anim.addUpdateListener(<span class="keyword">new</span> AnimatorUpdateListener() &#123;  </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;                </span><br><span class="line">    mView.setTranslationX(animation.getAnimatedValue());</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;); </span><br><span class="line">animator.setDuration(<span class="number">1000</span>).start()</span><br></pre></td></tr></table></figure>
<h2 id="ObjectAnimator"><a href="#ObjectAnimator" class="headerlink" title="ObjectAnimator"></a>ObjectAnimator</h2><blockquote>
<p>在ValueAnimator的基础之上，对控件的某个属性执行一次动画。</p>
</blockquote>
<p>相同的对mView进行平移的动画ObjectAnimator是这样实现的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectAnimator animator=ObjectAnimator.ofFloat (mView,<span class="string">"translationX"</span>,<span class="number">0</span>,<span class="number">1000</span>);</span><br><span class="line">animator.setDuration (<span class="number">1000</span>);</span><br><span class="line">animator.start ();</span><br></pre></td></tr></table></figure>
<h2 id="PropertyAnimation流程图"><a href="#PropertyAnimation流程图" class="headerlink" title="PropertyAnimation流程图"></a>PropertyAnimation流程图</h2><center><img src="https://upload-images.jianshu.io/upload_images/1319879-f05a45411913e0cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/410" alt="property-animation.png"></center>



<h2 id="属性动画代码的执行过程"><a href="#属性动画代码的执行过程" class="headerlink" title="属性动画代码的执行过程"></a>属性动画代码的执行过程</h2><h3 id="start"><a href="#start" class="headerlink" title="start"></a>start</h3><h4 id="ObjectAnimator-start"><a href="#ObjectAnimator-start" class="headerlink" title="ObjectAnimator.start"></a>ObjectAnimator.start</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectAnimator</span> <span class="keyword">extends</span> <span class="title">ValueAnimator</span> </span>&#123;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先依次判断了当前动画、等待的动画、延迟的动画中是否有和当前动画相同的动画</span></span><br><span class="line">        <span class="comment">//若有就把相同的动画取消掉</span></span><br><span class="line">        <span class="comment">// See if any of the current active/pending animators need to be canceled</span></span><br><span class="line">        AnimationHandler handler = sAnimationHandler.get();</span><br><span class="line">        <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> numAnims = handler.mAnimations.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = numAnims - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (handler.mAnimations.get(i) <span class="keyword">instanceof</span> ObjectAnimator) &#123;</span><br><span class="line">                    ObjectAnimator anim = (ObjectAnimator) handler.mAnimations.get(i);</span><br><span class="line">                    <span class="keyword">if</span> (anim.mAutoCancel &amp;&amp; hasSameTargetAndProperties(anim)) &#123;</span><br><span class="line">                        anim.cancel();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">/***部分代码省略***/</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/***部分代码省略***/</span></span><br><span class="line">        <span class="comment">//然后调用ValueAnimator.start()方法</span></span><br><span class="line">        <span class="keyword">super</span>.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ValueAnimator-start"><a href="#ValueAnimator-start" class="headerlink" title="ValueAnimator.start"></a>ValueAnimator.start</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueAnimator</span> <span class="keyword">extends</span> <span class="title">Animator</span> </span>&#123;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> ThreadLocal&lt;AnimationHandler&gt; sAnimationHandler =</span><br><span class="line">            <span class="keyword">new</span> ThreadLocal&lt;AnimationHandler&gt;();</span><br><span class="line">    <span class="comment">//保证每个线程有且只有一个AnimationHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> AnimationHandler <span class="title">getOrCreateAnimationHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        AnimationHandler handler = sAnimationHandler.get();</span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            handler = <span class="keyword">new</span> AnimationHandler();</span><br><span class="line">            sAnimationHandler.set(handler);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        start(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">boolean</span> playBackwards)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Looper.myLooper() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AndroidRuntimeException(<span class="string">"Animators may only be run on Looper threads"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/***部分代码省略***/</span></span><br><span class="line">        <span class="comment">//创建或者获取animationHandler实例</span></span><br><span class="line">        AnimationHandler animationHandler = getOrCreateAnimationHandler();</span><br><span class="line">        animationHandler.mPendingAnimations.add(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (mStartDelay == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// This sets the initial value of the animation, prior to actually starting it running</span></span><br><span class="line">            <span class="keyword">if</span> (prevPlayingState != SEEKED) &#123;</span><br><span class="line">                setCurrentPlayTime(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mPlayingState = STOPPED;</span><br><span class="line">            mRunning = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//回调监听器，通知动画开始</span></span><br><span class="line">            notifyStartListeners();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始动画</span></span><br><span class="line">        animationHandler.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//回调监听器，通知动画开始</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyStartListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mListeners != <span class="keyword">null</span> &amp;&amp; !mStartListenersCalled) &#123;</span><br><span class="line">            ArrayList&lt;AnimatorListener&gt; tmpListeners =</span><br><span class="line">                    (ArrayList&lt;AnimatorListener&gt;) mListeners.clone();</span><br><span class="line">            <span class="keyword">int</span> numListeners = tmpListeners.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</span><br><span class="line">                tmpListeners.get(i).onAnimationStart(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mStartListenersCalled = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCurrentPlayTime</span><span class="params">(<span class="keyword">long</span> playTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">float</span> fraction = mUnscaledDuration &gt; <span class="number">0</span> ? (<span class="keyword">float</span>) playTime / mUnscaledDuration : <span class="number">1</span>;</span><br><span class="line">        setCurrentFraction(fraction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCurrentFraction</span><span class="params">(<span class="keyword">float</span> fraction)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化动画</span></span><br><span class="line">        initAnimation();</span><br><span class="line">        <span class="keyword">if</span> (fraction &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            fraction = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AnimationHandler-start"><a href="#AnimationHandler-start" class="headerlink" title="AnimationHandler.start"></a>AnimationHandler.start</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueAnimator</span> <span class="keyword">extends</span> <span class="title">Animator</span> </span>&#123;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimationHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="comment">/***部分代码省略***/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始动画</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            scheduleAnimation();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送VSYNC信号回调请求</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleAnimation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!mAnimationScheduled) &#123;</span><br><span class="line">                mChoreographer.postCallback(Choreographer.CALLBACK_ANIMATION, <span class="keyword">this</span>, <span class="keyword">null</span>);</span><br><span class="line">                mAnimationScheduled = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Called by the Choreographer.</span></span><br><span class="line">        <span class="comment">//Choreographer的VSYNC信号回调</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            mAnimationScheduled = <span class="keyword">false</span>;</span><br><span class="line">            doAnimationFrame(mChoreographer.getFrameTime());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAnimationFrame</span><span class="params">(<span class="keyword">long</span> frameTime)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/***部分代码省略***/</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Now process all active animations. The return value from animationFrame()</span></span><br><span class="line">            <span class="comment">// tells the handler whether it should now be ended</span></span><br><span class="line">            <span class="keyword">int</span> numAnims = mAnimations.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numAnims; ++i) &#123;</span><br><span class="line">                mTmpAnimations.add(mAnimations.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numAnims; ++i) &#123;</span><br><span class="line">                ValueAnimator anim = mTmpAnimations.get(i);</span><br><span class="line">                <span class="comment">//执行动画</span></span><br><span class="line">                <span class="comment">//doAnimationFrame方法返回ture,则该动画添加在mEndingAnims队列中进行end操作</span></span><br><span class="line">                <span class="keyword">if</span> (mAnimations.contains(anim) &amp;&amp; anim.doAnimationFrame(frameTime)) &#123;</span><br><span class="line">                    mEndingAnims.add(anim);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/***部分代码省略***/</span></span><br><span class="line">            <span class="comment">//循环执行，直到endAnimation将mAnimations置空</span></span><br><span class="line">            <span class="keyword">if</span> (!mAnimations.isEmpty() || !mDelayedAnims.isEmpty()) &#123;</span><br><span class="line">                scheduleAnimation();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><h4 id="ObjectAnimator-initAnimation"><a href="#ObjectAnimator-initAnimation" class="headerlink" title="ObjectAnimator.initAnimation"></a>ObjectAnimator.initAnimation</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectAnimator</span> <span class="keyword">extends</span> <span class="title">ValueAnimator</span> </span>&#123;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initAnimation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mInitialized) &#123;</span><br><span class="line">            <span class="comment">// mValueType may change due to setter/getter setup; do this before calling super.init(),</span></span><br><span class="line">            <span class="comment">// which uses mValueType to set up the default type evaluator.</span></span><br><span class="line">            <span class="keyword">final</span> Object target = getTarget();</span><br><span class="line">            <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> numValues = mValues.length;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValues; ++i) &#123;</span><br><span class="line">                    mValues[i].setupSetterAndGetter(target);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">super</span>.initAnimation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="setupSetterAndGetter"><a href="#setupSetterAndGetter" class="headerlink" title="setupSetterAndGetter"></a>setupSetterAndGetter</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectAnimator</span> <span class="keyword">extends</span> <span class="title">ValueAnimator</span> </span>&#123;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setupSetterAndGetter</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        mKeyframes.invalidateCache();</span><br><span class="line">        <span class="keyword">if</span> (mProperty != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">/***部分代码省略***/</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// We can't just say 'else' here because the catch statement sets mProperty to null.</span></span><br><span class="line">        <span class="keyword">if</span> (mProperty == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Class targetClass = target.getClass();</span><br><span class="line">            <span class="keyword">if</span> (mSetter == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//初始化mSetter</span></span><br><span class="line">                setupSetter(targetClass);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/***部分代码省略***/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化mSetter用于以后反射执行get、set操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setupSetter</span><span class="params">(Class targetClass)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; propertyType = mConverter == <span class="keyword">null</span> ? mValueType : mConverter.getTargetType();</span><br><span class="line">        mSetter = setupSetterOrGetter(targetClass, sSetterPropertyMap, <span class="string">"set"</span>, propertyType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h3><h4 id="ValueAnimator-doAnimationFrame"><a href="#ValueAnimator-doAnimationFrame" class="headerlink" title="ValueAnimator.doAnimationFrame"></a>ValueAnimator.doAnimationFrame</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueAnimator</span> <span class="keyword">extends</span> <span class="title">Animator</span> </span>&#123;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">doAnimationFrame</span><span class="params">(<span class="keyword">long</span> frameTime)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/***部分代码省略***/</span></span><br><span class="line">        <span class="keyword">return</span> animationFrame(currentTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">animationFrame</span><span class="params">(<span class="keyword">long</span> currentTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">switch</span> (mPlayingState) &#123;</span><br><span class="line">        <span class="keyword">case</span> RUNNING:</span><br><span class="line">        <span class="keyword">case</span> SEEKED:</span><br><span class="line">            <span class="comment">/***部分代码省略***/</span></span><br><span class="line">            <span class="keyword">if</span> (fraction &gt;= <span class="number">1f</span>) &#123;</span><br><span class="line">            	<span class="comment">//mCurrentIteration是否等于mRepeatCount</span></span><br><span class="line">                <span class="keyword">if</span> (mCurrentIteration &lt; mRepeatCount || mRepeatCount == INFINITE) &#123;</span><br><span class="line">                    <span class="comment">// Time to repeat</span></span><br><span class="line">                    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                	<span class="comment">//执行完这次，该动画结束</span></span><br><span class="line">                    done = <span class="keyword">true</span>;</span><br><span class="line">                    fraction = Math.min(fraction, <span class="number">1.0f</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mPlayingBackwards) &#123;</span><br><span class="line">                fraction = <span class="number">1f</span> - fraction;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//设置View的属性值</span></span><br><span class="line">            animateValue(fraction);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ValueAnimator-animateValue"><a href="#ValueAnimator-animateValue" class="headerlink" title="ValueAnimator.animateValue"></a>ValueAnimator.animateValue</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueAnimator</span> <span class="keyword">extends</span> <span class="title">Animator</span> </span>&#123;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">animateValue</span><span class="params">(<span class="keyword">float</span> fraction)</span> </span>&#123;</span><br><span class="line">        fraction = mInterpolator.getInterpolation(fraction);</span><br><span class="line">        mCurrentFraction = fraction;</span><br><span class="line">        <span class="keyword">int</span> numValues = mValues.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValues; ++i) &#123;</span><br><span class="line">            <span class="comment">//PropertyValuesHolder.calculateValue就是计算每帧动画所对应的值</span></span><br><span class="line">            mValues[i].calculateValue(fraction);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mUpdateListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> numListeners = mUpdateListeners.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</span><br><span class="line">                <span class="comment">//属性值得改变的回调</span></span><br><span class="line">                mUpdateListeners.get(i).onAnimationUpdate(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ObjectAnimator-animateValue"><a href="#ObjectAnimator-animateValue" class="headerlink" title="ObjectAnimator.animateValue"></a>ObjectAnimator.animateValue</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectAnimator</span> <span class="keyword">extends</span> <span class="title">ValueAnimator</span> </span>&#123;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">animateValue</span><span class="params">(<span class="keyword">float</span> fraction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Object target = getTarget();</span><br><span class="line">        <span class="keyword">if</span> (mTarget != <span class="keyword">null</span> &amp;&amp; target == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// We lost the target reference, cancel and clean up.</span></span><br><span class="line">            cancel();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//ValueAnimator.animateValue方法</span></span><br><span class="line">        <span class="keyword">super</span>.animateValue(fraction);</span><br><span class="line">        <span class="keyword">int</span> numValues = mValues.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValues; ++i) &#123;</span><br><span class="line">        	<span class="comment">//设置target的属性值，进行View的移动，产生动画</span></span><br><span class="line">            mValues[i].setAnimatedValue(target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="PropertyValuesHolder"><a href="#PropertyValuesHolder" class="headerlink" title="PropertyValuesHolder"></a>PropertyValuesHolder</h2><blockquote>
<p>PropertyValuesHolder这个类的意义就是，它其中保存了动画过程中所需要操作的属性和对应的值。我们通过ofFloat(Object target, String propertyName, float… values)构造的动画，ofFloat()的内部实现其实就是将传进来的参数封装成PropertyValuesHolder实例来保存动画状态。在封装成PropertyValuesHolder实例以后，后期的各种操作也是以PropertyValuesHolder为主的。 </p>
</blockquote>
<h3 id="ObjectAnimator-ofFloat"><a href="#ObjectAnimator-ofFloat" class="headerlink" title="ObjectAnimator.ofFloat"></a>ObjectAnimator.ofFloat</h3><p>我们先看看我们之前的代码中构造ObjectAnimator的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectAnimator</span> <span class="keyword">extends</span> <span class="title">ValueAnimator</span> </span>&#123;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ObjectAnimator</span><span class="params">(Object target, String propertyName)</span> </span>&#123;</span><br><span class="line">        setTarget(target);</span><br><span class="line">        setPropertyName(propertyName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ObjectAnimator <span class="title">ofFloat</span><span class="params">(Object target, String propertyName, <span class="keyword">float</span>... values)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构造ObjectAnimator</span></span><br><span class="line">        ObjectAnimator anim = <span class="keyword">new</span> ObjectAnimator(target, propertyName);</span><br><span class="line">        anim.setFloatValues(values);</span><br><span class="line">        <span class="keyword">return</span> anim;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置属性值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPropertyName</span><span class="params">(@NonNull String propertyName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/***部分代码省略***/</span></span><br><span class="line">        mPropertyName = propertyName;</span><br><span class="line">        <span class="comment">// New property/values/target should cause re-initialization prior to starting</span></span><br><span class="line">        mInitialized = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFloatValues</span><span class="params">(<span class="keyword">float</span>... values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mValues == <span class="keyword">null</span> || mValues.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// No values yet - this animator is being constructed piecemeal. Init the values with</span></span><br><span class="line">            <span class="comment">// whatever the current propertyName is</span></span><br><span class="line">            <span class="keyword">if</span> (mProperty != <span class="keyword">null</span>) &#123;</span><br><span class="line">                setValues(PropertyValuesHolder.ofFloat(mProperty, values));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                setValues(PropertyValuesHolder.ofFloat(mPropertyName, values));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.setFloatValues(values);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构造FloatPropertyValueHolder"><a href="#构造FloatPropertyValueHolder" class="headerlink" title="构造FloatPropertyValueHolder"></a>构造FloatPropertyValueHolder</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyValuesHolder</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PropertyValuesHolder <span class="title">ofFloat</span><span class="params">(String propertyName, <span class="keyword">float</span>... values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FloatPropertyValuesHolder(propertyName, values);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">        </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyValuesHolder</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FloatPropertyValuesHolder</span> <span class="keyword">extends</span> <span class="title">PropertyValuesHolder</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">FloatPropertyValuesHolder</span><span class="params">(String propertyName, <span class="keyword">float</span>... values)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(propertyName);</span><br><span class="line">            setFloatValues(values);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/***部分代码省略***/</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFloatValues</span><span class="params">(<span class="keyword">float</span>... values)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.setFloatValues(values);</span><br><span class="line">            mFloatKeyframes = (Keyframes.FloatKeyframes) mKeyframes;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setAnimatedValue</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/***部分代码省略***/</span></span><br><span class="line">            <span class="keyword">if</span> (mSetter != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    mTmpValueArray[<span class="number">0</span>] = mFloatAnimatedValue;</span><br><span class="line">                    <span class="comment">//反射操作target的属性，通过set、get方法</span></span><br><span class="line">                    mSetter.invoke(target, mTmpValueArray);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">                    Log.e(<span class="string">"PropertyValuesHolder"</span>, e.toString());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                    Log.e(<span class="string">"PropertyValuesHolder"</span>, e.toString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="属性动画的内存泄露"><a href="#属性动画的内存泄露" class="headerlink" title="属性动画的内存泄露"></a>属性动画的内存泄露</h2><ul>
<li>上面讲述到 <code>ValueAnimator.AnimationHandler.doAnimationFrame</code> 的时候说过，这个方法会循环执行。</li>
<li>因为 <code>ValueAnimator.AnimationHandler.doAnimationFrame</code> 每次执行完动画（如果动画没有结束），都在再一次请求Vsync同步信号回调给自己。</li>
<li><code>Choreographer</code> 的回调都配post进入了当前线程的looper队列中。</li>
<li><code>mRepeatCount</code> 无穷大，会导致该循环会一直执行下去，即使关闭当前的页面也不会停止。</li>
</ul>
<h1 id="Drawable-Animation-1"><a href="#Drawable-Animation-1" class="headerlink" title="Drawable Animation"></a>Drawable Animation</h1><h2 id="帧动画使用"><a href="#帧动画使用" class="headerlink" title="帧动画使用"></a>帧动画使用</h2><h3 id="animalist-xml"><a href="#animalist-xml" class="headerlink" title="animalist.xml"></a>animalist.xml</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:oneshot=&quot;false&quot;&gt;</span><br><span class="line">    &lt;item</span><br><span class="line">        android:drawable=&quot;@mipmap/c_1&quot;</span><br><span class="line">        android:duration=&quot;50&quot; /&gt;</span><br><span class="line">    &lt;item</span><br><span class="line">        android:drawable=&quot;@mipmap/c_2&quot;</span><br><span class="line">        android:duration=&quot;50&quot; /&gt;</span><br><span class="line">     &lt;!--  省略...  --&gt;</span><br><span class="line">    &lt;item</span><br><span class="line">        android:drawable=&quot;@mipmap/circle_19&quot;</span><br><span class="line">        android:duration=&quot;50&quot; /&gt;</span><br><span class="line">    &lt;item</span><br><span class="line">        android:drawable=&quot;@mipmap/circle_20&quot;</span><br><span class="line">        android:duration=&quot;50&quot; /&gt;</span><br><span class="line">&lt;/animation-list&gt;</span><br></pre></td></tr></table></figure>
<h3 id="layout-xml"><a href="#layout-xml" class="headerlink" title="layout.xml"></a>layout.xml</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    tools:context=&quot;com.ansen.frameanimation.sample.MainActivity&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;ImageView</span><br><span class="line">        android:id=&quot;@+id/image&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:src=&quot;@drawable/animlist&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure>
<h3 id="java类使用"><a href="#java类使用" class="headerlink" title="java类使用"></a>java类使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ImageView image = (ImageView) findViewById(R.id.image);</span><br><span class="line">AnimationDrawable animationDrawable = (AnimationDrawable) image.getDrawable();</span><br><span class="line">animationDrawable.start();</span><br></pre></td></tr></table></figure>
<h2 id="DrawableAnimation流程图"><a href="#DrawableAnimation流程图" class="headerlink" title="DrawableAnimation流程图"></a>DrawableAnimation流程图</h2><center><img src="https://upload-images.jianshu.io/upload_images/1319879-af6001b9113bfeb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/410" alt="drawable-animation.png"></center>


<h2 id="帧动画代码执行过程"><a href="#帧动画代码执行过程" class="headerlink" title="帧动画代码执行过程"></a>帧动画代码执行过程</h2><h3 id="start-1"><a href="#start-1" class="headerlink" title="start"></a>start</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimationDrawable</span> <span class="keyword">extends</span> <span class="title">DrawableContainer</span> <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">Animatable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/***代码部分省略***/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mAnimating = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isRunning()) &#123;</span><br><span class="line">            <span class="comment">// Start from 0th frame.</span></span><br><span class="line">            setFrame(<span class="number">0</span>, <span class="keyword">false</span>, mAnimationState.getChildCount() &gt; <span class="number">1</span></span><br><span class="line">                    || !mAnimationState.mOneShot);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置当前展示第几帧</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setFrame</span><span class="params">(<span class="keyword">int</span> frame, <span class="keyword">boolean</span> unschedule, <span class="keyword">boolean</span> animate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (frame &gt;= mAnimationState.getChildCount()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mAnimating = animate;</span><br><span class="line">        mCurFrame = frame;</span><br><span class="line">        selectDrawable(frame);</span><br><span class="line">        <span class="comment">//如果取消下一帧任务，或者这已经是当前最后一帧，则取消当帧动画任务</span></span><br><span class="line">        <span class="keyword">if</span> (unschedule || animate) &#123;</span><br><span class="line">            unscheduleSelf(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (animate) &#123;</span><br><span class="line">            <span class="comment">// Unscheduling may have clobbered these values; restore them</span></span><br><span class="line">            mCurFrame = frame;</span><br><span class="line">            mRunning = <span class="keyword">true</span>;</span><br><span class="line">            scheduleSelf(<span class="keyword">this</span>, SystemClock.uptimeMillis() + mAnimationState.mDurations[frame]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//安排动画绘制任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleSelf</span><span class="params">(Runnable what, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//该Callback是当前AnimationDrawable绑定的View</span></span><br><span class="line">        <span class="keyword">final</span> Callback callback = getCallback();</span><br><span class="line">        <span class="comment">//判断当前绑定的View是否被销毁</span></span><br><span class="line">        <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            callback.scheduleDrawable(<span class="keyword">this</span>, what, when);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="scheduleDrawable"><a href="#scheduleDrawable" class="headerlink" title="scheduleDrawable"></a>scheduleDrawable</h3><ul>
<li><a href="https://blog.csdn.net/stven_king/article/details/78775166" target="_blank" rel="noopener">ViewRootImpl的独白，我不是一个View(布局篇)</a></li>
<li><a href="https://blog.csdn.net/stven_king/article/details/80098845" target="_blank" rel="noopener">Android系统的编舞者Choreographer</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">View</span> <span class="keyword">implements</span> <span class="title">Drawable</span>.<span class="title">Callback</span>, <span class="title">KeyEvent</span>.<span class="title">Callback</span>,</span></span><br><span class="line"><span class="class">        <span class="title">AccessibilityEventSource</span> </span>&#123;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span>   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleDrawable</span><span class="params">(Drawable who, Runnable what, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (verifyDrawable(who) &amp;&amp; what != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> delay = when - SystemClock.uptimeMillis();</span><br><span class="line">            <span class="keyword">if</span> (mAttachInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            	<span class="comment">//请求Vsync信号同步</span></span><br><span class="line">                mAttachInfo.mViewRootImpl.mChoreographer.postCallbackDelayed(</span><br><span class="line">                        Choreographer.CALLBACK_ANIMATION, what, who,</span><br><span class="line">                        Choreographer.subtractFrameDelay(delay));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ViewRootImpl.getRunQueue().postDelayed(what, delay);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimationDrawable</span> <span class="keyword">extends</span> <span class="title">DrawableContainer</span> <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">Animatable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/***代码部分省略***/</span></span><br><span class="line">    <span class="comment">//Choreographer的Vsync同步回调</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        nextFrame(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//继续执行下一帧动画</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextFrame</span><span class="params">(<span class="keyword">boolean</span> unschedule)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nextFrame = mCurFrame + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> numFrames = mAnimationState.getChildCount();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isLastFrame = mAnimationState.mOneShot &amp;&amp; nextFrame &gt;= (numFrames - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Loop if necessary. One-shot animations should never hit this case.</span></span><br><span class="line">        <span class="keyword">if</span> (!mAnimationState.mOneShot &amp;&amp; nextFrame &gt;= numFrames) &#123;</span><br><span class="line">            nextFrame = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//新一轮的循环又开始</span></span><br><span class="line">        setFrame(nextFrame, unschedule, !isLastFrame);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="CallBack的绑定"><a href="#CallBack的绑定" class="headerlink" title="CallBack的绑定"></a>CallBack的绑定</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">View</span> <span class="keyword">implements</span> <span class="title">Drawable</span>.<span class="title">Callback</span>, <span class="title">KeyEvent</span>.<span class="title">Callback</span>,</span></span><br><span class="line"><span class="class">        <span class="title">AccessibilityEventSource</span> </span>&#123;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBackgroundDrawable</span><span class="params">(Drawable background)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/***部分代码省略***/</span></span><br><span class="line">        <span class="comment">//清除之前的背景</span></span><br><span class="line">        <span class="keyword">if</span> (mBackground != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mBackground.setCallback(<span class="keyword">null</span>);</span><br><span class="line">            unscheduleDrawable(mBackground);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (background != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">/***部分代码省略***/</span></span><br><span class="line">            <span class="comment">//Drawable绑定当前的View</span></span><br><span class="line">            background.setCallback(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (background.isStateful()) &#123;</span><br><span class="line">                background.setState(getDrawableState());</span><br><span class="line">            &#125;</span><br><span class="line">            background.setVisible(getVisibility() == VISIBLE, <span class="keyword">false</span>);</span><br><span class="line">            mBackground = background;</span><br><span class="line"></span><br><span class="line">            applyBackgroundTint();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) != <span class="number">0</span>) &#123;</span><br><span class="line">                mPrivateFlags &amp;= ~PFLAG_SKIP_DRAW;</span><br><span class="line">                requestLayout = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/***部分代码省略***/</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        computeOpaqueFlags();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (requestLayout) &#123;</span><br><span class="line">            requestLayout();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mBackgroundSizeChanged = <span class="keyword">true</span>;</span><br><span class="line">        invalidate(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内存方面"><a href="#内存方面" class="headerlink" title="内存方面"></a>内存方面</h3><p>帧动画相比较属性动画而言可能会出现OOM，因为在家的每一帧的图片会占用很大的内存空间。</p>
<p>帧动画不会出现内存泄露的问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Drawable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="comment">//持有当前View的弱引用，当View回收之后，没办法继续下一帧的展示</span></span><br><span class="line">    <span class="keyword">private</span> WeakReference&lt;Callback&gt; mCallback = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Callback <span class="title">getCallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> mCallback.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Tween-Animation-1"><a href="#Tween-Animation-1" class="headerlink" title="Tween Animation"></a>Tween Animation</h1><h2 id="补间动画的使用"><a href="#补间动画的使用" class="headerlink" title="补间动画的使用"></a>补间动画的使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Animation translateAnimation = <span class="keyword">new</span> TranslateAnimation(<span class="number">0</span>, <span class="number">100</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">translateAnimation.setDuration(<span class="number">500</span>);</span><br><span class="line">translateAnimation.setInterpolator(<span class="keyword">new</span> AccelerateInterpolator());</span><br><span class="line">translateAnimation.setFillAfter(<span class="keyword">true</span>);<span class="comment">//设置动画结束后保持当前的位置（即不返回到动画开始前的位置）</span></span><br><span class="line">imageView.startAnimation(translateAnimation);</span><br></pre></td></tr></table></figure>
<h2 id="TweenAnimation流程图"><a href="#TweenAnimation流程图" class="headerlink" title="TweenAnimation流程图"></a>TweenAnimation流程图</h2><center><img src="https://upload-images.jianshu.io/upload_images/1319879-e40f995c13e22c95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/410" alt="tween-animation.png"></center>


<h2 id="补间动画代码的执行过程"><a href="#补间动画代码的执行过程" class="headerlink" title="补间动画代码的执行过程"></a>补间动画代码的执行过程</h2><h3 id="start-2"><a href="#start-2" class="headerlink" title="start"></a>start</h3><p>View:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">View</span> <span class="keyword">implements</span> <span class="title">Drawable</span>.<span class="title">Callback</span>, <span class="title">KeyEvent</span>.<span class="title">Callback</span>,</span></span><br><span class="line"><span class="class">        <span class="title">AccessibilityEventSource</span> </span>&#123;    </span><br><span class="line">    <span class="comment">//部分代码省略</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startAnimation</span><span class="params">(Animation animation)</span> </span>&#123;</span><br><span class="line">        animation.setStartTime(Animation.START_ON_FIRST_FRAME);</span><br><span class="line">        setAnimation(animation);</span><br><span class="line">        invalidateParentCaches();</span><br><span class="line">        invalidate(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">invalidate</span><span class="params">(<span class="keyword">boolean</span> invalidateCache)</span> </span>&#123;</span><br><span class="line">        invalidateInternal(<span class="number">0</span>, <span class="number">0</span>, mRight - mLeft, mBottom - mTop, invalidateCache, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">invalidateInternal</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b, <span class="keyword">boolean</span> invalidateCache,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> fullInvalidate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mGhostView != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mGhostView.invalidate(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (skipInvalidate()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((mPrivateFlags &amp; (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)</span><br><span class="line">                || (invalidateCache &amp;&amp; (mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID)</span><br><span class="line">                || (mPrivateFlags &amp; PFLAG_INVALIDATED) != PFLAG_INVALIDATED</span><br><span class="line">                || (fullInvalidate &amp;&amp; isOpaque() != mLastIsOpaque)) &#123;</span><br><span class="line">            <span class="comment">//部分代码省略</span></span><br><span class="line">            <span class="comment">// Propagate the damage rectangle to the parent view.</span></span><br><span class="line">            <span class="keyword">final</span> AttachInfo ai = mAttachInfo;</span><br><span class="line">            <span class="keyword">final</span> ViewParent p = mParent;</span><br><span class="line">            <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; ai != <span class="keyword">null</span> &amp;&amp; l &lt; r &amp;&amp; t &lt; b) &#123;</span><br><span class="line">                <span class="keyword">final</span> Rect damage = ai.mTmpInvalRect;</span><br><span class="line">                damage.set(l, t, r, b);</span><br><span class="line">                <span class="comment">//执行ViewParent的invalidateChild方法</span></span><br><span class="line">                p.invalidateChild(<span class="keyword">this</span>, damage);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//部分代码省略</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ViewGroup</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewGroup</span> <span class="keyword">extends</span> <span class="title">View</span> <span class="keyword">implements</span> <span class="title">ViewParent</span>, <span class="title">ViewManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">invalidateChild</span><span class="params">(View child, <span class="keyword">final</span> Rect dirty)</span> </span>&#123;</span><br><span class="line">        ViewParent parent = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">final</span> AttachInfo attachInfo = mAttachInfo;</span><br><span class="line">        <span class="keyword">if</span> (attachInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">/***部分代码省略***/</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">/***部分代码省略***/</span></span><br><span class="line">                <span class="comment">//向顶部的View便利找到根View，即：ViewRootImpl</span></span><br><span class="line">                <span class="comment">//执行ViewRootImpl的invalidateChildInParent方法</span></span><br><span class="line">                parent = parent.invalidateChildInParent(location, dirty);</span><br><span class="line">                <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Account for transform on current parent</span></span><br><span class="line">                    Matrix m = view.getMatrix();</span><br><span class="line">                    <span class="keyword">if</span> (!m.isIdentity()) &#123;</span><br><span class="line">                        RectF boundingRect = attachInfo.mTmpTransformRect;</span><br><span class="line">                        boundingRect.set(dirty);</span><br><span class="line">                        m.mapRect(boundingRect);</span><br><span class="line">                        dirty.set((<span class="keyword">int</span>) (boundingRect.left - <span class="number">0.5f</span>),</span><br><span class="line">                                (<span class="keyword">int</span>) (boundingRect.top - <span class="number">0.5f</span>),</span><br><span class="line">                                (<span class="keyword">int</span>) (boundingRect.right + <span class="number">0.5f</span>),</span><br><span class="line">                                (<span class="keyword">int</span>) (boundingRect.bottom + <span class="number">0.5f</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/***部分代码省略***/</span></span><br><span class="line">            &#125; <span class="keyword">while</span> (parent != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ViewRootImpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewRootImpl</span> <span class="keyword">implements</span> <span class="title">ViewParent</span>,</span></span><br><span class="line"><span class="class">        <span class="title">View</span>.<span class="title">AttachInfo</span>.<span class="title">Callbacks</span>, <span class="title">HardwareRenderer</span>.<span class="title">HardwareDrawCallbacks</span> </span>&#123;  </span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ViewParent <span class="title">invalidateChildInParent</span><span class="params">(<span class="keyword">int</span>[] location, Rect dirty)</span> </span>&#123;</span><br><span class="line">        checkThread();</span><br><span class="line">        <span class="comment">/***部分代码省略***/</span></span><br><span class="line">        invalidateRectOnScreen(dirty);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invalidateRectOnScreen</span><span class="params">(Rect dirty)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/***部分代码省略***/</span></span><br><span class="line">        <span class="keyword">if</span> (!mWillDrawSoon &amp;&amp; (intersected || mIsAnimating)) &#123;</span><br><span class="line">            <span class="comment">//开始View的绘制任务</span></span><br><span class="line">            scheduleTraversals();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前写过一篇文章 <a href="http://dandanlove.com/2017/12/11/viewrootimpl-activity/" target="_blank" rel="noopener">ViewRootImpl的独白，我不是一个View(布局篇)</a> 其中 <a href="http://dandanlove.com/2017/12/11/viewrootimpl-activity/#ViewRootImpl%E5%AF%B9mView%E8%BF%9B%E8%A1%8C%E6%93%8D%E4%BD%9C" target="_blank" rel="noopener">ViewRootImpl对mView进行操作</a> 讲述了再<code>ViewRootImpl</code> 中View的绘制。</p>
<h3 id="draw"><a href="#draw" class="headerlink" title="draw"></a>draw</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">View</span> <span class="keyword">implements</span> <span class="title">Drawable</span>.<span class="title">Callback</span>, <span class="title">KeyEvent</span>.<span class="title">Callback</span>,</span></span><br><span class="line"><span class="class">        <span class="title">AccessibilityEventSource</span> </span>&#123;    </span><br><span class="line">    <span class="comment">//部分代码省略</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/***部分代码省略***/</span></span><br><span class="line">        <span class="comment">//如果有子 View(DecorView当然有子View)，就会调用dispatchDraw() 将绘制事件通知给子 View。</span></span><br><span class="line">        <span class="comment">//ViewGroup 重写了 dispatchDraw()，调用了 drawChild()</span></span><br><span class="line">        <span class="comment">//drawChild() 调用了子 View 的 draw(Canvas, ViewGroup, long)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">draw</span><span class="params">(Canvas canvas, ViewGroup parent, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> hardwareAcceleratedCanvas = canvas.isHardwareAccelerated();</span><br><span class="line">        <span class="comment">/***部分代码省略***/</span></span><br><span class="line">        Transformation transformToApply = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> concatMatrix = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> scalingRequired = mAttachInfo != <span class="keyword">null</span> &amp;&amp; mAttachInfo.mScalingRequired;</span><br><span class="line">        <span class="keyword">final</span> Animation a = getAnimation();</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">            more = applyLegacyAnimation(parent, drawingTime, a, scalingRequired);</span><br><span class="line">            concatMatrix = a.willChangeTransformationMatrix();</span><br><span class="line">            <span class="keyword">if</span> (concatMatrix) &#123;</span><br><span class="line">                mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;</span><br><span class="line">            &#125;</span><br><span class="line">            transformToApply = parent.getChildTransformation();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/***部分代码省略***/</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">applyLegacyAnimation</span><span class="params">(ViewGroup parent, <span class="keyword">long</span> drawingTime,</span></span></span><br><span class="line"><span class="function"><span class="params">            Animation a, <span class="keyword">boolean</span> scalingRequired)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/***部分代码省略***/</span></span><br><span class="line">		<span class="comment">//绘制动画的当前帧，并获取当前动画的状态（是否继续运行）</span></span><br><span class="line">        <span class="keyword">boolean</span> more = a.getTransformation(drawingTime, t, <span class="number">1f</span>);</span><br><span class="line">        <span class="keyword">if</span> (scalingRequired &amp;&amp; mAttachInfo.mApplicationScale != <span class="number">1f</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent.mInvalidationTransformation == <span class="keyword">null</span>) &#123;</span><br><span class="line">                parent.mInvalidationTransformation = <span class="keyword">new</span> Transformation();</span><br><span class="line">            &#125;</span><br><span class="line">            invalidationTransform = parent.mInvalidationTransformation;</span><br><span class="line">            a.getTransformation(drawingTime, invalidationTransform, <span class="number">1f</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            invalidationTransform = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果动画没有结果</span></span><br><span class="line">        <span class="keyword">if</span> (more) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!a.willChangeBounds()) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((flags &amp; (ViewGroup.FLAG_OPTIMIZE_INVALIDATE | ViewGroup.FLAG_ANIMATION_DONE)) ==</span><br><span class="line">                        ViewGroup.FLAG_OPTIMIZE_INVALIDATE) &#123;</span><br><span class="line">                    parent.mGroupFlags |= ViewGroup.FLAG_INVALIDATE_REQUIRED;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((flags &amp; ViewGroup.FLAG_INVALIDATE_REQUIRED) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// The child need to draw an animation, potentially offscreen, so</span></span><br><span class="line">                    <span class="comment">// make sure we do not cancel invalidate requests</span></span><br><span class="line">                    parent.mPrivateFlags |= PFLAG_DRAW_ANIMATION;</span><br><span class="line">                    <span class="comment">//进行绘制</span></span><br><span class="line">                    parent.invalidate(mLeft, mTop, mRight, mBottom);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/***部分代码省略***/</span></span><br><span class="line">                <span class="comment">//进行绘制</span></span><br><span class="line">                parent.invalidate(left, top, left + (<span class="keyword">int</span>) (region.width() + .<span class="number">5f</span>),</span><br><span class="line">                        top + (<span class="keyword">int</span>) (region.height() + .<span class="number">5f</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> more;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="running"><a href="#running" class="headerlink" title="running"></a>running</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animation</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123; </span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getTransformation</span><span class="params">(<span class="keyword">long</span> currentTime, Transformation outTransformation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/***部分代码省略***/</span></span><br><span class="line">        <span class="comment">//执行时间是否过期</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> expired = normalizedTime &gt;= <span class="number">1.0f</span>;</span><br><span class="line">        mMore = !expired;</span><br><span class="line">        <span class="comment">//动画进度为0.0~1.0之间</span></span><br><span class="line">        <span class="keyword">if</span> (!mFillEnabled) normalizedTime = Math.max(Math.min(normalizedTime, <span class="number">1.0f</span>), <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((normalizedTime &gt;= <span class="number">0.0f</span> || mFillBefore) &amp;&amp; (normalizedTime &lt;= <span class="number">1.0f</span> || mFillAfter)) &#123;</span><br><span class="line">            <span class="comment">/***部分代码省略***/</span></span><br><span class="line">            <span class="comment">//插值器计算动画执行进度</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> interpolatedTime = mInterpolator.getInterpolation(normalizedTime);</span><br><span class="line">            <span class="comment">//真正的动画效果代码执行处(通过矩阵变化)</span></span><br><span class="line">            applyTransformation(interpolatedTime, outTransformation);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果动画绘制完成</span></span><br><span class="line">        <span class="keyword">if</span> (expired) &#123;</span><br><span class="line">            <span class="comment">//判断动画是否需要继续循环</span></span><br><span class="line">            <span class="keyword">if</span> (mRepeatCount == mRepeated) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!mEnded) &#123;</span><br><span class="line">                    mEnded = <span class="keyword">true</span>;</span><br><span class="line">                    guard.close();</span><br><span class="line">                    fireAnimationEnd();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (mRepeatCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    mRepeated++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mRepeatMode == REVERSE) &#123;</span><br><span class="line">                    mCycleFlip = !mCycleFlip;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                mStartTime = -<span class="number">1</span>;</span><br><span class="line">                mMore = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                fireAnimationRepeat();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!mMore &amp;&amp; mOneMoreTime) &#123;</span><br><span class="line">            mOneMoreTime = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mMore;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><p>通过代码分析可以证明补间动画也不会存在内存泄露的问题，因为他是靠着View的绘制来完成每一帧动效的展示。</p>
<h1 id="使用动画的注意事项"><a href="#使用动画的注意事项" class="headerlink" title="使用动画的注意事项"></a>使用动画的注意事项</h1><h2 id="OOM的问题"><a href="#OOM的问题" class="headerlink" title="OOM的问题"></a>OOM的问题</h2><blockquote>
<p>这个问题主要出现在帧动画中，当图片数量过多的且图片较大的时候就极易出现OOM，这个在实际的开发中要尤其注意，尽量避免使用帧动画。</p>
</blockquote>
<h2 id="内存泄漏的问题"><a href="#内存泄漏的问题" class="headerlink" title="内存泄漏的问题"></a>内存泄漏的问题</h2><blockquote>
<p>在属性动画中有一类无限循环的动画，这类动画需要在Activity退出时及时停止，否则导致Activity无法释放从而造成内存泄露，通过验证发现View动画（帧动画和补间动画）并不存在此问题。</p>
</blockquote>
<h2 id="兼容性问题"><a href="#兼容性问题" class="headerlink" title="兼容性问题"></a>兼容性问题</h2><blockquote>
<p>动画在3.0以下的系统上有兼容性问题，在某些特殊场景可能无法正常工作，因此要做好适配工作。</p>
</blockquote>
<h2 id="View动画的问题"><a href="#View动画的问题" class="headerlink" title="View动画的问题"></a>View动画的问题</h2><blockquote>
<p>View动画对View的影像做动画，并不是真正的改变View的状态，因此有时候会出现动画完成后View无法影藏的现象，即<code>setVisibility(View.GONE)</code>失效了，这个时候只要调用<code>view.clearAnimation()</code>清除View动画即可解决此问题。</p>
</blockquote>
<h2 id="不要使用px"><a href="#不要使用px" class="headerlink" title="不要使用px"></a>不要使用px</h2><blockquote>
<p>在进行动画的过程中，要尽量使用dp，使用px会导致在不同的设备上有不同的效果。</p>
</blockquote>
<h2 id="动画元素的交互"><a href="#动画元素的交互" class="headerlink" title="动画元素的交互"></a>动画元素的交互</h2><blockquote>
<p>将View移动（平移）后，在Android3.0之前的系统上，不管是View动画还是属性动画，新位置均无法触发单击事件，同时老位置任然可以触发单击事件。尽管View已经在视觉上不存在了，将View移回原位置以后，原位置的单击事件继续生效。从3.0开始，属性动画的单击事件触发位置为移动以后的位置，但View动画仍然在原位置。</p>
</blockquote>
<h2 id="硬件加速"><a href="#硬件加速" class="headerlink" title="硬件加速"></a>硬件加速</h2><blockquote>
<p>使用动画的过程中，建议开启硬件加速，这样会提交动画的流畅性。</p>
</blockquote>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>animation</tag>
        <tag>tween</tag>
        <tag>frame</tag>
        <tag>property</tag>
      </tags>
  </entry>
  <entry>
    <title>Android系统的编舞者Choreographer</title>
    <url>/2018/04/25/android-source-choreographer/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇文章 <a href="http://dandanlove.com/2018/04/13/android-16ms/" target="_blank" rel="noopener">Android的16ms和垂直同步以及三重缓存</a> 解释了手机流畅性的问题，并在文章中提到了在Android4.1中添加的<code>Vsync</code>。<code>Choreographer</code>机制，用于同<code>Vsync</code>机制配合，实现统一调度界面绘图。</p>
<h1 id="Choreographer的构造"><a href="#Choreographer的构造" class="headerlink" title="Choreographer的构造"></a>Choreographer的构造</h1><p>Choreographer是线程级别的单例，并且具有处理当前线程消息循环队列的功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Choreographer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Enable/disable vsync for animations and drawing.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> USE_VSYNC = SystemProperties.getBoolean(</span><br><span class="line">            <span class="string">"debug.choreographer.vsync"</span>, <span class="keyword">true</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//单例</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Choreographer <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sThreadInstance.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每个线程一个Choreographer实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Choreographer&gt; sThreadInstance =</span><br><span class="line">            <span class="keyword">new</span> ThreadLocal&lt;Choreographer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Choreographer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Looper looper = Looper.myLooper();</span><br><span class="line">            <span class="keyword">if</span> (looper == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The current thread must have a looper!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Choreographer(looper);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Choreographer</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">        mLooper = looper;</span><br><span class="line">        <span class="comment">//创建handle对象，用于处理消息，其looper为当前的线程的消息队列</span></span><br><span class="line">        mHandler = <span class="keyword">new</span> FrameHandler(looper);</span><br><span class="line">        <span class="comment">//创建VSYNC的信号接受对象</span></span><br><span class="line">        mDisplayEventReceiver = USE_VSYNC ? <span class="keyword">new</span> FrameDisplayEventReceiver(looper) : <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//初始化上一次frame渲染的时间点</span></span><br><span class="line">        mLastFrameTimeNanos = Long.MIN_VALUE;</span><br><span class="line">        <span class="comment">//计算帧率，也就是一帧所需的渲染时间，getRefreshRate是刷新率，一般是60</span></span><br><span class="line">        mFrameIntervalNanos = (<span class="keyword">long</span>)(<span class="number">1000000000</span> / getRefreshRate());</span><br><span class="line">        <span class="comment">//创建消息处理队列</span></span><br><span class="line">        mCallbackQueues = <span class="keyword">new</span> CallbackQueue[CALLBACK_LAST + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= CALLBACK_LAST; i++) &#123;</span><br><span class="line">            mCallbackQueues[i] = <span class="keyword">new</span> CallbackQueue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>变量USE_VSYNC用于表示系统是否是用了Vsync同步机制，该值是通过读取系统属性debug.choreographer.vsync来获取的。如果系统使用了Vsync同步机制，则创建一个FrameDisplayEventReceiver对象用于请求并接收Vsync事件，最后Choreographer创建了一个大小为3的CallbackQueue队列数组，用于保存不同类型的Callback。</p>
</blockquote>
<h1 id="Choreographer的使用"><a href="#Choreographer的使用" class="headerlink" title="Choreographer的使用"></a>Choreographer的使用</h1><h2 id="注册Runnable对象"><a href="#注册Runnable对象" class="headerlink" title="注册Runnable对象"></a>注册Runnable对象</h2><p>作者之前写过一篇关于<strong>ViewRootImpl</strong>的文章：<a href="[**https://www.jianshu.com/p/005afb47e00c**](https://www.jianshu.com/p/005afb47e00c"><strong>ViewRootImpl</strong>的独白，我不是一个<strong>View</strong>(布局篇)</a>)里面有涉及使用Choreographer进行View的绘制，这次我们从ViewRootImpl的绘制出发来看看Choreographer的使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewRootImpl</span> <span class="keyword">implements</span> <span class="title">ViewParent</span>,</span></span><br><span class="line"><span class="class">        <span class="title">View</span>.<span class="title">AttachInfo</span>.<span class="title">Callbacks</span>, <span class="title">HardwareRenderer</span>.<span class="title">HardwareDrawCallbacks</span> </span>&#123;</span><br><span class="line">    Choreographer mChoreographer;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ViewRootImpl</span><span class="params">(Context context, Display display)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/***部分代码省略***/</span></span><br><span class="line">        mChoreographer = Choreographer.getInstance();</span><br><span class="line">        <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">            mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">            mTraversalBarrier = mHandler.getLooper().postSyncBarrier();</span><br><span class="line">            mChoreographer.postCallback(</span><br><span class="line">                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (!mUnbufferedInputDispatch) &#123;</span><br><span class="line">                scheduleConsumeBatchedInput();</span><br><span class="line">            &#125;</span><br><span class="line">            notifyRendererOfFramePending();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注册FrameCallback对象"><a href="#注册FrameCallback对象" class="headerlink" title="注册FrameCallback对象"></a>注册FrameCallback对象</h2><blockquote>
<p>无论是注册<code>Runnable</code>还是注册<code>FrameCallback</code>对象最终都会调用<code>postCallbackDelayedInternal</code>方法往<code>mCallbackQueues</code>添加回调，区别在于<code>FrameCallback</code>的token为<code>FRAME_CALLBACK_TOKEN</code>，两者在回调的时候不相同。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Choreographer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// All frame callbacks posted by applications have this token.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object FRAME_CALLBACK_TOKEN = <span class="keyword">new</span> Object() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"FRAME_CALLBACK_TOKEN"</span>; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CallbackRecord</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> CallbackRecord next;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">long</span> dueTime;</span><br><span class="line">        <span class="keyword">public</span> Object action; <span class="comment">// Runnable or FrameCallback</span></span><br><span class="line">        <span class="keyword">public</span> Object token;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (token == FRAME_CALLBACK_TOKEN) &#123;</span><br><span class="line">                ((FrameCallback)action).doFrame(frameTimeNanos);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ((Runnable)action).run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Choreographer的消息处理"><a href="#Choreographer的消息处理" class="headerlink" title="Choreographer的消息处理"></a>Choreographer的消息处理</h1><h2 id="Choreographer接受消息"><a href="#Choreographer接受消息" class="headerlink" title="Choreographer接受消息"></a>Choreographer接受消息</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Choreographer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Input callback.  Runs first.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CALLBACK_INPUT = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//Animation callback.  Runs before traversals.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CALLBACK_ANIMATION = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// Traversal callback.  Handles layout and draw.  </span></span><br><span class="line">    <span class="comment">//Runs last after all other asynchronous messages have been handled.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CALLBACK_TRAVERSAL = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CALLBACK_LAST = CALLBACK_TRAVERSAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//长度为3（CALLBACK_LAST+1）的CallbackQueue类型的数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CallbackQueue[] mCallbackQueues;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送回调事件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postCallback</span><span class="params">(<span class="keyword">int</span> callbackType, Runnable action, Object token)</span> </span>&#123;</span><br><span class="line">        postCallbackDelayed(callbackType, action, token, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postCallbackDelayed</span><span class="params">(<span class="keyword">int</span> callbackType,</span></span></span><br><span class="line"><span class="function"><span class="params">            Runnable action, Object token, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"action must not be null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (callbackType &lt; <span class="number">0</span> || callbackType &gt; CALLBACK_LAST) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"callbackType is invalid"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        postCallbackDelayedInternal(callbackType, action, token, delayMillis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postCallbackDelayedInternal</span><span class="params">(<span class="keyword">int</span> callbackType,</span></span></span><br><span class="line"><span class="function"><span class="params">            Object action, Object token, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/***部分代码省略***/</span></span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            <span class="comment">//从开机到现在的毫秒数（手机睡眠的时间不包括在内）； </span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> dueTime = now + delayMillis;</span><br><span class="line">            <span class="comment">//添加类型为callbackType的CallbackQueue（将要执行的回调封装而成）</span></span><br><span class="line">            mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</span><br><span class="line">            <span class="comment">//函数执行时间</span></span><br><span class="line">            <span class="keyword">if</span> (dueTime &lt;= now) &#123;</span><br><span class="line">                <span class="comment">//立即执行</span></span><br><span class="line">                scheduleFrameLocked(now);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//异步回调延迟执行</span></span><br><span class="line">                Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class="line">                msg.arg1 = callbackType;</span><br><span class="line">                msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">                mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dueTime 任务开始时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> action 任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token 标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> CallbackRecord <span class="title">obtainCallbackLocked</span><span class="params">(<span class="keyword">long</span> dueTime, Object action, Object token)</span> </span>&#123;</span><br><span class="line">        CallbackRecord callback = mCallbackPool;</span><br><span class="line">        <span class="keyword">if</span> (callback == <span class="keyword">null</span>) &#123;</span><br><span class="line">            callback = <span class="keyword">new</span> CallbackRecord();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mCallbackPool = callback.next;</span><br><span class="line">            callback.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        callback.dueTime = dueTime;</span><br><span class="line">        callback.action = action;</span><br><span class="line">        callback.token = token;</span><br><span class="line">        <span class="keyword">return</span> callback;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CallbackQueue</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> CallbackRecord mHead;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCallbackLocked</span><span class="params">(<span class="keyword">long</span> dueTime, Object action, Object token)</span> </span>&#123;</span><br><span class="line">            CallbackRecord callback = obtainCallbackLocked(dueTime, action, token);</span><br><span class="line">            CallbackRecord entry = mHead;</span><br><span class="line">            <span class="comment">//判断当前的是否不头节点</span></span><br><span class="line">            <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mHead = callback;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断当前任务出发起始时间是不是当前所有任务的最开始时间</span></span><br><span class="line">            <span class="keyword">if</span> (dueTime &lt; entry.dueTime) &#123;</span><br><span class="line">                callback.next = entry;</span><br><span class="line">                mHead = callback;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//根据任务开始时间由小到大插入到链表当中</span></span><br><span class="line">            <span class="keyword">while</span> (entry.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dueTime &lt; entry.next.dueTime) &#123;</span><br><span class="line">                    callback.next = entry.next;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                entry = entry.next;</span><br><span class="line">            &#125;</span><br><span class="line">            entry.next = callback;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CallbackQueue"><a href="#CallbackQueue" class="headerlink" title="CallbackQueue"></a>CallbackQueue</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Choreographer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Callback type: Input callback.  Runs first.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CALLBACK_INPUT = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Callback type: Animation callback.  Runs before traversals.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CALLBACK_ANIMATION = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Callback type: Traversal callback.  Handles layout and draw.  Runs</span></span><br><span class="line"><span class="comment">     * after all other asynchronous messages have been handled.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CALLBACK_TRAVERSAL = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>三种类型不同的<code>CallbackRecord</code>链表，按照任务触发时间由小到大排列。</p>
</blockquote>
<center><img src="https://upload-images.jianshu.io/upload_images/1319879-3e4ccbfece97a82c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CallbackQueue.png"></center>


<h2 id="FrameHandler异步处理"><a href="#FrameHandler异步处理" class="headerlink" title="FrameHandler异步处理"></a>FrameHandler异步处理</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Choreographer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MSG_DO_FRAME = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MSG_DO_SCHEDULE_VSYNC = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MSG_DO_SCHEDULE_CALLBACK = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FrameHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">FrameHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(looper);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> MSG_DO_FRAME:</span><br><span class="line">                    <span class="comment">//刷新当前这一帧</span></span><br><span class="line">                    doFrame(System.nanoTime(), <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MSG_DO_SCHEDULE_VSYNC:</span><br><span class="line">                    <span class="comment">//做VSYNC的信号同步</span></span><br><span class="line">                    doScheduleVsync();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MSG_DO_SCHEDULE_CALLBACK:</span><br><span class="line">                    <span class="comment">//将当前任务加入执行队列</span></span><br><span class="line">                    doScheduleCallback(msg.arg1);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="doFrame"><a href="#doFrame" class="headerlink" title="doFrame"></a>doFrame</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Choreographer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos, <span class="keyword">int</span> frame)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> startNanos;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mFrameScheduled) &#123;</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// no work to do</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前时间</span></span><br><span class="line">            startNanos = System.nanoTime();</span><br><span class="line">            <span class="comment">//抖动间隔</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> jitterNanos = startNanos - frameTimeNanos;</span><br><span class="line">            <span class="comment">//抖动间隔大于屏幕刷新时间间隔（16ms）</span></span><br><span class="line">            <span class="keyword">if</span> (jitterNanos &gt;= mFrameIntervalNanos) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> skippedFrames = jitterNanos / mFrameIntervalNanos;</span><br><span class="line">                <span class="comment">//跳过了几帧！，也许当前应用在主线程做了太多的事情。</span></span><br><span class="line">                <span class="keyword">if</span> (skippedFrames &gt;= SKIPPED_FRAME_WARNING_LIMIT) &#123;</span><br><span class="line">                    Log.i(TAG, <span class="string">"Skipped "</span> + skippedFrames + <span class="string">" frames!  "</span></span><br><span class="line">                            + <span class="string">"The application may be doing too much work on its main thread."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//最后一次的屏幕刷是lastFrameOffset之前开始的</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> lastFrameOffset = jitterNanos % mFrameIntervalNanos;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                    Log.d(TAG, <span class="string">"Missed vsync by "</span> + (jitterNanos * <span class="number">0.000001f</span>) + <span class="string">" ms "</span></span><br><span class="line">                            + <span class="string">"which is more than the frame interval of "</span></span><br><span class="line">                            + (mFrameIntervalNanos * <span class="number">0.000001f</span>) + <span class="string">" ms!  "</span></span><br><span class="line">                            + <span class="string">"Skipping "</span> + skippedFrames + <span class="string">" frames and setting frame "</span></span><br><span class="line">                            + <span class="string">"time to "</span> + (lastFrameOffset * <span class="number">0.000001f</span>) + <span class="string">" ms in the past."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//最后一帧的刷新开始时间</span></span><br><span class="line">                frameTimeNanos = startNanos - lastFrameOffset;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//由于跳帧可能造成了当前展现的是之前的帧，这样需要等待下一个vsync信号</span></span><br><span class="line">            <span class="keyword">if</span> (frameTimeNanos &lt; mLastFrameTimeNanos) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                    Log.d(TAG, <span class="string">"Frame time appears to be going backwards.  May be due to a "</span></span><br><span class="line">                            + <span class="string">"previously skipped frame.  Waiting for next vsync."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                scheduleVsyncLocked();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前画面刷新的状态置false</span></span><br><span class="line">            mFrameScheduled = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//更新最后一帧的刷新时间</span></span><br><span class="line">            mLastFrameTimeNanos = frameTimeNanos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//按照优先级策略进行画面刷新时间处理</span></span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);</span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);</span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> endNanos = System.nanoTime();</span><br><span class="line">            Log.d(TAG, <span class="string">"Frame "</span> + frame + <span class="string">": Finished, took "</span></span><br><span class="line">                    + (endNanos - startNanos) * <span class="number">0.000001f</span> + <span class="string">" ms, latency "</span></span><br><span class="line">                    + (startNanos - frameTimeNanos) * <span class="number">0.000001f</span> + <span class="string">" ms."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="doScheduleVsync"><a href="#doScheduleVsync" class="headerlink" title="doScheduleVsync"></a>doScheduleVsync</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Choreographer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//等待vsync信号</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doScheduleVsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mFrameScheduled) &#123;</span><br><span class="line">                scheduleVsyncLocked();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当运行在Looper线程，则立刻调度vsync</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleVsyncLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mDisplayEventReceiver.scheduleVsync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="doScheduleCallback"><a href="#doScheduleCallback" class="headerlink" title="doScheduleCallback"></a>doScheduleCallback</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Choreographer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Enable/disable vsync for animations and drawing.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> USE_VSYNC = SystemProperties.getBoolean(</span><br><span class="line">            <span class="string">"debug.choreographer.vsync"</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CallbackQueue</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否有能执行的任务</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasDueCallbacksLocked</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mHead != <span class="keyword">null</span> &amp;&amp; mHead.dueTime &lt;= now;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="comment">//执行任务回调</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doScheduleCallback</span><span class="params">(<span class="keyword">int</span> callbackType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mFrameScheduled) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">                <span class="comment">//有能执行的任务</span></span><br><span class="line">                <span class="keyword">if</span> (mCallbackQueues[callbackType].hasDueCallbacksLocked(now)) &#123;</span><br><span class="line">                    scheduleFrameLocked(now);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleFrameLocked</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mFrameScheduled) &#123;</span><br><span class="line">            mFrameScheduled = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (USE_VSYNC) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                    Log.d(TAG, <span class="string">"Scheduling next frame on vsync."</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// If running on the Looper thread, then schedule the vsync immediately,</span></span><br><span class="line">                <span class="comment">// otherwise post a message to schedule the vsync from the UI thread</span></span><br><span class="line">                <span class="comment">// as soon as possible.</span></span><br><span class="line">                <span class="keyword">if</span> (isRunningOnLooperThreadLocked()) &#123;</span><br><span class="line">                    <span class="comment">//当运行在Looper线程，则立刻调度vsync</span></span><br><span class="line">                    scheduleVsyncLocked();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//切换到主线程，调度vsync</span></span><br><span class="line">                    Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC);</span><br><span class="line">                    msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">                    mHandler.sendMessageAtFrontOfQueue(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果没有VSYNC的同步，则发送消息刷新画面</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> nextFrameTime = Math.max(</span><br><span class="line">                        mLastFrameTimeNanos / TimeUtils.NANOS_PER_MS + sFrameDelay, now);</span><br><span class="line">                <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                    Log.d(TAG, <span class="string">"Scheduling next frame in "</span> + (nextFrameTime - now) + <span class="string">" ms."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                Message msg = mHandler.obtainMessage(MSG_DO_FRAME);</span><br><span class="line">                msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">                mHandler.sendMessageAtTime(msg, nextFrameTime);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检测当前的Looper线程是不是主线程</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRunningOnLooperThreadLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Looper.myLooper() == mLooper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Choreographer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The display event receiver can only be accessed by the looper thread to which</span></span><br><span class="line">    <span class="comment">// it is attached.  We take care to ensure that we post message to the looper</span></span><br><span class="line">    <span class="comment">// if appropriate when interacting with the display event receiver.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FrameDisplayEventReceiver mDisplayEventReceiver;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Choreographer</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/***部分代码省略***/</span></span><br><span class="line">        <span class="comment">//在Choreographer的构造函数中，我们使用USE_VSYNC则会有FrameDisplayEventReceiver做为与显示器时间进行交互</span></span><br><span class="line">        mDisplayEventReceiver = USE_VSYNC ? <span class="keyword">new</span> FrameDisplayEventReceiver(looper) : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FrameDisplayEventReceiver</span> <span class="keyword">extends</span> <span class="title">DisplayEventReceiver</span></span></span><br><span class="line"><span class="class">            <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构造函数需要传入当前的looper队列  </span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">FrameDisplayEventReceiver</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(looper);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/***部分代码省略***/</span>  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DisplayEventReceiver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeScheduleVsync</span><span class="params">(<span class="keyword">long</span> receiverPtr)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a display event receiver.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> looper The looper to use when invoking callbacks.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DisplayEventReceiver</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (looper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"looper must not be null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mMessageQueue = looper.getQueue();</span><br><span class="line">        <span class="comment">//接受数量多少等于looper中消息的多少</span></span><br><span class="line">        mReceiverPtr = nativeInit(<span class="keyword">this</span>, mMessageQueue);</span><br><span class="line">        mCloseGuard.open(<span class="string">"dispose"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Schedules a single vertical sync pulse to be delivered when the next</span></span><br><span class="line"><span class="comment">     * display frame begins.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleVsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mReceiverPtr == <span class="number">0</span>) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">"Attempted to schedule a vertical sync pulse but the display event "</span></span><br><span class="line">                    + <span class="string">"receiver has already been disposed."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nativeScheduleVsync(mReceiverPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Choreographer流程汇总"><a href="#Choreographer流程汇总" class="headerlink" title="Choreographer流程汇总"></a>Choreographer流程汇总</h2><center><img src="https://upload-images.jianshu.io/upload_images/1319879-15dd68b1b499b02c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="choreographer.png"></center>


<h1 id="native端的消息处理"><a href="#native端的消息处理" class="headerlink" title="native端的消息处理"></a>native端的消息处理</h1><p>文件路径：<code>frameworks/base/core/jni/android_view_DisplayEventReceiver.cpp</code></p>
<h2 id="NativeDisplayEventReceiver类结构"><a href="#NativeDisplayEventReceiver类结构" class="headerlink" title="NativeDisplayEventReceiver类结构"></a>NativeDisplayEventReceiver类结构</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//NativeDisplayEventReceiver类的定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NativeDisplayEventReceiver</span> :</span> <span class="keyword">public</span> LooperCallback &#123;</span><br><span class="line"><span class="keyword">public</span>:<span class="comment">//对象公共方法</span></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    NativeDisplayEventReceiver(JNIEnv* env,</span><br><span class="line">            jobject receiverObj, <span class="keyword">const</span> sp&lt;MessageQueue&gt;&amp; messageQueue);</span><br><span class="line">    <span class="keyword">status_t</span> initialize();  <span class="comment">//初始化方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">status_t</span> scheduleVsync();<span class="comment">//获取下一个VSYNC信号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~NativeDisplayEventReceiver();<span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    jobject mReceiverObjGlobal;<span class="comment">//java层的DisplayEventReceiver的全局引用</span></span><br><span class="line">    sp&lt;MessageQueue&gt; mMessageQueue;<span class="comment">//looper的消息队列</span></span><br><span class="line">    DisplayEventReceiver mReceiver;<span class="comment">//frameworks/nivate/libs/gui/DisplayEventReceiver.cpp</span></span><br><span class="line">    <span class="keyword">bool</span> mWaitingForVsync;<span class="comment">//默认为false</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">handleEvent</span><span class="params">(<span class="keyword">int</span> receiveFd, <span class="keyword">int</span> events, <span class="keyword">void</span>* data)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">processPendingEvents</span><span class="params">(<span class="keyword">nsecs_t</span>* outTimestamp, <span class="keyword">int32_t</span>* id, <span class="keyword">uint32_t</span>* outCount)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dispatchVsync</span><span class="params">(<span class="keyword">nsecs_t</span> timestamp, <span class="keyword">int32_t</span> id, <span class="keyword">uint32_t</span> count)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dispatchHotplug</span><span class="params">(<span class="keyword">nsecs_t</span> timestamp, <span class="keyword">int32_t</span> id, <span class="keyword">bool</span> connected)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ststem/core/include/utils/Looper.h</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A looper callback.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//NativeDisplayEventReceiver的父类，用与looper中消息的回调</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LooperCallback</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~LooperCallback() &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">handleEvent</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span>* data)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="NativeDisplayEventReceiver初始化"><a href="#NativeDisplayEventReceiver初始化" class="headerlink" title="NativeDisplayEventReceiver初始化"></a>NativeDisplayEventReceiver初始化</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化native的消息队列</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeInit</span><span class="params">(JNIEnv* env, jclass clazz, jobject receiverObj,</span></span></span><br><span class="line"><span class="function"><span class="params">        jobject messageQueueObj)</span> </span>&#123;</span><br><span class="line">    sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj);</span><br><span class="line">    <span class="keyword">if</span> (messageQueue == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        jniThrowRuntimeException(env, <span class="string">"MessageQueue is not initialized."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造NativeDisplayEventReceiver对象</span></span><br><span class="line">    sp&lt;NativeDisplayEventReceiver&gt; receiver = <span class="keyword">new</span> NativeDisplayEventReceiver(env,</span><br><span class="line">            receiverObj, messageQueue);</span><br><span class="line">    <span class="keyword">status_t</span> status = receiver-&gt;initialize();</span><br><span class="line">    <span class="keyword">if</span> (status) &#123;</span><br><span class="line">        String8 message;</span><br><span class="line">        message.appendFormat(<span class="string">"Failed to initialize display event receiver.  status=%d"</span>, status);</span><br><span class="line">        jniThrowRuntimeException(env, message.<span class="built_in">string</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receiver-&gt;incStrong(gDisplayEventReceiverClassInfo.clazz); <span class="comment">// retain a reference for the object</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(receiver.get());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//NativeDisplayEventReceiver的构造函数</span></span><br><span class="line">NativeDisplayEventReceiver::NativeDisplayEventReceiver(JNIEnv* env,</span><br><span class="line">        jobject receiverObj, <span class="keyword">const</span> sp&lt;MessageQueue&gt;&amp; messageQueue) :</span><br><span class="line">        mReceiverObjGlobal(env-&gt;NewGlobalRef(receiverObj)),</span><br><span class="line">        mMessageQueue(messageQueue), mWaitingForVsync(<span class="literal">false</span>) &#123;</span><br><span class="line">    ALOGV(<span class="string">"receiver %p ~ Initializing input event receiver."</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//receiver内部数据的初始化</span></span><br><span class="line"><span class="keyword">status_t</span> NativeDisplayEventReceiver::initialize() &#123;</span><br><span class="line">    <span class="keyword">status_t</span> result = mReceiver.initCheck();</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        ALOGW(<span class="string">"Failed to initialize display event receiver, status=%d"</span>, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//监听mReceiver的所获取的文件句柄。</span></span><br><span class="line">    <span class="keyword">int</span> rc = mMessageQueue-&gt;getLooper()-&gt;addFd(mReceiver.getFd(), <span class="number">0</span>, Looper::EVENT_INPUT,</span><br><span class="line">            <span class="keyword">this</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="NativeDisplayEventReceiver请求VSYNC的同步"><a href="#NativeDisplayEventReceiver请求VSYNC的同步" class="headerlink" title="NativeDisplayEventReceiver请求VSYNC的同步"></a>NativeDisplayEventReceiver请求VSYNC的同步</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//java层调用DisplayEventReceiver的scheduleVsync请求VSYNC的同步</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeScheduleVsync</span><span class="params">(JNIEnv* env, jclass clazz, jlong receiverPtr)</span> </span>&#123;</span><br><span class="line">    sp&lt;NativeDisplayEventReceiver&gt; receiver =</span><br><span class="line">            <span class="keyword">reinterpret_cast</span>&lt;NativeDisplayEventReceiver*&gt;(receiverPtr);</span><br><span class="line">    <span class="keyword">status_t</span> status = receiver-&gt;scheduleVsync();</span><br><span class="line">    <span class="keyword">if</span> (status) &#123;</span><br><span class="line">        String8 message;</span><br><span class="line">        message.appendFormat(<span class="string">"Failed to schedule next vertical sync pulse.  status=%d"</span>, status);</span><br><span class="line">        jniThrowRuntimeException(env, message.<span class="built_in">string</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> NativeDisplayEventReceiver::scheduleVsync() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mWaitingForVsync) &#123;</span><br><span class="line">        ALOGV(<span class="string">"receiver %p ~ Scheduling vsync."</span>, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Drain all pending events.</span></span><br><span class="line">        <span class="keyword">nsecs_t</span> vsyncTimestamp;</span><br><span class="line">        <span class="keyword">int32_t</span> vsyncDisplayId;</span><br><span class="line">        <span class="keyword">uint32_t</span> vsyncCount;</span><br><span class="line">        processPendingEvents(&amp;vsyncTimestamp, &amp;vsyncDisplayId, &amp;vsyncCount);</span><br><span class="line">        <span class="comment">//请求下一次Vsync信息处理</span></span><br><span class="line">        <span class="keyword">status_t</span> status = mReceiver.requestNextVsync();</span><br><span class="line">        <span class="keyword">if</span> (status) &#123;</span><br><span class="line">            ALOGW(<span class="string">"Failed to request next vsync, status=%d"</span>, status);</span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mWaitingForVsync = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//frameworks/native/libs/gui/DisplayEventReceiver.cpp</span></span><br><span class="line"><span class="comment">//通过IDisplayEventConnection接口来请求Vsync信号，IDisplayEventConnection实现了Binder通信框架，可以跨进程调用。</span></span><br><span class="line"><span class="comment">//因为Vsync信号请求进程和Vsync产生进程有可能不在同一个进程空间，因此这里就借助IDisplayEventConnection接口来实现。</span></span><br><span class="line"><span class="keyword">status_t</span> DisplayEventReceiver::requestNextVsync() &#123;</span><br><span class="line">    <span class="keyword">if</span> (mEventConnection != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mEventConnection-&gt;requestNextVsync();</span><br><span class="line">        <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO_INIT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="NativeDisplayEventReceiver处理消息"><a href="#NativeDisplayEventReceiver处理消息" class="headerlink" title="NativeDisplayEventReceiver处理消息"></a>NativeDisplayEventReceiver处理消息</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//NativeDisplayEventReceiver处理消息</span></span><br><span class="line"><span class="keyword">int</span> NativeDisplayEventReceiver::handleEvent(<span class="keyword">int</span> receiveFd, <span class="keyword">int</span> events, <span class="keyword">void</span>* data) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">nsecs_t</span> vsyncTimestamp;</span><br><span class="line">    <span class="keyword">int32_t</span> vsyncDisplayId;</span><br><span class="line">    <span class="keyword">uint32_t</span> vsyncCount;</span><br><span class="line">    <span class="comment">//过滤出最后一次的vsync</span></span><br><span class="line">    <span class="keyword">if</span> (processPendingEvents(&amp;vsyncTimestamp, &amp;vsyncDisplayId, &amp;vsyncCount)) &#123;</span><br><span class="line">        mWaitingForVsync = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//分发Vsync，调用到native的android/view/DisplayEventReceiver.class的dispatchVsync方法</span></span><br><span class="line">        dispatchVsync(vsyncTimestamp, vsyncDisplayId, vsyncCount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="DisplayEventReceiver分发VSYNC信号"><a href="#DisplayEventReceiver分发VSYNC信号" class="headerlink" title="DisplayEventReceiver分发VSYNC信号"></a>DisplayEventReceiver分发VSYNC信号</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DisplayEventReceiver</span> </span>&#123;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onVsync</span><span class="params">(<span class="keyword">long</span> timestampNanos, <span class="keyword">int</span> builtInDisplayId, <span class="keyword">int</span> frame)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Called from native code.</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchVsync</span><span class="params">(<span class="keyword">long</span> timestampNanos, <span class="keyword">int</span> builtInDisplayId, <span class="keyword">int</span> frame)</span> </span>&#123;</span><br><span class="line">        onVsync(timestampNanos, builtInDisplayId, frame);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FrameDisplayEventReceiver</span> <span class="keyword">extends</span> <span class="title">DisplayEventReceiver</span></span></span><br><span class="line"><span class="class">            <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mHavePendingVsync;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> mTimestampNanos;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mFrame;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onVsync</span><span class="params">(<span class="keyword">long</span> timestampNanos, <span class="keyword">int</span> builtInDisplayId, <span class="keyword">int</span> frame)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//忽略来自第二显示屏的Vsync</span></span><br><span class="line">        <span class="keyword">if</span> (builtInDisplayId != SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN) &#123;</span><br><span class="line">            scheduleVsync();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/***部分代码省略***/</span></span><br><span class="line">        mTimestampNanos = timestampNanos;</span><br><span class="line">        mFrame = frame;</span><br><span class="line">        <span class="comment">//该消息的callback为当前对象FrameDisplayEventReceiver</span></span><br><span class="line">        Message msg = Message.obtain(mHandler, <span class="keyword">this</span>);</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">        mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mHavePendingVsync = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//DisplayEventReceiver消息处理</span></span><br><span class="line">        doFrame(mTimestampNanos, mFrame);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="DisplayEventReceiver消息处理"><a href="#DisplayEventReceiver消息处理" class="headerlink" title="DisplayEventReceiver消息处理"></a>DisplayEventReceiver消息处理</h2><blockquote>
<p>参见<code>4.2.1、doFrame</code>介绍</p>
</blockquote>
<h1 id="Choreographer处理回调"><a href="#Choreographer处理回调" class="headerlink" title="Choreographer处理回调"></a>Choreographer处理回调</h1><h2 id="Choreographer触发可执行任务的回调"><a href="#Choreographer触发可执行任务的回调" class="headerlink" title="Choreographer触发可执行任务的回调"></a>Choreographer触发可执行任务的回调</h2><blockquote>
<p>这里为什么说可执行任务呢？因为每个任务都有自己的触发时间，<code>Choreographer</code>只选择它能触发的任务。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Choreographer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//进行回调的标识</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mCallbacksRunning;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doCallbacks</span><span class="params">(<span class="keyword">int</span> callbackType, <span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</span><br><span class="line">        CallbackRecord callbacks;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">            <span class="comment">//找到当前能触发的回调链表</span></span><br><span class="line">            callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked(now);</span><br><span class="line">            <span class="keyword">if</span> (callbacks == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mCallbacksRunning = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (CallbackRecord c = callbacks; c != <span class="keyword">null</span>; c = c.next) &#123;</span><br><span class="line">                <span class="comment">//循环遍历，回调所有的任务</span></span><br><span class="line">                c.run(frameTimeNanos);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">                mCallbacksRunning = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">final</span> CallbackRecord next = callbacks.next;</span><br><span class="line">                    recycleCallbackLocked(callbacks);</span><br><span class="line">                    callbacks = next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (callbacks != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//回收回调任务资源</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recycleCallbackLocked</span><span class="params">(CallbackRecord callback)</span> </span>&#123;</span><br><span class="line">        callback.action = <span class="keyword">null</span>;</span><br><span class="line">        callback.token = <span class="keyword">null</span>;</span><br><span class="line">        callback.next = mCallbackPool;</span><br><span class="line">        mCallbackPool = callback;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CallbackQueue</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> CallbackRecord <span class="title">extractDueCallbacksLocked</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">            CallbackRecord callbacks = mHead;</span><br><span class="line">            <span class="comment">//当链表头部的任务触发事件都比当前时间晚，那么整个链表则没有任务需要触发</span></span><br><span class="line">            <span class="keyword">if</span> (callbacks == <span class="keyword">null</span> || callbacks.dueTime &gt; now) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            CallbackRecord last = callbacks;</span><br><span class="line">            CallbackRecord next = last.next;</span><br><span class="line">            <span class="comment">//找到当前时间之前需要触发任务链表，将该链表截断并返回</span></span><br><span class="line">            <span class="keyword">while</span> (next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (next.dueTime &gt; now) &#123;</span><br><span class="line">                    last.next = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                last = next;</span><br><span class="line">                next = next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//mHead重置为原始链表截断的头部</span></span><br><span class="line">            mHead = next;</span><br><span class="line">            <span class="keyword">return</span> callbacks;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="处理Choreographer回调"><a href="#处理Choreographer回调" class="headerlink" title="处理Choreographer回调"></a>处理Choreographer回调</h2><p><code>3、Choreographer的使用</code>部分讲述了<code>ViewRootImpl</code>使用<code>Choreographer</code>的使用，那么我们现在来看一下<code>ViewRootImpl</code>对<code>Choreographer</code>回调时间的处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewRootImpl</span> <span class="keyword">implements</span> <span class="title">ViewParent</span>,</span></span><br><span class="line"><span class="class">        <span class="title">View</span>.<span class="title">AttachInfo</span>.<span class="title">Callbacks</span>, <span class="title">HardwareRenderer</span>.<span class="title">HardwareDrawCallbacks</span> </span>&#123;</span><br><span class="line">    Choreographer mChoreographer;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ViewRootImpl</span><span class="params">(Context context, Display display)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/***部分代码省略***/</span></span><br><span class="line">        mChoreographer = Choreographer.getInstance();</span><br><span class="line">        <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***部分代码省略***/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">            mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">            mTraversalBarrier = mHandler.getLooper().postSyncBarrier();</span><br><span class="line">            mChoreographer.postCallback(</span><br><span class="line">                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (!mUnbufferedInputDispatch) &#123;</span><br><span class="line">                scheduleConsumeBatchedInput();</span><br><span class="line">            &#125;</span><br><span class="line">            notifyRendererOfFramePending();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//开始View的测量、布局、绘制</span></span><br><span class="line">            doTraversal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> TraversalRunnable mTraversalRunnable = <span class="keyword">new</span> TraversalRunnable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>整片文章单独看起来留下的印象不是很深刻，以前阅读过 <a href="http://dandanlove.com/2018/04/13/android-16ms/" target="_blank" rel="noopener">Android的16ms和垂直同步以及三重缓存</a> 这篇文章之后就会知道本文章是对  <a href="http://dandanlove.com/2018/04/13/android-16ms/" target="_blank" rel="noopener">Android的16ms和垂直同步以及三重缓存</a>  这篇文章其中的一些疑问进行解答。从代码的角度讲述了android的屏幕绘制部分知识。</p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>VSYNC</tag>
        <tag>Choreographer</tag>
      </tags>
  </entry>
  <entry>
    <title>Android的16ms和垂直同步以及三重缓存</title>
    <url>/2018/04/13/android-16ms/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>手机屏幕是由许多的像素点组成的，每个像素点通过显示不同的颜色最终屏幕呈现各种各样的图像。手机系统的类型和手机硬件的不同导致UI的流畅性体验个不一致。</p>
<h1 id="屏幕展示的颜色数据"><a href="#屏幕展示的颜色数据" class="headerlink" title="屏幕展示的颜色数据"></a>屏幕展示的颜色数据</h1><blockquote>
<ul>
<li>在GPU中有一块缓冲区叫做 Frame Buffer ,这个帧缓冲区可以认为是存储像素值的二位数组。</li>
<li>数组中的每一个值就对应了手机屏幕的像素点需要显示的颜色。</li>
<li>由于这个帧缓冲区的数值是在不断变化的,所以只要完成对屏幕的刷新就可以显示不同的图像了.。</li>
<li>至于刷新工作手记的逻辑电路会定期的刷新 Frame Buffer的 目前主流的刷新频率为60次/秒  折算出来就是16ms刷新一次。</li>
</ul>
</blockquote>
<h2 id="GPU的Frame-Buffer中的数据"><a href="#GPU的Frame-Buffer中的数据" class="headerlink" title="GPU的Frame Buffer中的数据"></a>GPU的Frame Buffer中的数据</h2><blockquote>
<ul>
<li>GPU 除了帧缓冲区用以交给手机屏幕进行绘制外. 还有一个缓冲区 Back Buffer 这个用以交给应用的,让CPU往里面填充数据。</li>
<li>GPU会定期交换 Back Buffer 和 Frame Buffer ，也就是对Back Buffer中的数据进行栅格化后将其转到 Frame Buffer 然后交给屏幕进行显示绘制，同时让原先的Frame Buffer 变成 Back Buffer 让程序处理。</li>
</ul>
</blockquote>
<h1 id="Android的16ms"><a href="#Android的16ms" class="headerlink" title="Android的16ms"></a>Android的16ms</h1><p>在Android中我们一般都会提到<code>16ms</code>绘制一次，那么到底是那里控制这16ms的呢？</p>
<p>在<code>Choreographer</code>类中我们有一个方法获取屏幕刷新速率：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Choreographer</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">float</span> <span class="title">getRefreshRate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DisplayInfo di = DisplayManagerGlobal.getInstance().getDisplayInfo(</span><br><span class="line">                Display.DEFAULT_DISPLAY);</span><br><span class="line">        <span class="keyword">return</span> di.refreshRate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Describes the characteristics of a particular logical display.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DisplayInfo</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The refresh rate of this display in frames per second.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The value of this field is indeterminate if the logical display is presented on</span></span><br><span class="line"><span class="comment">     * more than one physical display.</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> refreshRate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">VirtualDisplayAdapter</span> <span class="keyword">extends</span> <span class="title">DisplayAdapter</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">VirtualDisplayDevice</span> <span class="keyword">extends</span> <span class="title">DisplayDevice</span> <span class="keyword">implements</span> <span class="title">DeathRecipient</span> </span>&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> DisplayDeviceInfo <span class="title">getDisplayDeviceInfoLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (mInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mInfo = <span class="keyword">new</span> DisplayDeviceInfo();</span><br><span class="line">                mInfo.name = mName;</span><br><span class="line">                mInfo.uniqueId = getUniqueId();</span><br><span class="line">                mInfo.width = mWidth;</span><br><span class="line">                mInfo.height = mHeight;</span><br><span class="line">                mInfo.refreshRate = <span class="number">60</span>;</span><br><span class="line">                <span class="comment">/***部分代码省略***/</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> mInfo;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一秒60帧，计算下来大概16.7ms一帧。</p>
<h1 id="屏幕绘制"><a href="#屏幕绘制" class="headerlink" title="屏幕绘制"></a>屏幕绘制</h1><p>作为严重影响Android口碑问题之一的UI流畅性差的问题，首先在Android 4.1版本中得到了有效处理。其解决方法就是本文要介绍的Project Butter。</p>
<p>Project Butter对Android Display系统进行了重构，引入了三个核心元素，即VSYNC、Triple Buffer和Choreographer。其中， VSYNC是理解Project Buffer的核心。VSYNC是Vertical Synchronization（垂直同步）的缩写，是一种在PC上已经很早就广泛使用的技术。 可简单的把它认为是一种定时中断。</p>
<p>接下来，将围绕VSYNC来介绍Android Display系统的工作方式。请注意，后续讨论将以Display为基准，将其划分成16ms长度的时间段， 在每一时间段中，Display显示一帧数据（相当于每秒60帧）。时间段从1开始编号。</p>
<h2 id="没有VSYNC的情况"><a href="#没有VSYNC的情况" class="headerlink" title="没有VSYNC的情况:"></a>没有VSYNC的情况:</h2><center><img src="http://upload-images.jianshu.io/upload_images/1319879-f60a862bb3158ef8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></center>

<p>由上图可知</p>
<p>1.时间从0开始，进入第一个16ms：Display显示第0帧，CPU处理完第一帧后，GPU紧接其后处理继续第一帧。三者互不干扰，一切正常。 2.时间进入第二个16ms：因为早在上一个16ms时间内，第1帧已经由CPU，GPU处理完毕。故Display可以直接显示第1帧。显示没有问题。但在本16ms期间，CPU和GPU 却并未及时去绘制第2帧数据（注意前面的空白区），而是在本周期快结束时，CPU/GPU才去处理第2帧数据。 3.时间进入第3个16ms，此时Display应该显示第2帧数据，但由于CPU和GPU还没有处理完第2帧数据，故Display只能继续显示第一帧的数据，结果使得第1 帧多画了一次（对应时间段上标注了一个Jank）。 4.通过上述分析可知，此处发生Jank的关键问题在于，为何第1个16ms段内，CPU/GPU没有及时处理第2帧数据？原因很简单，CPU可能是在忙别的事情（比如某个应用通过sleep 固定时间来实现动画的逐帧显示），不知道该到处理UI绘制的时间了。可CPU一旦想起来要去处理第2帧数据，时间又错过了！</p>
<h2 id="NSYNC的出现"><a href="#NSYNC的出现" class="headerlink" title="NSYNC的出现"></a>NSYNC的出现</h2><p>为解决这个问题，Project Buffer引入了VSYNC，这类似于时钟中断。结果如图所示：</p>
<center><img src="http://upload-images.jianshu.io/upload_images/1319879-3d4fc1008f41584a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></center>

<p>由图可知，每收到VSYNC中断，CPU就开始处理各帧数据。整个过程非常完美。 不过，仔细琢磨图2却会发现一个新问题：图2中，CPU和GPU处理数据的速度似乎都能在16ms内完成，而且还有时间空余，也就是说，CPU/GPU的FPS（帧率，Frames Per Second）要高于Display的FPS。确实如此。由于CPU/GPU只在收到VSYNC时才开始数据处理，故它们的FPS被拉低到与Display的FPS相同。但这种处理并没有什么问题，因为Android设备的Display FPS一般是60，其对应的显示效果非常平滑。 如果CPU/GPU的FPS小于Display的FPS，会是什么情况呢？请看下图：</p>
<center><img src="http://upload-images.jianshu.io/upload_images/1319879-9d0cacdee6305ec9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></center>

<p>由图可知： 1.在第二个16ms时间段，Display本应显示B帧，但却因为GPU还在处理B帧，导致A帧被重复显示。 2.同理，在第二个16ms时间段内，CPU无所事事，因为A Buffer被Display在使用。B Buffer被GPU在使用。注意，一旦过了VSYNC时间点， CPU就不能被触发以处理绘制工作了。</p>
<h2 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h2><p>为什么CPU不能在第二个16ms处开始绘制工作呢？原因就是只有两个Buffer。如果有第三个Buffer的存在，CPU就能直接使用它， 而不至于空闲。出于这一思路就引出了Triple Buffer。结果如图所示：</p>
<center><img src="http://upload-images.jianshu.io/upload_images/1319879-ac8a796f5d898625.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></center>

<p>由图可知： 第二个16ms时间段，CPU使用C Buffer绘图。虽然还是会多显示A帧一次，但后续显示就比较顺畅了。 是不是Buffer越多越好呢？回答是否定的。由图4可知，在第二个时间段内，CPU绘制的第C帧数据要到第四个16ms才能显示， 这比双Buffer情况多了16ms延迟。所以，Buffer最好还是两个，三个足矣。</p>
<p>以上对VSYNC进行了理论分析，其实也引出了Project Buffer的三个关键点： 核心关键：需要VSYNC定时中断。 Triple Buffer：当双Buffer不够使用时，该系统可分配第三块Buffer。 另外，还有一个非常隐秘的关键点：即将绘制工作都统一到VSYNC时间点上。这就是Choreographer的作用。在它的统一指挥下，应用的绘制工作都将变得井井有条。</p>
<p>转自MrlLeed的： <a href="http://www.apkbus.com/blog-705730-61226.html" target="_blank" rel="noopener">Android垂直同步和三重缓存</a></p>
<p>如果有对源码有兴趣的话可以继续阅读另一篇文章：<a href="http://dandanlove.com/2018/04/25/android-source-choreographer/" target="_blank" rel="noopener">Android系统的编舞者Choreographer</a></p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>16ms</tag>
        <tag>VSYNC</tag>
      </tags>
  </entry>
  <entry>
    <title>寻找红黑树的操作手册</title>
    <url>/2018/03/18/red-black-tree/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="http://dandanlove.com/2017/10/20/about-binary-tree/" target="_blank" rel="noopener">二叉树知识点回忆以及整理</a>这篇文章中我们说过“二叉树是一个简单的二分查找，但其性能取决于二叉树的层数”。</p>
<ul>
<li>最好的情况是O(logn),存在于完全二叉树情况下，其访问性能近似于折半查找；</li>
<li>最差的情况是O(n),比如插入的元素所有节点都没有左子树（右子树），这种情况需要将二叉树的全部节点遍历一次。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzEzMTk4NzktYzgyN2YwYjg2ZjUxNzk3ZS5wbmc?x-oss-process=image/format,png#pic_center" alt="二叉排序树"></li>
</ul>
<p>红黑树本质上是一种二叉查找树，在节点类中添加类一个用来标识颜色的字段，同时具有一定的规则。同时具备这亮点使得红黑树的性能达到理想中的均衡状态（插入、删除、查找的最坏时间负责度为O(logn)）。</p>
<p>在Java1.8中HashMap使用的就是链表和红黑树，<a href="http://dandanlove.com/2017/10/27/late-one-year-hashmap/" target="_blank" rel="noopener">迟到一年HashMap解读</a>。Java集合中的TreeSet和TreeMap，C++ STL中的set、map，以及Linux虚拟内存的管理，都是通过红黑树去实现的。</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>红黑树（英语：Red–black tree）是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组。它是在1972年由鲁道夫·贝尔发明的，他称之为”对称二叉B树”，它现代的名字是在Leo J. Guibas和Robert Sedgewick于1978年写的一篇论文中获得的。它是复杂的，但它的操作有着良好的最坏情况运行时间，并且在实践中是高效的：它可以在 O(logn)时间内做查找，插入和删除，这里的n是树中元素的数目，<a href="https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91" target="_blank" rel="noopener">摘自：维基百科-红黑树</a>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RBTree</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> RBNode&lt;T&gt; mRoot = <span class="keyword">null</span>;    <span class="comment">// 根结点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> RED = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> BLACK = <span class="keyword">false</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">RBNode</span> &lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">//颜色</span></span><br><span class="line">        <span class="keyword">boolean</span> color;</span><br><span class="line">        <span class="comment">//关键字（键值）</span></span><br><span class="line">        T key;</span><br><span class="line">        <span class="comment">//左子节点</span></span><br><span class="line">        RBNode&lt;T&gt; left;</span><br><span class="line">        <span class="comment">//右子节点</span></span><br><span class="line">        RBNode&lt;T&gt; right;</span><br><span class="line">        <span class="comment">//父节点</span></span><br><span class="line">        RBNode&lt;T&gt; parent;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">RBNode</span><span class="params">(T key, <span class="keyword">boolean</span> color, RBNode&lt;T&gt; parent, RBNode&lt;T&gt; left, RBNode&lt;T&gt; right)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.color = color;</span><br><span class="line">            <span class="keyword">this</span>.parent = parent;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span> + key + (<span class="keyword">this</span>.color == RED ? <span class="string">"RED"</span> : <span class="string">"BLACK"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="红黑树特点"><a href="#红黑树特点" class="headerlink" title="红黑树特点"></a>红黑树特点</h1><blockquote>
<ul>
<li>1、每个节点不是红色就是黑色的；</li>
<li>2、根节点总是黑色的；</li>
<li>3、所有的叶节点都是是黑色的（红黑树的叶子节点都是空节点（NIL或者NULL））；</li>
<li>4、如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；</li>
<li>5、从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。</li>
</ul>
</blockquote>
<p>需要注意：</p>
<blockquote>
<p>特性3中的叶子节点，是只为空(NIL或null)的节点。<br>特性5，确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树。</p>
</blockquote>
<h1 id="红黑树的修正"><a href="#红黑树的修正" class="headerlink" title="红黑树的修正"></a>红黑树的修正</h1><blockquote>
<p>变色、左旋、右旋是红黑树在二叉树上的扩展操作，同时也是基于这三个操作才能遵守红黑树的五个特性。所以熟悉二叉树操作的同学只要掌握这红黑树这三个操作那么就能更加容易的理解进行红黑树的添加和删除之后怎么保证其平衡性，不熟悉二叉树的也可以先看看<a href="http://dandanlove.com/2017/10/20/about-binary-tree/" target="_blank" rel="noopener">《二叉树知识点回忆以及整理》</a>这片文章。</p>
</blockquote>
<h2 id="变色"><a href="#变色" class="headerlink" title="变色"></a>变色</h2><blockquote>
<p>变色仅仅指的是红黑树节点的变色。因为红黑树节点必须是【红】或者【黑】这两中颜色，所以变色只是将当前的节点颜色进行变化，以满足特性（2，3，4，5）。</p>
</blockquote>
<h2 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h2><p>通常左旋操作用于将一个向右倾斜的红色链接旋转为向左链接。示意图如下：<br><img src="https://img-blog.csdnimg.cn/20191224152901205.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kYW5kYW5sb3ZlLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>左旋操作动画（更加容易理解和记忆）：<br><img src="https://img-blog.csdnimg.cn/20191224152932810.gif#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************对红黑树节点x进行左旋操作 ******************/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 左旋示意图：对节点x进行左旋</span></span><br><span class="line"><span class="comment"> *     p                       p</span></span><br><span class="line"><span class="comment"> *    /                       /</span></span><br><span class="line"><span class="comment"> *   x                       y</span></span><br><span class="line"><span class="comment"> *  / \                     / \</span></span><br><span class="line"><span class="comment"> * lx  y      -----&gt;       x  ry</span></span><br><span class="line"><span class="comment"> *    / \                 / \</span></span><br><span class="line"><span class="comment"> *   ly ry               lx ly</span></span><br><span class="line"><span class="comment"> * 左旋做了三件事：</span></span><br><span class="line"><span class="comment"> * 1. 将y的左子节点赋给x的右子节点,并将x赋给y左子节点的父节点(y左子节点非空时)</span></span><br><span class="line"><span class="comment"> * 2. 将x的父节点p(非空时)赋给y的父节点，同时更新p的子节点为y(左或右)</span></span><br><span class="line"><span class="comment"> * 3. 将y的左子节点设为x，将x的父节点设为y</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leftRotate</span><span class="params">(RBNode&lt;T&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//1. 将y的左子节点赋给x的右子节点,并将x赋给y左子节点的父节点(y左子节点非空时)</span></span><br><span class="line">    RBNode&lt;T&gt; y = x.right;</span><br><span class="line">    x.right = y.left;</span><br><span class="line">    <span class="keyword">if</span> (y.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        y.left.parent = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 将x的父节点p(非空时)赋给y的父节点，同时更新p的子节点为y(左或右)</span></span><br><span class="line">    y.parent = x.parent;</span><br><span class="line">    <span class="keyword">if</span> (x.parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//mRoot是RBTree的根节点</span></span><br><span class="line">        <span class="keyword">this</span>.mRoot = y;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == x.parent.left) &#123;</span><br><span class="line">            x.parent.left = y;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            x.parent.right = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3. 将y的左子节点设为x，将x的父节点设为y</span></span><br><span class="line">    y.left = x;</span><br><span class="line">    x.parent = y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h2><p>右旋可左旋刚好相反，这里不再赘述，直接看示意图：<br><img src="https://img-blog.csdnimg.cn/20191224153005170.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kYW5kYW5sb3ZlLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>右旋操作动画（更加容易理解和记忆）：<br><img src="https://img-blog.csdnimg.cn/20191224153029893.gif#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************对红黑树节点y进行右旋操作 ******************/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 右旋示意图：对节点y进行右旋</span></span><br><span class="line"><span class="comment"> *        p                   p</span></span><br><span class="line"><span class="comment"> *       /                   /</span></span><br><span class="line"><span class="comment"> *      y                   x</span></span><br><span class="line"><span class="comment"> *     / \                 / \</span></span><br><span class="line"><span class="comment"> *    x  ry   -----&gt;      lx  y</span></span><br><span class="line"><span class="comment"> *   / \                     / \</span></span><br><span class="line"><span class="comment"> * lx  rx                   rx ry</span></span><br><span class="line"><span class="comment"> * 右旋做了三件事：</span></span><br><span class="line"><span class="comment"> * 1. 将x的右子节点赋给y的左子节点,并将y赋给x右子节点的父节点(x右子节点非空时)</span></span><br><span class="line"><span class="comment"> * 2. 将y的父节点p(非空时)赋给x的父节点，同时更新p的子节点为x(左或右)</span></span><br><span class="line"><span class="comment"> * 3. 将x的右子节点设为y，将y的父节点设为x</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rightRotate</span><span class="params">(RBNode&lt;T&gt; y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (y == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//1. 将x的右子节点赋给y的左子节点,并将y赋给x右子节点的父节点(x右子节点非空时)</span></span><br><span class="line">    RBNode&lt;T&gt; x = y.left;</span><br><span class="line">    y.left = x.right;</span><br><span class="line">    <span class="keyword">if</span> (x.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        x.right.parent = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 将y的父节点p(非空时)赋给x的父节点，同时更新p的子节点为x(左或右)</span></span><br><span class="line">    x.parent = y.parent;</span><br><span class="line">    <span class="keyword">if</span> (y.parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.mRoot = x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (y == y.parent.left) &#123;</span><br><span class="line">            y.parent.left = x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            y.parent.right = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3. 将x的右子节点设为y，将y的父节点设为x</span></span><br><span class="line">    x.right = y;</span><br><span class="line">    y.parent = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="红黑树节点的添加"><a href="#红黑树节点的添加" class="headerlink" title="红黑树节点的添加"></a>红黑树节点的添加</h1><p>红黑树是在二叉树的基础上进行扩展的，其添加节点也是像二叉树一样进行添加，然后再做调整。<a href="http://dandanlove.com/2017/10/20/about-binary-tree/" target="_blank" rel="noopener">二叉树知识点回忆以及整理#创建二叉树</a> 这部分讲述了二叉树节点的添加。所以这里我们重点讲述二叉树的添加完后的调整。</p>
<blockquote>
<ul>
<li>红黑树的第 5 条特征规定，任一节点到它子树的每个叶子节点的路径中都包含同样数量的黑节点。也就是说当我们往红黑树中插入一个黑色节点时，会违背这条特征。</li>
<li>同时第 4 条特征规定红色节点的左右孩子一定都是黑色节点，当我们给一个红色节点下插入一个红色节点时，会违背这条特征。</li>
</ul>
</blockquote>
<blockquote>
<p>因此我们需要在插入黑色节点后进行结构调整，保证红黑树始终满足这 5 条特征。</p>
</blockquote>
<h1 id="红黑树插入后节点的调整思想"><a href="#红黑树插入后节点的调整思想" class="headerlink" title="红黑树插入后节点的调整思想"></a>红黑树插入后节点的调整思想</h1><blockquote>
<p>数学里最常用的一个解题技巧就是把多个未知数化解成一个未知数。</p>
</blockquote>
<p>我们插入黑色节点的时候担心违背第5条，插入红色节点时担心违背第4条，所以我们将将插入的节点改为红色，然后判断插入的节点的父亲是不是红色，是的话进行修改调整（变色、左旋、右旋）。同时在调整的过程中我们需要遵守<code>5条特性</code>。</p>
<p>因为左右子树的操作是对称的，我们下边讲述需要添加的节点的父节点是祖父节点的左孩子的情况，右子树添加与其相反。</p>
<blockquote>
<ul>
<li>1、如果我们添加的【红色节点】的【父节点】是黑色，那么树不需要做调整。</li>
<li>2、如果我们添加的【红色节点】的【父节点】是红色，那么树需要做调整。<ul>
<li>1）、父节点是红色，叔叔节点（父节点的兄弟节点）是红色的。</li>
<li>2）、父节点是红色，叔叔节点是黑色，添加的节点是父节点的左孩子。</li>
<li>3）、父节点是红色，叔叔节点是黑色，添加的节点是父节点的右孩子。</li>
</ul>
</li>
</ul>
</blockquote>
<p><code>父节点是黑色，祖父节点一定是黑色的，因为红色节点的父节点不可能是红色（特性4:每个红色节点的两个子节点一定都是黑色）。</code></p>
<h2 id="调整-情况（1）：父节点是红色，叔叔节点（父节点的兄弟节点）是红色的。"><a href="#调整-情况（1）：父节点是红色，叔叔节点（父节点的兄弟节点）是红色的。" class="headerlink" title="调整-情况（1）：父节点是红色，叔叔节点（父节点的兄弟节点）是红色的。"></a>调整-情况（1）：父节点是红色，叔叔节点（父节点的兄弟节点）是红色的。</h2><p>下图是这样情况的红黑树的修改过程（上边是目标节点为左孩子，下边是目标节点是右孩子）：</p>
<p><img src="https://img-blog.csdnimg.cn/20191224153143480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kYW5kYW5sb3ZlLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>为了新添加的节点也满足特性4:</p>
<ul>
<li>将父节点和叔叔节点全部染成黑色（节点T满足了特性四），但是这样父亲和叔叔节点的分支都多了一个黑色；</li>
<li>将祖父节点染成红色，这样祖父节点的两个分支满足了所有特性，但是我们需要检验祖父节点是否符合红黑树的特性；</li>
<li>将祖父节点当前插入节点，继续向树根方向进行修改；</li>
</ul>
<p>这样我们一直向上循环，直到父节点变为黑色，或者达到树根为止。</p>
<h2 id="调整-情况（2）：父节点是红色，叔叔节点是黑色，添加的节点是父节点的左孩子。"><a href="#调整-情况（2）：父节点是红色，叔叔节点是黑色，添加的节点是父节点的左孩子。" class="headerlink" title="调整-情况（2）：父节点是红色，叔叔节点是黑色，添加的节点是父节点的左孩子。"></a>调整-情况（2）：父节点是红色，叔叔节点是黑色，添加的节点是父节点的左孩子。</h2><p>下图是这样情况的红黑树的修改过程:<br><img src="https://img-blog.csdnimg.cn/20191224153215672.png#pic_center" alt="在这里插入图片描述"></p>
<p>我们通过将祖父节点的左孩子分支上的连续两个红色节点，转移一个插入到祖父节点和他的右孩子之间（保证左边没有两个连续红点、右边插入的红点满足所有特性）。</p>
<ul>
<li>先将父节点染成黑色；</li>
<li>将祖父节点染成红色；</li>
<li>将父节点进行右旋；</li>
</ul>
<p>我们仅仅通过以上3个步骤就调整完使整个红黑树的节点满足5个特性。</p>
<h2 id="调整-情况（3）：父节点是红色，叔叔节点是黑色，添加的节点是父节点的右孩子。"><a href="#调整-情况（3）：父节点是红色，叔叔节点是黑色，添加的节点是父节点的右孩子。" class="headerlink" title="调整-情况（3）：父节点是红色，叔叔节点是黑色，添加的节点是父节点的右孩子。"></a>调整-情况（3）：父节点是红色，叔叔节点是黑色，添加的节点是父节点的右孩子。</h2><p>下图是这样情况的红黑树的修改过程:<br><img src="https://img-blog.csdnimg.cn/20191224153238966.png#pic_center" alt="在这里插入图片描述"></p>
<p>我们父节点进行左旋操作，这样就变成了<code>调整-情况（2）</code>的状态，然后再按照其调整操作继续进行调整。</p>
<blockquote>
<p>通过以上三个情况对红黑树的调整，我们可以解决红黑树插入红色节点中的所有问题。</p>
</blockquote>
<h1 id="红黑树插入代码实现："><a href="#红黑树插入代码实现：" class="headerlink" title="红黑树插入代码实现："></a>红黑树插入代码实现：</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*********************** 向红黑树中插入节点 **********************/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">    RBNode&lt;T&gt; node = <span class="keyword">new</span> RBNode&lt;&gt;(key, BLACK, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    insert(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、将节点插入到红黑树中，这个过程与二叉搜索树是一样的</span></span><br><span class="line"><span class="comment"> * 2、将插入的节点着色为"红色"；将插入的节点着色为红色，不会违背"特性5"！</span></span><br><span class="line"><span class="comment"> *    少违背了一条特性，意味着我们需要处理的情况越少。</span></span><br><span class="line"><span class="comment"> * 3、通过一系列的旋转或者着色等操作，使之重新成为一颗红黑树。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 插入的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(RBNode&lt;T&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//node的父节点</span></span><br><span class="line">    RBNode&lt;T&gt; current = <span class="keyword">null</span>;</span><br><span class="line">    RBNode&lt;T&gt; x = mRoot;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="keyword">null</span>) &#123;</span><br><span class="line">        current = x;</span><br><span class="line">        <span class="keyword">int</span> cmp = node.key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = x.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            x = x.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找到位置，将当前current作为node的父节点</span></span><br><span class="line">    node.parent = current;</span><br><span class="line">    <span class="comment">//2. 接下来判断node是插在左子节点还是右子节点</span></span><br><span class="line">    <span class="keyword">if</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = node.key.compareTo(current.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            current.left = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current.right = node;</span><br><span class="line">        &#125;</span><br><span class="line">        node.color = RED;</span><br><span class="line">        insertFixUp(node);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.mRoot = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改整插入node节点之后的红黑树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertFixUp</span><span class="params">(RBNode&lt;T&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义父节点和祖父节点</span></span><br><span class="line">    RBNode&lt;T&gt; parent, gparent;</span><br><span class="line">    <span class="comment">//需要修整的条件：父节点存在，且父节点的颜色是红色</span></span><br><span class="line">    <span class="keyword">while</span> (((parent = node.parent) != <span class="keyword">null</span>) &amp;&amp; isRed(parent)) &#123;</span><br><span class="line">        <span class="comment">//祖父节点</span></span><br><span class="line">        gparent = parent.parent;</span><br><span class="line">        <span class="comment">//若父节点是祖父节点的左子节点</span></span><br><span class="line">        <span class="keyword">if</span> (parent == gparent.left) &#123;</span><br><span class="line">            <span class="comment">//获取叔叔点点</span></span><br><span class="line">            RBNode&lt;T&gt; uncle = gparent.right;</span><br><span class="line">            <span class="comment">//case1:叔叔节点是红色</span></span><br><span class="line">            <span class="keyword">if</span> (uncle != <span class="keyword">null</span> &amp;&amp; isRed(uncle)) &#123;</span><br><span class="line">                <span class="comment">//把父亲和叔叔节点涂黑色</span></span><br><span class="line">                parent.color = BLACK;</span><br><span class="line">                uncle.color = BLACK;</span><br><span class="line">                <span class="comment">//把祖父节点图红色</span></span><br><span class="line">                gparent.color = RED;</span><br><span class="line">                <span class="comment">//将位置放到祖父节点</span></span><br><span class="line">                node = gparent;</span><br><span class="line">                <span class="comment">//继续往上循环判断</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//case2：叔叔节点是黑色，且当前节点是右子节点</span></span><br><span class="line">            <span class="keyword">if</span> (node == parent.right) &#123;</span><br><span class="line">                <span class="comment">//从父亲即诶单处左旋</span></span><br><span class="line">                leftRotate(parent);</span><br><span class="line">                <span class="comment">//将父节点和自己调换一下，为右旋左准备</span></span><br><span class="line">                RBNode&lt;T&gt; tmp = parent;</span><br><span class="line">                parent = node;</span><br><span class="line">                node = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//case3：叔叔节点是黑色，且当前节点是左子节点</span></span><br><span class="line">            parent.color = BLACK;</span><br><span class="line">            gparent.color = RED;</span><br><span class="line">            rightRotate(gparent);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//若父亲节点是祖父节点的右子节点，与上面的完全相反，本质一样的</span></span><br><span class="line">            RBNode&lt;T&gt; uncle = gparent.left;</span><br><span class="line">            <span class="comment">//case1:叔叔节点也是红色</span></span><br><span class="line">            <span class="keyword">if</span> (uncle != <span class="keyword">null</span> &amp; isRed(uncle)) &#123;</span><br><span class="line">                parent.color = BLACK;</span><br><span class="line">                uncle.color = BLACK;</span><br><span class="line">                gparent.color = RED;</span><br><span class="line">                node = gparent;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//case2: 叔叔节点是黑色的，且当前节点是左子节点</span></span><br><span class="line">            <span class="keyword">if</span> (node == parent.left) &#123;</span><br><span class="line">                rightRotate(parent);</span><br><span class="line">                RBNode&lt;T&gt; tmp = parent;</span><br><span class="line">                parent = node;</span><br><span class="line">                node = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//case3: 叔叔节点是黑色的，且当前节点是右子节点</span></span><br><span class="line">            parent.color = BLACK;</span><br><span class="line">            gparent.color = RED;</span><br><span class="line">            leftRotate(gparent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将根节点设置为黑色</span></span><br><span class="line">    <span class="keyword">this</span>.mRoot.color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="红黑树节点的删除"><a href="#红黑树节点的删除" class="headerlink" title="红黑树节点的删除"></a>红黑树节点的删除</h1><p>上面部分讨论了红黑树添加新节点，接下来的部分讲述红黑树的删除。红黑树的删除是红黑树操作中最重要的部分（为什么说最重要呢？因为它最难理解）。</p>
<p>同样红黑树的删除是在二叉树进行删除操作的基础上进行调整的，使之满足红黑树的所有特性。<br><a href="http://dandanlove.com/2017/10/20/about-binary-tree/" target="_blank" rel="noopener">二叉树知识点回忆以及整理#二叉树节点删除</a> 这部分讲述了二叉树节点的添加，所以这里我们重点讲述二叉树的添加完后的调整。</p>
<h2 id="二叉树节点删除的思路"><a href="#二叉树节点删除的思路" class="headerlink" title="二叉树节点删除的思路"></a>二叉树节点删除的思路</h2><blockquote>
<ul>
<li>如果要删除的节点正好是叶子节点，直接删除就 Ok 了；</li>
<li>如果要删除的节点还有子节点，就需要建立父节点和子节点的关系：<ul>
<li>如果只有左孩子或者右孩子，直接把这个孩子上移放到要删除的位置就好了；</li>
<li>如果有两个孩子，就需要选一个合适的孩子节点作为新的根节点，该节点称为 继承节点。（新节点要求比所有左子树要大、比右子树要小，我们可以选择左子树中的最大节点，或者选择右子树中的最小的节点。）</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="红黑树删除总纲"><a href="#红黑树删除总纲" class="headerlink" title="红黑树删除总纲"></a>红黑树删除总纲</h2><blockquote>
<p>我们需要在二叉树删除的思路上，再考虑对删除完后的树进行调整。还记得文章说过<code>数学里最常用的一个解题技巧就是把多个未知数化解成一个未知数。</code>这句话么？二叉树的删除分为两个大case或者三个小case。我们首先把这些case合并为一个case，再进行调整是不是就更加简单来？</p>
</blockquote>
<h2 id="红黑树删除之三派合并"><a href="#红黑树删除之三派合并" class="headerlink" title="红黑树删除之三派合并"></a>红黑树删除之三派合并</h2><p>上述将删除的步骤总结在一下就是：</p>
<ul>
<li>1、如果删除节点的左孩子和右孩子不同时为null，那么只需要让其子树继承删除该节点的位置；</li>
<li>2、如果删除的节点是叶子节点，我们直接进行调整；</li>
<li>假如删除节点的左右孩子都不是null，需要<code>后继节点</code>替换被删除的节点和值和颜色，这样才不会引起红黑树平衡的破坏，只需要对 <code>后继节点</code>删除后进行调整，这样我们就回归处理情况 1 和 2 的状态；<ul>
<li><code>后继节点</code>为左子树最右边的子叶节点</li>
<li><code>后继节点</code>为右子树最左边的叶子节点；</li>
</ul>
</li>
</ul>
<blockquote>
<p>如果需要删除的节点颜色为<code>红色</code>，那么红黑树的结构不被破坏，也就不需要进行调整。如果我们判断删除节点的颜色为<code>黑色</code>，那么就进行调整；</p>
</blockquote>
<p>代码以及解析：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*********************** 删除红黑树中的节点 **********************/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">    RBNode&lt;T&gt; node;</span><br><span class="line">    <span class="keyword">if</span> ((node = search(mRoot, key)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        remove(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、被删除的节点没有儿子，即删除的是叶子节点。那么，直接删除该节点。</span></span><br><span class="line"><span class="comment"> * 2、被删除的节点只有一个儿子。那么直接删除该节点，并用该节点的唯一子节点顶替它的初始位置。</span></span><br><span class="line"><span class="comment"> * 3、被删除的节点有两个儿子。那么先找出它的后继节点（右孩子中的最小的，该孩子没有子节点或者只有一右孩子）。</span></span><br><span class="line"><span class="comment"> *    然后把"它的后继节点的内容"复制给"该节点的内容"；之后，删除"它的后继节点"。</span></span><br><span class="line"><span class="comment"> *    在这里后继节点相当与替身，在将后继节点的内容复制给"被删除节点"之后，再将后继节点删除。</span></span><br><span class="line"><span class="comment"> *    ------这样问题就转化为怎么删除后继即节点的问题？</span></span><br><span class="line"><span class="comment"> *    在"被删除节点"有两个非空子节点的情况下，它的后继节点不可能是双子都非空。</span></span><br><span class="line"><span class="comment"> *    注：后继节点为补充被删除的节点；</span></span><br><span class="line"><span class="comment"> *    即：意味着"要么没有儿子，要么只有一个儿子"。</span></span><br><span class="line"><span class="comment"> *    若没有儿子，则回归到（1）。</span></span><br><span class="line"><span class="comment"> *    若只有一个儿子，则回归到（2）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node  需要删除的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(RBNode&lt;T&gt; node)</span> </span>&#123;</span><br><span class="line">    RBNode&lt;T&gt; child, parent;</span><br><span class="line">    <span class="keyword">boolean</span> color;</span><br><span class="line">    <span class="comment">//1、删除的节点的左右孩子都不为空</span></span><br><span class="line">    <span class="keyword">if</span> ((node.left != <span class="keyword">null</span>) &amp;&amp; (node.right != <span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="comment">//先找到被删除节点的后继节点，用它来取代被删除节点的位置</span></span><br><span class="line">        RBNode&lt;T&gt; replace = node;</span><br><span class="line">        <span class="comment">//1).获取后继节点[右孩子中的最小]</span></span><br><span class="line">        replace = replace.right;</span><br><span class="line">        <span class="keyword">while</span> (replace.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            replace = replace.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2).处理【后继节点的子节点】和【被删除节点的子节点】之间的关系</span></span><br><span class="line">        <span class="keyword">if</span> (node.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//要删除的节点不是根节点</span></span><br><span class="line">            <span class="keyword">if</span> (node == node.parent.left) &#123;</span><br><span class="line">                node.parent.left = replace;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.parent.right = replace;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mRoot = replace;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3).处理【后继节点的子节点】和【被删除节点的子节点】之间的关系</span></span><br><span class="line">        <span class="comment">//后继节点肯定不存在左子节点</span></span><br><span class="line">        child = replace.right;</span><br><span class="line">        parent = replace.parent;</span><br><span class="line">        <span class="comment">//保存后继节点的颜色</span></span><br><span class="line">        color = replace.color;</span><br><span class="line">        <span class="comment">//后继节点是被删除的节点</span></span><br><span class="line">        <span class="keyword">if</span> (parent == node) &#123;</span><br><span class="line">            parent =replace;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">                child.parent = parent;</span><br><span class="line">            &#125;</span><br><span class="line">            parent.left = child;</span><br><span class="line">            replace.right = node.right;</span><br><span class="line">            node.right.parent = replace;</span><br><span class="line">        &#125;</span><br><span class="line">        replace.parent = node.parent;</span><br><span class="line">        replace.color = node.color;</span><br><span class="line">        replace.left = node.left;</span><br><span class="line">        node.left.parent = replace;</span><br><span class="line">        <span class="comment">//4。如果移走的后继节点颜色是黑色，重新修正红黑树</span></span><br><span class="line">        <span class="keyword">if</span> (color == BLACK) &#123;</span><br><span class="line">            removeFixUp(child, parent);</span><br><span class="line">        &#125;</span><br><span class="line">        node = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//被删除的节点是叶子节点，或者只有一个孩子。</span></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            child = node.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            child = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        parent = node.parent;</span><br><span class="line">        <span class="comment">//保存"取代节点"的颜色</span></span><br><span class="line">        color = node.color;</span><br><span class="line">        <span class="keyword">if</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">            child.parent = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//"node节点"不是根节点</span></span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent.left == node) &#123;</span><br><span class="line">                parent.left = child;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent.right = child;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mRoot = child;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (color == BLACK) &#123;</span><br><span class="line">            removeFixUp(child, parent);</span><br><span class="line">        &#125;</span><br><span class="line">        node = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>完成删除操作后接下来进行我们的调整操作，看完上面代码后我们知道调整时需要传递的参数是<code>后继节点</code>和<code>删除的父节点</code>。</p>
<h2 id="红黑树删除之节点调整"><a href="#红黑树删除之节点调整" class="headerlink" title="红黑树删除之节点调整"></a>红黑树删除之节点调整</h2><p>删除后那么<code>后继节点</code>就成才删除节点的孩子，那么接下的过程中我们将<code>后继节点</code>定义<code>目标节点</code>。</p>
<p>下边我们讨论一下节点的颜色情况：因为当前节点的颜色一定是黑色的，我们只根据兄弟节点的颜色做讨论。</p>
<ul>
<li>1、当前节点是黑色的，且兄弟节点是红色的（那么父节点和兄弟节点的子节点肯定是黑色的）；</li>
<li>2、当前节点是黑色的，且兄弟节点是黑色的，<ul>
<li>1）、兄弟节点的两个子节点均为黑色的；</li>
<li>2）、兄弟节点的左子节点是红色，右子节点时黑色的；</li>
<li>3）、兄弟节点的右子节点是红色，左子节点任意颜色；</li>
</ul>
</li>
</ul>
<h4 id="调整情况（1）-当前节点是黑色的，且兄弟节点是红色的"><a href="#调整情况（1）-当前节点是黑色的，且兄弟节点是红色的" class="headerlink" title="调整情况（1）:当前节点是黑色的，且兄弟节点是红色的"></a>调整情况（1）:当前节点是黑色的，且兄弟节点是红色的</h4><p>下图是这样情况的红黑树的修改过程：<br><img src="https://img-blog.csdnimg.cn/20191224153433246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kYW5kYW5sb3ZlLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li>将父节点涂红，将兄弟节点涂黑，然后将当前节点的父节点进行支点左旋。这样就会转化为情况2中的某种状态。</li>
</ul>
<h3 id="调整情况（2）-当前节点是黑色的，且兄弟节点是黑色的"><a href="#调整情况（2）-当前节点是黑色的，且兄弟节点是黑色的" class="headerlink" title="调整情况（2）:当前节点是黑色的，且兄弟节点是黑色的"></a>调整情况（2）:当前节点是黑色的，且兄弟节点是黑色的</h3><h4 id="2-1、兄弟节点的左子节点是红色，右子节点时黑色的；"><a href="#2-1、兄弟节点的左子节点是红色，右子节点时黑色的；" class="headerlink" title="2.1、兄弟节点的左子节点是红色，右子节点时黑色的；"></a>2.1、兄弟节点的左子节点是红色，右子节点时黑色的；</h4><p>下图是这样情况的红黑树的修改过程：<br><img src="https://img-blog.csdnimg.cn/20191224153500801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kYW5kYW5sb3ZlLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li>将兄弟节点涂红，将当前节点指向其父节点，将其父节点指向当前节点的祖父节点，继续往树根递归判断以及调整；</li>
</ul>
<h4 id="2-2、兄弟节点的两个子节点均为黑色的；"><a href="#2-2、兄弟节点的两个子节点均为黑色的；" class="headerlink" title="2.2、兄弟节点的两个子节点均为黑色的；"></a>2.2、兄弟节点的两个子节点均为黑色的；</h4><p>下图是这样情况的红黑树的修改过程：<br><img src="https://img-blog.csdnimg.cn/20191224153536670.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kYW5kYW5sb3ZlLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li>把当前节点的兄弟节点涂红，把兄弟节点的左子节点涂黑，然后以兄弟节点作为支点做右旋操作。</li>
</ul>
<h4 id="2-3、兄弟节点的右子节点是红色，左子节点任意颜色；"><a href="#2-3、兄弟节点的右子节点是红色，左子节点任意颜色；" class="headerlink" title="2.3、兄弟节点的右子节点是红色，左子节点任意颜色；"></a>2.3、兄弟节点的右子节点是红色，左子节点任意颜色；</h4><p>下图是这样情况的红黑树的修改过程：<br><img src="https://img-blog.csdnimg.cn/20191224153615785.png#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li>把兄弟节点涂成父节点的颜色，再把父节点涂黑，把兄弟节点的右子节点涂黑，然后以当前节点的父节点为支点做左旋操作。</li>
</ul>
<h2 id="红黑树删除调整case总结-amp-代码实现"><a href="#红黑树删除调整case总结-amp-代码实现" class="headerlink" title="红黑树删除调整case总结&amp;代码实现"></a>红黑树删除调整case总结&amp;代码实现</h2><p>如果是从<code>case:1</code>开始发生的，可能<code>case:2，3，4</code>中的一种：如果是<code>case:2</code>，就不可能再出现<code>case:3和4</code>；如果是<code>case:3</code>，必然会导致<code>case:4</code>的出现；如果<code>case:2和3</code>都不是，那必然是<code>case:4</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 红黑树删除修正函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在从红黑树中删除插入节点之后(红黑树失去平衡)，再调用该函数；</span></span><br><span class="line"><span class="comment"> * 目的是将它重新塑造成一颗红黑树。</span></span><br><span class="line"><span class="comment"> * 如果当前待删除节点是红色的，它被删除之后对当前树的特性不会造成任何破坏影响。</span></span><br><span class="line"><span class="comment"> * 而如果被删除的节点是黑色的，这就需要进行进一步的调整来保证后续的树结构满足要求。</span></span><br><span class="line"><span class="comment"> * 这里我们只修正删除的节点是黑色的情况：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 调整思想：</span></span><br><span class="line"><span class="comment"> * 为了保证删除节点的父节点左右两边黑色节点数一致，需要重点关注父节点没删除的那一边节点是不是黑色。</span></span><br><span class="line"><span class="comment"> * 如果删除后父亲节点另一边比删除的一边黑色多，就要想办法搞到平衡。</span></span><br><span class="line"><span class="comment"> * 1、把父亲节点另一边（即删除节点的兄弟树）其中一个节点弄成红色，也少了一个黑色。</span></span><br><span class="line"><span class="comment"> * 2、或者把另一边多的节点（染成黑色）转过来一个</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1）、当前节点是黑色的，且兄弟节点是红色的（那么父节点和兄弟节点的子节点肯定是黑色的）；</span></span><br><span class="line"><span class="comment"> * 2）、当前节点是黑色的，且兄弟节点是黑色的，且兄弟节点的两个子节点均为黑色的；</span></span><br><span class="line"><span class="comment"> * 3）、当前节点是黑色的，且兄弟节点是黑色的，且兄弟节点的左子节点是红色，右子节点时黑色的；</span></span><br><span class="line"><span class="comment"> * 4）、当前节点是黑色的，且兄弟节点是黑色的，且兄弟节点的右子节点是红色，左子节点任意颜色。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 以上四种情况中，2，3，4都是（当前节点是黑色的，且兄弟节点是黑色的）的子集。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 删除之后代替的节点（后序节点）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parent 后序节点的父节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeFixUp</span><span class="params">(RBNode&lt;T&gt; node, RBNode&lt;T&gt; parent)</span> </span>&#123;</span><br><span class="line">    RBNode&lt;T&gt; other;</span><br><span class="line">    RBNode&lt;T&gt; root = mRoot;</span><br><span class="line">    <span class="keyword">while</span> ((node == <span class="keyword">null</span> || node.color == BLACK) &amp;&amp; node != root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent.left == node) &#123;</span><br><span class="line">            other = parent.right;</span><br><span class="line">            <span class="keyword">if</span> (other.color == RED) &#123;</span><br><span class="line">                <span class="comment">//case 1：x的兄弟w是红色的【对应状态1，将其转化为2，3，4】</span></span><br><span class="line">                other.color = BLACK;</span><br><span class="line">                parent.color = RED;</span><br><span class="line">                leftRotate(parent);</span><br><span class="line">                other = parent.right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((other.left == <span class="keyword">null</span> || other.left.color == BLACK)</span><br><span class="line">                    &amp;&amp; (other.right == <span class="keyword">null</span> || other.right.color == BLACK)) &#123;</span><br><span class="line">                <span class="comment">//case 2：x的兄弟w是黑色，且w的两个孩子都是黑色的【对应状态2，利用调整思想1网树的根部做递归】</span></span><br><span class="line">                other.color = RED;</span><br><span class="line">                node = parent;</span><br><span class="line">                parent = node.parent;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (other.right == <span class="keyword">null</span> || other.right.color == BLACK) &#123;</span><br><span class="line">                    <span class="comment">//case 3:x的兄弟w是黑色的，并且w的左孩子是红色的，右孩子是黑色的【对应状态3，调整到状态4】</span></span><br><span class="line">                    other.left.color = BLACK;</span><br><span class="line">                    other.color = RED;</span><br><span class="line">                    rightRotate(other);</span><br><span class="line">                    other = parent.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//case 4:x的兄弟w是黑色的；并且w的右孩子是红色的，左孩子任意颜色【对应状态4，利用调整思想2做调整】</span></span><br><span class="line">                other.color = parent.color;</span><br><span class="line">                parent.color = BLACK;</span><br><span class="line">                other.right.color = BLACK;</span><br><span class="line">                leftRotate(parent);</span><br><span class="line">                node = root;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            other = parent.left;</span><br><span class="line">            <span class="keyword">if</span> (other.color == RED) &#123;</span><br><span class="line">                <span class="comment">//case 1:x的兄弟w是红色的</span></span><br><span class="line">                other.color = BLACK;</span><br><span class="line">                parent.color = RED;</span><br><span class="line">                rightRotate(parent);</span><br><span class="line">                other = parent.left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((other.left == <span class="keyword">null</span> || other.left.color == BLACK)</span><br><span class="line">                    &amp;&amp; (other.right == <span class="keyword">null</span> || other.right.color == BLACK)) &#123;</span><br><span class="line">                <span class="comment">//case 2:x兄弟w是黑色，且w的两个孩子也都是黑色的</span></span><br><span class="line">                other.color = RED;</span><br><span class="line">                node = parent;</span><br><span class="line">                parent = node.parent;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (other.left == <span class="keyword">null</span> || other.left.color == BLACK) &#123;</span><br><span class="line">                    <span class="comment">//case 3:x的兄弟w是黑色的，并且w的左孩子是红色，右孩子为黑色。</span></span><br><span class="line">                    other.right.color = BLACK;</span><br><span class="line">                    other.color = RED;</span><br><span class="line">                    leftRotate(other);</span><br><span class="line">                    other = parent.left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//case 4:x的兄弟w是黑色的；并且w的右孩子是红色的，左孩子任意颜色。</span></span><br><span class="line">                other.color = parent.color;</span><br><span class="line">                parent.color = BLACK;</span><br><span class="line">                other.left.color = BLACK;</span><br><span class="line">                rightRotate(parent);</span><br><span class="line">                node = root;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.color = BLACK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>红黑树查找的最坏时间复杂度也是O(logN)。为了它这么高的性能，我感觉自己费了这么多脑细胞和时间来学习也是值得的(自己前前后后看了好多次)。这篇文章和插入图也是我自己用心根据自己的理解来做，希望大家能在学习红黑树的时候提高效率，不走弯路。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>红黑树的文章有好多，仔细阅读几篇之后感觉这三篇讲的不错。第一篇的红黑树插入，第二篇的红黑树左旋和右旋（动画做的非常好）和红黑树的删除，最后一篇的代码写的很棒并且提供的测试的case。文章的主要内容都是以下三篇文章的总结。</p>
<p><a href="https://www.cnblogs.com/skywang12345/p/3624343.html" target="_blank" rel="noopener">重温数据结构：深入理解红黑树</a><br><a href="http://blog.csdn.net/eson_15/article/details/51144079" target="_blank" rel="noopener">【数据结构和算法05】 红-黑树（看完包懂~）</a><br><a href="https://www.cnblogs.com/skywang12345/p/3624343.html" target="_blank" rel="noopener">红黑树(五)之 Java的实现</a></p>
<p>源码：<a href="https://gitee.com/dandanlove/codes/xezpa7g3q1dybw5mutvk643" target="_blank" rel="noopener">红黑树操作&amp;代码注释</a></p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title>【可视化教程】iTerm2+oh-my-zsh+solarized配色方案</title>
    <url>/2018/03/07/iterm-zsh-solarized/</url>
    <content><![CDATA[<h1 id="【可视化教程】iTerm2-oh-my-zsh-solarized配色方案"><a href="#【可视化教程】iTerm2-oh-my-zsh-solarized配色方案" class="headerlink" title="【可视化教程】iTerm2+oh-my-zsh+solarized配色方案"></a>【可视化教程】iTerm2+oh-my-zsh+solarized配色方案</h1><h2 id="自己Mac的terminal配色"><a href="#自己Mac的terminal配色" class="headerlink" title="自己Mac的terminal配色"></a>自己Mac的terminal配色</h2><center><img src="http://upload-images.jianshu.io/upload_images/1319879-0571ea9cc6e1eae3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="terminal配色"></center>


<h2 id="修改Mac的terminal配色"><a href="#修改Mac的terminal配色" class="headerlink" title="修改Mac的terminal配色"></a>修改Mac的terminal配色</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#enables colorin the terminal bash shell</span></span><br><span class="line"><span class="built_in">export</span> <span class="built_in">export</span> CLICOLOR=1</span><br><span class="line"><span class="comment">#sets up thecolor scheme for list</span></span><br><span class="line"><span class="built_in">export</span> <span class="built_in">export</span> LSCOLORS=gxfxcxdxbxegedabagacad</span><br><span class="line"><span class="comment">#sets up theprompt color (currently a green similar to linux terminal)</span></span><br><span class="line"><span class="comment">#export PS1='\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;36m\]\w\[\033[00m\]\$ '</span></span><br><span class="line"><span class="comment">#enables colorfor iTerm </span></span><br><span class="line"><span class="built_in">export</span> TERM=xterm-color</span><br></pre></td></tr></table></figure>
<p>其中<code>export PS1=&#39;\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;36m\]\w\[\033[00m\]\$ &#39;</code>是注释掉的。</p>
<h2 id="开工前的准备"><a href="#开工前的准备" class="headerlink" title="开工前的准备"></a>开工前的准备</h2><ul>
<li><a href="https://link.jianshu.com/?t=http://www.iterm2.com/" target="_blank" rel="noopener">iTerm</a> Mac最好用的终端，点击链接下载最新的版本。</li>
<li><a href="https://link.jianshu.com/?t=http://ethanschoonover.com/solarized" target="_blank" rel="noopener">Solarized Dark</a> 现在配色资源。</li>
<li><a href="https://link.jianshu.com/?t=https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="noopener">oh-my-zsh</a>可使用<code>curl -L https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh | sh</code>进行安装</li>
<li><a href="https://link.jianshu.com/?t=https://github.com/mneorr/powerline-fonts/blob/bfcb152306902c09b62be6e4a5eec7763e46d62d/Monaco/Monaco%20for%20Powerline.otf" target="_blank" rel="noopener">Monaco Powerline</a>解决部分字符的乱码问题。</li>
</ul>
<h2 id="iTerm"><a href="#iTerm" class="headerlink" title="iTerm"></a>iTerm</h2><p>下载&amp;解压，移动到<code>Application</code>文件中。</p>
<h2 id="Solarized-Dark"><a href="#Solarized-Dark" class="headerlink" title="Solarized Dark"></a>Solarized Dark</h2><p>下载解压<code>Solarized Dark</code>，点击目录<code>solarized\iterm2-colors-solarized</code>的<code>Solarized Dark.itermcolors</code>和 <code>Solarized Light.itermcolors</code>进行安装。</p>
<center><img src="http://upload-images.jianshu.io/upload_images/1319879-c42c443703510c22.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="iTerm的配色方案.jpg"></center>


<h2 id="oh-my-zsh安装agnoster主题"><a href="#oh-my-zsh安装agnoster主题" class="headerlink" title="oh-my-zsh安装agnoster主题"></a>oh-my-zsh安装agnoster主题</h2><p>通过命令行安装：<code>curl -L https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh | sh</code>。<br>卸载oh-my-zsh命令：<code>uninstall_oh_my_zsh</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim ~/.zshrc    //进入.zshrc文件，将ZSH_THEME后面字段改为agnoster</span><br></pre></td></tr></table></figure>
<center><img src="http://upload-images.jianshu.io/upload_images/1319879-6b73c3e18c5f5d1e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="安装agnoster主题.jpg"></center>




<h2 id="Monaco-Powerline"><a href="#Monaco-Powerline" class="headerlink" title="Monaco Powerline"></a>Monaco Powerline</h2><p>下载并安装。</p>
<center><img src="http://upload-images.jianshu.io/upload_images/1319879-470e09ba88519562.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ITerm修改字体.jpg"></center>


<h2 id="设置语法高亮-–-zsh-syntax-highlighting"><a href="#设置语法高亮-–-zsh-syntax-highlighting" class="headerlink" title="设置语法高亮 – zsh-syntax-highlighting"></a>设置语法高亮 – <a href="https://link.jianshu.com/?t=https://github.com/zsh-users/zsh-syntax-highlighting" target="_blank" rel="noopener">zsh-syntax-highlighting</a></h2><p>直接使用homebrew安装zsh-syntax-highlighting插件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install zsh-syntax-highlighting</span><br></pre></td></tr></table></figure></p>
<p>然后在根目录下.zshrc中插入下面内容：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source /usr/local/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh</span><br></pre></td></tr></table></figure></p>
<h2 id="隐藏用户名信息"><a href="#隐藏用户名信息" class="headerlink" title="隐藏用户名信息"></a>隐藏用户名信息</h2><p>一般终端每一行前都会有<code>xxx@xxxdeMacbook-Pro:</code>我们可以将其隐藏掉。<br>进入oh-my-zsh的agnoster主题，编辑agnoster.zsh-theme文件：<br><code>vim ~/.oh-my-zsh/themes/agnoster.zsh-theme</code></p>
<center><img src="http://upload-images.jianshu.io/upload_images/1319879-635328c0ce8a09f0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="隐藏用户信息.jpg"></center>


<p>参考文章：</p>
<p><a href="https://www.jianshu.com/p/246b844f4449" target="_blank" rel="noopener">最漂亮iTerm2+oh-my-zsh配色</a></p>
<p><a href="https://www.jianshu.com/p/bb1c97269b11" target="_blank" rel="noopener">mac－改造你的terminal</a></p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>MAC</category>
      </categories>
      <tags>
        <tag>Terminal</tag>
      </tags>
  </entry>
  <entry>
    <title>Android项目解耦--路由框架ARouter源码解析</title>
    <url>/2018/02/06/arouter-source/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇文章<a href="http://dandanlove.com/2018/02/06/arouter-study/" target="_blank" rel="noopener">Android项目解耦–路由框架ARouter的使用</a>讲述了ARouter在项目中的使用，这边文章主要对ARouter的源码进行学习和分析。</p>
<h1 id="ARouter的结构"><a href="#ARouter的结构" class="headerlink" title="ARouter的结构"></a>ARouter的结构</h1><p>ARouter主要由三部分组成，包括对外提供的api调用模块、注解模块以及编译时通过注解生产相关的类模块。</p>
<blockquote>
<ul>
<li><code>arouter-annotation</code>注解的声明和信息存储类的模块</li>
<li><code>arouter-compiler</code>编译期解析注解信息并生成相应类以便进行注入的模块</li>
<li><code>arouter-api</code>核心调用Api功能的模块</li>
</ul>
</blockquote>
<h3 id="annotation模块"><a href="#annotation模块" class="headerlink" title="annotation模块"></a>annotation模块</h3><center><img src="http://upload-images.jianshu.io/upload_images/1319879-10b754d5c3a6f21c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="arouter-annotation.png"></center>

<p><code>Route</code>、<code>Interceptor</code>、<code>Autowired</code>都是我们在开发是需要的注解。</p>
<h3 id="compiler模块"><a href="#compiler模块" class="headerlink" title="compiler模块"></a>compiler模块</h3><center><img src="http://upload-images.jianshu.io/upload_images/1319879-26147b5dd9aa6678.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="arouter-compiler.png"></center>

<p><code>AutoWiredProcessor</code>、<code>InterceptorProcessor</code>、<code>RouteProcessor</code>分别为annotation模块对应的<code>Autowired</code>、<code>Interceptor</code>、<code>Route</code>在项目编译时产生相关的类文件。</p>
<center><img src="http://upload-images.jianshu.io/upload_images/1319879-7118f5ca0fa3ac5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="build-source.png"></center>

<h3 id="api模块"><a href="#api模块" class="headerlink" title="api模块"></a>api模块</h3><p>主要是ARouter具体实现和对外暴露使用的api。api部分我们可以参数上一篇文章<a href="https://www.jianshu.com/p/3d7d12deae10" target="_blank" rel="noopener">Android项目解耦–路由框架ARouter的使用</a>，ARouter实现我们具体在下面讲解。</p>
<h1 id="ARouter的工作流程"><a href="#ARouter的工作流程" class="headerlink" title="ARouter的工作流程"></a>ARouter的工作流程</h1><center><img src="http://upload-images.jianshu.io/upload_images/1319879-596be6eb9b74ee90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="arouter-init.png"></center>

<h2 id="Arouter初始化"><a href="#Arouter初始化" class="headerlink" title="Arouter初始化"></a>Arouter初始化</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ARouter</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Init, it must be call before used router.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Application application)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasInit) &#123;</span><br><span class="line">            logger = _ARouter.logger;</span><br><span class="line">            _ARouter.logger.info(Consts.TAG, <span class="string">"ARouter init start."</span>);</span><br><span class="line">            hasInit = _ARouter.init(application);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (hasInit) &#123;</span><br><span class="line">                _ARouter.afterInit();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            _ARouter.logger.info(Consts.TAG, <span class="string">"ARouter init over."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ARouter初始化"><a href="#ARouter初始化" class="headerlink" title="_ARouter初始化"></a>_ARouter初始化</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">_ARouter</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">init</span><span class="params">(Application application)</span> </span>&#123;</span><br><span class="line">        mContext = application;</span><br><span class="line">        LogisticsCenter.init(mContext, executor);</span><br><span class="line">        logger.info(Consts.TAG, <span class="string">"ARouter init success!"</span>);</span><br><span class="line">        hasInit = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// It's not a good idea.</span></span><br><span class="line">        <span class="comment">// if (Build.VERSION.SDK_INT &gt; Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123;</span></span><br><span class="line">        <span class="comment">//     application.registerActivityLifecycleCallbacks(new AutowiredLifecycleCallback());</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LogisticsCenter初始化"><a href="#LogisticsCenter初始化" class="headerlink" title="LogisticsCenter初始化"></a>LogisticsCenter初始化</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogisticsCenter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * LogisticsCenter init, load all metas in memory. Demand initialization</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Context context, ThreadPoolExecutor tpe)</span> <span class="keyword">throws</span> HandlerException </span>&#123;</span><br><span class="line">        mContext = context;</span><br><span class="line">        executor = tpe;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> startInit = System.currentTimeMillis();</span><br><span class="line">            Set&lt;String&gt; routerMap;</span><br><span class="line">            <span class="comment">//debug或者版本更新的时候每次都重新加载router信息</span></span><br><span class="line">            <span class="comment">// It will rebuild router map every times when debuggable.</span></span><br><span class="line">            <span class="keyword">if</span> (ARouter.debuggable() || PackageUtils.isNewVersion(context)) &#123;</span><br><span class="line">                logger.info(TAG, <span class="string">"Run with debug mode or new install, rebuild router map."</span>);</span><br><span class="line">                <span class="comment">// These class was generate by arouter-compiler.</span></span><br><span class="line">                <span class="comment">//加载alibaba.android.arouter.routes包下载的类</span></span><br><span class="line">                routerMap = ClassUtils.getFileNameByPackageName(mContext, ROUTE_ROOT_PAKCAGE);</span><br><span class="line">                <span class="keyword">if</span> (!routerMap.isEmpty()) &#123;</span><br><span class="line">                    context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE).edit().putStringSet(AROUTER_SP_KEY_MAP, routerMap).apply();</span><br><span class="line">                &#125;</span><br><span class="line">                PackageUtils.updateVersion(context);    <span class="comment">// Save new version name when router map update finish.</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.info(TAG, <span class="string">"Load router map from cache."</span>);</span><br><span class="line">                routerMap = <span class="keyword">new</span> HashSet&lt;&gt;(context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE).getStringSet(AROUTER_SP_KEY_MAP, <span class="keyword">new</span> HashSet&lt;String&gt;()));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            logger.info(TAG, <span class="string">"Find router map finished, map size = "</span> + routerMap.size() + <span class="string">", cost "</span> + (System.currentTimeMillis() - startInit) + <span class="string">" ms."</span>);</span><br><span class="line">            startInit = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (String className : routerMap) &#123;</span><br><span class="line">                <span class="keyword">if</span> (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_ROOT)) &#123;</span><br><span class="line">                    <span class="comment">// This one of root elements, load root. </span></span><br><span class="line">                    <span class="comment">//导入ARouter$$Root$$app.java,初始化Warehouse.groupsIndex集合</span></span><br><span class="line">                    ((IRouteRoot) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.groupsIndex);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_INTERCEPTORS)) &#123;</span><br><span class="line">                    <span class="comment">// Load interceptorMeta</span></span><br><span class="line">                    <span class="comment">//导入ARouter$$Interceptors$$app.java，初始化Warehouse.interceptorsIndex集合</span></span><br><span class="line">                    ((IInterceptorGroup) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.interceptorsIndex);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_PROVIDERS)) &#123;</span><br><span class="line">                    <span class="comment">// Load providerIndex</span></span><br><span class="line">                    <span class="comment">//导入ARouter$$Providers$$app.java，初始化Warehouse.providersIndex集合</span></span><br><span class="line">                    ((IProviderGroup) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.providersIndex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*******部分代码省略********/</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> HandlerException(TAG + <span class="string">"ARouter init logistics center exception! ["</span> + e.getMessage() + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ARouter的结构-1"><a href="#ARouter的结构-1" class="headerlink" title="ARouter的结构"></a>ARouter的结构</h1><center><img src="http://upload-images.jianshu.io/upload_images/1319879-d3e40018e4fb68bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/310" alt="结构.png"></center>

<p><code>ARouter、Postcard、LogisticsCenter、DegradeService、PathReplaceService、InterceptroService</code>这五个部分基本构成了ARouter的主体架构。</p>
<h2 id="ARouter-ARouter-模块"><a href="#ARouter-ARouter-模块" class="headerlink" title="ARouter(_ARouter)模块"></a>ARouter(_ARouter)模块</h2><p><code>ARouter</code>主要提供对外调用的api，<code>_ARouter</code>路由协议的具体实现类。</p>
<h3 id="获取服务"><a href="#获取服务" class="headerlink" title="获取服务"></a>获取服务</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">_ARouter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">navigation</span><span class="params">(Class&lt;? extends T&gt; service)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Postcard postcard = LogisticsCenter.buildProvider(service.getName());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Compatible 1.0.5 compiler sdk.</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == postcard) &#123; <span class="comment">// No service, or this service in old version.</span></span><br><span class="line">                postcard = LogisticsCenter.buildProvider(service.getSimpleName());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            LogisticsCenter.completion(postcard);</span><br><span class="line">            <span class="keyword">return</span> (T) postcard.getProvider();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoRouteFoundException ex) &#123;</span><br><span class="line">            logger.warning(Consts.TAG, ex.getMessage());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="跳转协议"><a href="#跳转协议" class="headerlink" title="跳转协议"></a>跳转协议</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">_ARouter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">navigation</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> Postcard postcard, <span class="keyword">final</span> <span class="keyword">int</span> requestCode, <span class="keyword">final</span> NavigationCallback callback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            LogisticsCenter.completion(postcard);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoRouteFoundException ex) &#123;</span><br><span class="line">            <span class="comment">/**************部分代码省略***************/</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != callback) &#123;</span><br><span class="line">                callback.onLost(postcard);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;    <span class="comment">// No callback for this invoke, then we use the global degrade service.</span></span><br><span class="line">                DegradeService degradeService = ARouter.getInstance().navigation(DegradeService.class);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != degradeService) &#123;</span><br><span class="line">                    degradeService.onLost(context, postcard);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != callback) &#123;</span><br><span class="line">            callback.onFound(postcard);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//是否为绿色通道，是否进过拦截器处理</span></span><br><span class="line">        <span class="keyword">if</span> (!postcard.isGreenChannel()) &#123;   <span class="comment">// It must be run in async thread, maybe interceptor cost too mush time made ANR.</span></span><br><span class="line">            interceptorService.doInterceptions(postcard, <span class="keyword">new</span> InterceptorCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onContinue</span><span class="params">(Postcard postcard)</span> </span>&#123;</span><br><span class="line">                    _navigation(context, postcard, requestCode, callback);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInterrupt</span><span class="params">(Throwable exception)</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//中断处理</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> != callback) &#123;</span><br><span class="line">                        callback.onInterrupt(postcard);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> _navigation(context, postcard, requestCode, callback);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">_navigation</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> Postcard postcard, <span class="keyword">final</span> <span class="keyword">int</span> requestCode, <span class="keyword">final</span> NavigationCallback callback)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//没有上下文环境，就用Application的上下文环境</span></span><br><span class="line">        <span class="keyword">final</span> Context currentContext = <span class="keyword">null</span> == context ? mContext : context;</span><br><span class="line">        <span class="keyword">switch</span> (postcard.getType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> ACTIVITY:</span><br><span class="line">                <span class="comment">// Build intent 构建跳转的intent</span></span><br><span class="line">                <span class="keyword">final</span> Intent intent = <span class="keyword">new</span> Intent(currentContext, postcard.getDestination());</span><br><span class="line">                intent.putExtras(postcard.getExtras());</span><br><span class="line">                <span class="comment">// Set flags. 设置flag</span></span><br><span class="line">                <span class="keyword">int</span> flags = postcard.getFlags();</span><br><span class="line">                <span class="keyword">if</span> (-<span class="number">1</span> != flags) &#123;</span><br><span class="line">                    intent.setFlags(flags);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(currentContext <span class="keyword">instanceof</span> Activity)) &#123;    <span class="comment">// Non activity, need less one flag.</span></span><br><span class="line">                    <span class="comment">//如果上下文不是Activity，则添加FLAG_ACTIVITY_NEW_TASK的flag</span></span><br><span class="line">                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Navigation in main looper.  切换到主线程中</span></span><br><span class="line">                <span class="keyword">new</span> Handler(Looper.getMainLooper()).post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (requestCode &gt; <span class="number">0</span>) &#123;  <span class="comment">// Need start for result</span></span><br><span class="line">                            ActivityCompat.startActivityForResult((Activity) currentContext, intent, requestCode, postcard.getOptionsBundle());</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            ActivityCompat.startActivity(currentContext, intent, postcard.getOptionsBundle());</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> ((<span class="number">0</span> != postcard.getEnterAnim() || <span class="number">0</span> != postcard.getExitAnim()) &amp;&amp; currentContext <span class="keyword">instanceof</span> Activity) &#123;    <span class="comment">// Old version.</span></span><br><span class="line">                            ((Activity) currentContext).overridePendingTransition(postcard.getEnterAnim(), postcard.getExitAnim());</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (<span class="keyword">null</span> != callback) &#123; <span class="comment">// Navigation over.</span></span><br><span class="line">                            callback.onArrival(postcard);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> PROVIDER:</span><br><span class="line">                <span class="keyword">return</span> postcard.getProvider();</span><br><span class="line">            <span class="keyword">case</span> BOARDCAST:</span><br><span class="line">            <span class="keyword">case</span> CONTENT_PROVIDER:</span><br><span class="line">            <span class="keyword">case</span> FRAGMENT:</span><br><span class="line">                Class fragmentMeta = postcard.getDestination();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Object instance = fragmentMeta.getConstructor().newInstance();</span><br><span class="line">                    <span class="keyword">if</span> (instance <span class="keyword">instanceof</span> Fragment) &#123;</span><br><span class="line">                        ((Fragment) instance).setArguments(postcard.getExtras());</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (instance <span class="keyword">instanceof</span> android.support.v4.app.Fragment) &#123;</span><br><span class="line">                        ((android.support.v4.app.Fragment) instance).setArguments(postcard.getExtras());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> instance;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    logger.error(Consts.TAG, <span class="string">"Fetch fragment instance error, "</span> + TextUtils.formatStackTrace(ex.getStackTrace()));</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> METHOD:</span><br><span class="line">            <span class="keyword">case</span> SERVICE:</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Postcard模块"><a href="#Postcard模块" class="headerlink" title="Postcard模块"></a>Postcard模块</h2><center><img src="http://upload-images.jianshu.io/upload_images/1319879-965754585e704306.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/310" alt="postcard.png"></center>

<p><code>Postcard</code>主要为信息的携带者，内容是在构造一次路由信息的时候生产的，其继承于<code>RouteMeta</code>。<code>RouteMeta</code>是在代码编译时生成的内容，主要在初始化<code>WareHouse</code>时对跳转信息做了缓存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Warehouse</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Cache route and metas</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt; groupsIndex = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> Map&lt;String, RouteMeta&gt; routes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache provider</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Class, IProvider&gt; providers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> Map&lt;String, RouteMeta&gt; providersIndex = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache interceptor</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Integer, Class&lt;? extends IInterceptor&gt;&gt; interceptorsIndex = <span class="keyword">new</span> UniqueKeyTreeMap&lt;&gt;(<span class="string">"More than one interceptors use same priority [%s]"</span>);</span><br><span class="line">    <span class="keyword">static</span> List&lt;IInterceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        routes.clear();</span><br><span class="line">        groupsIndex.clear();</span><br><span class="line">        providers.clear();</span><br><span class="line">        providersIndex.clear();</span><br><span class="line">        interceptors.clear();</span><br><span class="line">        interceptorsIndex.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先来看一下一些基础类的信息：</p>
<center><img src="http://upload-images.jianshu.io/upload_images/1319879-059618ec0c0cec82.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="router-data.png"></center>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DO NOT EDIT THIS FILE!!! IT WAS GENERATED BY AROUTER. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ARouter</span>$$<span class="title">Group</span>$$<span class="title">activity</span> <span class="keyword">implements</span> <span class="title">IRouteGroup</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadInto</span><span class="params">(Map&lt;String, RouteMeta&gt; atlas)</span> </span>&#123;</span><br><span class="line">    atlas.put(<span class="string">"/Example1Activity"</span>, RouteMeta.build(RouteType.ACTIVITY, Example1Activity.class, <span class="string">"/example1activity"</span>, <span class="string">"activity"</span>, <span class="keyword">null</span>, -<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">    atlas.put(<span class="string">"/activity/FragActivity"</span>, RouteMeta.build(RouteType.ACTIVITY, FragActivity.class, <span class="string">"/activity/fragactivity"</span>, <span class="string">"activity"</span>, <span class="keyword">null</span>, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">    atlas.put(<span class="string">"/activity/MainActivity"</span>, RouteMeta.build(RouteType.ACTIVITY, MainActivity.class, <span class="string">"/activity/mainactivity"</span>, <span class="string">"activity"</span>, <span class="keyword">null</span>, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">    atlas.put(<span class="string">"/activity/ParamsCallActivity"</span>, RouteMeta.build(RouteType.ACTIVITY, ParamsCallActivity.class, <span class="string">"/activity/paramscallactivity"</span>, <span class="string">"activity"</span>, <span class="keyword">new</span> java.util.HashMap&lt;String, Integer&gt;()&#123;&#123;put(<span class="string">"obj"</span>, <span class="number">10</span>); put(<span class="string">"name"</span>, <span class="number">8</span>); put(<span class="string">"girl"</span>, <span class="number">0</span>); put(<span class="string">"age"</span>, <span class="number">3</span>); &#125;&#125;, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">    atlas.put(<span class="string">"/activity/WebViewActivity"</span>, RouteMeta.build(RouteType.ACTIVITY, WebViewActivity.class, <span class="string">"/activity/webviewactivity"</span>, <span class="string">"activity"</span>, <span class="keyword">null</span>, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LogisticsCenter"><a href="#LogisticsCenter" class="headerlink" title="LogisticsCenter"></a>LogisticsCenter</h2><p>逻辑中心涉路由信息的处理。主要分为两个部分初始化路由信息（初始化时已经讲述过），和路由跳转时的路由功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LogisticsCenter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Completion the postcard by route metas</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> postcard Incomplete postcard, should completion by this method.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">completion</span><span class="params">(Postcard postcard)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == postcard) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoRouteFoundException(TAG + <span class="string">"No postcard!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从仓库中获取路由信息</span></span><br><span class="line">        RouteMeta routeMeta = Warehouse.routes.get(postcard.getPath());</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == routeMeta) &#123;    <span class="comment">// Maybe its does't exist, or didn't load.</span></span><br><span class="line">            <span class="comment">//导入改路由分组信息</span></span><br><span class="line">            Class&lt;? extends IRouteGroup&gt; groupMeta = Warehouse.groupsIndex.get(postcard.getGroup());  <span class="comment">// Load route meta.</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == groupMeta) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoRouteFoundException(TAG + <span class="string">"There is no route match the path ["</span> + postcard.getPath() + <span class="string">"], in group ["</span> + postcard.getGroup() + <span class="string">"]"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Load route and cache it into memory, then delete from metas.</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ARouter.debuggable()) &#123;</span><br><span class="line">                        logger.debug(TAG, String.format(Locale.getDefault(), <span class="string">"The group [%s] starts loading, trigger by [%s]"</span>, postcard.getGroup(), postcard.getPath()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//从缓存中读取该分组的路由信息</span></span><br><span class="line">                    IRouteGroup iGroupInstance = groupMeta.getConstructor().newInstance();</span><br><span class="line">                    iGroupInstance.loadInto(Warehouse.routes);</span><br><span class="line">                    Warehouse.groupsIndex.remove(postcard.getGroup());</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (ARouter.debuggable()) &#123;</span><br><span class="line">                        logger.debug(TAG, String.format(Locale.getDefault(), <span class="string">"The group [%s] has already been loaded, trigger by [%s]"</span>, postcard.getGroup(), postcard.getPath()));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> HandlerException(TAG + <span class="string">"Fatal exception when loading group meta. ["</span> + e.getMessage() + <span class="string">"]"</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                completion(postcard);   <span class="comment">// Reload</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//将路由信息导入到卡片中</span></span><br><span class="line">            postcard.setDestination(routeMeta.getDestination());</span><br><span class="line">            postcard.setType(routeMeta.getType());</span><br><span class="line">            postcard.setPriority(routeMeta.getPriority());</span><br><span class="line">            postcard.setExtra(routeMeta.getExtra());</span><br><span class="line"></span><br><span class="line">            Uri rawUri = postcard.getUri();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != rawUri) &#123;   <span class="comment">// Try to set params into bundle.</span></span><br><span class="line">                Map&lt;String, String&gt; resultMap = TextUtils.splitQueryParameters(rawUri);</span><br><span class="line">                Map&lt;String, Integer&gt; paramsType = routeMeta.getParamsType();</span><br><span class="line">                <span class="comment">//初始化跳转协议中的参数信息</span></span><br><span class="line">                <span class="keyword">if</span> (MapUtils.isNotEmpty(paramsType)) &#123;</span><br><span class="line">                    <span class="comment">// Set value by its type, just for params which annotation by @Param</span></span><br><span class="line">                    <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; params : paramsType.entrySet()) &#123;</span><br><span class="line">                        setValue(postcard,</span><br><span class="line">                                params.getValue(),</span><br><span class="line">                                params.getKey(),</span><br><span class="line">                                resultMap.get(params.getKey()));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Save params name which need auto inject.</span></span><br><span class="line">                    postcard.getExtras().putStringArray(ARouter.AUTO_INJECT, paramsType.keySet().toArray(<span class="keyword">new</span> String[]&#123;&#125;));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Save raw uri</span></span><br><span class="line">                postcard.withString(ARouter.RAW_URI, rawUri.toString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (routeMeta.getType()) &#123;</span><br><span class="line">                <span class="keyword">case</span> PROVIDER:  <span class="comment">// if the route is provider, should find its instance</span></span><br><span class="line">                    <span class="comment">// Its provider, so it must be implememt IProvider</span></span><br><span class="line">                    Class&lt;? extends IProvider&gt; providerMeta = (Class&lt;? extends IProvider&gt;) routeMeta.getDestination();</span><br><span class="line">                    IProvider instance = Warehouse.providers.get(providerMeta);</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123; <span class="comment">// There's no instance of this provider</span></span><br><span class="line">                        IProvider provider;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">//通过反射构造Provider</span></span><br><span class="line">                            provider = providerMeta.getConstructor().newInstance();</span><br><span class="line">                            provider.init(mContext);</span><br><span class="line">                            <span class="comment">//缓存provider路由信息</span></span><br><span class="line">                            Warehouse.providers.put(providerMeta, provider);</span><br><span class="line">                            instance = provider;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> HandlerException(<span class="string">"Init provider failed! "</span> + e.getMessage());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    postcard.setProvider(instance);</span><br><span class="line">                    postcard.greenChannel();    <span class="comment">// Provider should skip all of interceptors</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> FRAGMENT:</span><br><span class="line">                    postcard.greenChannel();    <span class="comment">// Fragment needn't interceptors</span></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="DegradeService-降级容错服务"><a href="#DegradeService-降级容错服务" class="headerlink" title="DegradeService(降级容错服务)"></a>DegradeService(降级容错服务)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Route</span>(path = DegradeServiceImpl.PATH)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DegradeServiceImpl</span> <span class="keyword">implements</span> <span class="title">DegradeService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/service/DegradeServiceImpl"</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLost</span><span class="params">(Context context, Postcard postcard)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (context != <span class="keyword">null</span> &amp;&amp; postcard.getGroup().equals(<span class="string">"activity"</span>)) &#123;</span><br><span class="line">            ActivityCompat.startActivity(context, <span class="keyword">new</span> Intent(context, DefalutActivity.class), <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>路由寻址出现问题的时候的容错处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">_ARouter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">navigation</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> Postcard postcard, <span class="keyword">final</span> <span class="keyword">int</span> requestCode, <span class="keyword">final</span> NavigationCallback callback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            LogisticsCenter.completion(postcard);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoRouteFoundException ex) &#123;</span><br><span class="line">            <span class="comment">/***********部分代码省略************/</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != callback) &#123;</span><br><span class="line">                callback.onLost(postcard);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;    <span class="comment">// No callback for this invoke, then we use the global degrade service.</span></span><br><span class="line">                DegradeService degradeService = ARouter.getInstance().navigation(DegradeService.class);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != degradeService) &#123;</span><br><span class="line">                    degradeService.onLost(context, postcard);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/***********部分代码省略************/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="PathReplaceService"><a href="#PathReplaceService" class="headerlink" title="PathReplaceService"></a>PathReplaceService</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Route</span>(path = PathReplaceServiceImpl.PATH)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathReplaceServiceImpl</span> <span class="keyword">implements</span> <span class="title">PathReplaceService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/ddservice/PathReplaceServiceImpl"</span>;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; pathMap;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">forString</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        String result = pathMap.containsKey(path) ? pathMap.get(path) : path;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Uri <span class="title">forUri</span><span class="params">(Uri uri)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uri;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replacePath</span><span class="params">(String sourcePath, String targetPath)</span> </span>&#123;</span><br><span class="line">        pathMap.put(sourcePath, targetPath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        pathMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">getReplacePathMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableMap(pathMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从定义的类名我们可以看出来就是替换路径的服务，在构造路由协议的时候首先都会使用<code>PathReplaceService</code>服务进行地址替换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">_ARouter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Build postcard by path and default group</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Postcard <span class="title">build</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (TextUtils.isEmpty(path)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> HandlerException(Consts.TAG + <span class="string">"Parameter is invalid!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            PathReplaceService pService = ARouter.getInstance().navigation(PathReplaceService.class);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != pService) &#123;</span><br><span class="line">                path = pService.forString(path);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> build(path, extractGroup(path));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Build postcard by uri</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Postcard <span class="title">build</span><span class="params">(Uri uri)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == uri || TextUtils.isEmpty(uri.toString())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> HandlerException(Consts.TAG + <span class="string">"Parameter invalid!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            PathReplaceService pService = ARouter.getInstance().navigation(PathReplaceService.class);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != pService) &#123;</span><br><span class="line">                uri = pService.forUri(uri);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Postcard(uri.getPath(), extractGroup(uri.getPath()), uri, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Interceptor拦截器"><a href="#Interceptor拦截器" class="headerlink" title="Interceptor拦截器"></a>Interceptor拦截器</h2><p>在ARouter模块的时候讲述Interceptor的使用，如果本次路由跳转不是走的绿色通道那么则会触发拦截器进行过滤。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">_ARouter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">navigation</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> Postcard postcard, <span class="keyword">final</span> <span class="keyword">int</span> requestCode, <span class="keyword">final</span> NavigationCallback callback)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/************部分代码省略************/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!postcard.isGreenChannel()) &#123;   <span class="comment">// It must be run in async thread, maybe interceptor cost too mush time made ANR.</span></span><br><span class="line">            interceptorService.doInterceptions(postcard, <span class="keyword">new</span> InterceptorCallback() &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * Continue process</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 * <span class="doctag">@param</span> postcard route meta</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onContinue</span><span class="params">(Postcard postcard)</span> </span>&#123;</span><br><span class="line">                    _navigation(context, postcard, requestCode, callback);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * Interrupt process, pipeline will be destory when this method called.</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 * <span class="doctag">@param</span> exception Reson of interrupt.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInterrupt</span><span class="params">(Throwable exception)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> != callback) &#123;</span><br><span class="line">                        callback.onInterrupt(postcard);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    logger.info(Consts.TAG, <span class="string">"Navigation failed, termination by interceptor : "</span> + exception.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> _navigation(context, postcard, requestCode, callback);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拦截器的初始化"><a href="#拦截器的初始化" class="headerlink" title="拦截器的初始化"></a>拦截器的初始化</h3><p><code>InterceptorServiceImpl</code>的构造时间：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">_ARouter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">afterInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Trigger interceptor init, use byName.</span></span><br><span class="line">        interceptorService = (InterceptorService) ARouter.getInstance().build(<span class="string">"/arouter/service/interceptor"</span>).navigation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>InterceptorServiceImpl</code>的init方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Route</span>(path = <span class="string">"/arouter/service/interceptor"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorServiceImpl</span> <span class="keyword">implements</span> <span class="title">InterceptorService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">final</span> Context context)</span> </span>&#123;</span><br><span class="line">        LogisticsCenter.executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (MapUtils.isNotEmpty(Warehouse.interceptorsIndex)) &#123;</span><br><span class="line">                    <span class="comment">//循环遍历仓库中的拦截器</span></span><br><span class="line">                    <span class="keyword">for</span> (Map.Entry&lt;Integer, Class&lt;? extends IInterceptor&gt;&gt; entry : Warehouse.interceptorsIndex.entrySet()) &#123;</span><br><span class="line">                        Class&lt;? extends IInterceptor&gt; interceptorClass = entry.getValue();</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">//反射机制构造自定义的每一个拦截器实例</span></span><br><span class="line">                            IInterceptor iInterceptor = interceptorClass.getConstructor().newInstance();</span><br><span class="line">                            iInterceptor.init(context);</span><br><span class="line">                            <span class="comment">//并将其添加在缓存中</span></span><br><span class="line">                            Warehouse.interceptors.add(iInterceptor);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> HandlerException(TAG + <span class="string">"ARouter init interceptor error! name = ["</span> + interceptorClass.getName() + <span class="string">"], reason = ["</span> + ex.getMessage() + <span class="string">"]"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    interceptorHasInit = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                    logger.info(TAG, <span class="string">"ARouter interceptors init over."</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">synchronized</span> (interceptorInitLock) &#123;</span><br><span class="line">                        interceptorInitLock.notifyAll();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拦截器的工作过程"><a href="#拦截器的工作过程" class="headerlink" title="拦截器的工作过程"></a>拦截器的工作过程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Route</span>(path = <span class="string">"/arouter/service/interceptor"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorServiceImpl</span> <span class="keyword">implements</span> <span class="title">InterceptorService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doInterceptions</span><span class="params">(<span class="keyword">final</span> Postcard postcard, <span class="keyword">final</span> InterceptorCallback callback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != Warehouse.interceptors &amp;&amp; Warehouse.interceptors.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//检测是否初始化完所有的烂机器</span></span><br><span class="line">            checkInterceptorsInitStatus();</span><br><span class="line">            <span class="comment">//没有完成正常的初始化，抛异常</span></span><br><span class="line">            <span class="keyword">if</span> (!interceptorHasInit) &#123;</span><br><span class="line">                callback.onInterrupt(<span class="keyword">new</span> HandlerException(<span class="string">"Interceptors initialization takes too much time."</span>));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//顺序遍历每一个拦截器，</span></span><br><span class="line">            LogisticsCenter.executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    CancelableCountDownLatch interceptorCounter = <span class="keyword">new</span> CancelableCountDownLatch(Warehouse.interceptors.size());</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        _excute(<span class="number">0</span>, interceptorCounter, postcard);</span><br><span class="line">                        interceptorCounter.await(postcard.getTimeout(), TimeUnit.SECONDS);</span><br><span class="line">                        <span class="comment">//拦截器的遍历终止之后，如果有还有没有遍历的拦截器，则表示路由事件被拦截</span></span><br><span class="line">                        <span class="keyword">if</span> (interceptorCounter.getCount() &gt; <span class="number">0</span>) &#123;    <span class="comment">// Cancel the navigation this time, if it hasn't return anythings.</span></span><br><span class="line">                            callback.onInterrupt(<span class="keyword">new</span> HandlerException(<span class="string">"The interceptor processing timed out."</span>));</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">null</span> != postcard.getTag()) &#123;    <span class="comment">// Maybe some exception in the tag.</span></span><br><span class="line">                            callback.onInterrupt(<span class="keyword">new</span> HandlerException(postcard.getTag().toString()));</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            callback.onContinue(postcard);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        callback.onInterrupt(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            callback.onContinue(postcard);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行拦截器的过滤事件</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">_excute</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> index, <span class="keyword">final</span> CancelableCountDownLatch counter, <span class="keyword">final</span> Postcard postcard)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; Warehouse.interceptors.size()) &#123;</span><br><span class="line">            IInterceptor iInterceptor = Warehouse.interceptors.get(index);</span><br><span class="line">            iInterceptor.process(postcard, <span class="keyword">new</span> InterceptorCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onContinue</span><span class="params">(Postcard postcard)</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// Last interceptor excute over with no exception.</span></span><br><span class="line">                    counter.countDown();</span><br><span class="line">                    <span class="comment">//如果当前没有拦截过滤，那么使用下一个拦截器</span></span><br><span class="line">                    _excute(index + <span class="number">1</span>, counter, postcard);  <span class="comment">// When counter is down, it will be execute continue ,but index bigger than interceptors size, then U know.</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInterrupt</span><span class="params">(Throwable exception)</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// Last interceptor excute over with fatal exception.</span></span><br><span class="line">                    postcard.setTag(<span class="keyword">null</span> == exception ? <span class="keyword">new</span> HandlerException(<span class="string">"No message."</span>) : exception.getMessage());    <span class="comment">// save the exception message for backup.</span></span><br><span class="line">                    counter.cancel();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Autowired的数据传输和自动注入"><a href="#Autowired的数据传输和自动注入" class="headerlink" title="Autowired的数据传输和自动注入"></a>Autowired的数据传输和自动注入</h2><p>将数据放入intent中，然后getintent获取赋值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DO NOT EDIT THIS FILE!!! IT WAS GENERATED BY AROUTER. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParamsCallActivity</span>$$<span class="title">ARouter</span>$$<span class="title">Autowired</span> <span class="keyword">implements</span> <span class="title">ISyringe</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> SerializationService serializationService;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    serializationService = ARouter.getInstance().navigation(SerializationService.class);</span><br><span class="line">    ParamsCallActivity substitute = (ParamsCallActivity)target;</span><br><span class="line">    substitute.name = substitute.getIntent().getStringExtra(<span class="string">"name"</span>);</span><br><span class="line">    substitute.age = substitute.getIntent().getIntExtra(<span class="string">"age"</span>, substitute.age);</span><br><span class="line">    substitute.boy = substitute.getIntent().getBooleanExtra(<span class="string">"girl"</span>, substitute.boy);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != serializationService) &#123;</span><br><span class="line">      substitute.obj = serializationService.parseObject(substitute.getIntent().getStringExtra(<span class="string">"obj"</span>), <span class="keyword">new</span> com.alibaba.android.arouter.facade.model.TypeWrapper&lt;Person&gt;()&#123;&#125;.getType());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Log.e(<span class="string">"ARouter::"</span>, <span class="string">"You want automatic inject the field 'obj' in class 'ParamsCallActivity' , then you should implement 'SerializationService' to support object auto inject!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数据类型转化"><a href="#数据类型转化" class="headerlink" title="数据类型转化"></a>数据类型转化</h3><p><code>Postcard</code>添加路由参数的时候都是放在Bundle中的，传递Object对象的时候是通过<code>SerializationService</code>服务先将其转化为String类型，然后在获取的时候再进反序列化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Types types;</span><br><span class="line">    <span class="keyword">private</span> Elements elements;</span><br><span class="line">    <span class="keyword">private</span> TypeMirror parcelableType;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TypeUtils</span><span class="params">(Types types, Elements elements)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.types = types;</span><br><span class="line">        <span class="keyword">this</span>.elements = elements;</span><br><span class="line">        parcelableType = <span class="keyword">this</span>.elements.getTypeElement(PARCELABLE).asType();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将数据类型转化为int值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">typeExchange</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line">        TypeMirror typeMirror = element.asType();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Primitive</span></span><br><span class="line">        <span class="keyword">if</span> (typeMirror.getKind().isPrimitive()) &#123;</span><br><span class="line">            <span class="keyword">return</span> element.asType().getKind().ordinal();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (typeMirror.toString()) &#123;</span><br><span class="line">            <span class="keyword">case</span> BYTE:</span><br><span class="line">                <span class="keyword">return</span> TypeKind.BYTE.ordinal();</span><br><span class="line">            <span class="keyword">case</span> SHORT:</span><br><span class="line">                <span class="keyword">return</span> TypeKind.SHORT.ordinal();</span><br><span class="line">            <span class="keyword">case</span> INTEGER:</span><br><span class="line">                <span class="keyword">return</span> TypeKind.INT.ordinal();</span><br><span class="line">            <span class="keyword">case</span> LONG:</span><br><span class="line">                <span class="keyword">return</span> TypeKind.LONG.ordinal();</span><br><span class="line">            <span class="keyword">case</span> FLOAT:</span><br><span class="line">                <span class="keyword">return</span> TypeKind.FLOAT.ordinal();</span><br><span class="line">            <span class="keyword">case</span> DOUBEL:</span><br><span class="line">                <span class="keyword">return</span> TypeKind.DOUBLE.ordinal();</span><br><span class="line">            <span class="keyword">case</span> BOOLEAN:</span><br><span class="line">                <span class="keyword">return</span> TypeKind.BOOLEAN.ordinal();</span><br><span class="line">            <span class="keyword">case</span> STRING:</span><br><span class="line">                <span class="keyword">return</span> TypeKind.STRING.ordinal();</span><br><span class="line">            <span class="keyword">default</span>:    <span class="comment">// Other side, maybe the PARCELABLE or OBJECT.</span></span><br><span class="line">                <span class="keyword">if</span> (types.isSubtype(typeMirror, parcelableType)) &#123;  <span class="comment">// PARCELABLE</span></span><br><span class="line">                    <span class="keyword">return</span> TypeKind.PARCELABLE.ordinal();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;    <span class="comment">// For others</span></span><br><span class="line">                    <span class="keyword">return</span> TypeKind.OBJECT.ordinal();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缓存的数据模板，用int值表示数据类型进行存储：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">atlas.put(<span class="string">"/activity/ParamsCallActivity"</span>, RouteMeta.build(RouteType.ACTIVITY, ParamsCallActivity.class, <span class="string">"/activity/paramscallactivity"</span>, <span class="string">"activity"</span>, <span class="keyword">new</span> java.util.HashMap&lt;String, Integer&gt;()&#123;&#123;put(<span class="string">"obj"</span>, <span class="number">10</span>); put(<span class="string">"name"</span>, <span class="number">8</span>); put(<span class="string">"girl"</span>, <span class="number">0</span>); put(<span class="string">"age"</span>, <span class="number">3</span>); &#125;&#125;, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br></pre></td></tr></table></figure>
<p>编译时的注解过程中执行数据获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoService</span>(Processor.class)</span><br><span class="line"><span class="meta">@SupportedOptions</span>(KEY_MODULE_NAME)</span><br><span class="line"><span class="meta">@SupportedSourceVersion</span>(SourceVersion.RELEASE_7)</span><br><span class="line"><span class="meta">@SupportedAnnotationTypes</span>(&#123;ANNOTATION_TYPE_AUTOWIRED&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutowiredProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">buildStatement</span><span class="params">(String originalValue, String statement, <span class="keyword">int</span> type, <span class="keyword">boolean</span> isActivity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == TypeKind.BOOLEAN.ordinal()) &#123;</span><br><span class="line">            statement += (isActivity ? (<span class="string">"getBooleanExtra($S, "</span> + originalValue + <span class="string">")"</span>) : (<span class="string">"getBoolean($S)"</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == TypeKind.BYTE.ordinal()) &#123;</span><br><span class="line">            statement += (isActivity ? (<span class="string">"getByteExtra($S, "</span> + originalValue + <span class="string">""</span>) : (<span class="string">"getByte($S)"</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == TypeKind.SHORT.ordinal()) &#123;</span><br><span class="line">            statement += (isActivity ? (<span class="string">"getShortExtra($S, "</span> + originalValue + <span class="string">")"</span>) : (<span class="string">"getShort($S)"</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == TypeKind.INT.ordinal()) &#123;</span><br><span class="line">            statement += (isActivity ? (<span class="string">"getIntExtra($S, "</span> + originalValue + <span class="string">")"</span>) : (<span class="string">"getInt($S)"</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == TypeKind.LONG.ordinal()) &#123;</span><br><span class="line">            statement += (isActivity ? (<span class="string">"getLongExtra($S, "</span> + originalValue + <span class="string">")"</span>) : (<span class="string">"getLong($S)"</span>));</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type == TypeKind.CHAR.ordinal())&#123;</span><br><span class="line">            statement += (isActivity ? (<span class="string">"getCharExtra($S, "</span> + originalValue + <span class="string">")"</span>) : (<span class="string">"getChar($S)"</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == TypeKind.FLOAT.ordinal()) &#123;</span><br><span class="line">            statement += (isActivity ? (<span class="string">"getFloatExtra($S, "</span> + originalValue + <span class="string">")"</span>) : (<span class="string">"getFloat($S)"</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == TypeKind.DOUBLE.ordinal()) &#123;</span><br><span class="line">            statement += (isActivity ? (<span class="string">"getDoubleExtra($S, "</span> + originalValue + <span class="string">")"</span>) : (<span class="string">"getDouble($S)"</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == TypeKind.STRING.ordinal()) &#123;</span><br><span class="line">            statement += (isActivity ? (<span class="string">"getStringExtra($S)"</span>) : (<span class="string">"getString($S)"</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == TypeKind.PARCELABLE.ordinal()) &#123;</span><br><span class="line">            statement += (isActivity ? (<span class="string">"getParcelableExtra($S)"</span>) : (<span class="string">"getParcelable($S)"</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == TypeKind.OBJECT.ordinal()) &#123;</span><br><span class="line">            statement = <span class="string">"serializationService.parseObject(substitute."</span> + (isActivity ? <span class="string">"getIntent()."</span> : <span class="string">"getArguments()."</span>) + (isActivity ? <span class="string">"getStringExtra($S)"</span> : <span class="string">"getString($S)"</span>) + <span class="string">", new com.alibaba.android.arouter.facade.model.TypeWrapper&lt;$T&gt;()&#123;&#125;.getType())"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> statement;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="多dex的支持"><a href="#多dex的支持" class="headerlink" title="多dex的支持"></a>多dex的支持</h1><p>可查看<code>multidex</code>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassUtils</span> </span>&#123;  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Identifies if the current VM has a native support for multidex, meaning there is no need for</span></span><br><span class="line"><span class="comment">     * additional installation by this library.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if the VM handles multidex</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isVMMultidexCapable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isMultidexCapable = <span class="keyword">false</span>;</span><br><span class="line">        String vmName = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isYunOS()) &#123;    <span class="comment">// YunOS需要特殊判断</span></span><br><span class="line">                vmName = <span class="string">"'YunOS'"</span>;</span><br><span class="line">                isMultidexCapable = Integer.valueOf(System.getProperty(<span class="string">"ro.build.version.sdk"</span>)) &gt;= <span class="number">21</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 非YunOS原生Android</span></span><br><span class="line">                vmName = <span class="string">"'Android'"</span>;</span><br><span class="line">                String versionString = System.getProperty(<span class="string">"java.vm.version"</span>);</span><br><span class="line">                <span class="keyword">if</span> (versionString != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Matcher matcher = Pattern.compile(<span class="string">"(\\d+)\\.(\\d+)(\\.\\d+)?"</span>).matcher(versionString);</span><br><span class="line">                    <span class="keyword">if</span> (matcher.matches()) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">int</span> major = Integer.parseInt(matcher.group(<span class="number">1</span>));</span><br><span class="line">                            <span class="keyword">int</span> minor = Integer.parseInt(matcher.group(<span class="number">2</span>));</span><br><span class="line">                            isMultidexCapable = (major &gt; VM_WITH_MULTIDEX_VERSION_MAJOR)</span><br><span class="line">                                    || ((major == VM_WITH_MULTIDEX_VERSION_MAJOR)</span><br><span class="line">                                    &amp;&amp; (minor &gt;= VM_WITH_MULTIDEX_VERSION_MINOR));</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (NumberFormatException ignore) &#123;</span><br><span class="line">                            <span class="comment">// let isMultidexCapable be false</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ignore) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Log.i(Consts.TAG, <span class="string">"VM with name "</span> + vmName + (isMultidexCapable ? <span class="string">" has multidex support"</span> : <span class="string">" does not have multidex support"</span>));</span><br><span class="line">        <span class="keyword">return</span> isMultidexCapable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="InstantRun支持"><a href="#InstantRun支持" class="headerlink" title="InstantRun支持"></a>InstantRun支持</h1><p>在自己运行过程中，貌似InstantRun是不生效的。<code>com.android.tools.fd.runtime.Paths</code>这个类是不存在的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassUtils</span> </span>&#123;  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get instant run dex path, used to catch the branch usingApkSplits=false.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">tryLoadInstantRunDexFile</span><span class="params">(ApplicationInfo applicationInfo)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; instantRunSourcePaths = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP &amp;&amp; <span class="keyword">null</span> != applicationInfo.splitSourceDirs) &#123;</span><br><span class="line">            <span class="comment">// add the split apk, normally for InstantRun, and newest version.</span></span><br><span class="line">            instantRunSourcePaths.addAll(Arrays.asList(applicationInfo.splitSourceDirs));</span><br><span class="line">            Log.d(Consts.TAG, <span class="string">"Found InstantRun support"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// This man is reflection from Google instant run sdk, he will tell me where the dex files go.</span></span><br><span class="line">                Class pathsByInstantRun = Class.forName(<span class="string">"com.android.tools.fd.runtime.Paths"</span>);</span><br><span class="line">                Method getDexFileDirectory = pathsByInstantRun.getMethod(<span class="string">"getDexFileDirectory"</span>, String.class);</span><br><span class="line">                String instantRunDexPath = (String) getDexFileDirectory.invoke(<span class="keyword">null</span>, applicationInfo.packageName);</span><br><span class="line"></span><br><span class="line">                File instantRunFilePath = <span class="keyword">new</span> File(instantRunDexPath);</span><br><span class="line">                <span class="keyword">if</span> (instantRunFilePath.exists() &amp;&amp; instantRunFilePath.isDirectory()) &#123;</span><br><span class="line">                    File[] dexFile = instantRunFilePath.listFiles();</span><br><span class="line">                    <span class="keyword">for</span> (File file : dexFile) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="keyword">null</span> != file &amp;&amp; file.exists() &amp;&amp; file.isFile() &amp;&amp; file.getName().endsWith(<span class="string">".dex"</span>)) &#123;</span><br><span class="line">                            instantRunSourcePaths.add(file.getAbsolutePath());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Log.d(Consts.TAG, <span class="string">"Found InstantRun support"</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Log.e(Consts.TAG, <span class="string">"InstantRun support error, "</span> + e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instantRunSourcePaths;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>整个ARouter没有多少东西，但是值得我们学习的却有很多。框架对整个路由功能的模块划分以及像拦截器、降级处理、替换路径以及分组加载等。</p>
<p><a href="https://github.com/stven0king/RouterHelper.git" target="_blank" rel="noopener">RouterHelper GitHub地址</a></p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>ARouter</tag>
      </tags>
  </entry>
  <entry>
    <title>Android项目解耦--路由框架ARouter的使用</title>
    <url>/2018/02/06/arouter-study/</url>
    <content><![CDATA[<p><a href="http://dandanlove.com/2018/02/06/arouter-source/" target="_blank" rel="noopener">Android项目解耦–路由框架ARouter源码解析</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着业务量的增长，客户端必然随之越来越业务和功能模块耦合越来越生，开发人员代码维护成本越来越高。<br>App一般都会走向组件化、插件化的道路，而组件化、插件化的前提就是解耦，那么我们首先要做的就是解耦页面之间的依赖关系。</p>
<center><img src="http://upload-images.jianshu.io/upload_images/1319879-1cd8adf59a67340d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/620" alt="2.9.png"></center>

<h2 id="目前Android原生页面跳转现状"><a href="#目前Android原生页面跳转现状" class="headerlink" title="目前Android原生页面跳转现状"></a>目前Android原生页面跳转现状</h2><ul>
<li>（显式的startActivity）多个module之前的页面跳转必须使module之间进行依赖；</li>
<li>（隐式的intent-filter）书写麻烦，不好管理成功与否难以控制；</li>
<li>Native页&amp;M页跳转统一Native页面有不同的协议，管理复杂；</li>
<li>页面跳转过程无法干预（增加拦截过滤，日志打点）；</li>
<li>页面跳转结果无法修改（跳转失败进行重定向）；</li>
</ul>
<h2 id="模块解耦-amp-高效开发"><a href="#模块解耦-amp-高效开发" class="headerlink" title="模块解耦&amp;高效开发"></a>模块解耦&amp;高效开发</h2><ul>
<li>“声明/使用” 简单.</li>
<li>适用多module开发,避免直接依赖.</li>
<li>统一协议, 适用”H5/Weex/Native” 跳转 “Native”,对”Android/ios”两个平台协议应该是一样的.</li>
<li>有统一的外部调用入口</li>
<li>能对”不支持”的跳转统一处理</li>
<li>支持跳转前预处理</li>
<li>支持重定向</li>
</ul>
<h2 id="ARouter现在有的模块解耦的最好的轮子"><a href="#ARouter现在有的模块解耦的最好的轮子" class="headerlink" title="ARouter现在有的模块解耦的最好的轮子"></a>ARouter现在有的模块解耦的最好的轮子</h2><p><a href="https://github.com/alibaba/ARouter" target="_blank" rel="noopener">ARouter</a> git上star四千多。</p>
<h3 id="ARouter应用场景"><a href="#ARouter应用场景" class="headerlink" title="ARouter应用场景"></a>ARouter应用场景</h3><blockquote>
<ul>
<li>从外部URL映射到内部页面，以及参数传递与解析</li>
<li>跨模块页面跳转，模块间解耦</li>
<li>拦截跳转过程，处理登陆、埋点等逻辑</li>
<li>跨模块API调用，通过控制反转来做组件解耦</li>
</ul>
</blockquote>
<h3 id="ARouter的已支持功能"><a href="#ARouter的已支持功能" class="headerlink" title="ARouter的已支持功能"></a>ARouter的已支持功能</h3><ul>
<li>支持直接解析标准URL进行跳转，并自动注入参数到目标页面中</li>
<li>支持多模块工程使用</li>
<li>支持添加多个拦截器，自定义拦截顺序</li>
<li>支持依赖注入，可单独作为依赖注入框架使用</li>
<li>支持InstantRun(本人使用时貌似有问题无法找到该类<code>com.android.tools.fd.runtime.Paths</code>)</li>
<li>支持MultiDex(Google方案)</li>
<li>映射关系按组分类、多级管理，按需初始化</li>
<li>支持用户指定全局降级与局部降级策略</li>
<li>页面、拦截器、服务等组件均自动注册到框架</li>
<li>支持多种方式配置转场动画</li>
<li>支持获取Fragment</li>
</ul>
<h3 id="ARouter项目集成"><a href="#ARouter项目集成" class="headerlink" title="ARouter项目集成"></a>ARouter项目集成</h3><h4 id="添加依赖配置"><a href="#添加依赖配置" class="headerlink" title="添加依赖配置"></a>添加依赖配置</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">	...</span><br><span class="line">	javaCompileOptions &#123;</span><br><span class="line">	    annotationProcessorOptions &#123;</span><br><span class="line">		arguments = [ moduleName : project.getName() ]</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">// 替换成最新版本, 需要注意的是api</span></span><br><span class="line">    <span class="comment">// 要与compiler匹配使用，均使用最新版可以保证兼容</span></span><br><span class="line">    compile <span class="string">'com.alibaba:arouter-api:x.x.x'</span></span><br><span class="line">    annotationProcessor <span class="string">'com.alibaba:arouter-compiler:x.x.x'</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 旧版本gradle插件(&lt; 2.2)，可以使用apt插件，配置方法见文末'其他#4'</span></span><br><span class="line"><span class="comment">// Kotlin配置参考文末'其他#5'</span></span><br></pre></td></tr></table></figure>
<h4 id="详细的API说明"><a href="#详细的API说明" class="headerlink" title="详细的API说明"></a>详细的API说明</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构建标准的路由请求</span></span><br><span class="line">ARouter.getInstance().build(<span class="string">"/home/main"</span>).navigation();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建标准的路由请求，并指定分组</span></span><br><span class="line">ARouter.getInstance().build(<span class="string">"/home/main"</span>, <span class="string">"ap"</span>).navigation();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建标准的路由请求，通过Uri直接解析</span></span><br><span class="line">Uri uri;</span><br><span class="line">ARouter.getInstance().build(uri).navigation();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建标准的路由请求，startActivityForResult</span></span><br><span class="line"><span class="comment">// navigation的第一个参数必须是Activity，第二个参数则是RequestCode</span></span><br><span class="line">ARouter.getInstance().build(<span class="string">"/home/main"</span>, <span class="string">"ap"</span>).navigation(<span class="keyword">this</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接传递Bundle</span></span><br><span class="line">Bundle params = <span class="keyword">new</span> Bundle();</span><br><span class="line">ARouter.getInstance()</span><br><span class="line">	.build(<span class="string">"/home/main"</span>)</span><br><span class="line">	.with(params)</span><br><span class="line">	.navigation();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定Flag</span></span><br><span class="line">ARouter.getInstance()</span><br><span class="line">	.build(<span class="string">"/home/main"</span>)</span><br><span class="line">	.withFlags();</span><br><span class="line">	.navigation();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取Fragment</span></span><br><span class="line">Fragment fragment = (Fragment) ARouter.getInstance().build(<span class="string">"/test/fragment"</span>).navigation();</span><br><span class="line">					</span><br><span class="line"><span class="comment">// 对象传递</span></span><br><span class="line">ARouter.getInstance()</span><br><span class="line">	.withObject(<span class="string">"key"</span>, <span class="keyword">new</span> TestObj(<span class="string">"Jack"</span>, <span class="string">"Rose"</span>))</span><br><span class="line">	.navigation();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 觉得接口不够多，可以直接拿出Bundle赋值</span></span><br><span class="line">ARouter.getInstance()</span><br><span class="line">	    .build(<span class="string">"/home/main"</span>)</span><br><span class="line">	    .getExtra();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转场动画(常规方式)</span></span><br><span class="line">ARouter.getInstance()</span><br><span class="line">    .build(<span class="string">"/test/activity2"</span>)</span><br><span class="line">    .withTransition(R.anim.slide_in_bottom, R.anim.slide_out_bottom)</span><br><span class="line">    .navigation(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转场动画(API16+)</span></span><br><span class="line">ActivityOptionsCompat compat = ActivityOptionsCompat.</span><br><span class="line">    makeScaleUpAnimation(v, v.getWidth() / <span class="number">2</span>, v.getHeight() / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ps. makeSceneTransitionAnimation 使用共享元素的时候，需要在navigation方法中传入当前Activity</span></span><br><span class="line"></span><br><span class="line">ARouter.getInstance()</span><br><span class="line">	.build(<span class="string">"/test/activity2"</span>)</span><br><span class="line">	.withOptionsCompat(compat)</span><br><span class="line">	.navigation();</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 使用绿色通道(跳过所有的拦截器)</span></span><br><span class="line">ARouter.getInstance().build(<span class="string">"/home/main"</span>).greenChannel().navigation();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用自己的日志工具打印日志</span></span><br><span class="line">ARouter.setLogger();</span><br></pre></td></tr></table></figure>
<h4 id="添加注解"><a href="#添加注解" class="headerlink" title="添加注解"></a>添加注解</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在支持路由的页面上添加注解(必选)</span></span><br><span class="line"><span class="comment">// 这里的路径需要注意的是至少需要有两级，/xx/xx</span></span><br><span class="line"><span class="meta">@Route</span>(path = <span class="string">"/test/activity"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YourActivity</span> <span class="title">extend</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="初始化SDK"><a href="#初始化SDK" class="headerlink" title="初始化SDK"></a>初始化SDK</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isDebug()) &#123;           <span class="comment">// 这两行必须写在init之前，否则这些配置在init过程中将无效</span></span><br><span class="line">    ARouter.openLog();     <span class="comment">// 打印日志</span></span><br><span class="line">    ARouter.openDebug();   <span class="comment">// 开启调试模式(如果在InstantRun模式下运行，必须开启调试模式！线上版本需要关闭,否则有安全风险)</span></span><br><span class="line">&#125;</span><br><span class="line">ARouter.init(mApplication); <span class="comment">// 尽可能早，推荐在Application中初始化</span></span><br></pre></td></tr></table></figure>
<h4 id="发起路由操作"><a href="#发起路由操作" class="headerlink" title="发起路由操作"></a>发起路由操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 应用内简单的跳转(通过URL跳转在'进阶用法'中)</span></span><br><span class="line">ARouter.getInstance().build(<span class="string">"/test/activity"</span>).navigation();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 跳转并携带参数</span></span><br><span class="line">ARouter.getInstance().build(<span class="string">"/test/1"</span>)</span><br><span class="line">			.withLong(<span class="string">"key1"</span>, <span class="number">666L</span>)</span><br><span class="line">			.withString(<span class="string">"key3"</span>, <span class="string">"888"</span>)</span><br><span class="line">			.withObject(<span class="string">"key4"</span>, <span class="keyword">new</span> Test(<span class="string">"Jack"</span>, <span class="string">"Rose"</span>))</span><br><span class="line">			.navigation();</span><br></pre></td></tr></table></figure>
<h4 id="添加混淆规则-如果使用了Proguard"><a href="#添加混淆规则-如果使用了Proguard" class="headerlink" title="添加混淆规则(如果使用了Proguard)"></a>添加混淆规则(如果使用了Proguard)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-keep <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">alibaba</span>.<span class="title">android</span>.<span class="title">arouter</span>.<span class="title">routes</span>.**</span>&#123;*;&#125;</span><br><span class="line">-keep <span class="class"><span class="keyword">class</span> * <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">alibaba</span>.<span class="title">android</span>.<span class="title">arouter</span>.<span class="title">facade</span>.<span class="title">template</span>.<span class="title">ISyringe</span></span>&#123;*;&#125;</span><br><span class="line"></span><br><span class="line"># 如果使用了 byType 的方式获取 Service，需添加下面规则，保护接口</span><br><span class="line">-keep <span class="class"><span class="keyword">interface</span> * <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">alibaba</span>.<span class="title">android</span>.<span class="title">arouter</span>.<span class="title">facade</span>.<span class="title">template</span>.<span class="title">IProvider</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"># 如果使用了 单类注入，即不定义接口实现 <span class="title">IProvider</span>，需添加下面规则，保护实现</span></span><br><span class="line"><span class="class">-<span class="title">keep</span> <span class="title">class</span> * <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">alibaba</span>.<span class="title">android</span>.<span class="title">arouter</span>.<span class="title">facade</span>.<span class="title">template</span>.<span class="title">IProvider</span></span></span><br></pre></td></tr></table></figure>
<h4 id="通过URL跳转"><a href="#通过URL跳转" class="headerlink" title="通过URL跳转"></a>通过URL跳转</h4><p>html内容<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">        function openActivity() &#123;</span></span><br><span class="line"><span class="undefined">            window.location.href = 'router://dandanlove/activity/ParamsCallActivity?obj=&#123;"age":19,"name":"Jack"&#125;';</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"testDiv"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"openActivity()"</span>&gt;</span>openActivity<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">'router://dandanlove/activity/ParamsCallActivity?name=Tom&amp;age=18&amp;girl=true&amp;obj=&#123;"age":19,"name":"Jack"&#125;'</span>&gt;</span>ExternalCallActivity<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>AndroidManifest.xml注册拦截<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;activity android:name=<span class="string">"com.dandan.tzx.activity.SchameFilterActivity"</span>&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;data</span><br><span class="line">            android:host=<span class="string">"dandanlove"</span></span><br><span class="line">            android:scheme=<span class="string">"router"</span>/&gt;</span><br><span class="line">        &lt;action android:name=<span class="string">"android.intent.action.VIEW"</span>/&gt;</span><br><span class="line">        &lt;category android:name=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span><br><span class="line">        &lt;category android:name=<span class="string">"android.intent.category.BROWSABLE"</span>/&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure></p>
<p>中转页面和目标注解页面<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新建一个Activity用于监听Schame事件,之后直接把url传递给ARouter即可</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SchameFilterActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">	Uri uri = getIntent().getData();</span><br><span class="line">	ARouter.getInstance().build(uri).navigation();</span><br><span class="line">	finish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="解析URL中的参数"><a href="#解析URL中的参数" class="headerlink" title="解析URL中的参数"></a>解析URL中的参数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Router</span>(path = <span class="string">"/activity/ParamsCallActivity"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParamsCallActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="meta">@Autowired</span>(name = <span class="string">"girl"</span>) <span class="comment">// 通过name来映射URL中的不同参数</span></span><br><span class="line">    <span class="keyword">boolean</span> boy;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    TestObj obj;    <span class="comment">// 支持解析自定义对象，URL中使用json传递</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">	ARouter.getInstance().inject(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ARouter会自动对字段进行赋值，无需主动获取</span></span><br><span class="line">	Log.d(<span class="string">"param"</span>, name + age + boy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="自定义序列化服务"><a href="#自定义序列化服务" class="headerlink" title="自定义序列化服务"></a>自定义序列化服务</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果需要传递自定义对象，需要实现 SerializationService,并使用@Route注解标注(方便用户自行选择序列化方式)，例如：</span></span><br><span class="line"><span class="meta">@Route</span>(path = <span class="string">"/service/json"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonServiceImpl</span> <span class="keyword">implements</span> <span class="title">SerializationService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">json2Object</span><span class="params">(String text, Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> JSON.parseObject(text, clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">object2Json</span><span class="params">(Object instance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> JSON.toJSONString(instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="声明拦截器-拦截跳转过程，面向切面编程"><a href="#声明拦截器-拦截跳转过程，面向切面编程" class="headerlink" title="声明拦截器(拦截跳转过程，面向切面编程)"></a>声明拦截器(拦截跳转过程，面向切面编程)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比较经典的应用就是在跳转过程中处理登陆事件，这样就不需要在目标页重复做登陆检查</span></span><br><span class="line"><span class="comment">// 拦截器会在跳转之间执行，多个拦截器会按优先级顺序依次执行</span></span><br><span class="line"><span class="meta">@Interceptor</span>(priority = <span class="number">8</span>, name = <span class="string">"测试用拦截器"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInterceptor</span> <span class="keyword">implements</span> <span class="title">IInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Postcard postcard, InterceptorCallback callback)</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	callback.onContinue(postcard);  <span class="comment">// 处理完成，交还控制权</span></span><br><span class="line">	<span class="comment">// callback.onInterrupt(new RuntimeException("我觉得有点异常"));      // 觉得有问题，中断路由流程</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 以上两种至少需要调用其中一种，否则不会继续路由</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 拦截器的初始化，会在sdk初始化的时候调用该方法，仅会调用一次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="处理跳转结果"><a href="#处理跳转结果" class="headerlink" title="处理跳转结果"></a>处理跳转结果</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用两个参数的navigation方法，可以获取单次跳转的结果</span></span><br><span class="line">ARouter.getInstance().build(<span class="string">"/test/1"</span>).navigation(<span class="keyword">this</span>, <span class="keyword">new</span> NavigationCallback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFound</span><span class="params">(Postcard postcard)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLost</span><span class="params">(Postcard postcard)</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="自定义全局降级策略"><a href="#自定义全局降级策略" class="headerlink" title="自定义全局降级策略"></a>自定义全局降级策略</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现DegradeService接口，并加上一个Path内容任意的注解即可</span></span><br><span class="line"><span class="meta">@Route</span>(path = <span class="string">"/xxx/xxx"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DegradeServiceImpl</span> <span class="keyword">implements</span> <span class="title">DegradeService</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLost</span><span class="params">(Context context, Postcard postcard)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// do something.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="为目标页面声明更多信息"><a href="#为目标页面声明更多信息" class="headerlink" title="为目标页面声明更多信息"></a>为目标页面声明更多信息</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我们经常需要在目标页面中配置一些属性，比方说"是否需要登陆"之类的</span></span><br><span class="line"><span class="comment">// 可以通过 Route 注解中的 extras 属性进行扩展，这个属性是一个 int值，换句话说，单个int有4字节，也就是32位，可以配置32个开关</span></span><br><span class="line"><span class="comment">// 剩下的可以自行发挥，通过字节操作可以标识32个开关，通过开关标记目标页面的一些属性，在拦截器中可以拿到这个标记进行业务逻辑判断</span></span><br><span class="line"><span class="meta">@Route</span>(path = <span class="string">"/test/activity"</span>, extras = Consts.XXXX)</span><br></pre></td></tr></table></figure>
<h4 id="通过依赖注入解耦-服务管理-一-暴露服务"><a href="#通过依赖注入解耦-服务管理-一-暴露服务" class="headerlink" title="通过依赖注入解耦:服务管理(一) 暴露服务"></a>通过依赖注入解耦:服务管理(一) 暴露服务</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明接口,其他组件通过接口来调用服务</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> <span class="keyword">extends</span> <span class="title">IProvider</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现接口</span></span><br><span class="line"><span class="meta">@Route</span>(path = <span class="string">"/service/hello"</span>, name = <span class="string">"测试服务"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"hello, "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="通过依赖注入解耦-服务管理-二-发现服务"><a href="#通过依赖注入解耦-服务管理-二-发现服务" class="headerlink" title="通过依赖注入解耦:服务管理(二) 发现服务"></a>通过依赖注入解耦:服务管理(二) 发现服务</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    HelloService helloService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span>(name = <span class="string">"/service/hello"</span>)</span><br><span class="line">    HelloService helloService2;</span><br><span class="line"></span><br><span class="line">    HelloService helloService3;</span><br><span class="line"></span><br><span class="line">    HelloService helloService4;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ARouter.getInstance().inject(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	 <span class="comment">// 1. (推荐)使用依赖注入的方式发现服务,通过注解标注字段,即可使用，无需主动获取</span></span><br><span class="line">	 <span class="comment">// Autowired注解中标注name之后，将会使用byName的方式注入对应的字段，不设置name属性，会默认使用byType的方式发现服务(当同一接口有多个实现的时候，必须使用byName的方式发现服务)</span></span><br><span class="line">	helloService.sayHello(<span class="string">"Vergil"</span>);</span><br><span class="line">	helloService2.sayHello(<span class="string">"Vergil"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 使用依赖查找的方式发现服务，主动去发现服务并使用，下面两种方式分别是byName和byType</span></span><br><span class="line">	helloService3 = ARouter.getInstance().navigation(HelloService.class);</span><br><span class="line">	helloService4 = (HelloService) ARouter.getInstance().build(<span class="string">"/service/hello"</span>).navigation();</span><br><span class="line">	helloService3.sayHello(<span class="string">"Vergil"</span>);</span><br><span class="line">	helloService4.sayHello(<span class="string">"Vergil"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="重写跳转URL"><a href="#重写跳转URL" class="headerlink" title="重写跳转URL"></a>重写跳转URL</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现PathReplaceService接口，并加上一个Path内容任意的注解即可</span></span><br><span class="line"><span class="meta">@Route</span>(path = <span class="string">"/xxx/xxx"</span>) <span class="comment">// 必须标明注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathReplaceServiceImpl</span> <span class="keyword">implements</span> <span class="title">PathReplaceService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * For normal path.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path raw path</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">forString</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> path;    <span class="comment">// 按照一定的规则处理之后返回处理后的结果</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * For uri type.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> uri raw uri</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">Uri <span class="title">forUri</span><span class="params">(Uri uri)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> url;    <span class="comment">// 按照一定的规则处理之后返回处理后的结果</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>ARouter</tag>
      </tags>
  </entry>
  <entry>
    <title>Dialog、Toast的Window和ViewRootImpl</title>
    <url>/2017/12/11/viewrootimpl-dialog-toast/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>文章<a href="http://blog.csdn.net/stven_king/article/details/49095221" target="_blank" rel="noopener">Activity中的Window的setContentView</a>、<a href="http://blog.csdn.net/stven_king/article/details/78559145" target="_blank" rel="noopener">遇见LayoutInflater&amp;Factory</a>、<a href="http://blog.csdn.net/stven_king/article/details/78775166" target="_blank" rel="noopener">ViewRootImpl的独白，我不是一个View(布局篇)</a> 分别讲述了Activity的<code>setContentView添加View</code>、<code>LayoutInflater布局解析</code>以及<code>添加Window</code>。文章内容都是站在Activity的角度来进行代码解析的，因此我们不再对Dialog和Toast与Activity做具体分析，主要来看看它们与Activity有什么不同之处<code>源码:android-22</code>。</p>
<h1 id="Dialog"><a href="#Dialog" class="headerlink" title="Dialog"></a>Dialog</h1><h2 id="Dialog的构造"><a href="#Dialog的构造" class="headerlink" title="Dialog的构造"></a>Dialog的构造</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dialog</span> <span class="keyword">implements</span> <span class="title">DialogInterface</span>, <span class="title">Window</span>.<span class="title">Callback</span>,</span></span><br><span class="line"><span class="class">        <span class="title">KeyEvent</span>.<span class="title">Callback</span>, <span class="title">OnCreateContextMenuListener</span>,<span class="title">Window</span>.<span class="title">OnWindowDismissedCallback</span></span>&#123;</span><br><span class="line">    <span class="comment">//只有Activity的Context可以启动Dialog，因为Dialog展示的时候需要主题资源也就是ContextThemeWrapper。</span></span><br><span class="line">    Dialog(Context context, <span class="keyword">int</span> theme, <span class="keyword">boolean</span> createContextThemeWrapper) &#123;</span><br><span class="line">        <span class="keyword">if</span> (createContextThemeWrapper) &#123;</span><br><span class="line">            <span class="keyword">if</span> (theme == <span class="number">0</span>) &#123;</span><br><span class="line">                TypedValue outValue = <span class="keyword">new</span> TypedValue();</span><br><span class="line">                context.getTheme().resolveAttribute(com.android.internal.R.attr.dialogTheme,</span><br><span class="line">                        outValue, <span class="keyword">true</span>);</span><br><span class="line">                theme = outValue.resourceId;</span><br><span class="line">            &#125;</span><br><span class="line">            mContext = <span class="keyword">new</span> ContextThemeWrapper(context, theme);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mContext = context;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为每个上下文环境获取的系统服务都是相同的实例，这里获取的WindowManager是Activity的WindowManager。</span></span><br><span class="line">        mWindowManager = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">        <span class="comment">//创建Dialog的PhoneWindow对象。</span></span><br><span class="line">        Window w = PolicyManager.makeNewWindow(mContext);</span><br><span class="line">        mWindow = w;</span><br><span class="line">        w.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        w.setOnWindowDismissedCallback(<span class="keyword">this</span>);</span><br><span class="line">        w.setWindowManager(mWindowManager, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        w.setGravity(Gravity.CENTER);</span><br><span class="line">        <span class="comment">//Handler中的Looper默认为当前线程的Looper</span></span><br><span class="line">        mListenersHandler = <span class="keyword">new</span> ListenersHandler(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Dialog添加View"><a href="#Dialog添加View" class="headerlink" title="Dialog添加View"></a>Dialog添加View</h2><p>和Activity相同通过<code>setContentView</code>初始化 <code>Window</code> 中的 <code>DecorView</code>，并对页面 <code>View</code> 进行add。详细讲述请移动到<a href="http://www.jianshu.com/p/e62990e1c88e" target="_blank" rel="noopener">Activity中的Window的setContentView</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dialog</span> <span class="keyword">implements</span> <span class="title">DialogInterface</span>, <span class="title">Window</span>.<span class="title">Callback</span>,</span></span><br><span class="line"><span class="class">        <span class="title">KeyEvent</span>.<span class="title">Callback</span>, <span class="title">OnCreateContextMenuListener</span>,<span class="title">Window</span>.<span class="title">OnWindowDismissedCallback</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Set the screen content from a layout resource.  The resource will be</span></span><br><span class="line"><span class="comment">     * inflated, adding all top-level views to the screen.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> layoutResID Resource ID to be inflated.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">        mWindow.setContentView(layoutResID);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Dialog的展现"><a href="#Dialog的展现" class="headerlink" title="Dialog的展现"></a>Dialog的展现</h2><p><code>Dialog</code> 的展现和 <code>Activity</code> 不同是因为两者的声明周期不同，<code>Activity</code> 的声明周期是有 <code>AMS</code> 调用而 <code>Dialog</code> 是应用程序自己调用的。<code>ViewRootImpl</code>的初始化在 <code>Activity</code> 会在<code>onResume()</code>方法之后，而是 <code>Dialog</code> 被调用<code>show</code>方法时触发的。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dialog</span> <span class="keyword">implements</span> <span class="title">DialogInterface</span>, <span class="title">Window</span>.<span class="title">Callback</span>,</span></span><br><span class="line"><span class="class">        <span class="title">KeyEvent</span>.<span class="title">Callback</span>, <span class="title">OnCreateContextMenuListener</span>,<span class="title">Window</span>.<span class="title">OnWindowDismissedCallback</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Start the dialog and display it on screen.  The window is placed in the</span></span><br><span class="line"><span class="comment">     * application layer and opaque.  Note that you should not override this</span></span><br><span class="line"><span class="comment">     * method to do initialization when the dialog is shown, instead implement</span></span><br><span class="line"><span class="comment">     * that in &#123;<span class="doctag">@link</span> #onStart&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mShowing) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mDecor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) &#123;</span><br><span class="line">                    mWindow.invalidatePanelMenu(Window.FEATURE_ACTION_BAR);</span><br><span class="line">                &#125;</span><br><span class="line">                mDecor.setVisibility(View.VISIBLE);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mCanceled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//判断是否调用onCreate方法</span></span><br><span class="line">        <span class="keyword">if</span> (!mCreated) &#123;</span><br><span class="line">            dispatchOnCreate(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用onStart方法</span></span><br><span class="line">        onStart();</span><br><span class="line">        <span class="comment">//获取DecorView对象实例</span></span><br><span class="line">        mDecor = mWindow.getDecorView();</span><br><span class="line">        <span class="keyword">if</span> (mActionBar == <span class="keyword">null</span> &amp;&amp; mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) &#123;</span><br><span class="line">            <span class="keyword">final</span> ApplicationInfo info = mContext.getApplicationInfo();</span><br><span class="line">            mWindow.setDefaultIcon(info.icon);</span><br><span class="line">            mWindow.setDefaultLogo(info.logo);</span><br><span class="line">            mActionBar = <span class="keyword">new</span> WindowDecorActionBar(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新Window属性参数</span></span><br><span class="line">        WindowManager.LayoutParams l = mWindow.getAttributes();</span><br><span class="line">        <span class="keyword">if</span> ((l.softInputMode</span><br><span class="line">                &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) == <span class="number">0</span>) &#123;</span><br><span class="line">            WindowManager.LayoutParams nl = <span class="keyword">new</span> WindowManager.LayoutParams();</span><br><span class="line">            nl.copyFrom(l);</span><br><span class="line">            nl.softInputMode |=</span><br><span class="line">                    WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;</span><br><span class="line">            l = nl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//Windowmanger添加Window、ViewRootImpl初始化并绑定Window</span></span><br><span class="line">            mWindowManager.addView(mDecor, l);</span><br><span class="line">            mShowing = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//OnShowListener监听回调</span></span><br><span class="line">            sendShowMessage();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Toast"><a href="#Toast" class="headerlink" title="Toast"></a>Toast</h1><h2 id="Toast的构造"><a href="#Toast的构造" class="headerlink" title="Toast的构造"></a>Toast的构造</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Toast</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Context mContext;</span><br><span class="line">    <span class="keyword">final</span> TN mTN;<span class="comment">//</span></span><br><span class="line">    <span class="keyword">int</span> mDuration;<span class="comment">//展示时间</span></span><br><span class="line">    View mNextView;<span class="comment">//所展示的View</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Construct an empty Toast object.  You must call &#123;<span class="doctag">@link</span> #setView&#125; before you</span></span><br><span class="line"><span class="comment">     * can call &#123;<span class="doctag">@link</span> #show&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context  The context to use.  Usually your &#123;<span class="doctag">@link</span> android.app.Application&#125;</span></span><br><span class="line"><span class="comment">     *                 or &#123;<span class="doctag">@link</span> android.app.Activity&#125; object.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//Context可以为Application也可以为Activity，</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Toast</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        mContext = context;</span><br><span class="line">        mTN = <span class="keyword">new</span> TN();</span><br><span class="line">        mTN.mY = context.getResources().getDimensionPixelSize(</span><br><span class="line">                com.android.internal.R.dimen.toast_y_offset);</span><br><span class="line">        mTN.mGravity = context.getResources().getInteger(</span><br><span class="line">                com.android.internal.R.integer.config_toastDefaultGravity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//NotificationManagerService的客户端IBinder对</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> INotificationManager sService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TN</span> <span class="keyword">extends</span> <span class="title">ITransientNotification</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line">        <span class="comment">/***部分代码省略***/</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> WindowManager.LayoutParams mParams = <span class="keyword">new</span> WindowManager.LayoutParams();</span><br><span class="line">        <span class="comment">//Handler中的Looper默认为当前线程的Looper</span></span><br><span class="line">        <span class="keyword">final</span> Handler mHandler = <span class="keyword">new</span> Handler(); </span><br><span class="line">        TN() &#123;</span><br><span class="line">            <span class="comment">// XXX This should be changed to use a Dialog, with a Theme.Toast</span></span><br><span class="line">            <span class="comment">// defined that sets up the layout params appropriately.</span></span><br><span class="line">            <span class="keyword">final</span> WindowManager.LayoutParams params = mParams;</span><br><span class="line">            params.height = WindowManager.LayoutParams.WRAP_CONTENT;</span><br><span class="line">            params.width = WindowManager.LayoutParams.WRAP_CONTENT;</span><br><span class="line">            params.format = PixelFormat.TRANSLUCENT;</span><br><span class="line">            params.windowAnimations = com.android.internal.R.style.Animation_Toast;</span><br><span class="line">            <span class="comment">//设置Window类型为Toast</span></span><br><span class="line">            params.type = WindowManager.LayoutParams.TYPE_TOAST;</span><br><span class="line">            params.setTitle(<span class="string">"Toast"</span>);</span><br><span class="line">            params.flags = WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON</span><br><span class="line">                    | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE</span><br><span class="line">                    | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>transient_notification.xml</code><br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">"?android:attr/toastFrameBackground"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@android:id/message"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">"center_horizontal"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textAppearance</span>=<span class="string">"@style/TextAppearance.Toast"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">"@color/bright_foreground_dark"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:shadowColor</span>=<span class="string">"#BB000000"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:shadowRadius</span>=<span class="string">"2.75"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="Toast添加View"><a href="#Toast添加View" class="headerlink" title="Toast添加View"></a>Toast添加View</h2><p>从Toast的调用我们开始分析<code>Toast.makeText(MainActivity.this , &quot;Hello World&quot; , Toast.LENGTH_SHORT);</code>我们主要看<code>makeText</code>方法。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Toast</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Make a standard toast that just contains a text view.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context  The context to use.  Usually your &#123;<span class="doctag">@link</span> android.app.Application&#125;</span></span><br><span class="line"><span class="comment">     *                 or &#123;<span class="doctag">@link</span> android.app.Activity&#125; object.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text     The text to show.  Can be formatted text.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> duration How long to display the message.  Either &#123;<span class="doctag">@link</span> #LENGTH_SHORT&#125; or</span></span><br><span class="line"><span class="comment">     *                 &#123;<span class="doctag">@link</span> #LENGTH_LONG&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Toast <span class="title">makeText</span><span class="params">(Context context, CharSequence text, @Duration <span class="keyword">int</span> duration)</span> </span>&#123;</span><br><span class="line">        Toast result = <span class="keyword">new</span> Toast(context);</span><br><span class="line">        <span class="comment">//获取布局解析器</span></span><br><span class="line">        LayoutInflater inflate = (LayoutInflater)</span><br><span class="line">                context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br><span class="line">        <span class="comment">//解析transient_notification.xml生成对应的View</span></span><br><span class="line">        View v = inflate.inflate(com.android.internal.R.layout.transient_notification, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//找到View中的id为message的TextView</span></span><br><span class="line">        TextView tv = (TextView)v.findViewById(com.android.internal.R.id.message);</span><br><span class="line">        <span class="comment">//对Textview进行文字赋值</span></span><br><span class="line">        tv.setText(text);</span><br><span class="line">        <span class="comment">//展示的Toast所用的View</span></span><br><span class="line">        result.mNextView = v;</span><br><span class="line">        <span class="comment">//设置间隔时间</span></span><br><span class="line">        result.mDuration = duration;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主要是对Toast内部成员变量<code>mNextView</code>和<code>mDuration</code>进行初始化。</p>
<h2 id="Toast的展示"><a href="#Toast的展示" class="headerlink" title="Toast的展示"></a>Toast的展示</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzEzMTk4NzktYzhlYWMzNzE0ZDM3MjFkNS5wbmc?x-oss-process=image/format,png#pic_center" alt="toast"></p>
<p>将 <code>Toast</code> 内部的 <code>TN</code> ( <code>ITransientNotification</code> 客户端对象)加入到 <code>INotificationManager</code> 服务端的 <code>Binder</code> 兑现的 <code>mToastQueue</code> 队列中。再由服务端循环遍历 <code>mToastQueue</code> 队列中<code>ToastRecord</code>对象，处理一个移除一个，每次处理的都是 <code>List</code> 的第一个<code>ToastRecord</code>对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Toast</span> </span>&#123;</span><br><span class="line">    <span class="comment">//INotificationManager的客户端的Binder对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> INotificationManager sService;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">private</span> INotificationManager <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sService != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sService;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取INotificationManager的客户端的Binder对象</span></span><br><span class="line">        sService = INotificationManager.Stub.asInterface(ServiceManager.getService(<span class="string">"notification"</span>));</span><br><span class="line">        <span class="keyword">return</span> sService;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Show the view for the specified duration.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//mNextView不能为空</span></span><br><span class="line">        <span class="keyword">if</span> (mNextView == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"setView must have been called"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//service初始哈</span></span><br><span class="line">        INotificationManager service = getService();</span><br><span class="line">        <span class="comment">//获取当前Context对应的包名</span></span><br><span class="line">        String pkg = mContext.getOpPackageName();</span><br><span class="line">        TN tn = mTN;</span><br><span class="line">        tn.mNextView = mNextView;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//将TN加入INotificationManager中的mToastQueue队列</span></span><br><span class="line">            service.enqueueToast(pkg, tn, mDuration);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="comment">// Empty</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>NotificationManagerService</code>在服务端处理<code>ITransientNotification</code>客户端传过来的<code>enqueueToast</code>事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotificationManagerService</span> <span class="keyword">extends</span> <span class="title">SystemService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//是否是系统调用</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isCallerSystem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isUidSystem(Binder.getCallingUid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IBinder mService = <span class="keyword">new</span> INotificationManager.Stub() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueueToast</span><span class="params">(String pkg, ITransientNotification callback, <span class="keyword">int</span> duration)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (DBG) &#123;</span><br><span class="line">                Slog.i(TAG, <span class="string">"enqueueToast pkg="</span> + pkg + <span class="string">" callback="</span> + callback</span><br><span class="line">                        + <span class="string">" duration="</span> + duration);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pkg == <span class="keyword">null</span> || callback == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Slog.e(TAG, <span class="string">"Not doing toast. pkg="</span> + pkg + <span class="string">" callback="</span> + callback);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断是否是系统调动或者是Android系统应用程序进行调用</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> isSystemToast = isCallerSystem() || (<span class="string">"android"</span>.equals(pkg));</span><br><span class="line">            <span class="comment">//Toast或者通知权限被禁用</span></span><br><span class="line">            <span class="keyword">if</span> (ENABLE_BLOCKED_TOASTS &amp;&amp; !noteNotificationOp(pkg, Binder.getCallingUid())) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!isSystemToast) &#123;</span><br><span class="line">                    Slog.e(TAG, <span class="string">"Suppressing toast from package "</span> + pkg + <span class="string">" by user request."</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//mToastQueue加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (mToastQueue) &#123;</span><br><span class="line">                <span class="keyword">int</span> callingPid = Binder.getCallingPid();</span><br><span class="line">                <span class="keyword">long</span> callingId = Binder.clearCallingIdentity();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ToastRecord record;</span><br><span class="line">                    <span class="comment">//寻找当前callback在mToastQueue中的索引，没找到则返回-1</span></span><br><span class="line">                    <span class="keyword">int</span> index = indexOfToastLocked(pkg, callback);</span><br><span class="line">                    <span class="comment">// If it's already in the queue, we update it in place, we don't</span></span><br><span class="line">                    <span class="comment">// move it to the end of the queue.</span></span><br><span class="line">                    <span class="comment">//index&gt;=0表示mToastQueue中有该callback的索引，record进行更新展示时间</span></span><br><span class="line">                    <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        record = mToastQueue.get(index);</span><br><span class="line">                        record.update(duration);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// Limit the number of toasts that any given package except the android</span></span><br><span class="line">                        <span class="comment">// package can enqueue.  Prevents DOS attacks and deals with leaks.</span></span><br><span class="line">                        <span class="comment">//不是系统的Toast</span></span><br><span class="line">                        <span class="keyword">if</span> (!isSystemToast) &#123;</span><br><span class="line">                            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">                            <span class="keyword">final</span> <span class="keyword">int</span> N = mToastQueue.size();</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">                                 <span class="keyword">final</span> ToastRecord r = mToastQueue.get(i);</span><br><span class="line">                                 <span class="comment">//判断当前的Toast是不是同一个包发出的</span></span><br><span class="line">                                 <span class="keyword">if</span> (r.pkg.equals(pkg)) &#123;</span><br><span class="line">                                     count++;</span><br><span class="line">                                     <span class="comment">//当前包的需要展示的Toast缓存数量&gt;=50</span></span><br><span class="line">                                     <span class="keyword">if</span> (count &gt;= MAX_PACKAGE_NOTIFICATIONS) &#123;</span><br><span class="line">                                         Slog.e(TAG, <span class="string">"Package has already posted "</span> + count</span><br><span class="line">                                                + <span class="string">" toasts. Not showing more. Package="</span> + pkg);</span><br><span class="line">                                         <span class="keyword">return</span>;</span><br><span class="line">                                     &#125;</span><br><span class="line">                                 &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//根据callback等信息构造ToastRecord对象</span></span><br><span class="line">                        record = <span class="keyword">new</span> ToastRecord(callingPid, pkg, callback, duration);</span><br><span class="line">                        <span class="comment">//将新的ToastRecord对象加入到队列总</span></span><br><span class="line">                        mToastQueue.add(record);</span><br><span class="line">                        <span class="comment">//加入之后当前的索引是lenth-1</span></span><br><span class="line">                        index = mToastQueue.size() - <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">//将当前包对应的线程切换为前台线程</span></span><br><span class="line">                        keepProcessAliveLocked(callingPid);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// If it's at index 0, it's the current toast.  It doesn't matter if it's</span></span><br><span class="line">                    <span class="comment">// new or just been updated.  Call back and tell it to show itself.</span></span><br><span class="line">                    <span class="comment">// If the callback fails, this will remove it from the list, so don't</span></span><br><span class="line">                    <span class="comment">// assume that it's valid after this.</span></span><br><span class="line">                    <span class="comment">//如果之前队列中没有正在处理的消息，那么处理当前这个ToastRecord</span></span><br><span class="line">                    <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">                        showNextToastLocked();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    Binder.restoreCallingIdentity(callingId);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>NotificationManagerService</code>使用先进先出（<code>FIFO</code>）的方式处理 <code>mToastQueue</code> 队列中的消息。</p>
<ul>
<li><p>服务端的处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotificationManagerService</span> <span class="keyword">extends</span> <span class="title">SystemService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showNextToastLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取队列第一个ToastRecord</span></span><br><span class="line">        ToastRecord record = mToastQueue.get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (record != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DBG) Slog.d(TAG, <span class="string">"Show pkg="</span> + record.pkg + <span class="string">" callback="</span> + record.callback);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//调用客户端Binder对应的TN.show方法。</span></span><br><span class="line">                record.callback.show();</span><br><span class="line">                scheduleTimeoutLocked(record);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Object died trying to show notification "</span> + record.callback</span><br><span class="line">                        + <span class="string">" in package "</span> + record.pkg);</span><br><span class="line">                <span class="comment">// remove it from the list and let the process die</span></span><br><span class="line">                <span class="comment">//当前Toast客户端Binder方法调用抛出异常</span></span><br><span class="line">                <span class="comment">//移除当前ToastRecord</span></span><br><span class="line">                <span class="keyword">int</span> index = mToastQueue.indexOf(record);</span><br><span class="line">                <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    mToastQueue.remove(index);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//切换当前ToastRecord进程</span></span><br><span class="line">                keepProcessAliveLocked(record.pid);</span><br><span class="line">                <span class="comment">//遍历对象变为列表下一个oastRecord对象</span></span><br><span class="line">                <span class="keyword">if</span> (mToastQueue.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    record = mToastQueue.get(<span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    record = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端的处理</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TN</span> <span class="keyword">extends</span> <span class="title">ITransientNotification</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * schedule handleShow into the right thread</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">"SHOW: "</span> + <span class="keyword">this</span>);</span><br><span class="line">        mHandler.post(mShow);<span class="comment">//利用Handler执行mShow</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Runnable mShow = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            handleShow();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//展示Toast</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleShow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">"HANDLE SHOW: "</span> + <span class="keyword">this</span> + <span class="string">" mView="</span> + mView</span><br><span class="line">                + <span class="string">" mNextView="</span> + mNextView);</span><br><span class="line">        <span class="comment">//判断mNextView是否展示过</span></span><br><span class="line">        <span class="keyword">if</span> (mView != mNextView) &#123;</span><br><span class="line">            <span class="comment">// remove the old view if necessary</span></span><br><span class="line">            <span class="comment">//移除当前展示的Toast</span></span><br><span class="line">            handleHide();</span><br><span class="line">            mView = mNextView;</span><br><span class="line">            <span class="comment">//获取当前的应用程序的上下文环境</span></span><br><span class="line">            Context context = mView.getContext().getApplicationContext();</span><br><span class="line">            <span class="comment">//获取当前包名</span></span><br><span class="line">            String packageName = mView.getContext().getOpPackageName();</span><br><span class="line">            <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">                context = mView.getContext();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取上下文环境的WindowManagerImpl</span></span><br><span class="line">            mWM = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">            <span class="comment">// We can resolve the Gravity here by using the Locale for getting</span></span><br><span class="line">            <span class="comment">// the layout direction</span></span><br><span class="line">            <span class="keyword">final</span> Configuration config = mView.getContext().getResources().getConfiguration();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> gravity = Gravity.getAbsoluteGravity(mGravity, config.getLayoutDirection());</span><br><span class="line">            <span class="comment">//设置参数的重力防线</span></span><br><span class="line">            mParams.gravity = gravity;</span><br><span class="line">            <span class="keyword">if</span> ((gravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) == Gravity.FILL_HORIZONTAL) &#123;</span><br><span class="line">                mParams.horizontalWeight = <span class="number">1.0f</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((gravity &amp; Gravity.VERTICAL_GRAVITY_MASK) == Gravity.FILL_VERTICAL) &#123;</span><br><span class="line">                mParams.verticalWeight = <span class="number">1.0f</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//设置参数的坐标和偏移量</span></span><br><span class="line">            mParams.x = mX;</span><br><span class="line">            mParams.y = mY;</span><br><span class="line">            mParams.verticalMargin = mVerticalMargin;</span><br><span class="line">            mParams.horizontalMargin = mHorizontalMargin;</span><br><span class="line">            mParams.packageName = packageName;</span><br><span class="line">            <span class="comment">//如果mView添加过，那么先把mView从WindowManager中移除。</span></span><br><span class="line">            <span class="keyword">if</span> (mView.getParent() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">"REMOVE! "</span> + mView + <span class="string">" in "</span> + <span class="keyword">this</span>);</span><br><span class="line">                mWM.removeView(mView);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">"ADD! "</span> + mView + <span class="string">" in "</span> + <span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">//把需要展示的View添加在WindowManager中</span></span><br><span class="line">            mWM.addView(mView, mParams);</span><br><span class="line">            trySendAccessibilityEvent();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Toast的消失"><a href="#Toast的消失" class="headerlink" title="Toast的消失"></a>Toast的消失</h2><p>系统的 <code>Toast</code> 的 <code>hide</code> 都是在 <code>INotificationManager</code> 的服务端 <code>Binder</code> 中发起的，但最终的执行都是在 <code>INotificationManager</code> 的客户端 <code>Binder</code> 中执行的。</p>
<ul>
<li><p>服务端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotificationManagerService</span> <span class="keyword">extends</span> <span class="title">SystemService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what)&#123;</span><br><span class="line">                <span class="keyword">case</span> MESSAGE_TIMEOUT:</span><br><span class="line">                    <span class="comment">//调用当前的Toast的hide</span></span><br><span class="line">                    handleTimeout((ToastRecord)msg.obj);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MESSAGE_SAVE_POLICY_FILE:</span><br><span class="line">                    handleSavePolicyFile();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MESSAGE_SEND_RANKING_UPDATE:</span><br><span class="line">                    handleSendRankingUpdate();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MESSAGE_LISTENER_HINTS_CHANGED:</span><br><span class="line">                    handleListenerHintsChanged(msg.arg1);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MESSAGE_LISTENER_NOTIFICATION_FILTER_CHANGED:</span><br><span class="line">                    handleListenerInterruptionFilterChanged(msg.arg1);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//让当前Toast展示一段时间后消失</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleTimeoutLocked</span><span class="params">(ToastRecord r)</span></span>&#123;</span><br><span class="line">        <span class="comment">//移除mHandler关于这个TaostRecord的所有Message</span></span><br><span class="line">        mHandler.removeCallbacksAndMessages(r);</span><br><span class="line">        Message m = Message.obtain(mHandler, MESSAGE_TIMEOUT, r);</span><br><span class="line">        <span class="keyword">long</span> delay = r.duration == Toast.LENGTH_LONG ? LONG_DELAY : SHORT_DELAY;</span><br><span class="line">        <span class="comment">//发送一个delayed=duration的MESSAGE_TIMEOUT事件</span></span><br><span class="line">        mHandler.sendMessageDelayed(m, delay);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使Toast消失</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleTimeout</span><span class="params">(ToastRecord record)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DBG) Slog.d(TAG, <span class="string">"Timeout pkg="</span> + record.pkg + <span class="string">" callback="</span> + record.callback);</span><br><span class="line">        <span class="keyword">synchronized</span> (mToastQueue) &#123;</span><br><span class="line">            <span class="comment">//找当前ToastRecord在mToastQueue队列中的索引</span></span><br><span class="line">            <span class="keyword">int</span> index = indexOfToastLocked(record.pkg, record.callback);</span><br><span class="line">            <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                cancelToastLocked(index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用当前索引=index的ToastRecord.callback.hide</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cancelToastLocked</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        ToastRecord record = mToastQueue.get(index);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">////调用客户端Binder对应的TN.hide方法。</span></span><br><span class="line">            record.callback.hide();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Object died trying to hide notification "</span> + record.callback</span><br><span class="line">                    + <span class="string">" in package "</span> + record.pkg);</span><br><span class="line">            <span class="comment">// don't worry about this, we're about to remove it from</span></span><br><span class="line">            <span class="comment">// the list anyway</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//移除处理完的ToastRecord</span></span><br><span class="line">        mToastQueue.remove(index);</span><br><span class="line">        keepProcessAliveLocked(record.pid);</span><br><span class="line">        <span class="keyword">if</span> (mToastQueue.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Show the next one. If the callback fails, this will remove</span></span><br><span class="line">            <span class="comment">// it from the list, so don't assume that the list hasn't changed</span></span><br><span class="line">            <span class="comment">// after this point.</span></span><br><span class="line">            <span class="comment">//处理队列中的下一个ToastRecord</span></span><br><span class="line">            showNextToastLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TN</span> <span class="keyword">extends</span> <span class="title">ITransientNotification</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * schedule handleHide into the right thread</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hide</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">"HIDE: "</span> + <span class="keyword">this</span>);</span><br><span class="line">        mHandler.post(mHide);<span class="comment">//利用Handler执行mHide</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Runnable mHide = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            handleHide();</span><br><span class="line">            <span class="comment">// Don't do this in handleHide() because it is also invoked by handleShow()</span></span><br><span class="line">            mNextView = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleHide</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">"HANDLE HIDE: "</span> + <span class="keyword">this</span> + <span class="string">" mView="</span> + mView);</span><br><span class="line">        <span class="keyword">if</span> (mView != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// note: checking parent() just to make sure the view has</span></span><br><span class="line">            <span class="comment">// been added...  i have seen cases where we get here when</span></span><br><span class="line">            <span class="comment">// the view isn't yet added, so let's try not to crash.</span></span><br><span class="line">            <span class="keyword">if</span> (mView.getParent() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">"REMOVE! "</span> + mView + <span class="string">" in "</span> + <span class="keyword">this</span>);</span><br><span class="line">                <span class="comment">//调用WindowManager的removeView移除mView</span></span><br><span class="line">                mWM.removeView(mView);</span><br><span class="line">            &#125;</span><br><span class="line">            mView = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Dialog和Toast在异步线程的展现"><a href="#Dialog和Toast在异步线程的展现" class="headerlink" title="Dialog和Toast在异步线程的展现"></a>Dialog和Toast在异步线程的展现</h1><p><a href="https://dandanlove.blog.csdn.net/article/details/78775166" target="_blank" rel="noopener">ViewRootImpl的独白，我不是一个View(布局篇)</a> 这篇文章说明了为什么我们一般禁止在非 <code>UI线程</code> 中刷新 <code>View</code> ，以及怎么安全的在异步线程<strong>操作UI</strong>。</p>
<blockquote>
<p>发生了对任务执行线程的校验，而且当前执行任务的线程与创建 <code>ViewRootImpl</code> 的线程不一样；。</p>
</blockquote>
<p>那么 <code>Toast</code> 、 <code>Dialog</code> 和 <code>View</code> 的<strong>异步展现</strong>，与<strong>异步操作UI</strong>是否一致呢？</p>
<p>首先测试一下异步展现 <code>Dialog</code> 和 <code>Toast</code> :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Toast展现</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Looper.prepare();</span></span><br><span class="line">        Toast.makeText(TestActivity.<span class="keyword">this</span>, <span class="string">"test"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">        <span class="comment">//Looper.loop();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="comment">//Dialog的展现</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Looper.prepare();</span></span><br><span class="line">        <span class="keyword">new</span> MyDialog(TestActivity.<span class="keyword">this</span>, <span class="string">"test"</span>).show();</span><br><span class="line">        <span class="comment">//Looper.loop();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<p>崩溃日志：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Toast崩溃日志</span></span><br><span class="line">17:30:04.211#[androidcode@]#30824#E#AndroidRuntime #FATAL EXCEPTION: Thread-2</span><br><span class="line">		Process: com.tzx.androidcode, PID: <span class="number">30513</span></span><br><span class="line">		java.lang.RuntimeException: Can<span class="string">'t toast on a thread that has not called Looper.prepare()</span></span><br><span class="line"><span class="string">		at android.widget.Toast$TN.&lt;init&gt;(Toast.java:394)</span></span><br><span class="line"><span class="string">		at android.widget.Toast.&lt;init&gt;(Toast.java:114)</span></span><br><span class="line"><span class="string">		at android.widget.Toast.makeText(Toast.java:277)</span></span><br><span class="line"><span class="string">		at android.widget.Toast.makeText(Toast.java:267)</span></span><br><span class="line"><span class="string">		at com.tzx.androidcode.activity.TestActivity$1.run(TestActivity.java:72)</span></span><br><span class="line"><span class="string">		at java.lang.Thread.run(Thread.java:764)</span></span><br><span class="line"><span class="string">//Dialog的崩溃日志</span></span><br><span class="line"><span class="string">17:33:07.961#[androidcode@]#31514#E#AndroidRuntime #FATAL EXCEPTION: Thread-2</span></span><br><span class="line"><span class="string">		Process: com.tzx.androidcode, PID: 31438</span></span><br><span class="line"><span class="string">		java.lang.RuntimeException: Can'</span>t create handler inside thread that has not called Looper.prepare()</span><br><span class="line">		at android.os.Handler.&lt;init&gt;(Handler.java:<span class="number">203</span>)</span><br><span class="line">		at android.os.Handler.&lt;init&gt;(Handler.java:<span class="number">117</span>)</span><br><span class="line">		at android.app.Dialog.&lt;init&gt;(Dialog.java:<span class="number">123</span>)</span><br><span class="line">		at android.app.Dialog.&lt;init&gt;(Dialog.java:<span class="number">149</span>)</span><br><span class="line">		at com.tzx.rollaction.test.BaseDailog.&lt;init&gt;(BaseDailog.java:<span class="number">23</span>)</span><br><span class="line">		at com.tzx.rollaction.test.MyDialog.&lt;init&gt;(MyDialog.java:<span class="number">20</span>)</span><br><span class="line">		at com.tzx.androidcode.activity.TestActivity$<span class="number">2</span>.run(TestActivity.java:<span class="number">86</span>)</span><br><span class="line">		at java.lang.Thread.run(Thread.java:<span class="number">764</span>)</span><br></pre></td></tr></table></figure>
<p>我们可以看到都是提示 <code>当前的Handler的Looper没有调用prepare</code>。<br>我们在上面进行源码阅读的时候都看到了 <code>Toast.TN</code> 和 <code>Dialog</code> 构造的时候的 <code>Handler</code> 都是默认当前线程的 <code>Looper</code> 。<br>如果当前线程的 <code>Looper</code> 没有 <code>prepare</code> 那么必定会抛异常，如果仅仅执行了 <code>prepare</code> 那么崩溃不会产生了，但是依旧不展示。因为整个 <code>Looper</code> 还没有开始，里面的 <code>Message</code> 都未进行处理。最后我们将代码中注释的 <code>Looper.prepare();</code> 和 <code>Looper.loop();</code> 打开就可以正常在异步线程进行 <code>Toast</code> 和 <code>Dialog</code> 的展现。</p>
<p>所以 <code>Toast</code> 和 <code>Dialog</code> 的异步展现其实主要是与其线程的 <code>Looper</code> 队列有关。 <code>Toast</code> 和 <code>Dialog</code> 展示的时候进行的 <code>ViewRootImpl</code> 的创建，这个执行<strong>UI操作</strong>的也是这个线程，所以展现不会发现异常。如果对 <code>Dialog</code> 进行<strong>异步刷新UI</strong> ，那么他的限制和 <code>View</code> 的异步刷新是相同的。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过分析<code>Activity</code>、<code>Dialog</code>、<code>Toast</code>通过对 <code>ViewRootImpl</code> 的更细节的分析，所有添加在窗口上的 <code>View</code> 都有一个 <code>ViewRootImpl</code> 作为它的 <code>Parent</code> ，处理View的布局、事件处理等。</p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>ViewRootImpl</tag>
        <tag>Toast</tag>
        <tag>Dialog</tag>
      </tags>
  </entry>
  <entry>
    <title>ViewRootImpl的独白，我不是一个View(布局篇)</title>
    <url>/2017/12/11/viewrootimpl-activity/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前一段时间写过两篇关于View的文章 <a href="http://blog.csdn.net/stven_king/article/details/49095221" target="_blank" rel="noopener">Activity中的Window的setContentView</a> 和 <a href="http://blog.csdn.net/stven_king/article/details/78559145" target="_blank" rel="noopener">遇见LayoutInflater&amp;Factory</a> 。分析了Activity设置页面布局到页面View元素进行布局到底经历了一个怎么样的过程？</p>
<blockquote>
<ul>
<li>Activity的attach中生成PhoneWindow对象;</li>
<li>setContentView中初始化DecorView（ViewGroup）;</li>
<li>在LayoutInflater进行对布局文件的解析之后更加解析的数据</li>
<li>根据解析出的数据执行View的构造函数进行View的构造，同时生成ViewTree。</li>
</ul>
</blockquote>
<p>为什么接下来继续写这篇文章呢？是因为我在掘金上看到一篇子线程更新View的文章之后，发现自己对View还不是很了，以这个问题为方向看了View相关的源码。发现网络上有些文章对于ViewRootImpl的分析还是有些问题或者疑惑的，所以自己整理过的知识点分享给大家，希望能对大家有帮助。（<code>源码cm12.1</code>）</p>
<h1 id="View的介绍"><a href="#View的介绍" class="headerlink" title="View的介绍"></a>View的介绍</h1><p>最开始学习View的时候最先分析的是它的布局（LinearLayout、FrameLayout、TableLayout、RelativeLayout、AbsoluteLayout）,然后是它的三大方法（measure、layout、draw）。</p>
<h2 id="绘制-amp-加载View—–onMeasure"><a href="#绘制-amp-加载View—–onMeasure" class="headerlink" title="绘制&amp;加载View—–onMeasure()"></a>绘制&amp;加载View—–onMeasure()</h2><blockquote>
<ul>
<li>MeasureSpec.EXACTLY是精确尺寸， 当我们将控件的layout_width或layout_height指定为具体数值时如andorid:layout_width=”50dip”，或者为FILL_PARENT是，都是控件大小已经确定的情况，都是精确尺寸。</li>
<li>MeasureSpec.AT_MOST是最大尺寸，当控件的layout_width或layout_height指定为WRAP_CONTENT时  ，控件大小一般随着控件的子空间或内容进行变化，此时控件尺寸只要不超过父控件允许的最大尺寸即可。因此，此时的mode是AT_MOST，size给出了父控件允许的最大尺寸。  </li>
<li>MeasureSpec.UNSPECIFIED是未指定尺寸，这种情况不多，一般都是父控件是AdapterView,通过measure方法传入的模式。</li>
</ul>
</blockquote>
<p>ViewGroup.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildren</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChild</span><span class="params">(View child, <span class="keyword">int</span> parentWidthMeasureSpec,<span class="keyword">int</span> parentHeightMeasureSpec)</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildWithMargins</span><span class="params">(View child,<span class="keyword">int</span> parentWidthMeasureSpec, <span class="keyword">int</span> widthUsed,<span class="keyword">int</span> parentHeightMeasureSpec, <span class="keyword">int</span> heightUsed)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="绘制-amp-加载View—–onLayout"><a href="#绘制-amp-加载View—–onLayout" class="headerlink" title="绘制&amp;加载View—–onLayout()"></a>绘制&amp;加载View—–onLayout()</h2><blockquote>
<ul>
<li>onLayout方法：是ViewGroup中子View的布局方法。放置子View很简单，只需在重写onLayout方法，然后获取子View的实例，调用子View的layout方法实现布局。在实际开发中，一般要配合onMeasure测量方法一起使用。View的放置都是根据一个矩形空间放置的。</li>
<li>layout方法：是View的放置方法，在View类实现。调用该方法需要传入放置View的矩形空间左上角left、top值和右下角right、bottom值。</li>
</ul>
</blockquote>
<h2 id="绘制-amp-加载View—–onDraw"><a href="#绘制-amp-加载View—–onDraw" class="headerlink" title="绘制&amp;加载View—–onDraw()"></a>绘制&amp;加载View—–onDraw()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span><span class="params">(View,ViewGroup)</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">drawChild</span><span class="params">(Canvas canvas, View child, <span class="keyword">long</span> drawingTime)</span> <span class="params">(ViewGroup)</span></span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20191023100908801.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kYW5kYW5sb3ZlLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70#pic_center" alt="ViewTree"></p>
<h1 id="View的解析与生成"><a href="#View的解析与生成" class="headerlink" title="View的解析与生成"></a>View的解析与生成</h1><p>View的解析和生成之前在下边的这两篇文章中已经讲述</p>
<blockquote>
<p>View如何在页面进行展示的，View树是如何生成的。<br><a href="http://blog.csdn.net/stven_king/article/details/49095221" target="_blank" rel="noopener">Activity中的Window的setContentView</a></p>
</blockquote>
<blockquote>
<p>View对象的生成，属性值的初始化。<br><a href="http://blog.csdn.net/stven_king/article/details/78559145" target="_blank" rel="noopener">遇见LayoutInflater&amp;Factory</a></p>
</blockquote>
<p>在这两篇文章中用到了一些Android中相关的类：</p>
<blockquote>
<ul>
<li>Activity：一个Activity是一个应用程序组件,提供一个屏幕,用户可以用来交互为了完成某项任务,例如拨号、拍照、发送email……。</li>
<li>View：作为所有图形的基类。</li>
<li>ViewGroup:对View继承扩展为视图容器类。</li>
<li>Window:它概括了Android窗口的基本属性和基本功能。(抽象类)</li>
<li>PhoneWindow:Window的子类。</li>
<li>DecorView：界面的根View，PhoneWindow的内部类。</li>
<li>ViewRootImpl:ViewRoot是GUI管理系统与GUI呈现系统之间的桥梁。</li>
<li>WindowManangerService：简称WMS,它的作用是管理所有应用程序中的窗口，并用于管理用户与这些窗口发生的的各种交互。</li>
</ul>
</blockquote>
<h1 id="ViewRootImpl简介"><a href="#ViewRootImpl简介" class="headerlink" title="ViewRootImpl简介"></a>ViewRootImpl简介</h1><p><code>The top of a view hierarchy, implementing the needed protocol between View and the WindowManager.  This is for the most part an internal implementation detail of {@link WindowManagerGlobal}.</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewRootImpl</span> <span class="keyword">implements</span> <span class="title">ViewParent</span>,</span></span><br><span class="line"><span class="class">        <span class="title">View</span>.<span class="title">AttachInfo</span>.<span class="title">Callbacks</span>, <span class="title">HardwareRenderer</span>.<span class="title">HardwareDrawCallbacks</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*******部分代码省略**********/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ViewRootImpl是View中的最高层级，属于所有View的根（<code>但ViewRootImpl不是View，只是实现了ViewParent接口</code>），实现了View和WindowManager之间的通信协议，实现的具体细节在WindowManagerGlobal这个类当中。</p>
<p><img src="https://img-blog.csdnimg.cn/20191023101002907.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kYW5kYW5sb3ZlLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70#pic_center" alt="ViewManager"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ViewManager</span></span>&#123;</span><br><span class="line">    <span class="comment">//添加View</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params)</span></span>;</span><br><span class="line">    <span class="comment">//更新View</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateViewLayout</span><span class="params">(View view, ViewGroup.LayoutParams params)</span></span>;</span><br><span class="line">    <span class="comment">//移除View</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeView</span><span class="params">(View view)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面提到了<code>WindowManager</code>对<code>View</code>的添加、更新、删除操作，那么联系这两者之间的<code>Window</code>呢？</p>
<blockquote>
<p> <a href="http://www.jianshu.com/p/e62990e1c88e" target="_blank" rel="noopener">Activity中的Window的setContentView</a> 阅读这篇文章我们知道Activity中有Window对象，一个Window对象对应着一个View（<code>DecorView</code>），<code>ViewRootImpl</code>就是对这个View进行操作的。</p>
</blockquote>
<p>我们知道界面所有的元素都是有View构成的，界面上的每一个像素点也都是由View绘制的。Window只是一个抽象的概念，把界面抽象为一个窗口对象，也可以抽象为一个View。</p>
<h1 id="ViewRootImpl与其他类之间的关系"><a href="#ViewRootImpl与其他类之间的关系" class="headerlink" title="ViewRootImpl与其他类之间的关系"></a>ViewRootImpl与其他类之间的关系</h1><p>在了解ViewRootImpl与其他类的关系之前，我们先看一副图和一段代码：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzEzMTk4NzktYjg0NTQwNmE2YzQ3MmMyZC5qcGc?x-oss-process=image/format,png#pic_center" alt="ViewRootImpl.jpg"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowManagerGlobal</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*******部分代码省略**********/</span></span><br><span class="line">    <span class="comment">//所有Window对象中的View</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;View&gt; mViews = <span class="keyword">new</span> ArrayList&lt;View&gt;();</span><br><span class="line">    <span class="comment">//所有Window对象中的View所对应的ViewRootImpl</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;ViewRootImpl&gt; mRoots = <span class="keyword">new</span> ArrayList&lt;ViewRootImpl&gt;();</span><br><span class="line">    <span class="comment">//所有Window对象中的View所对应的布局参数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;WindowManager.LayoutParams&gt; mParams = <span class="keyword">new</span> ArrayList&lt;WindowManager.LayoutParams&gt;();</span><br><span class="line">    <span class="comment">/*******部分代码省略**********/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>WindowManagerGlobal</code>在其内部存储着<code>ViewRootImpl</code>和<code>View</code>实例的映射关系(顺序存储)。</p>
</li>
<li><p><code>WindowManager</code>继承与<code>ViewManger</code>，从<code>ViewManager</code>这个类名来看就是用来对<code>View</code>类进行管理的，从<code>ViewManager</code>接口中的添加、更新、删除View的方法也可以看出来<code>WindowManager</code>对<code>View</code>的管理。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowManagerImpl</span> <span class="keyword">implements</span> <span class="title">WindowManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(@NonNull View view, @NonNull ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">        applyDefaultToken(params);</span><br><span class="line">        mGlobal.addView(view, params, mDisplay, mParentWindow);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateViewLayout</span><span class="params">(@NonNull View view, @NonNull ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">        applyDefaultToken(params);</span><br><span class="line">        mGlobal.updateViewLayout(view, params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeView</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        mGlobal.removeView(view, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*******部分代码省略**********/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>WindowManagerImpl</code>为<code>WindowManager</code>的实现类。<code>WindowManagerImpl</code>内部方法实现都是由代理类<code>WindowManagerGlobal</code>完成，而<code>WindowManagerGlobal</code>是一个单例，也就是一个进程中只有一个<code>WindowManagerGlobal</code>对象服务于所有页面的View。</li>
</ul>
<h1 id="ViewRootImpl的初始化"><a href="#ViewRootImpl的初始化" class="headerlink" title="ViewRootImpl的初始化"></a>ViewRootImpl的初始化</h1><p>在Activity的onResume之后，当前Activity的Window对象中的View会被添加在WindowManager中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThread</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*******部分代码省略**********/</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> clearHide, <span class="keyword">boolean</span> isForward, <span class="keyword">boolean</span> reallyResume)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*******部分代码省略**********/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO Push resumeArgs into the activity for consideration</span></span><br><span class="line">        ActivityClientRecord r = performResumeActivity(token, clearHide);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">/*******部分代码省略**********/</span></span><br><span class="line">            <span class="keyword">if</span> (r.window == <span class="keyword">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">                r.window = r.activity.getWindow();</span><br><span class="line">                View decor = r.window.getDecorView();</span><br><span class="line">                decor.setVisibility(View.INVISIBLE);</span><br><span class="line">                ViewManager wm = a.getWindowManager();</span><br><span class="line">                WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">                a.mDecor = decor;</span><br><span class="line">                <span class="comment">//window的类型：一个应用窗口类型（所有的应用窗口类型都展现在最顶部）。</span></span><br><span class="line">                l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">                l.softInputMode |= forwardBit;</span><br><span class="line">                <span class="keyword">if</span> (a.mVisibleFromClient) &#123;</span><br><span class="line">                    a.mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="comment">//将decor添加在WindowManager中</span></span><br><span class="line">                    wm.addView(decor, l);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If the window has already been added, but during resume</span></span><br><span class="line">            <span class="comment">// we started another activity, then don't yet make the</span></span><br><span class="line">            <span class="comment">// window visible.</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!willBeVisible) &#123;</span><br><span class="line">                <span class="keyword">if</span> (localLOGV) Slog.v(</span><br><span class="line">                    TAG, <span class="string">"Launch "</span> + r + <span class="string">" mStartedActivity set"</span>);</span><br><span class="line">                r.hideForNow = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*******部分代码省略**********/</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// If an exception was thrown when trying to resume, then</span></span><br><span class="line">            <span class="comment">// just end this activity.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ActivityManagerNative.getDefault()</span><br><span class="line">                    .finishActivity(token, Activity.RESULT_CANCELED, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建Window所对应的ViewRootImpl，并将Window所对应的View、ViewRootImpl、LayoutParams顺序添加在WindowManager中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowManagerGlobal</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*******部分代码省略**********/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class="line"><span class="function"><span class="params">            Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//检查参数是否合法</span></span><br><span class="line">        <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"view must not be null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (display == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"display must not be null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(params <span class="keyword">instanceof</span> WindowManager.LayoutParams)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Params must be WindowManager.LayoutParams"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> WindowManager.LayoutParams wparams = (WindowManager.LayoutParams)params;</span><br><span class="line">        <span class="keyword">if</span> (parentWindow != <span class="keyword">null</span>) &#123;</span><br><span class="line">            parentWindow.adjustLayoutParamsForSubWindow(wparams);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// If there's no parent and we're running on L or above (or in the</span></span><br><span class="line">            <span class="comment">// system context), assume we want hardware acceleration.</span></span><br><span class="line">            <span class="keyword">final</span> Context context = view.getContext();</span><br><span class="line">            <span class="keyword">if</span> (context != <span class="keyword">null</span></span><br><span class="line">                    &amp;&amp; context.getApplicationInfo().targetSdkVersion &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">                wparams.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明ViwRootImpl</span></span><br><span class="line">        ViewRootImpl root;</span><br><span class="line">        View panelParentView = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            <span class="comment">// Start watching for system property changes.</span></span><br><span class="line">            <span class="keyword">if</span> (mSystemPropertyUpdater == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mSystemPropertyUpdater = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> i = mRoots.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                                mRoots.get(i).loadSystemProperties();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                SystemProperties.addChangeCallback(mSystemPropertyUpdater);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> index = findViewLocked(view, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mDyingViews.contains(view)) &#123;</span><br><span class="line">                    <span class="comment">// Don't wait for MSG_DIE to make it's way through root's queue.</span></span><br><span class="line">                    mRoots.get(index).doDie();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"View "</span> + view</span><br><span class="line">                            + <span class="string">" has already been added to the window manager."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// The previous removeView() had not completed executing. Now it has.</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If this is a panel window, then find the window it is being</span></span><br><span class="line">            <span class="comment">// attached to for future reference.</span></span><br><span class="line">            <span class="keyword">if</span> (wparams.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp;</span><br><span class="line">                    wparams.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> count = mViews.size();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mRoots.get(i).mWindow.asBinder() == wparams.token) &#123;</span><br><span class="line">                        panelParentView = mViews.get(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//创建ViwRootImpl</span></span><br><span class="line">            root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line"></span><br><span class="line">            view.setLayoutParams(wparams);</span><br><span class="line">            <span class="comment">//将Window所对应的View、ViewRootImpl、LayoutParams顺序添加在WindowManager中</span></span><br><span class="line">            mViews.add(view);</span><br><span class="line">            mRoots.add(root);</span><br><span class="line">            mParams.add(wparams);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// do this last because it fires off messages to start doing things</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//把将Window所对应的View设置给创建的ViewRootImpl</span></span><br><span class="line">            <span class="comment">//通过ViewRootImpl来更新界面并完成Window的添加过程。</span></span><br><span class="line">            root.setView(view, wparams, panelParentView);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            <span class="comment">// BadTokenException or InvalidDisplayException, clean up.</span></span><br><span class="line">            <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> index = findViewLocked(view, <span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    removeViewLocked(index, <span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ViewRootImpl绑定Window所对应的View"><a href="#ViewRootImpl绑定Window所对应的View" class="headerlink" title="ViewRootImpl绑定Window所对应的View"></a>ViewRootImpl绑定Window所对应的View</h1><p>ViewRootImpl绑定Window所对应的View，并对该View进行测量、布局、绘制等。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewRootImpl</span> <span class="keyword">implements</span> <span class="title">ViewParent</span>,</span></span><br><span class="line"><span class="class">        <span class="title">View</span>.<span class="title">AttachInfo</span>.<span class="title">Callbacks</span>, <span class="title">HardwareRenderer</span>.<span class="title">HardwareDrawCallbacks</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*******部分代码省略**********/</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * We have one child</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mView == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//ViewRootImpl成员变量view进行复制，以后操作的都是mView。</span></span><br><span class="line">                mView = view;</span><br><span class="line">                <span class="comment">/*******部分代码省略**********/</span></span><br><span class="line">                <span class="comment">//Window在添加完之前先进行一次布局，确保以后能再接受系统其它事件之后重新布局。</span></span><br><span class="line">                <span class="comment">//对View完成异步刷新，执行View的绘制方法。</span></span><br><span class="line">                requestLayout();</span><br><span class="line">                <span class="keyword">if</span> ((mWindowAttributes.inputFeatures</span><br><span class="line">                        &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == <span class="number">0</span>) &#123;</span><br><span class="line">                    mInputChannel = <span class="keyword">new</span> InputChannel();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    mOrigWindowType = mWindowAttributes.type;</span><br><span class="line">                    mAttachInfo.mRecomputeGlobalAttributes = <span class="keyword">true</span>;</span><br><span class="line">                    collectViewAttributes();</span><br><span class="line">                    <span class="comment">//将该Window添加到屏幕。</span></span><br><span class="line">                    <span class="comment">//mWindowSession实现了IWindowSession接口，它是Session的客户端Binder对象.</span></span><br><span class="line">                    <span class="comment">//addToDisplay是一次AIDL的跨进程通信，通知WindowManagerService添加IWindow</span></span><br><span class="line">                    res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">                            getHostVisibility(), mDisplay.getDisplayId(),</span><br><span class="line">                            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets, mInputChannel);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    mAdded = <span class="keyword">false</span>;</span><br><span class="line">                    mView = <span class="keyword">null</span>;</span><br><span class="line">                    mAttachInfo.mRootView = <span class="keyword">null</span>;</span><br><span class="line">                    mInputChannel = <span class="keyword">null</span>;</span><br><span class="line">                    mFallbackEventHandler.setView(<span class="keyword">null</span>);</span><br><span class="line">                    unscheduleTraversals();</span><br><span class="line">                    setAccessibilityFocus(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Adding window failed"</span>, e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (restore) &#123;</span><br><span class="line">                        attrs.restore();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/*******部分代码省略**********/</span></span><br><span class="line">                <span class="comment">//设置当前View的mParent</span></span><br><span class="line">                view.assignParent(<span class="keyword">this</span>);</span><br><span class="line">                <span class="comment">/*******部分代码省略**********/</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="ViewRootImpl对mView进行操作"><a href="#ViewRootImpl对mView进行操作" class="headerlink" title="ViewRootImpl对mView进行操作"></a>ViewRootImpl对mView进行操作</h1><p>对View的操作包括文章最开始讲述的测量、布局、绘制，其过程主要是在ViewRootImpl的performTraversals方法中。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewRootImpl</span> <span class="keyword">implements</span> <span class="title">ViewParent</span>,</span></span><br><span class="line"><span class="class">        <span class="title">View</span>.<span class="title">AttachInfo</span>.<span class="title">Callbacks</span>, <span class="title">HardwareRenderer</span>.<span class="title">HardwareDrawCallbacks</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*******部分代码省略**********/</span></span><br><span class="line">    <span class="comment">//请求对界面进行布局</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">            checkThread();</span><br><span class="line">            mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">            scheduleTraversals();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//校验所在线程，mThread是在ViewRootImpl初始化的时候执行mThread = Thread.currentThread()进行赋值的，也就是初始化ViewRootImpl所在的线程。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mThread != Thread.currentThread()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CalledFromWrongThreadException(</span><br><span class="line">                    <span class="string">"Only the original thread that created a view hierarchy can touch its views."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//安排任务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">            mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">            mTraversalBarrier = mHandler.getLooper().postSyncBarrier();</span><br><span class="line">            mChoreographer.postCallback(</span><br><span class="line">                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (!mUnbufferedInputDispatch) &#123;</span><br><span class="line">                scheduleConsumeBatchedInput();</span><br><span class="line">            &#125;</span><br><span class="line">            notifyRendererOfFramePending();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> TraversalRunnable mTraversalRunnable = <span class="keyword">new</span> TraversalRunnable();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            doTraversal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//做任务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">            mTraversalScheduled = <span class="keyword">false</span>;</span><br><span class="line">            mHandler.getLooper().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mProfile) &#123;</span><br><span class="line">                Debug.startMethodTracing(<span class="string">"ViewAncestor"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"performTraversals"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//执行任务</span></span><br><span class="line">                performTraversals();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mProfile) &#123;</span><br><span class="line">                Debug.stopMethodTracing();</span><br><span class="line">                mProfile = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行任务（分别调用mView的measure、layout、draw）</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// cache mView since it is used so much below...</span></span><br><span class="line">        <span class="keyword">final</span> View host = mView;</span><br><span class="line">        <span class="comment">/*******部分代码省略**********/</span></span><br><span class="line">        <span class="comment">//想要展示窗口的宽高</span></span><br><span class="line">        <span class="keyword">int</span> desiredWindowWidth;</span><br><span class="line">        <span class="keyword">int</span> desiredWindowHeight;</span><br><span class="line">        <span class="keyword">if</span> (mFirst) &#123;</span><br><span class="line">            <span class="comment">/*******部分代码省略**********/</span></span><br><span class="line">            <span class="comment">//将窗口信息依附给DecorView</span></span><br><span class="line">            host.dispatchAttachedToWindow(mAttachInfo, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">/*******部分代码省略**********/</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始进行布局准备</span></span><br><span class="line">        <span class="keyword">if</span> (mFirst || windowShouldResize || insetsChanged ||</span><br><span class="line">            viewVisibilityChanged || params != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">/*******部分代码省略**********/</span></span><br><span class="line">            <span class="keyword">if</span> (!mStopped) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> focusChangedDueToTouchMode = ensureTouchModeLocally(</span><br><span class="line">                        (relayoutResult&amp;WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth()</span><br><span class="line">                        || mHeight != host.getMeasuredHeight() || contentInsetsChanged) &#123;</span><br><span class="line">                    <span class="keyword">int</span> childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);</span><br><span class="line">                    <span class="keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);</span><br><span class="line"></span><br><span class="line">                    </span><br><span class="line">                     <span class="comment">// Ask host how big it wants to be</span></span><br><span class="line">                    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Implementation of weights from WindowManager.LayoutParams</span></span><br><span class="line">                    <span class="comment">// We just grow the dimensions as needed and re-measure if</span></span><br><span class="line">                    <span class="comment">// needs be</span></span><br><span class="line">                    <span class="keyword">int</span> width = host.getMeasuredWidth();</span><br><span class="line">                    <span class="keyword">int</span> height = host.getMeasuredHeight();</span><br><span class="line">                    <span class="keyword">boolean</span> measureAgain = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/*******部分代码省略**********/</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (measureAgain) &#123;</span><br><span class="line">                        <span class="comment">//View的测量</span></span><br><span class="line">                        performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    layoutRequested = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/*******部分代码省略**********/</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> didLayout = layoutRequested <span class="comment">/*&amp;&amp; !mStopped*/</span> ;</span><br><span class="line">        <span class="keyword">boolean</span> triggerGlobalLayoutListener = didLayout</span><br><span class="line">                || mAttachInfo.mRecomputeGlobalAttributes;</span><br><span class="line">        <span class="keyword">if</span> (didLayout) &#123;</span><br><span class="line">            <span class="comment">//View的布局</span></span><br><span class="line">            performLayout(lp, desiredWindowWidth, desiredWindowHeight);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*******部分代码省略**********/</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*******部分代码省略**********/</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!cancelDraw &amp;&amp; !newSurface) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!skipDraw || mReportNextDraw) &#123;</span><br><span class="line">                <span class="comment">/*******部分代码省略**********/</span></span><br><span class="line">                <span class="comment">//View的绘制</span></span><br><span class="line">                performDraw();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (viewVisibility == View.VISIBLE) &#123;</span><br><span class="line">                <span class="comment">// Try again</span></span><br><span class="line">                scheduleTraversals();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mPendingTransitions != <span class="keyword">null</span> &amp;&amp; mPendingTransitions.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mPendingTransitions.size(); ++i) &#123;</span><br><span class="line">                    mPendingTransitions.get(i).endChangingAnimations();</span><br><span class="line">                &#125;</span><br><span class="line">                mPendingTransitions.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mIsInTraversal = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="View的测量"><a href="#View的测量" class="headerlink" title="View的测量"></a>View的测量</h2><p>ViewRootImpl调用performMeasure执行Window对应的View的测量。</p>
<blockquote>
<ul>
<li>ViewRootImpl的performMeasure;</li>
<li>DecorView(FrameLayout)的measure;</li>
<li>DecorView(FrameLayout)的onMeasure;</li>
<li>DecorView(FrameLayout)所有子View的measure；</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewRootImpl</span> <span class="keyword">implements</span> <span class="title">ViewParent</span>,</span></span><br><span class="line"><span class="class">        <span class="title">View</span>.<span class="title">AttachInfo</span>.<span class="title">Callbacks</span>, <span class="title">HardwareRenderer</span>.<span class="title">HardwareDrawCallbacks</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*******部分代码省略**********/</span></span><br><span class="line">    <span class="comment">//View的测量</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performMeasure</span><span class="params">(<span class="keyword">int</span> childWidthMeasureSpec, <span class="keyword">int</span> childHeightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"measure"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//mView在Activity中为DecorView（FrameLayout）</span></span><br><span class="line">            mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="View的布局"><a href="#View的布局" class="headerlink" title="View的布局"></a>View的布局</h2><p>ViewRootImpl调用performLayout执行Window对应的View的布局。</p>
<blockquote>
<ul>
<li>ViewRootImpl的performLayout；</li>
<li>DecorView(FrameLayout)的layout方法；</li>
<li>DecorView(FrameLayout)的onLayout方法；</li>
<li>DecorView(FrameLayout)的layoutChildren方法；</li>
<li>DecorView(FrameLayout)的所有子View的Layout；</li>
</ul>
</blockquote>
<p>在这期间可能View会自己触发布布局请求，所以在此过程会在此调用ViewRootImpl的requestLayout重新进行测量、布局、绘制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewRootImpl</span> <span class="keyword">implements</span> <span class="title">ViewParent</span>,</span></span><br><span class="line"><span class="class">        <span class="title">View</span>.<span class="title">AttachInfo</span>.<span class="title">Callbacks</span>, <span class="title">HardwareRenderer</span>.<span class="title">HardwareDrawCallbacks</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*******部分代码省略**********/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//请求对ViewRootImpl进行布局</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">            checkThread();</span><br><span class="line">            mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">            scheduleTraversals();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//View的布局</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performLayout</span><span class="params">(WindowManager.LayoutParams lp, <span class="keyword">int</span> desiredWindowWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> desiredWindowHeight)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*******部分代码省略**********/</span></span><br><span class="line">        <span class="keyword">final</span> View host = mView;</span><br><span class="line">        <span class="comment">/*******部分代码省略**********/</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//调用View的Layout方法进行布局</span></span><br><span class="line">            host.layout(<span class="number">0</span>, <span class="number">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line">            mInLayout = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//在ViewRootImpl进行布局的期间，Window内的View自己进行requestLayout</span></span><br><span class="line">            <span class="keyword">int</span> numViewsRequestingLayout = mLayoutRequesters.size();</span><br><span class="line">            <span class="keyword">if</span> (numViewsRequestingLayout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// requestLayout() was called during layout.</span></span><br><span class="line">                <span class="comment">// If no layout-request flags are set on the requesting views, there is no problem.</span></span><br><span class="line">                <span class="comment">// If some requests are still pending, then we need to clear those flags and do</span></span><br><span class="line">                <span class="comment">// a full request/measure/layout pass to handle this situation.</span></span><br><span class="line">                ArrayList&lt;View&gt; validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters,</span><br><span class="line">                        <span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">if</span> (validLayoutRequesters != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Set this flag to indicate that any further requests are happening during</span></span><br><span class="line">                    <span class="comment">// the second pass, which may result in posting those requests to the next</span></span><br><span class="line">                    <span class="comment">// frame instead</span></span><br><span class="line">                    mHandlingLayoutInLayoutRequest = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Process fresh layout requests, then measure and layout</span></span><br><span class="line">                    <span class="keyword">int</span> numValidRequests = validLayoutRequesters.size();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValidRequests; ++i) &#123;</span><br><span class="line">                        <span class="keyword">final</span> View view = validLayoutRequesters.get(i);</span><br><span class="line">                        Log.w(<span class="string">"View"</span>, <span class="string">"requestLayout() improperly called by "</span> + view +</span><br><span class="line">                                <span class="string">" during layout: running second layout pass"</span>);</span><br><span class="line">                        <span class="comment">//请求对该View布局，最终回调到ViewRootImpl的requestLayout进行重新测量、布局、绘制</span></span><br><span class="line">                        view.requestLayout();</span><br><span class="line">                    &#125;</span><br><span class="line">                    measureHierarchy(host, lp, mView.getContext().getResources(),</span><br><span class="line">                            desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">                    mInLayout = <span class="keyword">true</span>;</span><br><span class="line">                    host.layout(<span class="number">0</span>, <span class="number">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line"></span><br><span class="line">                    mHandlingLayoutInLayoutRequest = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Check the valid requests again, this time without checking/clearing the</span></span><br><span class="line">                    <span class="comment">// layout flags, since requests happening during the second pass get noop'd</span></span><br><span class="line">                    validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters, <span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">if</span> (validLayoutRequesters != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">final</span> ArrayList&lt;View&gt; finalRequesters = validLayoutRequesters;</span><br><span class="line">                        <span class="comment">// Post second-pass requests to the next frame</span></span><br><span class="line">                        getRunQueue().post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                <span class="keyword">int</span> numValidRequests = finalRequesters.size();</span><br><span class="line">                                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValidRequests; ++i) &#123;</span><br><span class="line">                                    <span class="keyword">final</span> View view = finalRequesters.get(i);</span><br><span class="line">                                    <span class="comment">/*******部分代码省略**********/</span></span><br><span class="line">                                    <span class="comment">//请求对该View布局，最终回调到ViewRootImpl的requestLayout进行重新测量、布局、绘制</span></span><br><span class="line">                                    view.requestLayout();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">        &#125;</span><br><span class="line">        mInLayout = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="View的绘制"><a href="#View的绘制" class="headerlink" title="View的绘制"></a>View的绘制</h2><p>ViewRootImpl调用performDraw执行Window对应的View的布局。</p>
<blockquote>
<ul>
<li>ViewRootImpl的performDraw；</li>
<li>ViewRootImpl的draw；</li>
<li>ViewRootImpl的drawSoftware；</li>
<li>DecorView(FrameLayout)的draw方法；</li>
<li>DecorView(FrameLayout)的dispatchDraw方法；</li>
<li>DecorView(FrameLayout)的drawChild方法；</li>
<li>DecorView(FrameLayout)的所有子View的draw方法；</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewRootImpl</span> <span class="keyword">implements</span> <span class="title">ViewParent</span>,</span></span><br><span class="line"><span class="class">        <span class="title">View</span>.<span class="title">AttachInfo</span>.<span class="title">Callbacks</span>, <span class="title">HardwareRenderer</span>.<span class="title">HardwareDrawCallbacks</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*******部分代码省略**********/</span></span><br><span class="line">    <span class="comment">//View的绘制</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performDraw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mAttachInfo.mDisplayState == Display.STATE_OFF &amp;&amp; !mReportNextDraw) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> fullRedrawNeeded = mFullRedrawNeeded;</span><br><span class="line">        mFullRedrawNeeded = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        mIsDrawing = <span class="keyword">true</span>;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"draw"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            draw(fullRedrawNeeded);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mIsDrawing = <span class="keyword">false</span>;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*******部分代码省略**********/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进行绘制</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">boolean</span> fullRedrawNeeded)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*******部分代码省略**********/</span></span><br><span class="line">        <span class="comment">//View上添加的Observer进行绘制事件的分发</span></span><br><span class="line">        mAttachInfo.mTreeObserver.dispatchOnDraw();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!dirty.isEmpty() || mIsAnimating || accessibilityFocusDirty) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mAttachInfo.mHardwareRenderer != <span class="keyword">null</span> &amp;&amp; mAttachInfo.mHardwareRenderer.isEnabled()) &#123;</span><br><span class="line">                <span class="comment">/*******部分代码省略**********/</span></span><br><span class="line">                <span class="comment">//调用Window对应的ViewRootImpl的invalidate方法</span></span><br><span class="line">                mAttachInfo.mHardwareRenderer.draw(mView, mAttachInfo, <span class="keyword">this</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/*******部分代码省略**********/</span></span><br><span class="line">                <span class="comment">//绘制Window</span></span><br><span class="line">                <span class="keyword">if</span> (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (animating) &#123;</span><br><span class="line">            mFullRedrawNeeded = <span class="keyword">true</span>;</span><br><span class="line">            scheduleTraversals();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">invalidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mDirty.set(<span class="number">0</span>, <span class="number">0</span>, mWidth, mHeight);</span><br><span class="line">        <span class="keyword">if</span> (!mWillDrawSoon) &#123;</span><br><span class="line">            scheduleTraversals();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if drawing was successful, false if an error occurred</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">drawSoftware</span><span class="params">(Surface surface, AttachInfo attachInfo, <span class="keyword">int</span> xoff, <span class="keyword">int</span> yoff,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> scalingRequired, Rect dirty)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*******部分代码省略**********/</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/*******部分代码省略**********/</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                canvas.translate(-xoff, -yoff);</span><br><span class="line">                <span class="keyword">if</span> (mTranslator != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mTranslator.translateCanvas(canvas);</span><br><span class="line">                &#125;</span><br><span class="line">                canvas.setScreenDensity(scalingRequired ? mNoncompatDensity : <span class="number">0</span>);</span><br><span class="line">                attachInfo.mSetIgnoreDirtyState = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">//View绘制</span></span><br><span class="line">                mView.draw(canvas);</span><br><span class="line"></span><br><span class="line">                drawAccessibilityFocusedDrawableIfNeeded(canvas);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!attachInfo.mSetIgnoreDirtyState) &#123;</span><br><span class="line">                    <span class="comment">// Only clear the flag if it was not set during the mView.draw() call</span></span><br><span class="line">                    attachInfo.mIgnoreDirtyState = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">/*******部分代码省略**********/</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="异步线程更新视图"><a href="#异步线程更新视图" class="headerlink" title="异步线程更新视图"></a>异步线程更新视图</h1><p>异步线程中到底是否能对视图进行更新呢？我们先看看<code>TextView.setText</code>方法的代码执行流程图。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzEzMTk4NzktMmM3ZTRkMWRmOWVlM2ZmNy5wbmc?x-oss-process=image/format,png#pic_center" alt="setText.png"></p>
<p>从上图看在页面进行视图更新的时候会触发 <code>checkThread</code> ,校验当前线程是否是 <code>ViewRootImpl</code> 被创建时所在的线程。而 <code>ViewRootImpl</code> 的创建是在 <code>Activity</code> 的 <code>onResume</code> 生命周期之后。</p>
<p><strong>需要注意的是不是所有的 <code>TextView.setText</code>  都会触发 <code>checkThread</code> 。</strong> 比如 <code>TextView.setText</code> 之后对当前 <code>TextView</code> 的 <code>layout</code> 不会进行任何改变，那么这次的 <code>TextView.setText</code> 就可以在异步线程执行。 </p>
<p><img src="https://img-blog.csdnimg.cn/20200423193533332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0dmVuX2tpbmc=,size_16,color_FFFFFF,t_70#pic_center =600x220" alt="在这里插入图片描述"><br><strong>操作UI</strong>的时候只有这些方法被调用的时候才会执行 <code>ViewRootImpl.checkThread</code> ，进行任务执行线程的校验。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//异常信息，提示当前执行任务的线程与创建ViewRootImpl的线程不一样~！</span></span><br><span class="line"><span class="keyword">new</span> CalledFromWrongThreadException(<span class="string">"Only the original thread that created a view hierarchy can touch its views."</span>);</span><br></pre></td></tr></table></figure>
<h2 id="异步线程执行UI操作"><a href="#异步线程执行UI操作" class="headerlink" title="异步线程执行UI操作"></a>异步线程执行UI操作</h2><p>我们知道了异步线程不建议<strong>操作UI</strong>的最终原因是：</p>
<blockquote>
<p>发生了对任务执行线程的校验，而且当前执行任务的线程与创建<code>ViewRootImpl</code> 的线程不一样；</p>
</blockquote>
<p>所以只要避免上面的执行逻辑，还是可以在异步线程<strong>操作UI</strong>的。</p>
<ol>
<li>我们在不触发 <code>ViewRootImpl.checkThread</code> 的情况下再异步线程执行<strong>UI操作</strong>。</li>
<li>我们在 <code>Activity.onResume</code> 之前在异步线程进行视图更新,因为这个时候不会发生线程校验。（PS：我们知道 <code>Activity</code> 所绑定的 <code>ViewRootImpl</code> 的初始化是在主线程中，所以我们一般不会在非主线程进行 <code>UI操作</code> 。）</li>
<li>我们可以再异步线程初始化 <code>ViewRootImpl</code> 同时在该线程进行视图更新（eg: <code>Dialog</code> 异步线程的展现，具体参考：<a href="http://blog.csdn.net/stven_king/article/details/78775211" target="_blank" rel="noopener">Dialog、Toast的Window和ViewRootImpl</a>）。</li>
</ol>
<p>PS:我们学习Android源码并通过了解其内部实现，我们可以通过技术手段去掉、增加或修改部分代码逻辑。以期望能做出更好的产品、做更细节的优化。但是想这种界面绘制只能发生在主线程规则我们还是必须要遵守的。<code>两个线程不能同时draw，否则屏幕会花；不能同时写一块内存，否则内存会花；不能同时写一份文件，否则文件会花。同一时刻只有一个线程可以做ui，那么当两个线程互斥几率较大时，或者保证互斥的代码复杂时，选择其中一个长期持有其他发消息就是典型的解决方案。所以普遍的要求ui只能单线程。</code></p>
<h1 id="Activity、Dialog、Toast的ViewRootImpl的不同"><a href="#Activity、Dialog、Toast的ViewRootImpl的不同" class="headerlink" title="Activity、Dialog、Toast的ViewRootImpl的不同"></a>Activity、Dialog、Toast的ViewRootImpl的不同</h1><p>文章前面内容都是站在Activity的角度来进行代码解析的，因此我们不再对Dialog和Toast与Activity做具体分析，主要来看看它们与Activity有什么不同之处。详见：<a href="http://blog.csdn.net/stven_king/article/details/78775211" target="_blank" rel="noopener">Dialog、Toast的Window和ViewRootImpl</a>。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过对ViewRootImpl的更细节的分析，我们再看自定义View的布局时的一些方法会更加清楚（知其然且知其所以然）。同时也解开了<code>Android中异步线程更新View</code>的谜底。</p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>ViewRootImpl</tag>
      </tags>
  </entry>
  <entry>
    <title>Android换肤原理和Android-Skin-Loader框架解析</title>
    <url>/2017/11/27/android-skin-changed/</url>
    <content><![CDATA[<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzEzMTk4NzktZjUwYTMyNWNmMDc4MTU0Yy5KUEc?x-oss-process=image/format,png#pic_center" alt="换皮肤啦"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Android换肤技术已经是很久之前就已经被成熟使用的技术了，然而我最近才在学习和接触热修复的时候才看到。在看了一些换肤的方法之后，并且对市面上比较认可的Android-Skin-Loader换肤框架的源码进行了分析总结。再次记录一下祭奠自己逝去的时间。</p>
<h1 id="换肤介绍"><a href="#换肤介绍" class="headerlink" title="换肤介绍"></a>换肤介绍</h1><p>换肤本质上是对资源的一中替换包括、字体、颜色、背景、图片、大小等等。当然这些我们都有成熟的api可以通过控制代码逻辑做到。比如View的修改背景颜色<code>setBackgroundColor</code>,TextView的<code>setTextSize</code>修改字体等等。但是作为程序员我们怎么能忍受对每个页面的每个元素一个行行代码做换肤处理呢？我们需要用最少的代码实现最容易维护和使用效果完美（动态切换，及时生效）的换肤框架。</p>
<h2 id="换肤方式一：切换使用主题Theme"><a href="#换肤方式一：切换使用主题Theme" class="headerlink" title="换肤方式一：切换使用主题Theme"></a>换肤方式一：切换使用主题Theme</h2><blockquote>
<p>使用相同的资源id，但在不同的Theme下边自定义不同的资源。我们通过主动切换到不同的Theme从而切换界面元素创建时使用的资源。这种方案的代码量不多发，而且有个很明显的缺点不支持已经创建界面的换肤，必须重新加载界面元素。<a href="https://github.com/stven0king/MultipleTheme.git" target="_blank" rel="noopener">GitHub Demo</a></p>
</blockquote>
<h2 id="换肤方式二：加载资源包"><a href="#换肤方式二：加载资源包" class="headerlink" title="换肤方式二：加载资源包"></a>换肤方式二：加载资源包</h2><blockquote>
<p>加载资源包是各种应用程序都在使用的换肤方法，例如我们最常用的输入法皮肤、浏览器皮肤等等。我们可以将皮肤的资源文件放入安装包内部，也可以进行下载缓存到磁盘上。Android的应用程序可以使用这种方式进行换肤。GitHub上面有一个start非常高的换肤框架<a href="https://github.com/stven0king/Android-Skin-Loader.git" target="_blank" rel="noopener">Android-Skin-Loader</a> 就是通过加载资源包对app进行换肤。对这个框架的分析这个也是这篇文章主要的讲述内容。</p>
</blockquote>
<p>对比一下发现切换Theme可以进行小幅度的换肤设置（比如某个自定义组件的主题），而如果我们想要对整个app做主题切换那么通过加载资源包的这种方式目前应该说是比较好的了。</p>
<h1 id="Android换肤知识点"><a href="#Android换肤知识点" class="headerlink" title="Android换肤知识点"></a>Android换肤知识点</h1><h2 id="换肤相应的API"><a href="#换肤相应的API" class="headerlink" title="换肤相应的API"></a>换肤相应的API</h2><p>我们先来看一下Android提供的一些基本的api，通过使用这些api可以在App内部进行资源对象的替换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Resources</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getString</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> NotFoundException </span>&#123;</span><br><span class="line">        CharSequence res = mAssets.getResourceText(id);</span><br><span class="line">        <span class="keyword">if</span> (res != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotFoundException(<span class="string">"String resource ID #0x"</span></span><br><span class="line">                                    + Integer.toHexString(id));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Drawable <span class="title">getDrawable</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> NotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">/********部分代码省略*******/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getColor</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> NotFoundException </span>&#123;&#123;</span><br><span class="line">        <span class="comment">/********部分代码省略*******/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/********部分代码省略*******/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个是我们常用的Resources类的api，我们通常可以使用在资源文件中定义的<code>@+id</code>String类型，然后在编译出的R.java中对应的资源文件生产的id（int类型），从而通过这个id（int类型）调用Resources提供的这些api获取到对应的资源对象。这个在同一个app下没有任何问题，但是在皮肤包中我们怎么获取这个id值呢。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Resources</span> </span>&#123;</span><br><span class="line">    <span class="comment">/********部分代码省略*******/</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过给的资源名称返回一个资源的标识id。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 描述资源的名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> defType 资源的类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> defPackage 包名</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回资源id，0标识未找到该资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIdentifier</span><span class="params">(String name, String defType, String defPackage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"name is null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.parseInt(name);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// Ignore</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mAssets.getResourceIdentifier(name, defType, defPackage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Resources提供了可以通过<code>@+id</code>、Type、PackageName这三个参数就可以在AssetManager中寻找相应的PackageName中有没有Type类型并且id值都能与参数对应上的id，进行返回。然后我们可以通过这个id再调用Resource的获取资源的api就可以得到相应的资源。</p>
<blockquote>
<p>这里我们需要注意的一点是<code>getIdentifier(String name, String defType, String defPackage)</code>方法和<code>getString(int id)</code>方法所调用Resources对象的mAssets对象必须是同一个，并且包含有PackageName这个资源包。</p>
</blockquote>
<h2 id="AssetManager构造"><a href="#AssetManager构造" class="headerlink" title="AssetManager构造"></a>AssetManager构造</h2><p>怎么构造一个包含特定packageName资源的AssetManager对象实例呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AssetManager</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/********部分代码省略*******/</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create a new AssetManager containing only the basic system assets.</span></span><br><span class="line"><span class="comment">     * Applications will not generally use this method, instead retrieving the</span></span><br><span class="line"><span class="comment">     * appropriate asset manager with &#123;<span class="doctag">@link</span> Resources#getAssets&#125;.    Not for</span></span><br><span class="line"><span class="comment">     * use by applications.</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@hide</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AssetManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_REFS) &#123;</span><br><span class="line">                mNumRefs = <span class="number">0</span>;</span><br><span class="line">                incRefsLocked(<span class="keyword">this</span>.hashCode());</span><br><span class="line">            &#125;</span><br><span class="line">            init(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">"New asset manager: "</span> + <span class="keyword">this</span>);</span><br><span class="line">            ensureSystemAssets();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从AssetManager的构造函数来看有<code>{@hide}</code>的朱姐，所以在其他类里面是直接创建AssetManager实例。但是不要忘记Java中还有反射机制可以创建类对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AssetManager assetManager = AssetManager.class.newInstance();</span><br></pre></td></tr></table></figure>
<p>让创建的assetManager包含特定的PackageName的资源信息，怎么办？我们在AssetManager中找到相应的api可以调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AssetManager</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/********部分代码省略*******/</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Add an additional set of assets to the asset manager.  This can be</span></span><br><span class="line"><span class="comment">     * either a directory or ZIP file.  Not for use by applications.  Returns</span></span><br><span class="line"><span class="comment">     * the cookie of the added asset, or 0 on failure.</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@hide</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">addAssetPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> res = addAssetPathNative(path);</span><br><span class="line">            <span class="keyword">if</span> (mStringBlocks != <span class="keyword">null</span>) &#123;</span><br><span class="line">                makeStringBlocks(mStringBlocks);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样改方法也不支持外部调用，我们只能通过反射的方法来调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * apk路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String apkPath = Environment.getExternalStorageDirectory()+<span class="string">"/skin.apk"</span>;</span><br><span class="line">AssetManager assetManager = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    AssetManager assetManager = AssetManager.class.newInstance();</span><br><span class="line">    AssetManager.class.getDeclaredMethod(<span class="string">"addAssetPath"</span>, String.class).invoke(assetManager, apkPath);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">    th.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此我们可以构造属于自己换肤的Resources了。</p>
<h2 id="换肤Resources构造"><a href="#换肤Resources构造" class="headerlink" title="换肤Resources构造"></a>换肤Resources构造</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Resources <span class="title">getSkinResources</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插件apk路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String apkPath = Environment.getExternalStorageDirectory()+<span class="string">"/skin.apk"</span>;</span><br><span class="line">    AssetManager assetManager = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        AssetManager assetManager = AssetManager.class.newInstance();</span><br><span class="line">        AssetManager.class.getDeclaredMethod(<span class="string">"addAssetPath"</span>, String.class).invoke(assetManager, apkPath);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">        th.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Resources(assetManager, context.getResources().getDisplayMetrics(), context.getResources().getConfiguration());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用资源包中的资源换肤"><a href="#使用资源包中的资源换肤" class="headerlink" title="使用资源包中的资源换肤"></a>使用资源包中的资源换肤</h2><p>我们将上述所有的代码组合在一起就可以实现，使用资源包中的资源对app进行换肤。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Resources <span class="title">getSkinResources</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插件apk路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String apkPath = Environment.getExternalStorageDirectory()+<span class="string">"/skin.apk"</span>;</span><br><span class="line">    AssetManager assetManager = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        AssetManager assetManager = AssetManager.class.newInstance();</span><br><span class="line">        AssetManager.class.getDeclaredMethod(<span class="string">"addAssetPath"</span>, String.class).invoke(assetManager, apkPath);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">        th.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Resources(assetManager, context.getResources().getDisplayMetrics(), context.getResources().getConfiguration());</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    ImageView imageView = (ImageView) findViewById(R.id.imageView);</span><br><span class="line">    TextView textView = (TextView) findViewById(R.id.text);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插件资源对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Resources resources = getSkinResources(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取图片资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Drawable drawable = resources.getDrawable(resources.getIdentifier(<span class="string">"night_icon"</span>, <span class="string">"drawable"</span>,<span class="string">"com.tzx.skin"</span>));</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取Color资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> color = resources.getColor(resources.getIdentifier(<span class="string">"night_color"</span>,<span class="string">"color"</span>,<span class="string">"com.tzx.skin"</span>));</span><br><span class="line"></span><br><span class="line">    imageView.setImageDrawable(drawable);</span><br><span class="line">    textView.setText(text);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上述介绍，我们可以简单的对当前页面进行换肤了。但是想要做出一个一个成熟换肤框架那么仅仅这些还是不够的，提高一下我们的思维高度，如果我们在View创建的时候就直接使用皮肤资源包中的资源文件，那么这无疑就使换肤更加的简单已维护。</p>
<h2 id="LayoutInflater-Factory"><a href="#LayoutInflater-Factory" class="headerlink" title="LayoutInflater.Factory"></a>LayoutInflater.Factory</h2><p>看过我前一篇<a href="http://dandanlove.com/2017/11/15/layoutinflater-factory/" target="_blank" rel="noopener">遇见LayoutInflater&amp;Factory</a>文章的这部分可以省略掉.</p>
<p>很幸运Android给我们在View生产的时候做修改提供了法门。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LayoutInflater</span> </span>&#123;</span><br><span class="line">    <span class="comment">/***部分代码省略****/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(String name, Context context, AttributeSet attrs)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory2</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(View parent, String name, Context context, AttributeSet attrs)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***部分代码省略****/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以给当前的页面的Window对象在创建的时候设置Factory，那么在Window中的View进行创建的时候就会先通过自己设置的Factory进行创建。Factory使用方式和相关注意事项请移位到<a href="http://dandanlove.com/2017/11/15/layoutinflater-factory/" target="_blank" rel="noopener">遇见LayoutInflater&amp;Factory</a>，关于Factory的相关知识点尽在其中。</p>
<h1 id="Android-Skin-Loader解析"><a href="#Android-Skin-Loader解析" class="headerlink" title="Android-Skin-Loader解析"></a>Android-Skin-Loader解析</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><ul>
<li>初始化换肤框架，导入需要换肤的资源包（当前为一个apk文件，其中只有资源文件）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SkinApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.onCreate();</span><br><span class="line">		initSkinLoader();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Must call init first</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initSkinLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		SkinManager.getInstance().init(<span class="keyword">this</span>);</span><br><span class="line">		SkinManager.getInstance().load();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="构造换肤对象"><a href="#构造换肤对象" class="headerlink" title="构造换肤对象"></a>构造换肤对象</h2><ul>
<li>导入需要换肤的资源包，并构造换肤的Resources实例。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Load resources from apk in asyc task </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> skinPackagePath path of skin apk </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> callback callback to notify user </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(String skinPackagePath, <span class="keyword">final</span> ILoaderListener callback)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">new</span> AsyncTask&lt;String, Void, Resources&gt;() &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPreExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                callback.onStart();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Resources <span class="title">doInBackground</span><span class="params">(String... params)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (params.length == <span class="number">1</span>) &#123;</span><br><span class="line">                    String skinPkgPath = params[<span class="number">0</span>];</span><br><span class="line">                     </span><br><span class="line">                    File file = <span class="keyword">new</span> File(skinPkgPath); </span><br><span class="line">                    <span class="keyword">if</span>(file == <span class="keyword">null</span> || !file.exists())&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                     </span><br><span class="line">                    PackageManager mPm = context.getPackageManager();</span><br><span class="line">                    <span class="comment">//检索程序外的一个安装包文件</span></span><br><span class="line">                    PackageInfo mInfo = mPm.getPackageArchiveInfo(skinPkgPath, PackageManager.GET_ACTIVITIES);</span><br><span class="line">                    <span class="comment">//获取安装包报名</span></span><br><span class="line">                    skinPackageName = mInfo.packageName;</span><br><span class="line">                    <span class="comment">//构建换肤的AssetManager实例</span></span><br><span class="line">                    AssetManager assetManager = AssetManager.class.newInstance();</span><br><span class="line">                    Method addAssetPath = assetManager.getClass().getMethod(<span class="string">"addAssetPath"</span>, String.class);</span><br><span class="line">                    addAssetPath.invoke(assetManager, skinPkgPath);</span><br><span class="line">                    <span class="comment">//构建换肤的Resources实例</span></span><br><span class="line">                    Resources superRes = context.getResources();</span><br><span class="line">                    Resources skinResource = <span class="keyword">new</span> Resources(assetManager,superRes.getDisplayMetrics(),superRes.getConfiguration());</span><br><span class="line">                    <span class="comment">//存储当前皮肤路径</span></span><br><span class="line">                    SkinConfig.saveSkinPath(context, skinPkgPath);</span><br><span class="line">                     </span><br><span class="line">                    skinPath = skinPkgPath;</span><br><span class="line">                    isDefaultSkin = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> skinResource;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(Resources result)</span> </span>&#123;</span><br><span class="line">            mResources = result;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (mResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (callback != <span class="keyword">null</span>) callback.onSuccess();</span><br><span class="line">                <span class="comment">//更新多有可换肤的界面</span></span><br><span class="line">                notifySkinUpdate();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                isDefaultSkin = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (callback != <span class="keyword">null</span>) callback.onFailed();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"> </span><br><span class="line">    &#125;.execute(skinPackagePath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="定义基类"><a href="#定义基类" class="headerlink" title="定义基类"></a>定义基类</h2><ul>
<li>换肤页面的基类的通用代码实现基本换肤功能。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseFragmentActivity</span> <span class="keyword">extends</span> <span class="title">FragmentActivity</span> <span class="keyword">implements</span> <span class="title">ISkinUpdate</span>, <span class="title">IDynamicNewView</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/***部分代码省略****/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自定义LayoutInflater.Factory</span></span><br><span class="line">    <span class="keyword">private</span> SkinInflaterFactory mSkinInflaterFactory;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//设置LayoutInflater的mFactorySet为true，表示还未设置mFactory,否则会抛出异常。</span></span><br><span class="line">            Field field = LayoutInflater.class.getDeclaredField(<span class="string">"mFactorySet"</span>);</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            field.setBoolean(getLayoutInflater(), <span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//设置LayoutInflater的MFactory</span></span><br><span class="line">            mSkinInflaterFactory = <span class="keyword">new</span> SkinInflaterFactory();</span><br><span class="line">            getLayoutInflater().setFactory(mSkinInflaterFactory);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line">        <span class="comment">//注册皮肤管理对象</span></span><br><span class="line">        SkinManager.getInstance().attach(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        <span class="comment">//反注册皮肤管理对象</span></span><br><span class="line">        SkinManager.getInstance().detach(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***部分代码省略****/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SkinInflaterFactory"><a href="#SkinInflaterFactory" class="headerlink" title="SkinInflaterFactory"></a>SkinInflaterFactory</h2><ul>
<li>SkinInflaterFactory进行View的创建并对View进行换肤。</li>
</ul>
<h3 id="构造View"><a href="#构造View" class="headerlink" title="构造View"></a>构造View</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SkinInflaterFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/***部分代码省略****/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(String name, Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//读取View的skin:enable属性，false为不需要换肤</span></span><br><span class="line">        <span class="comment">// if this is NOT enable to be skined , simplly skip it </span></span><br><span class="line">        <span class="keyword">boolean</span> isSkinEnable = attrs.getAttributeBooleanValue(SkinConfig.NAMESPACE, SkinConfig.ATTR_SKIN_ENABLE, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (!isSkinEnable)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建View</span></span><br><span class="line">        View view = createView(context, name, attrs);</span><br><span class="line">        <span class="keyword">if</span> (view == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果View创建成功，对View进行换肤</span></span><br><span class="line">        parseSkinAttr(context, attrs, view);</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建View，类比可以查看LayoutInflater的createViewFromTag方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> View <span class="title">createView</span><span class="params">(Context context, String name, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        View view = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (-<span class="number">1</span> == name.indexOf(<span class="string">'.'</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"View"</span>.equals(name)) &#123;</span><br><span class="line">                    view = LayoutInflater.from(context).createView(name, <span class="string">"android.view."</span>, attrs);</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    view = LayoutInflater.from(context).createView(name, <span class="string">"android.widget."</span>, attrs);</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    view = LayoutInflater.from(context).createView(name, <span class="string">"android.webkit."</span>, attrs);</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                view = LayoutInflater.from(context).createView(name, <span class="keyword">null</span>, attrs);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            L.i(<span class="string">"about to create "</span> + name);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">            L.e(<span class="string">"error while create 【"</span> + name + <span class="string">"】 : "</span> + e.getMessage());</span><br><span class="line">            view = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对生产的View进行换肤"><a href="#对生产的View进行换肤" class="headerlink" title="对生产的View进行换肤"></a>对生产的View进行换肤</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SkinInflaterFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//存储当前Activity中的需要换肤的View</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;SkinItem&gt; mSkinItems = <span class="keyword">new</span> ArrayList&lt;SkinItem&gt;();</span><br><span class="line">    <span class="comment">/***部分代码省略****/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseSkinAttr</span><span class="params">(Context context, AttributeSet attrs, View view)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当前View的所有属性标签</span></span><br><span class="line">        List&lt;SkinAttr&gt; viewAttrs = <span class="keyword">new</span> ArrayList&lt;SkinAttr&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; attrs.getAttributeCount(); i++)&#123;</span><br><span class="line">            String attrName = attrs.getAttributeName(i);</span><br><span class="line">            String attrValue = attrs.getAttributeValue(i);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(!AttrFactory.isSupportedAttr(attrName))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//过滤view属性标签中属性的value的值为引用类型</span></span><br><span class="line">            <span class="keyword">if</span>(attrValue.startsWith(<span class="string">"@"</span>))&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> id = Integer.parseInt(attrValue.substring(<span class="number">1</span>));</span><br><span class="line">                    String entryName = context.getResources().getResourceEntryName(id);</span><br><span class="line">                    String typeName = context.getResources().getResourceTypeName(id);</span><br><span class="line">                    <span class="comment">//构造SkinAttr实例,attrname,id,entryName,typeName</span></span><br><span class="line">                    <span class="comment">//属性的名称（background）、属性的id值（int类型），属性的id值（@+id，string类型），属性的值类型（color）</span></span><br><span class="line">                    SkinAttr mSkinAttr = AttrFactory.get(attrName, id, entryName, typeName);</span><br><span class="line">                    <span class="keyword">if</span> (mSkinAttr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        viewAttrs.add(mSkinAttr);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NotFoundException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果当前View需要换肤，那么添加在mSkinItems中</span></span><br><span class="line">        <span class="keyword">if</span>(!ListUtils.isEmpty(viewAttrs))&#123;</span><br><span class="line">            SkinItem skinItem = <span class="keyword">new</span> SkinItem();</span><br><span class="line">            skinItem.view = view;</span><br><span class="line">            skinItem.attrs = viewAttrs;</span><br><span class="line"></span><br><span class="line">            mSkinItems.add(skinItem);</span><br><span class="line">            <span class="comment">//是否是使用外部皮肤进行换肤</span></span><br><span class="line">            <span class="keyword">if</span>(SkinManager.getInstance().isExternalSkin())&#123;</span><br><span class="line">                skinItem.apply();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="资源获取"><a href="#资源获取" class="headerlink" title="资源获取"></a>资源获取</h2><p>通过当前的资源id，找到对应的资源name。再从皮肤包中找到该资源name所对应的资源id。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SkinManager</span> <span class="keyword">implements</span> <span class="title">ISkinLoader</span></span>&#123;</span><br><span class="line">    <span class="comment">/***部分代码省略****/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getColor</span><span class="params">(<span class="keyword">int</span> resId)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> originColor = context.getResources().getColor(resId);</span><br><span class="line">        <span class="comment">//是否没有下载皮肤或者当前使用默认皮肤</span></span><br><span class="line">        <span class="keyword">if</span>(mResources == <span class="keyword">null</span> || isDefaultSkin)&#123;</span><br><span class="line">            <span class="keyword">return</span> originColor;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据resId值获取对应的xml的的@+id的String类型的值</span></span><br><span class="line">        String resName = context.getResources().getResourceEntryName(resId);</span><br><span class="line">        <span class="comment">//更具resName在皮肤包的mResources中获取对应的resId</span></span><br><span class="line">        <span class="keyword">int</span> trueResId = mResources.getIdentifier(resName, <span class="string">"color"</span>, skinPackageName);</span><br><span class="line">        <span class="keyword">int</span> trueColor = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//根据resId获取对应的资源value</span></span><br><span class="line">            trueColor = mResources.getColor(trueResId);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(NotFoundException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            trueColor = originColor;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> trueColor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Drawable <span class="title">getDrawable</span><span class="params">(<span class="keyword">int</span> resId)</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>除此之外再增加以下对于皮肤的管理api（下载、监听回调、应用、取消、异常处理、扩展模块等等）。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>换肤就是这么简单~！~！</p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Factory</tag>
        <tag>inflate</tag>
      </tags>
  </entry>
  <entry>
    <title>遇见LayoutInflater和Factory</title>
    <url>/2017/11/15/layoutinflater-factory/</url>
    <content><![CDATA[<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzEzMTk4NzktZGMxZDEyM2NhYzZlYzRhZC5qcGc?x-oss-process=image/format,png#pic_center" alt="奥体公园"></p>
<h2 id="LayoutInflater的获取"><a href="#LayoutInflater的获取" class="headerlink" title="LayoutInflater的获取"></a>LayoutInflater的获取</h2><p>在我们写listview的adapter的getView方法中我们都会通过 <code>LayoutInflater.from(mContext)</code> 获取LayoutInflater实例。<br>现在我们通过源码来分析一下LayoutInflater实例的获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LayoutInflater的获取</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LayoutInflater</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Obtains the LayoutInflater from the given context.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LayoutInflater <span class="title">from</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        LayoutInflater LayoutInflater =</span><br><span class="line">                (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br><span class="line">        <span class="keyword">if</span> (LayoutInflater == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"LayoutInflater not found."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> LayoutInflater;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>context.getSystemService</code> 是Android很重要的一个API，它是Activity的一个方法，根据传入的NAME来取得对应的Object，然后转换成相应的服务对象。以下介绍系统相应的服务。</p>
<table>
<thead>
<tr>
<th style="text-align:left">Name</th>
<th style="text-align:left">返回的对象</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">WINDOW_SERVICE</td>
<td style="text-align:left">WindowManager</td>
<td style="text-align:left">管理打开的窗口程序</td>
</tr>
<tr>
<td style="text-align:left">LAYOUT_INFLATER_SERVICE</td>
<td style="text-align:left">LayoutInflater</td>
<td style="text-align:left">取得xml里定义的view</td>
</tr>
<tr>
<td style="text-align:left">ACTIVITY_SERVICE</td>
<td style="text-align:left">ActivityManager</td>
<td style="text-align:left">管理应用程序的系统状态</td>
</tr>
<tr>
<td style="text-align:left">POWER_SERVICE</td>
<td style="text-align:left">PowerManger</td>
<td style="text-align:left">电源的服务</td>
</tr>
<tr>
<td style="text-align:left">ALARM_SERVICE</td>
<td style="text-align:left">AlarmManager</td>
<td style="text-align:left">闹钟的服务</td>
</tr>
<tr>
<td style="text-align:left">NOTIFICATION_SERVICE</td>
<td style="text-align:left">NotificationManager</td>
<td style="text-align:left">状态栏的服务</td>
</tr>
<tr>
<td style="text-align:left">KEYGUARD_SERVICE</td>
<td style="text-align:left">KeyguardManager</td>
<td style="text-align:left">键盘锁的服务</td>
</tr>
<tr>
<td style="text-align:left">LOCATION_SERVICE</td>
<td style="text-align:left">LocationManager</td>
<td style="text-align:left">位置的服务，如GPS</td>
</tr>
<tr>
<td style="text-align:left">SEARCH_SERVICE</td>
<td style="text-align:left">SearchManager</td>
<td style="text-align:left">搜索的服务</td>
</tr>
<tr>
<td style="text-align:left">VEBRATOR_SERVICE</td>
<td style="text-align:left">Vebrator</td>
<td style="text-align:left">手机震动的服务</td>
</tr>
<tr>
<td style="text-align:left">CONNECTIVITY_SERVICE</td>
<td style="text-align:left">Connectivity</td>
<td style="text-align:left">网络连接的服务</td>
</tr>
<tr>
<td style="text-align:left">WIFI_SERVICE</td>
<td style="text-align:left">WifiManager</td>
<td style="text-align:left">Wi-Fi服务</td>
</tr>
<tr>
<td style="text-align:left">TELEPHONY_SERVICE</td>
<td style="text-align:left">TeleponyManager</td>
<td style="text-align:left">电话服务</td>
</tr>
</tbody>
</table>
<h2 id="获取LayoutInflater服务"><a href="#获取LayoutInflater服务" class="headerlink" title="获取LayoutInflater服务"></a>获取LayoutInflater服务</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContextImpl</span> <span class="keyword">extends</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="comment">/***部分代码省略****/</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">/***部分代码省略****/</span></span><br><span class="line">        registerService(LAYOUT_INFLATER_SERVICE, <span class="keyword">new</span> ServiceFetcher() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">createService</span><span class="params">(ContextImpl ctx)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> PolicyManager.makeNewLayoutInflater(ctx.getOuterContext());</span><br><span class="line">            &#125;&#125;);</span><br><span class="line">        <span class="comment">/***部分代码省略****/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***部分代码省略****/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从源码可以看出LayoutInflater实例是由 <code>PolicyManager.makeNewLayoutInflater</code>获取的，PolicyManager有没有感觉很熟悉。上一章 <a href="//dandanlove.com/2017/11/10/activity-setcontentview/">Activity中的Window的setContentView</a>  中我们获取Activity中的Window的实例的时候就是通过PolicyManager获取的，我们进一步往下跟进。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PolicyManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String POLICY_IMPL_CLASS_NAME =</span><br><span class="line">    <span class="string">"com.android.internal.policy.impl.Policy"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> IPolicy sPolicy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// Pull in the actual implementation of the policy at run-time</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class policyClass = Class.forName(POLICY_IMPL_CLASS_NAME);</span><br><span class="line">            sPolicy = (IPolicy)policyClass.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    POLICY_IMPL_CLASS_NAME + <span class="string">" could not be loaded"</span>, ex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    POLICY_IMPL_CLASS_NAME + <span class="string">" could not be instantiated"</span>, ex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    POLICY_IMPL_CLASS_NAME + <span class="string">" could not be instantiated"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***部分代码省略****/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LayoutInflater <span class="title">makeNewLayoutInflater</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//反射获取实例</span></span><br><span class="line">        <span class="keyword">return</span> sPolicy.makeNewLayoutInflater(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Policy</span> <span class="keyword">implements</span> <span class="title">IPolicy</span> </span>&#123;</span><br><span class="line">    <span class="comment">/***部分代码省略****/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LayoutInflater <span class="title">makeNewLayoutInflater</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//LayoutInflater的最终实例</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PhoneLayoutInflater(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***部分代码省略****/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="PhoneLayoutInflater的实现"><a href="#PhoneLayoutInflater的实现" class="headerlink" title="PhoneLayoutInflater的实现"></a>PhoneLayoutInflater的实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneLayoutInflater</span> <span class="keyword">extends</span> <span class="title">LayoutInflater</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] sClassPrefixList = &#123;</span><br><span class="line">        <span class="string">"android.widget."</span>,</span><br><span class="line">        <span class="string">"android.webkit."</span>,</span><br><span class="line">        <span class="string">"android.app."</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PhoneLayoutInflater</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">PhoneLayoutInflater</span><span class="params">(LayoutInflater original, Context newContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(original, newContext);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Override onCreateView to instantiate names that correspond to the</span></span><br><span class="line"><span class="comment">        widgets known to the Widget factory. If we don't find a match,</span></span><br><span class="line"><span class="comment">        call through to our super class.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> View <span class="title">onCreateView</span><span class="params">(String name, AttributeSet attrs)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String prefix : sClassPrefixList) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                View view = createView(name, prefix, attrs);</span><br><span class="line">                <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> view;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// In this case we want to let the base class take a crack</span></span><br><span class="line">                <span class="comment">// at it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onCreateView(name, attrs);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> LayoutInflater <span class="title">cloneInContext</span><span class="params">(Context newContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PhoneLayoutInflater(<span class="keyword">this</span>, newContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LayoutInflater最常使用的方法"><a href="#LayoutInflater最常使用的方法" class="headerlink" title="LayoutInflater最常使用的方法"></a>LayoutInflater最常使用的方法</h2><p>在Android中LayoutInflater中最常使用的情况基本都是调用inflate方法用来构造View对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LayoutInflater</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(@LayoutRes <span class="keyword">int</span> resource, @Nullable ViewGroup root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inflate(resource, root, root != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(XmlPullParser parser, @Nullable ViewGroup root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inflate(parser, root, root != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(@LayoutRes <span class="keyword">int</span> resource, @Nullable ViewGroup root, <span class="keyword">boolean</span> attachToRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Resources res = getContext().getResources();</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"INFLATING from resource: \""</span> + res.getResourceName(resource) + <span class="string">"\" ("</span></span><br><span class="line">                    + Integer.toHexString(resource) + <span class="string">")"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> XmlResourceParser parser = res.getLayout(resource);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> inflate(parser, root, attachToRoot);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            parser.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parser xml数据结构</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 一个可依附的rootview</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> attachToRoot 是否将parser解析生产的View添加在root上</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(XmlPullParser parser, @Nullable ViewGroup root, <span class="keyword">boolean</span> attachToRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mConstructorArgs) &#123;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"inflate"</span>);</span><br><span class="line">            <span class="comment">//当前上下文环境</span></span><br><span class="line">            <span class="keyword">final</span> Context inflaterContext = mContext;</span><br><span class="line">            <span class="comment">//所有的属性集合获取类</span></span><br><span class="line">            <span class="keyword">final</span> AttributeSet attrs = Xml.asAttributeSet(parser);</span><br><span class="line">            Context lastContext = (Context) mConstructorArgs[<span class="number">0</span>];</span><br><span class="line">            mConstructorArgs[<span class="number">0</span>] = inflaterContext;</span><br><span class="line">            <span class="comment">//根节点</span></span><br><span class="line">            View result = root;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Look for the root node.寻找根节点</span></span><br><span class="line">                <span class="keyword">int</span> type;</span><br><span class="line">                <span class="keyword">while</span> ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp;</span><br><span class="line">                        type != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line">                    <span class="comment">// Empty</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//找不到根节点抛出异常</span></span><br><span class="line">                <span class="keyword">if</span> (type != XmlPullParser.START_TAG) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InflateException(parser.getPositionDescription()</span><br><span class="line">                            + <span class="string">": No start tag found!"</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> String name = parser.getName();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"**************************"</span>);</span><br><span class="line">                    System.out.println(<span class="string">"Creating root view: "</span></span><br><span class="line">                            + name);</span><br><span class="line">                    System.out.println(<span class="string">"**************************"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//merge标签解析</span></span><br><span class="line">                <span class="keyword">if</span> (TAG_MERGE.equals(name)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (root == <span class="keyword">null</span> || !attachToRoot) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> InflateException(<span class="string">"&lt;merge /&gt; can be used only with a valid "</span></span><br><span class="line">                                + <span class="string">"ViewGroup root and attachToRoot=true"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//递归调用，添加root的孩子节点</span></span><br><span class="line">                    rInflate(parser, root, inflaterContext, attrs, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Temp is the root view that was found in the xml。根据当前的attrs和xml创建一个xml根view</span></span><br><span class="line">                    <span class="keyword">final</span> View temp = createViewFromTag(root, name, inflaterContext, attrs);</span><br><span class="line"></span><br><span class="line">                    ViewGroup.LayoutParams params = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                            System.out.println(<span class="string">"Creating params from root: "</span> +</span><br><span class="line">                                    root);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// Create layout params that match root, if supplied。构造LayoutParams</span></span><br><span class="line">                        params = root.generateLayoutParams(attrs);</span><br><span class="line">                        <span class="keyword">if</span> (!attachToRoot) &#123;</span><br><span class="line">                            <span class="comment">// Set the layout params for temp if we are not</span></span><br><span class="line">                            <span class="comment">// attaching. (If we are, we use addView, below)</span></span><br><span class="line">                            temp.setLayoutParams(params);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"-----&gt; start inflating children"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Inflate all children under temp against its context.递归调用，添加temp的孩子节点</span></span><br><span class="line">                    rInflateChildren(parser, temp, attrs, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"-----&gt; done inflating children"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// We are supposed to attach all the views we found (int temp)</span></span><br><span class="line">                    <span class="comment">// to root. Do that now.</span></span><br><span class="line">                    <span class="keyword">if</span> (root != <span class="keyword">null</span> &amp;&amp; attachToRoot) &#123;</span><br><span class="line">                        <span class="comment">//将xml解析出来的viewgroup添加在root的根下</span></span><br><span class="line">                        root.addView(temp, params);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Decide whether to return the root that was passed in or the</span></span><br><span class="line">                    <span class="comment">// top view found in xml.</span></span><br><span class="line">                    <span class="keyword">if</span> (root == <span class="keyword">null</span> || !attachToRoot) &#123;</span><br><span class="line">                        result = temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (XmlPullParserException e) &#123;</span><br><span class="line">                InflateException ex = <span class="keyword">new</span> InflateException(e.getMessage());</span><br><span class="line">                ex.initCause(e);</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                InflateException ex = <span class="keyword">new</span> InflateException(</span><br><span class="line">                        parser.getPositionDescription()</span><br><span class="line">                                + <span class="string">": "</span> + e.getMessage());</span><br><span class="line">                ex.initCause(e);</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// Don't retain static reference on context.</span></span><br><span class="line">                mConstructorArgs[<span class="number">0</span>] = lastContext;</span><br><span class="line">                mConstructorArgs[<span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这四个重载的inflate方法最终都是通过<code>inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot)</code>进行实现的。</p>
<blockquote>
<p>LayoutInflater的使用中重点关注inflate方法的参数含义：</p>
<ul>
<li>inflate(xmlId, null); 只创建temp的View，然后直接返回temp。</li>
<li>inflate(xmlId, parent); 创建temp的View，然后执行root.addView(temp, params);最后返回root。</li>
<li>inflate(xmlId, parent, false); 创建temp的View，然后执行temp.setLayoutParams(params);然后再返回temp。</li>
<li>inflate(xmlId, parent, true); 创建temp的View，然后执行root.addView(temp, params);最后返回root。</li>
<li>inflate(xmlId, null, false); 只创建temp的View，然后直接返回temp。</li>
<li>inflate(xmlId, null, true); 只创建temp的View，然后直接返回temp。</li>
</ul>
</blockquote>
<h2 id="LayoutInflater解析视图xml"><a href="#LayoutInflater解析视图xml" class="headerlink" title="LayoutInflater解析视图xml"></a>LayoutInflater解析视图xml</h2><ul>
<li>xml视图树解析</li>
</ul>
<p>递归执行rInflate生产View并添加给父容器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LayoutInflater</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将parser解析器中包含的view结合属性标签attrs生产view添加在parent容器中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parser xml解析器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parent 父容器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> attrs  属性标签集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> finishInflate 生产view之后是否执行父容器的onFinishInflate方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">rInflateChildren</span><span class="params">(XmlPullParser parser, View parent, AttributeSet attrs,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> finishInflate)</span> <span class="keyword">throws</span> XmlPullParserException, IOException </span>&#123;</span><br><span class="line">        rInflate(parser, parent, parent.getContext(), attrs, finishInflate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rInflate</span><span class="params">(XmlPullParser parser, View parent, Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">        AttributeSet attrs, <span class="keyword">boolean</span> finishInflate)</span> <span class="keyword">throws</span> XmlPullParserException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> depth = parser.getDepth();</span><br><span class="line">        <span class="keyword">int</span> type;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (((type = parser.next()) != XmlPullParser.END_TAG ||</span><br><span class="line">                parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (type != XmlPullParser.START_TAG) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> String name = parser.getName();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (TAG_REQUEST_FOCUS.equals(name)) &#123;  <span class="comment">//requestFocus标签解析</span></span><br><span class="line">                parseRequestFocus(parser, parent);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (TAG_TAG.equals(name)) &#123; <span class="comment">//tag标签解析</span></span><br><span class="line">                parseViewTag(parser, parent, attrs);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (TAG_INCLUDE.equals(name)) &#123; <span class="comment">//include标签解析</span></span><br><span class="line">                <span class="keyword">if</span> (parser.getDepth() == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InflateException(<span class="string">"&lt;include /&gt; cannot be the root element"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                parseInclude(parser, context, parent, attrs);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (TAG_MERGE.equals(name)) &#123; <span class="comment">//merge标签解析</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InflateException(<span class="string">"&lt;merge /&gt; must be the root element"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//View标签解析</span></span><br><span class="line">                <span class="keyword">final</span> View view = createViewFromTag(parent, name, context, attrs);</span><br><span class="line">                <span class="keyword">final</span> ViewGroup viewGroup = (ViewGroup) parent;</span><br><span class="line">                <span class="comment">//View所在容器（ViewGroup）的属性解析</span></span><br><span class="line">                <span class="keyword">final</span> ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);</span><br><span class="line">                <span class="comment">//循环遍历xml的子节点</span></span><br><span class="line">                rInflateChildren(parser, view, attrs, <span class="keyword">true</span>);</span><br><span class="line">                <span class="comment">//将解析出的view和其对于的属性参数添加在父容器中</span></span><br><span class="line">                viewGroup.addView(view, params);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (finishInflate) &#123;</span><br><span class="line">            parent.onFinishInflate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>单个View布局的解析</li>
</ul>
<p>调用createViewFromTag，设置View的Theme属性。再调用CreateView方法创建view</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LayoutInflater</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> View <span class="title">onCreateView</span><span class="params">(String name, AttributeSet attrs)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createView(name, <span class="string">"android.view."</span>, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> View <span class="title">onCreateView</span><span class="params">(View parent, String name, AttributeSet attrs)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> onCreateView(name, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将parser解析器中包含的view结合属性标签attrs生产view添加在parent容器中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parent 父容器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name view名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context 上下文环境</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> attrs  属性标签集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> View <span class="title">createViewFromTag</span><span class="params">(View parent, String name, Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createViewFromTag(parent, name, context, attrs, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">View <span class="title">createViewFromTag</span><span class="params">(View parent, String name, Context context, AttributeSet attrs,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> ignoreThemeAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">"view"</span>)) &#123;</span><br><span class="line">            name = attrs.getAttributeValue(<span class="keyword">null</span>, <span class="string">"class"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Apply a theme wrapper, if allowed and one is specified.//应用theme</span></span><br><span class="line">        <span class="keyword">if</span> (!ignoreThemeAttr) &#123;</span><br><span class="line">            <span class="keyword">final</span> TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> themeResId = ta.getResourceId(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (themeResId != <span class="number">0</span>) &#123;</span><br><span class="line">                context = <span class="keyword">new</span> ContextThemeWrapper(context, themeResId);</span><br><span class="line">            &#125;</span><br><span class="line">            ta.recycle();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (name.equals(TAG_1995)) &#123;</span><br><span class="line">            <span class="comment">// Let's party like it's 1995!</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BlinkLayout(context, attrs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            View view;</span><br><span class="line">            <span class="comment">/*************************start Factory*/</span></span><br><span class="line">            <span class="comment">//使用LayoutInflater的Factory，对View进行修改</span></span><br><span class="line">            <span class="keyword">if</span> (mFactory2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                view = mFactory2.onCreateView(parent, name, context, attrs);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                view = mFactory.onCreateView(name, context, attrs);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                view = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (view == <span class="keyword">null</span> &amp;&amp; mPrivateFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                view = mPrivateFactory.onCreateView(parent, name, context, attrs);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*************************end Factory*/</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> Object lastContext = mConstructorArgs[<span class="number">0</span>];</span><br><span class="line">                mConstructorArgs[<span class="number">0</span>] = context;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (-<span class="number">1</span> == name.indexOf(<span class="string">'.'</span>)) &#123;</span><br><span class="line">                        <span class="comment">//创建Android原生的View（android.view包下面的view）</span></span><br><span class="line">                        view = onCreateView(parent, name, attrs);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//创建自定义View或者依赖包中的View（xml中声明的是全路径）</span></span><br><span class="line">                        view = createView(name, <span class="keyword">null</span>, attrs);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    mConstructorArgs[<span class="number">0</span>] = lastContext;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> view;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InflateException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">final</span> InflateException ie = <span class="keyword">new</span> InflateException(attrs.getPositionDescription()</span><br><span class="line">                    + <span class="string">": Error inflating class "</span> + name);</span><br><span class="line">            ie.initCause(e);</span><br><span class="line">            <span class="keyword">throw</span> ie;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">final</span> InflateException ie = <span class="keyword">new</span> InflateException(attrs.getPositionDescription()</span><br><span class="line">                    + <span class="string">": Error inflating class "</span> + name);</span><br><span class="line">            ie.initCause(e);</span><br><span class="line">            <span class="keyword">throw</span> ie;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> View <span class="title">createView</span><span class="params">(String name, String prefix, AttributeSet attrs)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ClassNotFoundException, InflateException </span>&#123;</span><br><span class="line">        Constructor&lt;? extends View&gt; constructor = sConstructorMap.get(name);</span><br><span class="line">        Class&lt;? extends View&gt; clazz = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);</span><br><span class="line">            <span class="comment">//判断View的构造是否进行缓存</span></span><br><span class="line">            <span class="keyword">if</span> (constructor == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Class not found in the cache, see if it's real, and try to add it</span></span><br><span class="line">                clazz = mContext.getClassLoader().loadClass(</span><br><span class="line">                        prefix != <span class="keyword">null</span> ? (prefix + name) : name).asSubclass(View.class);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (mFilter != <span class="keyword">null</span> &amp;&amp; clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">boolean</span> allowed = mFilter.onLoadClass(clazz);</span><br><span class="line">                    <span class="keyword">if</span> (!allowed) &#123;</span><br><span class="line">                        failNotAllowed(name, prefix, attrs);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//static final Class&lt;?&gt;[] mConstructorSignature = new Class[] &#123;Context.class, AttributeSet.class&#125;;</span></span><br><span class="line">                constructor = clazz.getConstructor(mConstructorSignature);</span><br><span class="line">                sConstructorMap.put(name, constructor);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// If we have a filter, apply it to cached constructor</span></span><br><span class="line">                <span class="keyword">if</span> (mFilter != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Have we seen this name before?</span></span><br><span class="line">                    Boolean allowedState = mFilterMap.get(name);</span><br><span class="line">                    <span class="keyword">if</span> (allowedState == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// New class -- remember whether it is allowed</span></span><br><span class="line">                        clazz = mContext.getClassLoader().loadClass(</span><br><span class="line">                                prefix != <span class="keyword">null</span> ? (prefix + name) : name).asSubclass(View.class);</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">boolean</span> allowed = clazz != <span class="keyword">null</span> &amp;&amp; mFilter.onLoadClass(clazz);</span><br><span class="line">                        mFilterMap.put(name, allowed);</span><br><span class="line">                        <span class="keyword">if</span> (!allowed) &#123;</span><br><span class="line">                            failNotAllowed(name, prefix, attrs);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (allowedState.equals(Boolean.FALSE)) &#123;</span><br><span class="line">                        failNotAllowed(name, prefix, attrs);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            Object[] args = mConstructorArgs;</span><br><span class="line">            args[<span class="number">1</span>] = attrs;</span><br><span class="line">            constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">//读取View的构造函数，传入context、attrs作为参数。View(Context context, AttributeSet attrs)；</span></span><br><span class="line">            <span class="keyword">final</span> View view = constructor.newInstance(args);</span><br><span class="line">            <span class="comment">//处理ViewStub标签</span></span><br><span class="line">            <span class="keyword">if</span> (view <span class="keyword">instanceof</span> ViewStub) &#123;</span><br><span class="line">                <span class="comment">// Use the same context when inflating ViewStub later.</span></span><br><span class="line">                <span class="keyword">final</span> ViewStub viewStub = (ViewStub) view;</span><br><span class="line">                viewStub.setLayoutInflater(cloneInContext((Context) args[<span class="number">0</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> view;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            InflateException ie = <span class="keyword">new</span> InflateException(attrs.getPositionDescription()</span><br><span class="line">                    + <span class="string">": Error inflating class "</span></span><br><span class="line">                    + (prefix != <span class="keyword">null</span> ? (prefix + name) : name));</span><br><span class="line">            ie.initCause(e);</span><br><span class="line">            <span class="keyword">throw</span> ie;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">            <span class="comment">// If loaded class is not a View subclass</span></span><br><span class="line">            InflateException ie = <span class="keyword">new</span> InflateException(attrs.getPositionDescription()</span><br><span class="line">                    + <span class="string">": Class is not a View "</span></span><br><span class="line">                    + (prefix != <span class="keyword">null</span> ? (prefix + name) : name));</span><br><span class="line">            ie.initCause(e);</span><br><span class="line">            <span class="keyword">throw</span> ie;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// If loadClass fails, we should propagate the exception.</span></span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            InflateException ie = <span class="keyword">new</span> InflateException(attrs.getPositionDescription()</span><br><span class="line">                    + <span class="string">": Error inflating class "</span></span><br><span class="line">                    + (clazz == <span class="keyword">null</span> ? <span class="string">"&lt;unknown&gt;"</span> : clazz.getName()));</span><br><span class="line">            ie.initCause(e);</span><br><span class="line">            <span class="keyword">throw</span> ie;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LayoutInflater创建View的总结"><a href="#LayoutInflater创建View的总结" class="headerlink" title="LayoutInflater创建View的总结"></a>LayoutInflater创建View的总结</h2><blockquote>
<ul>
<li>在inflate方法中，通过Resource.getLayout(resource)生产XmlResourceParser对象；</li>
<li>利用该对象实例生产XmlPullAttributes以便于xml标签中的属性。然后将这个两个对象传递到rInflate方法中，解析layout对应的xml文件；</li>
<li>接着将（父容器、xml中View的名称、属性标签）传递给createViewFromTag方法创建对应的View；</li>
<li>在createViewFromTag方法中执行LayoutInflater.Factory或者LayoutInflater的createView方法。</li>
<li>在createView方法中我们已知View的类名和View的属性标签集合，通过Java反射执行View的构造方法创建View对象。这也就是为什么我们在自定义View的时候必须复写View的构造函数View(Context context, AttributeSet attrs)；</li>
</ul>
</blockquote>
<h2 id="LayoutInflater-Factory简介"><a href="#LayoutInflater-Factory简介" class="headerlink" title="LayoutInflater.Factory简介"></a>LayoutInflater.Factory简介</h2><blockquote>
<p>LayoutInflater.Factory这个类在我们开发的过程中很少越到。但是我们在查看LayoutInflater解析View源码的过程中可以看到如果LayoutInflater中有mFactory这个实例那么可以通过mFactory创建View,同时也能修改入参AttributeSet属性值。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LayoutInflater</span> </span>&#123;</span><br><span class="line">    <span class="comment">/***部分代码省略****/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(String name, Context context, AttributeSet attrs)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory2</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(View parent, String name, Context context, AttributeSet attrs)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***部分代码省略****/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>LayoutInflater有两个工厂类，Factory和Factory2，区别只是在于Factory2可以传入父容器作为参数。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LayoutInflater</span> </span>&#123;</span><br><span class="line">    <span class="comment">/***部分代码省略****/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFactory</span><span class="params">(Factory factory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mFactorySet) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"A factory has already been set on this LayoutInflater"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (factory == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Given factory can not be null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mFactorySet = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (mFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mFactory = factory;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mFactory = <span class="keyword">new</span> FactoryMerger(factory, <span class="keyword">null</span>, mFactory, mFactory2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFactory2</span><span class="params">(Factory2 factory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mFactorySet) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"A factory has already been set on this LayoutInflater"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (factory == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Given factory can not be null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mFactorySet = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (mFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mFactory = mFactory2 = factory;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mFactory = mFactory2 = <span class="keyword">new</span> FactoryMerger(factory, factory, mFactory, mFactory2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***部分代码省略****/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个方法的功能基本是一致的，setFactory2是在Android3.0之后以后引入的，所以我们要根据SDK的版本去选择调用上述方法。</p>
<p>在supportv4下边也有LayoutInflaterCompat可以做相同的操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LayoutInflaterCompat</span> </span>&#123;</span><br><span class="line">    <span class="comment">/***部分代码省略****/</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> LayoutInflaterCompatImpl IMPL;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> version = Build.VERSION.SDK_INT;</span><br><span class="line">        <span class="keyword">if</span> (version &gt;= <span class="number">21</span>) &#123;</span><br><span class="line">            IMPL = <span class="keyword">new</span> LayoutInflaterCompatImplV21();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (version &gt;= <span class="number">11</span>) &#123;</span><br><span class="line">            IMPL = <span class="keyword">new</span> LayoutInflaterCompatImplV11();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            IMPL = <span class="keyword">new</span> LayoutInflaterCompatImplBase();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LayoutInflaterCompat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setFactory</span><span class="params">(LayoutInflater inflater, LayoutInflaterFactory factory)</span> </span>&#123;</span><br><span class="line">        IMPL.setFactory(inflater, factory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LayoutInflater-Factory的使用"><a href="#LayoutInflater-Factory的使用" class="headerlink" title="LayoutInflater.Factory的使用"></a>LayoutInflater.Factory的使用</h2><p>找到当前Activity中的id=R.id.text的TextView将其替换为Button，并修改BackgroundColor。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String TAG = <span class="string">"MainActivity"</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        LayoutInflater.from(<span class="keyword">this</span>).setFactory(<span class="keyword">new</span> LayoutInflater.Factory() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(String name, Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"TextView"</span>.equals(name)) &#123;</span><br><span class="line">                    Log.e(TAG, <span class="string">"name = "</span> + name);</span><br><span class="line">                    <span class="keyword">int</span> n = attrs.getAttributeCount();</span><br><span class="line">                    <span class="comment">//打印所有属性标签</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                        Log.e(TAG, attrs.getAttributeName(i) + <span class="string">" , "</span> + attrs.getAttributeValue(i));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (attrs.getAttributeName(i).equals(<span class="string">"id"</span>)) &#123;</span><br><span class="line">                            String attributeValue = attrs.getAttributeValue(i);</span><br><span class="line">                            String id = attributeValue.substring(<span class="number">1</span>, attributeValue.length());</span><br><span class="line">                            <span class="keyword">if</span> (R.id.text == Integer.valueOf(id)) &#123;</span><br><span class="line">                                Button button = <span class="keyword">new</span> Button(context, attrs);</span><br><span class="line">                                button.setBackgroundColor(Color.RED);</span><br><span class="line">                                <span class="keyword">return</span> button;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Console输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MainActivity: name = TextView</span><br><span class="line">MainActivity: id , @<span class="number">2131492944</span></span><br><span class="line">MainActivity: layout_width , -<span class="number">2</span></span><br><span class="line">MainActivity: layout_height , -<span class="number">2</span></span><br><span class="line">MainActivity: text , Hello World!</span><br></pre></td></tr></table></figure>
<p>是不是发现LayoutInflater的Factory功能很好很强大。</p>
<blockquote>
<p>这里提一个问题，如果把上面代码中的MainActivity的父类修改为AppCompatActivity会怎么样呢？我们试着运行一下。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.RuntimeException: Unable to start activity</span><br><span class="line">ComponentInfo&#123;com.example.tzx.dexload/com.example.tzx.dexload.MainActivity&#125;: </span><br><span class="line">java.lang.IllegalStateException: A factory has already been set on <span class="keyword">this</span> LayoutInflater</span><br></pre></td></tr></table></figure>
<p>程序运行报错:<code>A factory has already been set on this LayoutInflater</code>。这个是在执行LayoutInflater的setFactory方法时抛出的异常。因为mFactorySet=true。。。。这个时候我们发现LayoutInflater的Factory已经被设置过了。具体是在哪里设置的呢？我们看看下边<code>LayoutInflater.Factory在Android源码中的使用</code>部分内容。</p>
<h2 id="LayoutInflater-Factory在Android源码中的使用"><a href="#LayoutInflater-Factory在Android源码中的使用" class="headerlink" title="LayoutInflater.Factory在Android源码中的使用"></a>LayoutInflater.Factory在Android源码中的使用</h2><p>在我们开发过程是很少使用到LayoutInflater.Factory，但是Android在supportv7中就使用，我们来学习一下。</p>
<p>在AppComPatActivity中的onCreate就进行了LayoutInflater.Factory的设置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppCompatActivity</span> <span class="keyword">extends</span> <span class="title">FragmentActivity</span> <span class="keyword">implements</span> <span class="title">AppCompatCallback</span>,</span></span><br><span class="line"><span class="class">    <span class="title">TaskStackBuilder</span>.<span class="title">SupportParentable</span>, <span class="title">ActionBarDrawerToggle</span>.<span class="title">DelegateProvider</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        getDelegate().installViewFactory();</span><br><span class="line">        getDelegate().onCreate(savedInstanceState);</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AppCompatDelegate <span class="title">getDelegate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mDelegate == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mDelegate = AppCompatDelegate.create(<span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mDelegate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>根据不通的sdk版本做适配</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AppCompatDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AppCompatDelegate <span class="title">create</span><span class="params">(Activity activity, AppCompatCallback callback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> create(activity, activity.getWindow(), callback);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***部分代码省略****/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//对于不同的版本做适配</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> AppCompatDelegate <span class="title">create</span><span class="params">(Context context, Window window,</span></span></span><br><span class="line"><span class="function"><span class="params">        AppCompatCallback callback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> sdk = Build.VERSION.SDK_INT;</span><br><span class="line">        <span class="keyword">if</span> (sdk &gt;= <span class="number">23</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AppCompatDelegateImplV23(context, window, callback);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sdk &gt;= <span class="number">14</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AppCompatDelegateImplV14(context, window, callback);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sdk &gt;= <span class="number">11</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AppCompatDelegateImplV11(context, window, callback);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AppCompatDelegateImplV7(context, window, callback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LayoutInflaterFactory的实现类，以及触发LayoutInflater.setFactory的调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppCompatDelegateImplV7</span> <span class="keyword">extends</span> <span class="title">AppCompatDelegateImplBase</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">MenuBuilder</span>.<span class="title">Callback</span>, <span class="title">LayoutInflaterFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/***部分代码省略****/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">installViewFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LayoutInflater layoutInflater = LayoutInflater.from(mContext);</span><br><span class="line">        <span class="keyword">if</span> (layoutInflater.getFactory() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//进行setFactory的设置</span></span><br><span class="line">            LayoutInflaterCompat.setFactory(layoutInflater, <span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Log.i(TAG, <span class="string">"The Activity's LayoutInflater already has a Factory installed"</span></span><br><span class="line">                    + <span class="string">" so we can not install AppCompat's"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***部分代码省略****/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">createView</span><span class="params">(View parent, <span class="keyword">final</span> String name, @NonNull Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">            @NonNull AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isPre21 = Build.VERSION.SDK_INT &lt; <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mAppCompatViewInflater == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//具体的实现类，下文会有讲到</span></span><br><span class="line">            mAppCompatViewInflater = <span class="keyword">new</span> AppCompatViewInflater();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We only want the View to inherit it's context if we're running pre-v21</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> inheritContext = isPre21 &amp;&amp; mSubDecorInstalled</span><br><span class="line">                &amp;&amp; shouldInheritContext((ViewParent) parent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mAppCompatViewInflater.createView(parent, name, context, attrs, inheritContext,</span><br><span class="line">                isPre21, <span class="comment">/* Only read android:theme pre-L (L+ handles this anyway) */</span></span><br><span class="line">                <span class="keyword">true</span> <span class="comment">/* Read read app:theme as a fallback at all times for legacy reasons */</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>根据不同的版本找到LayoutInflater的包装类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LayoutInflaterCompat</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">LayoutInflaterCompatImpl</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFactory</span><span class="params">(LayoutInflater layoutInflater, LayoutInflaterFactory factory)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> LayoutInflaterFactory <span class="title">getFactory</span><span class="params">(LayoutInflater layoutInflater)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LayoutInflaterCompatImplBase</span> <span class="keyword">implements</span> <span class="title">LayoutInflaterCompatImpl</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFactory</span><span class="params">(LayoutInflater layoutInflater, LayoutInflaterFactory factory)</span> </span>&#123;</span><br><span class="line">            LayoutInflaterCompatBase.setFactory(layoutInflater, factory);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> LayoutInflaterFactory <span class="title">getFactory</span><span class="params">(LayoutInflater layoutInflater)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> LayoutInflaterCompatBase.getFactory(layoutInflater);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> LayoutInflaterCompatImpl IMPL;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> version = Build.VERSION.SDK_INT;</span><br><span class="line">        <span class="keyword">if</span> (version &gt;= <span class="number">21</span>) &#123;</span><br><span class="line">            IMPL = <span class="keyword">new</span> LayoutInflaterCompatImplV21();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (version &gt;= <span class="number">11</span>) &#123;</span><br><span class="line">            IMPL = <span class="keyword">new</span> LayoutInflaterCompatImplV11();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            IMPL = <span class="keyword">new</span> LayoutInflaterCompatImplBase();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***部分代码省略****/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LayoutInflaterCompat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setFactory</span><span class="params">(LayoutInflater inflater, LayoutInflaterFactory factory)</span> </span>&#123;</span><br><span class="line">        IMPL.setFactory(inflater, factory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LayoutInflaterFactory <span class="title">getFactory</span><span class="params">(LayoutInflater inflater)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> IMPL.getFactory(inflater);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>FactoryWrapper类通过调用LayoutInflaterFactory的onCreateView方法，实现了LayoutInflater.Factory接口。最终调用了LayoutInflater的setFactory方法，使得在LayoutInflater.createViewFromTag中创建View的时候通过Factory进行创建。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LayoutInflaterFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(View parent, String name, Context context, AttributeSet attrs)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LayoutInflaterCompatBase</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryWrapper</span> <span class="keyword">implements</span> <span class="title">LayoutInflater</span>.<span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> LayoutInflaterFactory mDelegateFactory;</span><br><span class="line"></span><br><span class="line">        FactoryWrapper(LayoutInflaterFactory delegateFactory) &#123;</span><br><span class="line">            mDelegateFactory = delegateFactory;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(String name, Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//调用LayoutInflaterFactory实现类的onCreateView(null, name, context, attrs)方法</span></span><br><span class="line">            <span class="keyword">return</span> mDelegateFactory.onCreateView(<span class="keyword">null</span>, name, context, attrs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getClass().getName() + <span class="string">"&#123;"</span> + mDelegateFactory + <span class="string">"&#125;"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setFactory</span><span class="params">(LayoutInflater inflater, LayoutInflaterFactory factory)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//最终调用了LayoutInflater的setFactory方法，对Factory进行设置</span></span><br><span class="line">        inflater.setFactory(factory != <span class="keyword">null</span> ? <span class="keyword">new</span> FactoryWrapper(factory) : <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> LayoutInflaterFactory <span class="title">getFactory</span><span class="params">(LayoutInflater inflater)</span> </span>&#123;</span><br><span class="line">        LayoutInflater.Factory factory = inflater.getFactory();</span><br><span class="line">        <span class="keyword">if</span> (factory <span class="keyword">instanceof</span> FactoryWrapper) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((FactoryWrapper) factory).mDelegateFactory;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在LayoutInflaterFactory的实现类之一AppCompatDelegateImplV7中，找到了setFactory的实际使用意义实际意思。<blockquote>
<ul>
<li>在LayoutInflater.createViewFromTag方法中调用<code>Factory.onCreateView(name, context, attrs)</code>方法</li>
<li>Factory的实现类FactoryWrapper中，调用<code>LayoutInflaterFactory的onCreateView(null, name, context, attrs)</code>方法</li>
</ul>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppCompatViewInflater</span> </span>&#123;</span><br><span class="line">    <span class="comment">/***部分代码省略****/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> View <span class="title">createView</span><span class="params">(View parent, <span class="keyword">final</span> String name, @NonNull Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull AttributeSet attrs, <span class="keyword">boolean</span> inheritContext,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> readAndroidTheme, <span class="keyword">boolean</span> readAppTheme, <span class="keyword">boolean</span> wrapContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Context originalContext = context;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can emulate Lollipop's android:theme attribute propagating down the view hierarchy</span></span><br><span class="line">        <span class="comment">// by using the parent's context</span></span><br><span class="line">        <span class="keyword">if</span> (inheritContext &amp;&amp; parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            context = parent.getContext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (readAndroidTheme || readAppTheme) &#123;</span><br><span class="line">            <span class="comment">// We then apply the theme on the context, if specified</span></span><br><span class="line">            context = themifyContext(context, attrs, readAndroidTheme, readAppTheme);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (wrapContext) &#123;</span><br><span class="line">            context = TintContextWrapper.wrap(context);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        View view = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We need to 'inject' our tint aware Views in place of the standard framework versions</span></span><br><span class="line">        <span class="keyword">switch</span> (name) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"TextView"</span>:</span><br><span class="line">                view = <span class="keyword">new</span> AppCompatTextView(context, attrs);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"ImageView"</span>:</span><br><span class="line">                view = <span class="keyword">new</span> AppCompatImageView(context, attrs);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"Button"</span>:</span><br><span class="line">                view = <span class="keyword">new</span> AppCompatButton(context, attrs);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"EditText"</span>:</span><br><span class="line">                view = <span class="keyword">new</span> AppCompatEditText(context, attrs);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"Spinner"</span>:</span><br><span class="line">                view = <span class="keyword">new</span> AppCompatSpinner(context, attrs);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"ImageButton"</span>:</span><br><span class="line">                view = <span class="keyword">new</span> AppCompatImageButton(context, attrs);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"CheckBox"</span>:</span><br><span class="line">                view = <span class="keyword">new</span> AppCompatCheckBox(context, attrs);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"RadioButton"</span>:</span><br><span class="line">                view = <span class="keyword">new</span> AppCompatRadioButton(context, attrs);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"CheckedTextView"</span>:</span><br><span class="line">                view = <span class="keyword">new</span> AppCompatCheckedTextView(context, attrs);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"AutoCompleteTextView"</span>:</span><br><span class="line">                view = <span class="keyword">new</span> AppCompatAutoCompleteTextView(context, attrs);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"MultiAutoCompleteTextView"</span>:</span><br><span class="line">                view = <span class="keyword">new</span> AppCompatMultiAutoCompleteTextView(context, attrs);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"RatingBar"</span>:</span><br><span class="line">                view = <span class="keyword">new</span> AppCompatRatingBar(context, attrs);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"SeekBar"</span>:</span><br><span class="line">                view = <span class="keyword">new</span> AppCompatSeekBar(context, attrs);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (view == <span class="keyword">null</span> &amp;&amp; originalContext != context) &#123;</span><br><span class="line">            <span class="comment">// If the original context does not equal our themed context, then we need to manually</span></span><br><span class="line">            <span class="comment">// inflate it using the name so that android:theme takes effect.</span></span><br><span class="line">            view = createViewFromTag(context, name, attrs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// If we have created a view, check it's android:onClick</span></span><br><span class="line">            checkOnClickListener(view, attrs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>AppCompatViewInflater作为LayoutInflaterFactory的的onCreateView方法的最终实现类，通过createView方法替换了一些我们想要自己替换的View。比如：</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">原始View</th>
<th style="text-align:left">实际创建的View</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">TextView</td>
<td style="text-align:left">AppCompatTextView</td>
</tr>
<tr>
<td style="text-align:left">ImageView</td>
<td style="text-align:left">AppCompatImageView</td>
</tr>
<tr>
<td style="text-align:left">Button</td>
<td style="text-align:left">AppCompatButton</td>
</tr>
<tr>
<td style="text-align:left">……</td>
<td style="text-align:left">……</td>
</tr>
</tbody>
</table>
<h2 id="在appcompat使用自定义的LayoutInflater-Factory"><a href="#在appcompat使用自定义的LayoutInflater-Factory" class="headerlink" title="在appcompat使用自定义的LayoutInflater.Factory"></a>在appcompat使用自定义的LayoutInflater.Factory</h2><p>这里我们有两种书写方式：</p>
<blockquote>
<p>这里必须写在 <code>super.oncreate</code> 之前，否则还会继续报错。</p>
<ul>
<li>继续使用 LayoutInflater.from(this).setFactory 方法。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LayoutInflater.from(<span class="keyword">this</span>).setFactory(<span class="keyword">new</span> LayoutInflater.Factory() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(String name, Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        AppCompatDelegate delegate = getDelegate();</span><br><span class="line">        <span class="comment">//调用AppCompatDelegate的createView方法将第一个参数设置为null</span></span><br><span class="line">        View view = delegate.createView(<span class="keyword">null</span>, name, context, attrs);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"TextView"</span>.equals(name)) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"name = "</span> + name);</span><br><span class="line">            <span class="keyword">int</span> n = attrs.getAttributeCount();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                Log.e(TAG, attrs.getAttributeName(i) + <span class="string">" , "</span> + attrs.getAttributeValue(i));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (attrs.getAttributeName(i).equals(<span class="string">"id"</span>)) &#123;</span><br><span class="line">                    String attributeValue = attrs.getAttributeValue(i);</span><br><span class="line">                    String id = attributeValue.substring(<span class="number">1</span>, attributeValue.length());</span><br><span class="line">                    <span class="keyword">if</span> (R.id.text == Integer.valueOf(id)) &#123;</span><br><span class="line">                        Button button = <span class="keyword">new</span> Button(context, attrs);</span><br><span class="line">                        button.setBackgroundColor(Color.RED);</span><br><span class="line">                        button.setAllCaps(<span class="keyword">false</span>);</span><br><span class="line">                        <span class="keyword">return</span> button;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>使用LayoutInflaterCompat.setFactory方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LayoutInflaterCompat.setFactory(LayoutInflater.from(<span class="keyword">this</span>), <span class="keyword">new</span> LayoutInflaterFactory() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(View parent, String name, Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//appcompat 创建view代码</span></span><br><span class="line">        AppCompatDelegate delegate = getDelegate();</span><br><span class="line">        View view = delegate.createView(parent, name, context, attrs);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"TextView"</span>.equals(name)) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"name = "</span> + name);</span><br><span class="line">            <span class="keyword">int</span> n = attrs.getAttributeCount();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                Log.e(TAG, attrs.getAttributeName(i) + <span class="string">" , "</span> + attrs.getAttributeValue(i));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (attrs.getAttributeName(i).equals(<span class="string">"id"</span>)) &#123;</span><br><span class="line">                    String attributeValue = attrs.getAttributeValue(i);</span><br><span class="line">                    String id = attributeValue.substring(<span class="number">1</span>, attributeValue.length());</span><br><span class="line">                    <span class="keyword">if</span> (R.id.text == Integer.valueOf(id)) &#123;</span><br><span class="line">                        Button button = <span class="keyword">new</span> Button(context, attrs);</span><br><span class="line">                        button.setBackgroundColor(Color.RED);</span><br><span class="line">                        button.setAllCaps(<span class="keyword">false</span>);</span><br><span class="line">                        <span class="keyword">return</span> button;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>两种写法的原理是相同的，因为上面讲述的LayoutInflater.Factory的实现类FactoryWrapper实现onCreateView方法的时候调用的AppCompatDelegate.onCreateView的时候第一个参数传递的值就是null。</p>
<p>Android应用中的换肤（夜间模式）是不是也利用的是LayoutInflater.Factory原理实现的呢，我们一起期待下一篇关于Android换肤文章。</p>
<p>参考文章：<br><a href="http://blog.csdn.net/lmj623565791/article/details/51503977" target="_blank" rel="noopener">Android 探究 LayoutInflater setFactory</a></p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Factory</tag>
        <tag>LayoutInflater</tag>
      </tags>
  </entry>
  <entry>
    <title>Activity中的Window的setContentView</title>
    <url>/2017/11/10/activity-setcontentview/</url>
    <content><![CDATA[<p>这篇文章距离现在已经两年的时间了。当初自己刚毕业工作不久，才开始接触Android，有一天中午和同事一起吃饭的时候，一个大牛问我你思考过Activity的setContentView是怎么执行的么。当初就因为这个问题我接入到了Android源码。两年时间过去了现在回过头来看，感觉自己写得有很多的不足，本次再补充一下。</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这几天正在进行初级自定义组件的学习，一不小心想到了view到底是怎么加载到屏幕上面的。每一个Activity中都有一个方法setContentView,我们可以加载自己想要的界面布局，展示在手机屏幕上。但到底内部是怎么实现的呢？（PS:源码基于Android5.1，cm12.1）</p>
<h1 id="Activity的onContentView"><a href="#Activity的onContentView" class="headerlink" title="Activity的onContentView"></a>Activity的onContentView</h1><p>首先查看Activity的onContentView的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//Activity.java</span><br><span class="line">public void setContentView(int layoutResID) &#123;</span><br><span class="line">     getWindow().setContentView(layoutResID);</span><br><span class="line">     initActionBar();</span><br><span class="line">&#125;</span><br><span class="line">public void setContentView(View view) &#123;</span><br><span class="line">    getWindow().setContentView(view);</span><br><span class="line">    initActionBar();</span><br><span class="line">&#125;</span><br><span class="line">public void setContentView(View view, ViewGroup.LayoutParams params) &#123;</span><br><span class="line">    getWindow().setContentView(view, params);</span><br><span class="line">    initActionBar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Activity一共重载了三个setContentView方法，其中第一个setContentView(int layoutResID)方法是我们常用的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void setContentView(int layoutResID) &#123;</span><br><span class="line">     //getWindow()获取activity内部对象mWindow并调用它的setContentView方法</span><br><span class="line">      getWindow().setContentView(layoutResID);</span><br><span class="line">      initActionBar(); //这是初始化actionBar，我们不关注它</span><br><span class="line">&#125;</span><br><span class="line">public Window getWindow() &#123;</span><br><span class="line">    return mWindow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Activity的setContentView方法实际还是调用mWindow的setContentView方法，接下看我们试看看mWindow的相关代码。</p>
<h1 id="mWindow对象"><a href="#mWindow对象" class="headerlink" title="mWindow对象"></a>mWindow对象</h1><p>查看Activity源码，找到在attach方法中对mWindow做了赋值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final void attach(Context context, ActivityThread aThread,</span><br><span class="line">           Instrumentation instr, IBinder token, int ident,</span><br><span class="line">           Application application, Intent intent, ActivityInfo info,</span><br><span class="line">           CharSequence title, Activity parent, String id,</span><br><span class="line">           NonConfigurationInstances lastNonConfigurationInstances,</span><br><span class="line">           Configuration config) &#123;</span><br><span class="line">    attachBaseContext(context);</span><br><span class="line">    </span><br><span class="line">    mFragments.attachActivity(this, mContainer, null);</span><br><span class="line">    </span><br><span class="line">    mWindow = PolicyManager.makeNewWindow(this);</span><br><span class="line">    mWindow.setCallback(this);</span><br><span class="line">    /…部分代码省略…/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么Activity的attach方法是Activity生命周期的第一个方法，它是ActivityThread中performLaunchActivity方法调用的，这是通过AMS(ActivityManagerService)的startActivity调用ActivityTrack的startActivityMayWait来调用的。</p>
<p>attach字面意思就是“使依附；贴上；系上”，也就是点击activity进行启动的时候之执行的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</span><br><span class="line">    /*******部分代码省略********/</span><br><span class="line">    try &#123;</span><br><span class="line">        java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</span><br><span class="line">        activity = mInstrumentation.newActivity(</span><br><span class="line">                cl, component.getClassName(), r.intent);</span><br><span class="line">        StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">        r.intent.setExtrasClassLoader(cl);</span><br><span class="line">        r.intent.prepareToEnterProcess();</span><br><span class="line">        if (r.state != null) &#123;</span><br><span class="line">            r.state.setClassLoader(cl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        if (!mInstrumentation.onException(activity, e)) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                &quot;Unable to instantiate activity &quot; + component</span><br><span class="line">                + &quot;: &quot; + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        Application app = r.packageInfo.makeApplication(false, mInstrumentation);</span><br><span class="line"></span><br><span class="line">        /*******部分代码省略********/</span><br><span class="line"></span><br><span class="line">        if (activity != null) &#123;</span><br><span class="line">            Context appContext = createBaseContextForActivity(r, activity);</span><br><span class="line">            CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());</span><br><span class="line">            Configuration config = new Configuration(mCompatConfiguration);</span><br><span class="line">            if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Launching activity &quot;</span><br><span class="line">                    + r.activityInfo.name + &quot; with config &quot; + config);</span><br><span class="line">            activity.attach(appContext, this, getInstrumentation(), r.token,</span><br><span class="line">                    r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                    r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                    r.referrer, r.voiceInteractor);</span><br><span class="line"></span><br><span class="line">            /*******部分代码省略********/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如述源代码当中就是在启动Activity的时候执行其attach：</p>
<blockquote>
<ul>
<li>ApplicationThread#scheduleLaunchActivity</li>
<li>ActivityThread#handleLaunchActivity</li>
<li>ActivityThread#performLaunchActivity</li>
<li>Activity#attach</li>
</ul>
</blockquote>
<h1 id="PolicyManager获取Window对象"><a href="#PolicyManager获取Window对象" class="headerlink" title="PolicyManager获取Window对象"></a>PolicyManager获取Window对象</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PolicyManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String POLICY_IMPL_CLASS_NAME =</span><br><span class="line">        <span class="string">"com.android.internal.policy.impl.Policy"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> IPolicy sPolicy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// Pull in the actual implementation of the policy at run-time</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class policyClass = Class.forName(POLICY_IMPL_CLASS_NAME);</span><br><span class="line">            sPolicy = (IPolicy)policyClass.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    POLICY_IMPL_CLASS_NAME + <span class="string">" could not be loaded"</span>, ex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    POLICY_IMPL_CLASS_NAME + <span class="string">" could not be instantiated"</span>, ex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    POLICY_IMPL_CLASS_NAME + <span class="string">" could not be instantiated"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cannot instantiate this class</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">PolicyManager</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The static methods to spawn new policy-specific objects</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Window <span class="title">makeNewWindow</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sPolicy.makeNewWindow(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*******部分代码省略********/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PolicyManager.makeNewWindow方法实际是通过反射机制调用了”com.android.internal.policy.impl.Policy”的makeNewWindow方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Policy</span> <span class="keyword">implements</span> <span class="title">IPolicy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"PhonePolicy"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] preload_classes = &#123;</span><br><span class="line">        <span class="string">"com.android.internal.policy.impl.PhoneLayoutInflater"</span>,</span><br><span class="line">        <span class="string">"com.android.internal.policy.impl.PhoneWindow"</span>,</span><br><span class="line">        <span class="string">"com.android.internal.policy.impl.PhoneWindow$1"</span>,</span><br><span class="line">        <span class="string">"com.android.internal.policy.impl.PhoneWindow$DialogMenuCallback"</span>,</span><br><span class="line">        <span class="string">"com.android.internal.policy.impl.PhoneWindow$DecorView"</span>,</span><br><span class="line">        <span class="string">"com.android.internal.policy.impl.PhoneWindow$PanelFeatureState"</span>,</span><br><span class="line">        <span class="string">"com.android.internal.policy.impl.PhoneWindow$PanelFeatureState$SavedState"</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// For performance reasons, preload some policy specific classes when</span></span><br><span class="line">        <span class="comment">// the policy gets loaded.</span></span><br><span class="line">        <span class="keyword">for</span> (String s : preload_classes) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Class.forName(s);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">                Log.e(TAG, <span class="string">"Could not preload class for phone policy: "</span> + s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Window <span class="title">makeNewWindow</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PhoneWindow(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******部分代码省略********/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Policy的makeNewWindow方法实际是返回一个PhoneWindow对象。</p>
<h1 id="PhoneWindow-setContentView"><a href="#PhoneWindow-setContentView" class="headerlink" title="PhoneWindow.setContentView"></a>PhoneWindow.setContentView</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneWindow</span> <span class="keyword">extends</span> <span class="title">Window</span> <span class="keyword">implements</span> <span class="title">MenuBuilder</span>.<span class="title">Callback</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*******部分代码省略********/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        setContentView(view, <span class="keyword">new</span> ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(View view, ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window</span></span><br><span class="line">        <span class="comment">// decor, when theme attributes and the like are crystalized. Do not check the feature</span></span><br><span class="line">        <span class="comment">// before this happens.</span></span><br><span class="line">        <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//构造DecorView对象并赋值给mDecor，并进行mContentParent的初始化</span></span><br><span class="line">            installDecor();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">            mContentParent.removeAllViews();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">            view.setLayoutParams(params);</span><br><span class="line">            <span class="keyword">final</span> Scene newScene = <span class="keyword">new</span> Scene(mContentParent, view);</span><br><span class="line">            transitionTo(newScene);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//将附带params属性的view对象添加在mContentParent中</span></span><br><span class="line">            mContentParent.addView(view, params);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> Callback cb = getCallback();</span><br><span class="line">        <span class="keyword">if</span> (cb != <span class="keyword">null</span> &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">            cb.onContentChanged();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window</span></span><br><span class="line">        <span class="comment">// decor, when theme attributes and the like are crystalized. Do not check the feature</span></span><br><span class="line">        <span class="comment">// before this happens.</span></span><br><span class="line">        <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            installDecor();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">            mContentParent.removeAllViews();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">            <span class="keyword">final</span> Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</span><br><span class="line">                    getContext());</span><br><span class="line">            transitionTo(newScene);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//将Resource对于的id等于layoutResID的xml布局文件，add到mContentParent中</span></span><br><span class="line">            mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> Callback cb = getCallback();</span><br><span class="line">        <span class="keyword">if</span> (cb != <span class="keyword">null</span> &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">            cb.onContentChanged();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*******部分代码省略********/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>setContentView主要做了两件事：</p>
<blockquote>
<ul>
<li>初始化整个界面（即：DecorView）</li>
<li>将setContentView的参数对于的View，add到mContentParent中。</li>
</ul>
</blockquote>
<h1 id="addView"><a href="#addView" class="headerlink" title="addView"></a>addView</h1><p>setContentView方法有两种在界面添加View的方法。</p>
<ul>
<li>调用mContentParent的add方法，将目标View添加进去。</li>
<li>调用LayoutInfater.inflate方法将资源xml解析并转化为View，添加到mContentParent中。 </li>
</ul>
<h1 id="installDecor"><a href="#installDecor" class="headerlink" title="installDecor"></a>installDecor</h1><p>在看installDecor方法的源代码的时候，我先让大家看一个Android手机界面的布局文件的分析图。</p>
<center><img src="http://upload-images.jianshu.io/upload_images/1319879-7b9e921ef2419900?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Android手机界面的布局"></center>

<center><img src="http://upload-images.jianshu.io/upload_images/1319879-800e67e27b8d6817?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="PhoneWindow"></center>

<p>PhoneWindow.java部分代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> DecorView <span class="title">generateDecor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DecorView(getContext(), -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installDecor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDecor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//构造mDecor对象DecorView</span></span><br><span class="line">        mDecor = generateDecor();</span><br><span class="line">        mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);</span><br><span class="line">        mDecor.setIsRootNamespace(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != <span class="number">0</span>) &#123;</span><br><span class="line">            mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//构造mContentParent</span></span><br><span class="line">        mContentParent = generateLayout(mDecor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set up decor part of UI to ignore fitsSystemWindows if appropriate.</span></span><br><span class="line">        mDecor.makeOptionalFitsSystemWindows();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> DecorContentParent decorContentParent = (DecorContentParent) mDecor.findViewById(</span><br><span class="line">                R.id.decor_content_parent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (decorContentParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//mDecorContentParent赋值R.id.decor_content_parent</span></span><br><span class="line">            mDecorContentParent = decorContentParent;</span><br><span class="line">            mDecorContentParent.setWindowCallback(getCallback());</span><br><span class="line">            <span class="keyword">if</span> (mDecorContentParent.getTitle() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mDecorContentParent.setWindowTitle(mTitle);</span><br><span class="line">            &#125;   </span><br><span class="line">   <span class="comment">/*******部分代码省略********/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>mDecorContentParent为mDecor中的R.id.decor_content_parent</p>
</blockquote>
<p>installDecor先构造mDecor，然后通过mDecor执行generateLayout()方法初始化mContentParent。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ViewGroup <span class="title">generateLayout</span><span class="params">(DecorView decor)</span> </span>&#123;</span><br><span class="line">     <span class="comment">/*******部分代码省略********/</span></span><br><span class="line">    View in = mLayoutInflater.inflate(layoutResource, <span class="keyword">null</span>);</span><br><span class="line">    decor.addView(in, <span class="keyword">new</span> ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">    mContentRoot = (ViewGroup) in;</span><br><span class="line"></span><br><span class="line">    ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);</span><br><span class="line">    <span class="keyword">if</span> (contentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Window couldn't find content container view"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">/*******部分代码省略********/</span></span><br><span class="line">    <span class="keyword">return</span> contentParent; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>mContentRoot为decor的content，经测试(mContentRoot == mDecorContentParent)为true。<br>generateLayout(DecorView decor)方法构造出来的mContentParent为ID_ANDROID_CONTENT，即mDecor中的R.id.content。</p>
</blockquote>
<p>从代码中可以看出显示获取当前窗口的根ViewGroup（mDecor），然后往这个ViewGroup中添加view。</p>
<p>最终我们要展示在Activity中的View已经构造好了，那么在Activity的<code>onResume</code> 方法之后，在 <code>ActivityThread#handleResumeActivity</code> 方法中会将该View通过WindowManager添加在Activity所挂在的Window上进行展现。</p>
<p>mDecor是什么可以参考博客：<a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2013/0322/1054.html" target="_blank" rel="noopener">DecorView浅析</a></p>
<p>好了学习过程到此结束~！<br>下边介绍在我学习过程中膜拜的博客，感觉这些大牛就是点亮我前行的灯塔，哈哈哈。<br><a href="http://blog.csdn.net/xyz_lmn/article/details/20122303" target="_blank" rel="noopener">Android View的加载过程</a><br><a href="http://www.2cto.com/kf/201505/402754.html" target="_blank" rel="noopener">Android应用setContentView与LayoutInflater加载解析机制源码分析</a><br><a href="http://blog.csdn.net/windskier/article/details/6957854" target="_blank" rel="noopener">android的窗口机制分析——UI管理系统</a></p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Window</tag>
        <tag>Decor</tag>
      </tags>
  </entry>
  <entry>
    <title>迟到一年HashMap解读</title>
    <url>/2017/10/27/late-one-year-hashmap/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>HashMap和List这两个类是我们在Java语言编程时使用的频率非常高集合类。“知其然，更要知其所以然”。HashMap认识我已经好多年了，对我在工作中一直也尽心尽力的提供帮助。我从去年开始就想去它家拜访来着，可是经常因为各种各样的原因让其遗忘在路过的风景中。（文章大部分源码基于jdk1.7）。</p>
<center><img src="http://upload-images.jianshu.io/upload_images/1319879-f243ffd6da9f703c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Map&amp;Set"></center>

<h1 id="HashMap概述："><a href="#HashMap概述：" class="headerlink" title="HashMap概述："></a>HashMap概述：</h1><p> HashMap是基于哈希表实现的键值对的集合，继承自AbstractMap并的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。<br>HashMap的特殊存储结构使得在获取指定元素的前需要经过哈希运算，得到目标元素在哈希表中的位置，然后再进行少量的比较即可得到元素，这使得HashMap的查找效率很高。</p>
<h1 id="HashMap的特点"><a href="#HashMap的特点" class="headerlink" title="HashMap的特点"></a>HashMap的特点</h1><ul>
<li>底层实现JDK1.8之前是数组加链表，之后是数组加红黑树。</li>
<li>key是用Set进行存储的，所以不允许重复（可以允许null作为key）。</li>
<li>元素的存储是无序的，每次重新扩容元素位置可能改变。</li>
<li>插入、获取的时间复杂度基本是O(1)（提前试有适当的哈希函数，让元素均匀分布分布）。</li>
<li>两个关键因子：出事容量，加载因子。</li>
</ul>
<h1 id="HashMap的数据结构"><a href="#HashMap的数据结构" class="headerlink" title="HashMap的数据结构"></a>HashMap的数据结构</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;</span><br><span class="line">    <span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> threshold;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ALTERNATIVE_HASHING_THRESHOLD_DEFAULT = Integer.MAX_VALUE;</span><br><span class="line">    <span class="comment">/**********部分代码省略**********/</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Entry&lt;K,V&gt; next;</span><br><span class="line">        <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="comment">/**********部分代码省略**********/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**********部分代码省略**********/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HashMap中主要存储着一个Entry的数组table，Entry就是数组中的元素，Entry实现了Map.Entry所以其实Entry就是一个key-value对，并且它持有一个指向下一个元素的引用，这样构成了链表（在java8中Entry改名为Node，因为在Java8中Entry不仅有链表形式还有树型结构，对应的类为TreeNode）。</p>
<center><img src="http://upload-images.jianshu.io/upload_images/1319879-7966cdd20c44eff4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HashMap的数据结构"></center>

<h1 id="HashMap的构造"><a href="#HashMap的构造" class="headerlink" title="HashMap的构造"></a>HashMap的构造</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment"> * capacity and load factor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment"> *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                            loadFactor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    threshold = initialCapacity;</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Math.max((<span class="keyword">int</span>) (m.size() / DEFAULT_LOAD_FACTOR) + <span class="number">1</span>,</span><br><span class="line">                    DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);</span><br><span class="line">    inflateTable(threshold);</span><br><span class="line"></span><br><span class="line">    putAllForCreate(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要有两个参数，【initialCapacity】初始容量、【loadFactor】加载因子。这两个属性在类定义时候都赋有默认值分别为16和0.75。table数组默认值为EMPTY_TABLE，在添加元素的时候判断table是否为EMPTY_TABLE来调用【inflateTable】。在构造HashMap实例的时候默认【threshold】阈值等于初始容量。当构造方法的参数为Map时，调用 【inflateTable(threshold)】方法对table数组容量进行设置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inflates the table.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Find a power of 2 &gt;= toSize</span></span><br><span class="line">    <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);</span><br><span class="line">    <span class="comment">//更新阈值</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">    initHashSeedAsNeeded(capacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回一个比初始容量大的最小的2的幂数,如果number为2的整数幂值那么直接返回，最小为1，最大为2^31。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">roundUpToPowerOf2</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert number &gt;= 0 : "number must be non-negative";</span></span><br><span class="line">    <span class="keyword">return</span> number &gt;= MAXIMUM_CAPACITY</span><br><span class="line">            ? MAXIMUM_CAPACITY</span><br><span class="line">            : (number &gt; <span class="number">1</span>) ? Integer.highestOneBit((number - <span class="number">1</span>) &lt;&lt; <span class="number">1</span>) : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="highestOneBit"><a href="#highestOneBit" class="headerlink" title="highestOneBit"></a>highestOneBit</h2><p>返回一个不大于i的2的整数次幂<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">highestOneBit</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// HD, Figure 3-1</span></span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">1</span>);<span class="comment">//i的二进制右边2位为1 。</span></span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">2</span>);<span class="comment">//i的二进制右边4位为1。</span></span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">4</span>);<span class="comment">//i的二进制右边8位为1。</span></span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">8</span>);<span class="comment">//i的二进制右边16位为1。</span></span><br><span class="line">    i |= (i &gt;&gt; <span class="number">16</span>);<span class="comment">//i的二进制右边32位为1。</span></span><br><span class="line">    <span class="comment">//这样5次移位后再进行与操作，i的所有非0低位全部变成1；</span></span><br><span class="line">    <span class="keyword">return</span> i - (i &gt;&gt;&gt; <span class="number">1</span>);<span class="comment">//i减去所有底位的1，只留一个高为的1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为什么桶的容量要是2的指数，后面会讲到这样有助于添加元素时减少哈希冲突。</p>
<h1 id="HashMap的存取实现"><a href="#HashMap的存取实现" class="headerlink" title="HashMap的存取实现"></a>HashMap的存取实现</h1><h2 id="HashMap的put方法"><a href="#HashMap的put方法" class="headerlink" title="HashMap的put方法"></a>HashMap的put方法</h2><blockquote>
<ul>
<li>获取key的hashcode</li>
<li>二次hash</li>
<li>通过hash找到对应的index</li>
<li>插入链表</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HashMap添加元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//table没有初始化size=0，先调用inflateTable对table容器进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在hashMap增加key=null的键值对</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="comment">//计算key的哈希值</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">//计算在table数据中的bucketIndex</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">//遍历table[i]的链表，如果节点不为null，通过循环遍历链表的下一个元素</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="comment">//找到对应的key，则将value进行替换</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没有找到对应的key的Entry，则需要对数据进行modify,modCount加一</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//将改key，value添加入table中</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加Entry</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当前桶的长度大于于阈值，而且当前桶的索引位置不为null。则需要对桶进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        <span class="comment">//对桶进行扩容</span></span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        <span class="comment">//重新计算hash值</span></span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//重新计算当前需要插入的桶的位置</span></span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在bucketIndex位置创建Entry</span></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建Entry</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//找到当前桶的当前链表的头节点</span></span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    <span class="comment">//新创建一个Entry将其插入在桶的bucketIndex位置的链表的头部</span></span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="获取key的hashcode并进行二次hash"><a href="#获取key的hashcode并进行二次hash" class="headerlink" title="获取key的hashcode并进行二次hash"></a>获取key的hashcode并进行二次hash</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么这么进行二次hash，目的是唯一的就是让产生的hashcode散列均匀。在网络上也找了一些关于hash值获取的介绍，下边是我找到感觉比较靠谱的一篇文章中关于hash算法的解析：</p>
<p>假设h^key.hashCode()的值为：0x7FFFFFFF，table.length为默认值16。<br>上面算法执行</p>
<center><img src="http://upload-images.jianshu.io/upload_images/1319879-e14ca1e958bf33cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="image.png"></center>

<p>得到i=15<br>其中h\^(h&gt;&gt;&gt;7)^(h&gt;&gt;&gt;4) 结果中的位运行标识是把h&gt;&gt;&gt;7 换成 h&gt;&gt;&gt;8来看。<br>即最后h\^(h&gt;&gt;&gt;8)^(h&gt;&gt;&gt;4) 运算后hashCode值每位数值如下： </p>
<blockquote>
<p>8=8<br>7=7^8<br>6=6^7^8<br>5=5^8^7^6<br>4=4^7^6^5^8<br>3=3^8^6^5^8^4^7 ————&gt;   3^4^5^6^7<br>2=2^7^5^4^7^3^8^6 ———&gt;   2^3^4^5^6^8<br>1=1^6^4^3^8^6^2^7^5  ——&gt;   1^2^3^4^5^7^8<br>算法中是采用(h&gt;&gt;&gt;7)而不是(h&gt;&gt;&gt;8)的算法，应该是考虑1、2、3三位出现重复位^运算的情况。使得最低位上原hashCode的8位都参与了\^运算，所以在table.length为默认值16的情况下面，hashCode任意位的变化基本都能反应到最终hash table 定位算法中，这种情况下只有原hashCode第3位高1位变化不会反应到结果中，即：0x7FFFF7FF的i=15。 </p>
</blockquote>
<p>从整个二次hash的解析过程来看，通过多次位移和多次与操作获取的hashc。每当key的hashcode有任何变化的时候都能影响到二次hash后的底位的不同，这样在下边根据hash获取在桶上的索引的时候最大减少哈希冲突。</p>
<h2 id="获取hash在桶上的索引"><a href="#获取hash在桶上的索引" class="headerlink" title="获取hash在桶上的索引"></a>获取hash在桶上的索引</h2><blockquote>
<p>当我们想找一个hash函数想让均匀分布在桶中时，我们首先想到的就是把hashcode对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，“模”运算的消耗还是比较大。而JDK中的实现hash根数组的长度-1做一次“&amp;”操作。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//找到当前的hash在桶的分布节点位置</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2";</span></span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要讲一下为什么index=h&amp;(length-1)呢？因为HashMap中的数组长度为2的指数。（lenth-1）的值恰好是数组能容纳的最大容量，且在二进制下每位都是1。所以在经过二次hash之后所获取的code，就能通过一次与操作（取hash值的底位）让其分布在table桶中。</p>
<h2 id="HashMap的get方法"><a href="#HashMap的get方法" class="headerlink" title="HashMap的get方法"></a>HashMap的get方法</h2><blockquote>
<p>在理解了put之后，get就很简单了。大致思路如下：<br>bucket里的第一个节点，直接命中；</p>
<ul>
<li>如果有冲突，则通过key.equals(k)去查找对应的entry</li>
<li>若为树，则在树中通过key.equals(k)查找，O(logn)；</li>
<li>若为链表，则在链表中通过key.equals(k)查找，O(n)。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HashMap的get方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取key为null的value</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getForNullKey();</span><br><span class="line">    <span class="comment">//获取key对应的Entry实例</span></span><br><span class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取Entry</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算key的hash值</span></span><br><span class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="comment">//根据hash调用indexFor方法找到当前key对应的桶的index，遍历该节点对应的链表</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="comment">//判断当前Entry的hash、key的hash和Entry的key、key是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="HashMap的扩容"><a href="#HashMap的扩容" class="headerlink" title="HashMap的扩容"></a>HashMap的扩容</h1><blockquote>
<p>当HashMap中的元素越来越多的时候，因为数组的长度是固定的所以hash冲突的几率也就越来越高，桶的节点处的链表就越来越长，这个时候查找元素的时间复杂度相应的增加。为了提高查询的效率，就要对HashMap的数组进行扩容（这是一个常用的操作，数组扩容这个操作也会出现在ArrayList中。），而在HashMap数组扩容之后，最消耗性能的地方就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。</p>
</blockquote>
<blockquote>
<p>当HashMap中的元素个数超过阈值时，就会进行数组扩容，【loadFactor】加载因子的默认值为0.75，【threshold】阈值等于桶长乘以loadFactor这是一个折中的取值。也就是说，默认情况下，数组大小为16，那么当HashMap中元素个数超过16<em>0.75=12的时候，就把数组的大小扩展为 2</em>16=32，即扩大一倍，然后重新计算每个元素在数组中的位置。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HashMap扩容</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//引用备份</span></span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="comment">//原来桶的长度</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="comment">//判断是否已经扩容到极限</span></span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据容器大小创新的建桶</span></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">    <span class="comment">//重置桶的引用</span></span><br><span class="line">    table = newTable;</span><br><span class="line">    <span class="comment">//重新计算阈值</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用于初始化hashSeed参数.</span></span><br><span class="line"><span class="comment">//其中hashSeed用于计算key的hash值，它与key的hashCode进行按位异或运算。</span></span><br><span class="line"><span class="comment">//这个hashSeed是一个与实例相关的随机值，主要用于解决hash冲突。</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">initHashSeedAsNeeded</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> currentAltHashing = hashSeed != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> useAltHashing = sun.misc.VM.isBooted() &amp;&amp;</span><br><span class="line">            (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">    <span class="keyword">boolean</span> switching = currentAltHashing ^ useAltHashing;</span><br><span class="line">    <span class="keyword">if</span> (switching) &#123;</span><br><span class="line">        hashSeed = useAltHashing</span><br><span class="line">            ? sun.misc.Hashing.randomHashSeed(<span class="keyword">this</span>)</span><br><span class="line">            : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> switching;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//桶中数据的迁移</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//新的痛长</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="comment">//遍历桶的没一个节点的链表</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="comment">//重新计算哈希值</span></span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到当前Entry在新桶中的位置</span></span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            <span class="comment">//将Entry添加在当桶中的bucketIndex处的链表的头部</span></span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            <span class="comment">//将产生的新链表赋值为桶的bucketIndex处</span></span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            <span class="comment">//遍历当前链表的下一个节点</span></span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>假设hash算法就是最简单的 key mod table.length（也就是数组的长度）。</li>
<li>最上面的是old hash 表，其中的Hash表的 size = 2, 所以 key = 3, 7, 5，在mod 2以后碰撞发生在 table[1]</li>
<li>接下来的三个步骤是 Hash表 resize 到4，并将所有的 &lt;key,value&gt; 重新resize到新Hash表的过程</li>
</ul>
</blockquote>
<center><img src="http://upload-images.jianshu.io/upload_images/1319879-4303ce1a45ea22a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="resize"></center>

<blockquote>
<p>在HashMap进行扩容的时候有一个点大家发现没，所有Entry的hash值是不需要重新计算的。因为hash值与（length - 1）取的总是hash值的二进制右边底位，扩容一次向左多取一位二进制。</p>
</blockquote>
<h1 id="有关HashMap的思考"><a href="#有关HashMap的思考" class="headerlink" title="有关HashMap的思考"></a>有关HashMap的思考</h1><blockquote>
<ul>
<li>什么时候会使用HashMap？他有什么特点？</li>
</ul>
</blockquote>
<p>是基于Map接口的实现，存储键值对时，它可以接收null的键值，是非同步的，HashMap存储着Entry(hash, key, value, next)对象。</p>
<blockquote>
<ul>
<li>你知道HashMap的工作原理吗？</li>
</ul>
</blockquote>
<p>通过hash的方法，通过put和get存储和获取对象。存储对象时，我们将K/V传给put方法时，它调用hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。</p>
<blockquote>
<ul>
<li>你知道get和put的原理吗？equals()和hashCode()的都有什么作用？</li>
</ul>
</blockquote>
<p>通过对key的hashCode()进行hashing，并计算下标( n-1 &amp; hash)，从而获得buckets的位置。如果产生碰撞，则利用key.equals()方法去链表或树中去查找对应的节点</p>
<blockquote>
<ul>
<li>你知道hash的实现吗？为什么要这样实现？</li>
</ul>
</blockquote>
<p>在通过hashCode()的高位与底位进行异或，主要是从速度、功效、质量来考虑的，这么做可以在bucket的n比较小的时候，也能保证考虑到高低bit都参与到hash的计算中，同时不会有太大的开销。</p>
<blockquote>
<ul>
<li>如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</li>
</ul>
</blockquote>
<p>如果超过了负载因子(默认0.75)，则会重新resize一个原来长度两倍的HashMap，并且重新调用hash方法。</p>
<h1 id="JDK1-8对HashMap的改进"><a href="#JDK1-8对HashMap的改进" class="headerlink" title="JDK1.8对HashMap的改进"></a>JDK1.8对HashMap的改进</h1><h2 id="代码实现的不同之处"><a href="#代码实现的不同之处" class="headerlink" title="代码实现的不同之处"></a>代码实现的不同之处</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//链表切换为红黑树的阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//红黑树切花为链表的阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="comment">//红黑树上的节点个数满足时对整个桶进行扩容</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"><span class="comment">//红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line">    <span class="comment">/*************部分代码省略*****************/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取key的hashCode,并进行二次hash。二次hash只是将hashcode的高16位于第16位进行异或</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//resize时hash冲突使用的是红黑树</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">/*************部分代码省略*****************/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="性能的提升"><a href="#性能的提升" class="headerlink" title="性能的提升"></a>性能的提升</h2><blockquote>
<p>哈希碰撞会对hashMap的性能带来灾难性的影响。如果多个hashCode()的值落到同一个桶内的时候，这些值是存储到一个链表中的。最坏的情况下，所有的key都映射到同一个桶中，这样hashmap就退化成了一个链表——查找时间从O(1)到O(n)，而使用红黑树代替链表查找时间会变为O(logn)。</p>
</blockquote>
<p>参考文章：<br><a href="http://www.iteye.com/topic/709945" target="_blank" rel="noopener">主题：HashMap hash方法分析</a></p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <tags>
        <tag>HashMap</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客yelee主题添加Gitment评论系统</title>
    <url>/2017/10/26/hexo-yelee-comment-gitment/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>自从六月份多说评论关闭后，接着好不容易迁到网易云跟帖。8月1日网易云跟帖发布公告宣布停止服务。看到wordpress博客大部分接的是畅言，可惜畅言需要网址备案，没有买阿里云服务器域名不给备案。今天突然看到了gitment（PS:gitment是imsun利用github上的issues做的评论系统），相见恨晚啊。然后自己立即着手开始自己的博客评论系统迁移，一个小时不到就搞定了^_^，成功的方法和喜悦给大家分享一下。</p>
<h2 id="注册OAuth-Application"><a href="#注册OAuth-Application" class="headerlink" title="注册OAuth Application"></a>注册OAuth Application</h2><p><a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">OAuth Application注册</a></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/036365a9ad16f8fe669a1f99d79f8edc.png#pic_center" alt="Register"></p>
<blockquote>
<p>注意callback URL需要填自己的博客地址，eg:<a href="http://dandanlove.com/" target="_blank" rel="noopener">http://dandanlove.com/</a></p>
</blockquote>
<p>创建成功后，你会得到一个 client ID 和一个 client secret，这个将被用于之后的用户登录</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/001a10da2e545f825ce5ec4762b81efe.png#pic_center" alt="密钥"></p>
<h2 id="在yelee主题中引入Gitment"><a href="#在yelee主题中引入Gitment" class="headerlink" title="在yelee主题中引入Gitment"></a>在yelee主题中引入Gitment</h2><p>在themes/yelee/layout/_partial/post文件夹下创建git.ejs文件，并写入下边代码：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Gitment评论插件通用代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"git"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://imsun.github.io/gitment/style/default.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://imsun.github.io/gitment/dist/gitment.browser.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">var gitment = new Gitment(&#123;</span></span><br><span class="line"><span class="undefined">  owner: "stven0king",//github用户名</span></span><br><span class="line"><span class="undefined">  repo: "stven0king.github.io",//用户存储评论的github项目名称</span></span><br><span class="line"><span class="undefined">  oauth: &#123;</span></span><br><span class="line"><span class="undefined">    client_id: "xxxxxxxxxxxxxxxxxxxxxxxx",//注册OAuth Application时生产的ClinetID</span></span><br><span class="line"><span class="undefined">    client_secret:"xxxxxxxxxxxxxxxxxxxxx",//注册OAuth Application时生成的Client Secret</span></span><br><span class="line"><span class="undefined">  &#125;,</span></span><br><span class="line"><span class="undefined">&#125;)</span></span><br><span class="line"><span class="undefined">gitment.render('git')</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Gitment代码结束 --&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>接着在<code>themes/yelee/layout/_partial/article.ejs</code>文件中找到</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span> (!<span class="attr">index</span> &amp;&amp; <span class="attr">post.comments</span>)&#123; %&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span> (<span class="attr">theme.duoshuo.on</span>) &#123; %&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">%-</span> <span class="attr">partial</span>('<span class="attr">comments</span>/<span class="attr">duoshuo</span>', &#123;</span></span><br><span class="line"><span class="tag">          <span class="attr">key:</span> <span class="attr">post.path</span>,</span></span><br><span class="line"><span class="tag">          <span class="attr">title:</span> <span class="attr">post.title</span>,</span></span><br><span class="line"><span class="tag">          <span class="attr">url:</span> <span class="attr">config.url</span>+<span class="attr">url_for</span>(<span class="attr">post.path</span>),</span></span><br><span class="line"><span class="tag">          &#125;) %&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%</span> &#125; <span class="attr">else</span> <span class="attr">if</span> (<span class="attr">theme.youyan.on</span>) &#123; %&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">%-</span> <span class="attr">partial</span>('<span class="attr">comments</span>/<span class="attr">youyan</span>') %&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%</span> &#125; <span class="attr">else</span> <span class="attr">if</span> (<span class="attr">theme.disqus.on</span>) &#123; %&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">%-</span> <span class="attr">partial</span>('<span class="attr">comments</span>/<span class="attr">disqus</span>', &#123;</span></span><br><span class="line"><span class="tag">            <span class="attr">shortname:</span> <span class="attr">theme.disqus.shortname</span></span></span><br><span class="line"><span class="tag">          &#125;) %&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%</span> &#125; <span class="attr">else</span> <span class="attr">if</span> (<span class="attr">config.disqus_shortname</span>) &#123; %&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">%-</span> <span class="attr">partial</span>('<span class="attr">comments</span>/<span class="attr">disqus</span>', &#123;</span></span><br><span class="line"><span class="tag">            <span class="attr">shortname:</span> <span class="attr">config.disqus_shortname</span></span></span><br><span class="line"><span class="tag">          &#125;) %&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br></pre></td></tr></table></figure>
<p>在这个节点下添加：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span> (!<span class="attr">index</span>)&#123; %&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span> (<span class="attr">post.comments</span>)&#123; %&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">%-</span> <span class="attr">partial</span>('<span class="attr">post</span>/<span class="attr">git</span>') %&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">%</span> &#125; <span class="attr">else</span> &#123; %&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"git"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>以上所有操作完成后，文章底部就可以展现评论视图了。</p>
<h2 id="初始化评论"><a href="#初始化评论" class="headerlink" title="初始化评论"></a>初始化评论</h2><p>最开始我们看到的是：Error:Comments Not Initialized</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/2bba97b35081ebe3e6d542aa9007b8e7.png#pic_center" alt="Error:Comments Not Initialized"></p>
<p>出现Error之后我们不要惊慌，点击评论部分的Login。在GitHub进行授权后页面会刷新成：Initialize Comments</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/dfd1b365dd112217092e8583f846ce75.png#pic_center" alt="Initialize Comments"></p>
<p>接着点击【Initialize Comments】按钮进行初始化就可以评论了。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/2b914cbc9665df9094c5e74240c8cf3d.png#pic_center" alt="issues"></p>
<p>没初始化一片文章都会在repo所在的github项目的issues中看到。</p>
<p>参考文章：<br><a href="http://blog.csdn.net/anttu/article/details/77688004" target="_blank" rel="noopener">Gitment</a></p>
<p><a href="https://github.com/imsun" target="_blank" rel="noopener">gitment github项目地址</a></p>
<p><a href="https://github.com/imsun/gitment/issues" target="_blank" rel="noopener">gitment 错误处理</a></p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>搞事情</category>
      </categories>
      <tags>
        <tag>gitment</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树知识点回忆以及整理</title>
    <url>/2017/10/20/about-binary-tree/</url>
    <content><![CDATA[<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>在计算机科学中，二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”和“右子树”，左子树和右子树同时也是二叉树。二叉树的子树有左右之分，并且次序不能任意颠倒。</p>
<h1 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h1><p>二叉排序树，又称二叉查找树、二叉搜索树、B树。</p>
<blockquote>
<p>二叉排序树是具有下列性质的二叉树：</p>
<ul>
<li>若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；</li>
<li>左、右子树也分别为二叉排序树。</li>
</ul>
</blockquote>
<p><center><img src="http://upload-images.jianshu.io/upload_images/1319879-a308ad01f82b52bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="二叉排序树"></center></p>
<p>也就是说，二叉排序树中，左子树都比节点小，右子树都比节点大，递归定义。</p>
<p>根据二叉排序树这个特点我们可以知道，二叉排序树的中序遍历一定是从小到大的，比如上图，中序遍历结果是：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1  3  4  6  7  8  13  14  19</span><br></pre></td></tr></table></figure></p>
<h1 id="二叉树节点定义"><a href="#二叉树节点定义" class="headerlink" title="二叉树节点定义"></a>二叉树节点定义</h1><p>采用单项链表的形式，只从根节点指向孩子节点，子节点不保存父节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  二叉树节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeNode</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T value;</span><br><span class="line">    BinaryTreeNode leftNode;</span><br><span class="line">    BinaryTreeNode rightNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="创建二叉树"><a href="#创建二叉树" class="headerlink" title="创建二叉树"></a>创建二叉树</h1><p>二叉树中左右节点值本身没有大小之分，所以如果要创建二叉树，就需要考虑如何处理某个节点是左节点还是右节点，如何终止某个子树而切换到另一个子树。 因此我选择了二叉排序树，二叉排序树中对于左右节点有明确的要求，程序可以自动根据键值大小自动选择是左节点还是右节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建二叉树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BinaryTreeNode&lt;Integer&gt; <span class="title">createTreeWithValues</span><span class="params">(<span class="keyword">int</span>[] values)</span> </span>&#123;</span><br><span class="line">    BinaryTreeNode root = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> value: values) &#123;</span><br><span class="line">        root = addTreeNode(root, value);<span class="comment">//添加每一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在treeNode中添加值为value的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BinaryTreeNode&lt;Integer&gt; <span class="title">addTreeNode</span><span class="params">(BinaryTreeNode&lt;Integer&gt; treeNode, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (treeNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        treeNode = <span class="keyword">new</span> BinaryTreeNode&lt;&gt;();<span class="comment">//创建节点</span></span><br><span class="line">        treeNode.value = value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value &lt;= treeNode.value) &#123;<span class="comment">//对比左右节点</span></span><br><span class="line">            treeNode.leftNode = addTreeNode(treeNode.leftNode, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            treeNode.rightNode = addTreeNode(treeNode.rightNode, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> treeNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><blockquote>
<p>根据二叉排序树的定义，我们可以知道在查找某个元素时：</p>
<ul>
<li>先比较它与根节点，相等就返回；或者根节点为空，说明树为空，也返回；</li>
<li>如果它比根节点小，就从根的左子树里进行递归查找；</li>
<li>如果它比根节点大，就从根的右子树里进行递归查找。</li>
</ul>
</blockquote>
<p>这就是一个简单的二分查找。只不过和二分查找还是有些不同的地方的。</p>
<blockquote>
<p>二叉树的性能取决于二叉树的层数：</p>
<ul>
<li>最好的情况是O(logn),存在于完全二叉树情况下，其访问性能近似于折半查找； </li>
<li>最差的情况是O(n),比如插入的元素所有节点都没有左子树（右子树），这种情况需要将二叉树的全部节点遍历一次。</li>
</ul>
</blockquote>
<p><center><img src="http://upload-images.jianshu.io/upload_images/1319879-c827f0b86f51797e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt="二叉排序树"></center></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中根遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrderTraverseTree</span><span class="params">(BinaryTreeNode&lt;Integer&gt; rootNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rootNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//左中右，中根遍历</span></span><br><span class="line">        inOrderTraverseTree(rootNode.leftNode);</span><br><span class="line">        <span class="comment">//中左右，先根遍历</span></span><br><span class="line">        System.out.println(<span class="string">" "</span> + rootNode.value + <span class="string">" "</span>);</span><br><span class="line">        <span class="comment">//左右中，后根遍历</span></span><br><span class="line">        inOrderTraverseTree(rootNode.rightNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一断中根遍历的代码，先根遍历和后根遍历只是调整上面几行代码的顺序而已。</p>
<h1 id="二叉树节点删除"><a href="#二叉树节点删除" class="headerlink" title="二叉树节点删除"></a>二叉树节点删除</h1><blockquote>
<p>插入操作和查找比较类似，而删除则相对复杂一点，需要根据删除节点的情况分类来对待：</p>
<ul>
<li>如果要删除的节点正好是叶子节点，直接删除就 Ok 了；</li>
<li>如果要删除的节点还有子节点，就需要建立父节点和子节点的关系： <blockquote>
<ul>
<li>如果只有左孩子或者右孩子，直接把这个孩子上移放到要删除的位置就好了；</li>
<li>如果有两个孩子，就需要选一个合适的孩子节点作为新的根节点，该节点称为 继承节点。（新节点要求比所有左子树要大、比右子树要小，我们可以选择左子树中的最大节点，或者选择右子树中的最小的节点。）</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树查找</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BinaryTreeNode&lt;Integer&gt; <span class="title">search</span><span class="params">(BinaryTreeNode&lt;Integer&gt; rootNode, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rootNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rootNode.value == value)&#123;</span><br><span class="line">            <span class="keyword">return</span> rootNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (value &gt; rootNode.value) &#123;</span><br><span class="line">            <span class="keyword">return</span> search(rootNode.rightNode, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> search(rootNode.leftNode, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rootNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 寻找value节点的父节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BinaryTreeNode&lt;Integer&gt; <span class="title">searchParent</span><span class="params">(BinaryTreeNode&lt;Integer&gt; rootNode, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果当前节点为null，或者当前节点为根节点。返回null</span></span><br><span class="line">    <span class="keyword">if</span> (rootNode == <span class="keyword">null</span> || rootNode.value == value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//当前节点的左儿子或者右儿子等于value，则返回当前节点。</span></span><br><span class="line">        <span class="keyword">if</span> (rootNode.leftNode != <span class="keyword">null</span> &amp;&amp; value == (Integer)rootNode.leftNode.value ||</span><br><span class="line">            rootNode.rightNode != <span class="keyword">null</span> &amp;&amp; value == (Integer)rootNode.rightNode.value) &#123;</span><br><span class="line">                <span class="keyword">return</span> rootNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断需要寻找的节点的位置，</span></span><br><span class="line">        <span class="keyword">if</span> (value &gt; rootNode.value &amp;&amp; rootNode.rightNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> searchParent(rootNode.rightNode, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> searchParent(rootNode.leftNode, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除rootNode为根节点的二叉树中值为value的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BinaryTreeNode&lt;Integer&gt; <span class="title">delete</span><span class="params">(BinaryTreeNode&lt;Integer&gt; rootNode, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断是否删除的节点为根节点</span></span><br><span class="line">    <span class="keyword">if</span> (rootNode == <span class="keyword">null</span> &amp;&amp; rootNode.value == value) &#123;</span><br><span class="line">        rootNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> rootNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找到删除的节点的父节点</span></span><br><span class="line">    BinaryTreeNode&lt;Integer&gt; parentNode = searchParent(rootNode, value);</span><br><span class="line">    <span class="comment">//找不到父节点，表示该二叉树没有对应的节点</span></span><br><span class="line">    <span class="keyword">if</span> (parentNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> rootNode;</span><br><span class="line">    &#125;</span><br><span class="line">    BinaryTreeNode&lt;Integer&gt; deleteNode = search(rootNode, value);</span><br><span class="line">    <span class="comment">//找不到该节点</span></span><br><span class="line">    <span class="keyword">if</span> (deleteNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> rootNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//需要删除的节点，为叶子节点</span></span><br><span class="line">    <span class="keyword">if</span> (deleteNode.leftNode == <span class="keyword">null</span> &amp;&amp; deleteNode.rightNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        deleteNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (parentNode.leftNode != <span class="keyword">null</span> &amp;&amp; value == (Integer)parentNode.leftNode.value) &#123;</span><br><span class="line">            parentNode.leftNode = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parentNode.rightNode = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//需要删除的节点，只有左子树，左子树继承该删除的位置</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (deleteNode.rightNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parentNode.leftNode != <span class="keyword">null</span> &amp;&amp; value == (Integer)parentNode.leftNode.value) &#123;</span><br><span class="line">            parentNode.leftNode = deleteNode.leftNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parentNode.rightNode = deleteNode.leftNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//需要删除的节点，只有右子树，右子树继承该删除的位置</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (deleteNode.leftNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parentNode.leftNode != <span class="keyword">null</span> &amp;&amp; value == (Integer)parentNode.leftNode.value) &#123;</span><br><span class="line">            parentNode.leftNode = deleteNode.rightNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parentNode.rightNode = deleteNode.rightNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//要删除的节点既有左海子，又有右孩子。需要选择一个设施的节点继承，我们选择左子树中的最右节点</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        BinaryTreeNode&lt;Integer&gt; tmpDeleteNode = deleteNode;</span><br><span class="line">        BinaryTreeNode&lt;Integer&gt; selectNode = tmpDeleteNode.leftNode;</span><br><span class="line">        <span class="keyword">if</span> (selectNode.rightNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">            selectNode.rightNode = deleteNode.rightNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//找到deleteNode的左子树中的最右节点，即最大节点</span></span><br><span class="line">            <span class="keyword">while</span> (selectNode.rightNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                tmpDeleteNode = selectNode;</span><br><span class="line">                selectNode = selectNode.rightNode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将选出的继承节点的左子树赋值给父节点的右子树</span></span><br><span class="line">            tmpDeleteNode.rightNode = selectNode.leftNode;</span><br><span class="line">            <span class="comment">//继承节点继承需要删除的左右子树</span></span><br><span class="line">            selectNode.leftNode = deleteNode.leftNode;</span><br><span class="line">            selectNode.rightNode = deleteNode.rightNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将选出的继承节点进行继承（删除对应节点）</span></span><br><span class="line">        <span class="keyword">if</span> (parentNode.leftNode != <span class="keyword">null</span> &amp;&amp; value == (Integer)parentNode.leftNode.value) &#123;</span><br><span class="line">            parentNode.leftNode = selectNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parentNode.rightNode = selectNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rootNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">8</span>,<span class="number">3</span>,<span class="number">19</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">14</span>,<span class="number">4</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    <span class="comment">//创建二叉树</span></span><br><span class="line">    BinaryTreeNode root = createTreeWithValues(array);</span><br><span class="line">    <span class="comment">//中根遍历</span></span><br><span class="line">    inOrderTraverseTree(root);</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">//插入13</span></span><br><span class="line">    addTreeNode(root, <span class="number">13</span>);</span><br><span class="line">    <span class="comment">//中根遍历</span></span><br><span class="line">    inOrderTraverseTree(root);</span><br><span class="line">    <span class="comment">//删除value=3的节点</span></span><br><span class="line">    delete(root, <span class="number">3</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">//中跟遍历结果</span></span><br><span class="line">    inOrderTraverseTree(root);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">14</span>  <span class="number">19</span> </span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">13</span>  <span class="number">14</span>  <span class="number">19</span> </span><br><span class="line"> <span class="number">1</span>  <span class="number">4</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">13</span>  <span class="number">14</span>  <span class="number">19</span> </span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h1 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h1><blockquote>
<p>二叉树深度定义：从根节点到叶子节点依次进过的节点形成树的一条路径，最长路径的长度为树的深度。</p>
<ul>
<li>如果根节点为空，则深度为0； </li>
<li>如果左右节点都为空，则深度为1；</li>
<li>递归思想：二叉树的深度=max(左子树的深度，右子树的深度) + 1；</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树的深度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">depthOfTree</span><span class="params">(BinaryTreeNode&lt;Integer&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.leftNode == <span class="keyword">null</span> &amp;&amp; root.rightNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> leftDepth = depthOfTree(root.leftNode);</span><br><span class="line">    <span class="keyword">int</span> rightDepth = depthOfTree(root.rightNode);</span><br><span class="line">    <span class="keyword">return</span> Math.max(leftDepth, rightDepth) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树的宽度"><a href="#二叉树的宽度" class="headerlink" title="二叉树的宽度"></a>二叉树的宽度</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树的宽度：各层节点数的最大值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 二叉树的根节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 二叉树的宽度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">widthOfTree</span><span class="params">(BinaryTreeNode&lt;Integer&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当前二叉树最大宽度=根节点</span></span><br><span class="line">    <span class="keyword">int</span> maxWith = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> currentWidth = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//队列：先进先出，每次循环后保留一层树的某一层的所有节点</span></span><br><span class="line">    Queue&lt;BinaryTreeNode&lt;Integer&gt;&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    list.add(root);</span><br><span class="line">    <span class="keyword">while</span> (list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        currentWidth = list.size();</span><br><span class="line">        <span class="comment">//遍历当前层的所有节点，并将所有节点的子节点加入到队列中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; currentWidth; i++) &#123;</span><br><span class="line">            BinaryTreeNode&lt;Integer&gt; node = list.peek();</span><br><span class="line">            list.poll();</span><br><span class="line">            <span class="keyword">if</span> (node.leftNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                list.add(node.leftNode);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.rightNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                list.add(node.rightNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maxWith = Math.max(maxWith, list.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxWith;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树某层中的节点数"><a href="#二叉树某层中的节点数" class="headerlink" title="二叉树某层中的节点数"></a>二叉树某层中的节点数</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树某层中的节点数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rootNode 二叉树根节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> level 层</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> level层的节点数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numberOfNodesOnLevel</span><span class="params">(BinaryTreeNode&lt;Integer&gt; rootNode, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//二叉树不存在，或者level不存在的时候节点数为0</span></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (rootNode == <span class="keyword">null</span> || level &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//level=1，为根节点，节点数为1</span></span><br><span class="line">    <span class="keyword">if</span> (level == <span class="number">1</span>) &#123;</span><br><span class="line">        result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归：node为根节点的二叉树的level层节点数 = </span></span><br><span class="line">    <span class="comment">// node节点左子树（level - 1）层的节点数 + node节点的右子树（level - 1）层的节点数</span></span><br><span class="line">    <span class="keyword">return</span> numberOfNodesOnLevel(rootNode.leftNode, level - <span class="number">1</span>) +</span><br><span class="line">            numberOfNodesOnLevel(rootNode.rightNode, level - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树的叶子节点个数"><a href="#二叉树的叶子节点个数" class="headerlink" title="二叉树的叶子节点个数"></a>二叉树的叶子节点个数</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树的叶子节点个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rootNode</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 叶子节点个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numberOfLeafsInTree</span><span class="params">(BinaryTreeNode&lt;Integer&gt; rootNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (rootNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//rootNode没有子节点，所以根节点为叶节点result=1;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == rootNode.leftNode &amp;&amp; <span class="keyword">null</span> == rootNode.rightNode) &#123;</span><br><span class="line">        result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归：root的叶节点 = node的左子树的叶节点 + node的右子树的叶节点</span></span><br><span class="line">    <span class="keyword">return</span> numberOfLeafsInTree(rootNode.leftNode) + numberOfLeafsInTree(rootNode.rightNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树的最大距离（二叉树的直径）"><a href="#二叉树的最大距离（二叉树的直径）" class="headerlink" title="二叉树的最大距离（二叉树的直径）"></a>二叉树的最大距离（二叉树的直径）</h1><blockquote>
<p>二叉树中任意两个节点都有且仅有一条路径，这个路径的长度叫这两个节点的距离。二叉树中所有节点之间的距离的最大值就是二叉树的直径。<br>有一种解法，把这个最大距离划分了3种情况：</p>
<ul>
<li>这2个节点分别在根节点的左子树和右子树上，他们之间的路径肯定经过根节点，而且他们肯定是根节点左右子树上最远的叶子节点（他们到根节点的距离=左右子树的深度）。</li>
<li>这2个节点都在左子树上</li>
<li>这2个节点都在右子树上<br>综上，只要取这3种情况中的最大值，就是二叉树的直径。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">**</span><br><span class="line"> * 二叉树的最大距离（直径）</span><br><span class="line"> * <span class="meta">@param</span> rootNode 根节点</span><br><span class="line"> * <span class="meta">@return</span> 最大距离</span><br><span class="line"> */</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxDistanceOfTree</span><span class="params">(BinaryTreeNode&lt;Integer&gt; rootNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rootNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1、最远距离经过根节点：距离 = 左子树深度 + 右子树深度</span></span><br><span class="line">    <span class="keyword">int</span> distance = depthOfTree(rootNode.leftNode) + depthOfTree(rootNode.rightNode);</span><br><span class="line">    <span class="comment">//2、最远距离在根节点左子树上，即计算左子树最远距离</span></span><br><span class="line">    <span class="keyword">int</span> disLeft = maxDistanceOfTree(rootNode.leftNode);</span><br><span class="line">    <span class="comment">//3、最远距离在根节点右子树上，即计算右子树最远距离</span></span><br><span class="line">    <span class="keyword">int</span> disRight = maxDistanceOfTree(rootNode.rightNode);</span><br><span class="line">    <span class="keyword">return</span> Math.max(distance, Math.max(disLeft, disRight));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方案效率较低，因为计算子树的深度和最远距离是分开递归的，存在重复递归遍历的情况。其实一次递归，就可以分别计算出深度和最远距离，于是有了第二种方案：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNodeProperty</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> distance = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxDistanceOfTree2</span><span class="params">(BinaryTreeNode&lt;Integer&gt; rootNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rootNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> propertyOfTreeNode(rootNode).distance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNodeProperty <span class="title">propertyOfTreeNode</span><span class="params">(BinaryTreeNode&lt;Integer&gt; rootNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rootNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeNodeProperty();</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNodeProperty left = propertyOfTreeNode(rootNode.leftNode);</span><br><span class="line">    TreeNodeProperty right = propertyOfTreeNode(rootNode.rightNode);</span><br><span class="line">    TreeNodeProperty p = <span class="keyword">new</span> TreeNodeProperty();</span><br><span class="line">    <span class="comment">//当前节点的树的深度depth = 左子树深度 + 右子树深度 + 1；（根节点也占一个depth）</span></span><br><span class="line">    p.depth = Math.max(left.depth, right.depth) + <span class="number">1</span>;</span><br><span class="line">    p.distance = Math.max(Math.max(left.distance, right.distance), left.depth + right.depth);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树中某个节点到根节点的路径"><a href="#二叉树中某个节点到根节点的路径" class="headerlink" title="二叉树中某个节点到根节点的路径"></a>二叉树中某个节点到根节点的路径</h1><blockquote>
<p>既是寻路问题，又是查找节点问题。<br>定义一个存放路径的栈（不是队列了，但是还是用可变数组来实现的）</p>
<ul>
<li>压入根节点，再从左子树中查找（递归进行的），如果未找到，再从右子树中查找，如果也未找到，则弹出根节点，再遍历栈中上一个节点。</li>
<li>如果找到，则栈中存放的节点就是路径所经过的节点。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树中某个节点到根节点的路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rootNode 根节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> treeNode 节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 路径队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stack&lt;BinaryTreeNode&gt; <span class="title">pathOfTreeNode</span><span class="params">(BinaryTreeNode&lt;Integer&gt; rootNode, <span class="keyword">int</span> treeNode)</span> </span>&#123;</span><br><span class="line">    Stack&lt;BinaryTreeNode&gt; pathList = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    isFoundTreeNode(rootNode, treeNode, pathList);</span><br><span class="line">    <span class="keyword">return</span> pathList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找某个节点是否在树中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rootNode 根节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> treeNode 待查找的节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> path 根节点到待查找节点的路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否找到该节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isFoundTreeNode</span><span class="params">(BinaryTreeNode&lt;Integer&gt; rootNode, <span class="keyword">int</span> treeNode,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Stack&lt;BinaryTreeNode&gt; path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rootNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当前节点就是需要找的节点</span></span><br><span class="line">    <span class="keyword">if</span> (rootNode.value == treeNode) &#123;</span><br><span class="line">        path.add(rootNode);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将路过的节点压入栈中</span></span><br><span class="line">    path.add(rootNode);</span><br><span class="line">    <span class="comment">//先在左子树中查找</span></span><br><span class="line">    <span class="keyword">boolean</span> find = isFoundTreeNode(rootNode.leftNode, treeNode, path);</span><br><span class="line">    <span class="keyword">if</span> (!find) &#123;</span><br><span class="line">        <span class="comment">//如果没有找到，然后在右子树中查找</span></span><br><span class="line">        find = isFoundTreeNode(rootNode.rightNode, treeNode, path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!find) &#123;</span><br><span class="line">        path.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> find;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树中两个节点最近的公共父节点"><a href="#二叉树中两个节点最近的公共父节点" class="headerlink" title="二叉树中两个节点最近的公共父节点"></a>二叉树中两个节点最近的公共父节点</h1><blockquote>
<p>首先需要明白，根节点肯定是二叉树中任意两个节点的公共父节点（不一定是最近的），因此二叉树中2个节点的最近公共父节点一定在从根节点到这个节点的路径上。因此我们可以先分别找到从根节点到这2个节点的路径，再从这两个路径中找到最近的公共父节点。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树种两个节点的最近公共节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rootNode 根节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nodeA 第一个节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nodeB 第二个节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 最近的公共节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parentOfNode</span><span class="params">(BinaryTreeNode&lt;Integer&gt; rootNode, <span class="keyword">int</span> nodeA, <span class="keyword">int</span> nodeB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rootNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//两个节点是同一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (nodeA == nodeB) &#123;</span><br><span class="line">        <span class="keyword">return</span> nodeA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其中一个点为根节点</span></span><br><span class="line">    <span class="keyword">if</span> (rootNode.value == nodeA || rootNode.value == nodeB) &#123;</span><br><span class="line">        <span class="keyword">return</span> rootNode.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从根节点到节点A的路径</span></span><br><span class="line">    Stack&lt;BinaryTreeNode&gt; pathA = pathOfTreeNode(rootNode, nodeA);</span><br><span class="line">    <span class="comment">//从根节点到节点B的路径</span></span><br><span class="line">    Stack&lt;BinaryTreeNode&gt; pathB = pathOfTreeNode(rootNode, nodeB);</span><br><span class="line">    <span class="comment">//寻找的节点不在树中</span></span><br><span class="line">    <span class="keyword">if</span> (pathA.size() == <span class="number">0</span> || pathB.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将路径的数据结构，变为数组</span></span><br><span class="line">    <span class="keyword">int</span>[] arrayA = <span class="keyword">new</span> <span class="keyword">int</span>[pathA.size()];</span><br><span class="line">    <span class="keyword">int</span>[] arrayB = <span class="keyword">new</span> <span class="keyword">int</span>[pathB.size()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = pathA.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        arrayA[i] = (<span class="keyword">int</span>) pathA.pop().value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = pathB.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        arrayB[i] = (<span class="keyword">int</span>) pathB.pop().value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第i+1个不相同的节点出现，则第i个节点为最近公共节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrayA.length - <span class="number">1</span> &amp;&amp; i &lt; arrayB.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arrayA[i + <span class="number">1</span>] != arrayB[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> arrayA[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> == arrayA.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> arrayA[arrayA.length - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> == arrayB.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> arrayB[arrayB.length - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树中两个节点之间的路径"><a href="#二叉树中两个节点之间的路径" class="headerlink" title="二叉树中两个节点之间的路径"></a>二叉树中两个节点之间的路径</h1><p>从查找最近公共父节点衍生出来的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树中两个节点之间的路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rootNode 根节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nodeA 第一个节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nodeB 第二个节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">pathFromNode</span><span class="params">(BinaryTreeNode&lt;Integer&gt; rootNode, <span class="keyword">int</span> nodeA, <span class="keyword">int</span> nodeB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rootNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (nodeA == nodeB) &#123;</span><br><span class="line">        result.add(nodeA);</span><br><span class="line">        result.add(nodeB);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从根节点到节点A的路径</span></span><br><span class="line">    Stack&lt;BinaryTreeNode&gt; pathA = pathOfTreeNode(rootNode, nodeA);</span><br><span class="line">    <span class="comment">//从根节点到节点B的路径</span></span><br><span class="line">    Stack&lt;BinaryTreeNode&gt; pathB = pathOfTreeNode(rootNode, nodeB);</span><br><span class="line">    <span class="keyword">if</span> (rootNode.value == nodeB) &#123;</span><br><span class="line">        pathA.forEach(<span class="keyword">new</span> Consumer&lt;BinaryTreeNode&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(BinaryTreeNode binaryTreeNode)</span> </span>&#123;</span><br><span class="line">                result.add((Integer) binaryTreeNode.value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rootNode.value == nodeA) &#123;</span><br><span class="line">        pathB.forEach(<span class="keyword">new</span> Consumer&lt;BinaryTreeNode&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(BinaryTreeNode binaryTreeNode)</span> </span>&#123;</span><br><span class="line">                result.add((Integer) binaryTreeNode.value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//寻找的节点不在树中</span></span><br><span class="line">    <span class="keyword">if</span> (pathA.size() == <span class="number">0</span> || pathB.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将路径的数据结构，变为数组</span></span><br><span class="line">    <span class="keyword">int</span>[] arrayA = <span class="keyword">new</span> <span class="keyword">int</span>[pathA.size()];</span><br><span class="line">    <span class="keyword">int</span>[] arrayB = <span class="keyword">new</span> <span class="keyword">int</span>[pathB.size()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = pathA.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        arrayA[i] = (<span class="keyword">int</span>) pathA.pop().value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = pathB.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        arrayB[i] = (<span class="keyword">int</span>) pathB.pop().value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第i+1个不相同的节点出现，则第i个节点为最近公共节点</span></span><br><span class="line">    <span class="keyword">int</span> lastNode = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrayA.length - <span class="number">1</span> &amp;&amp; i &lt; arrayB.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arrayA[i + <span class="number">1</span>] != arrayB[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            lastNode = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> == arrayA.length - <span class="number">1</span>) &#123;</span><br><span class="line">            lastNode = arrayA.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> == arrayB.length - <span class="number">1</span>) &#123;</span><br><span class="line">            lastNode = arrayB.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arrayA.length - <span class="number">1</span>; i &gt;= lastNode; i--) &#123;</span><br><span class="line">        result.add(arrayA[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lastNode + <span class="number">1</span>; i &lt; arrayB.length; i++) &#123;</span><br><span class="line">        result.add(arrayB[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h1><blockquote>
<p>翻转二叉树，又叫求二叉树的镜像，就是把二叉树的左右子树对调（当然是递归的）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 翻转二叉树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rootNode 根节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 翻转后的二叉树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BinaryTreeNode <span class="title">invertBinaryTree</span><span class="params">(BinaryTreeNode&lt;Integer&gt; rootNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rootNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//只有一个根节点</span></span><br><span class="line">    <span class="keyword">if</span> (rootNode.leftNode == <span class="keyword">null</span> &amp;&amp; rootNode.rightNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> rootNode;</span><br><span class="line">    &#125;</span><br><span class="line">    invertBinaryTree(rootNode.leftNode);</span><br><span class="line">    invertBinaryTree(rootNode.rightNode);</span><br><span class="line">    BinaryTreeNode tempNode = rootNode.leftNode;</span><br><span class="line">    rootNode.leftNode = rootNode.rightNode;</span><br><span class="line">    rootNode.rightNode = tempNode;</span><br><span class="line">    <span class="keyword">return</span> rootNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A Complete Binary Tree （CBT) is a binary tree in which every level, </span><br><span class="line">except possibly the last, is completely filled, and all nodes </span><br><span class="line">are as far left as possible.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>换句话说，完全二叉树从根结点到倒数第二层满足完美二叉树，最后一层可以不完全填充，其叶子结点都靠左对齐。</p>
</blockquote>
<p>例如：</p>
<p><center><img src="http://upload-images.jianshu.io/upload_images/1319879-132f6089438a44e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="完全二叉树"></center></p>
<blockquote>
<p>根据《李春葆数据结构教程》书上的完全二叉树定义为：“二叉树中最多只有最下面两层节点的度数小于二，并且最下边的一层的叶子节点都一次排列在该层最左边的位置上，这样的二叉树称为完全二叉树”。</p>
</blockquote>
<blockquote>
<p>特点</p>
<ul>
<li>叶子节点只可能在层次最大的两层出现；</li>
<li>对于最大层次中的叶子节点，都一次排列在该层的最左边的位置上；</li>
<li>如果有度为一的叶子节点，只可能有一个，且该节点只有左孩子而无有孩子。</li>
</ul>
</blockquote>
<p>采用优先广度遍历的算法，从上到下，从左到右依次入队列。我们可以设置一个标志位flag，当子树满足完全二叉树时，设置flag=true。当flag=ture而节点又破坏了完全二叉树的条件，那么它就不是完全二叉树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否完全二叉树</span></span><br><span class="line"><span class="comment"> * 完全二叉树：若设二叉树的高度为h，除第h层外，其它各层的结点数都达到最大个数，第h层有叶子结点，并且叶子结点都是从左到右依次排布</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rootNode 根节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否是完全二叉树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isCompleteBinaryTree</span><span class="params">(BinaryTreeNode&lt;Integer&gt; rootNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rootNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//左子树和右子树都是空，则是完全二叉树</span></span><br><span class="line">    <span class="keyword">if</span> (rootNode.leftNode == <span class="keyword">null</span> &amp;&amp; rootNode.rightNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//左子树是空，右子树不是空，则不是完全二叉树</span></span><br><span class="line">    <span class="keyword">if</span> (rootNode.leftNode == <span class="keyword">null</span> &amp;&amp; rootNode.rightNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Deque&lt;BinaryTreeNode&lt;Integer&gt;&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(rootNode);</span><br><span class="line">    <span class="comment">//是否满足二叉树</span></span><br><span class="line">    <span class="keyword">boolean</span> isComplete = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (queue.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        BinaryTreeNode&lt;Integer&gt; node = queue.pop();</span><br><span class="line">        <span class="comment">//左子树为空且右子树不为空，则不是完全二叉树</span></span><br><span class="line">        <span class="keyword">if</span> (node.leftNode == <span class="keyword">null</span> &amp;&amp; node.rightNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//前面的节点已满足完全二叉树,如果还有孩子节点，则不是完全二叉树</span></span><br><span class="line">        <span class="keyword">if</span> (isComplete &amp;&amp; (node.leftNode != <span class="keyword">null</span> || node.rightNode != <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右子树为空，则已经满足完全二叉树</span></span><br><span class="line">        <span class="keyword">if</span> (node.rightNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">            isComplete = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将子节点压入</span></span><br><span class="line">        <span class="keyword">if</span> (node.leftNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(node.leftNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.rightNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(node.rightNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isComplete;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="判断二叉树是否满二叉树"><a href="#判断二叉树是否满二叉树" class="headerlink" title="判断二叉树是否满二叉树"></a>判断二叉树是否满二叉树</h1><blockquote>
<p>满二叉树定义为：除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树</p>
</blockquote>
<blockquote>
<p>满二叉树的一个特性是：叶子数=2^(深度-1)，因此我们可以根据这个特性来判断二叉树是否是满二叉树。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否满二叉树</span></span><br><span class="line"><span class="comment"> * 满二叉树：除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rootNode 根节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否满二叉树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isFullBinaryTree</span><span class="params">(BinaryTreeNode&lt;Integer&gt; rootNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rootNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> depth = depthOfTree(rootNode);</span><br><span class="line">    <span class="keyword">int</span> leafNum = numberOfLeafsInTree(rootNode);</span><br><span class="line">    <span class="keyword">if</span> (leafNum == Math.pow(<span class="number">2</span>, (depth - <span class="number">1</span>))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><blockquote>
<p>平衡二叉树定义为：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树又叫AVL树。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否平衡二叉树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rootNode 根节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否平衡二叉树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> height;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isAVLBinaryTree</span><span class="params">(BinaryTreeNode&lt;Integer&gt; rootNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rootNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        height = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rootNode.leftNode == <span class="keyword">null</span> &amp;&amp; rootNode.rightNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        height = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> isAV&lt;center&gt;![LLeft = isAVLBinaryTree(rootNode.leftNode);</span><br><span class="line">    <span class="keyword">int</span> heightLeft = height;</span><br><span class="line">    <span class="keyword">boolean</span> isAVLRight = isAVLBinaryTree(rootNode.rightNode);</span><br><span class="line">    <span class="keyword">int</span> heightRight = height;</span><br><span class="line">    height = Math.max(heightLeft, heightRight) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> isAVLLeft &amp;&amp; isAVLRight &amp;&amp; Math.abs(heightLeft - heightRight) &lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本来是想看红黑树的，但关于树相关的知识忘记的差不多了，这几天抽时间看了看二叉树的相关知识，作为笔记整理。<br><a href="https://gitee.com/dandanlove/codes/vxyoskt9c7uf2e31zd5gp96/archive" target="_blank" rel="noopener">—&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;代码</a><br>参考文章：<br><a href="http://www.cnblogs.com/manji/p/4903990.html" target="_blank" rel="noopener">二叉树-你必须要懂！（二叉树相关算法实现-iOS）</a></p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java垃圾回收器与内存分配策略</title>
    <url>/2017/08/26/jvm-memory-GC/</url>
    <content><![CDATA[<p>上一篇<a href="http://dandanlove.com/2017/08/26/jvm-memory-model/" target="_blank" rel="noopener">JVM内存模型</a>讲述了Java虚拟机在运行时所管理的内存划分下的每个数据区域的各自用途，以及创建和销毁时间。当需要排查各种内存泄漏、内存溢出问题时，当来及收集成为系统达到更高并发量的瓶颈时，我们需要对JVM的GC机制和内存分配又更多的了解，这边文章是在上一篇文章的基础之上讲述了Java垃圾回收器与内存分配策略。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>说起垃圾收集器（Garbage Collection,GC），大部分人都把这项技术当做Java的伴生产物。实际上GC的历史远比Java久远，1960年诞生于MIT的Lisp是第一门真正使用内存动态分配和垃圾收集技术的语言。当Lisp还在胚胎时期时，人们就在思考GC需要完成的3件事情:</p>
<blockquote>
<ul>
<li>那些内存需要回收？</li>
<li>什么时候回收内存？</li>
<li>如何回收？</li>
</ul>
</blockquote>
<h2 id="垃圾收集器关注那些数据区域"><a href="#垃圾收集器关注那些数据区域" class="headerlink" title="垃圾收集器关注那些数据区域"></a>垃圾收集器关注那些数据区域</h2><blockquote>
<ul>
<li>程序计数器</li>
<li>虚拟机栈</li>
<li>本地方法栈</li>
<li>堆</li>
<li>方法区</li>
</ul>
</blockquote>
<p>程序计数器、Java虚拟机栈、本地方法栈这3个区域都是随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每个栈帧分配多少内存基本上是在类结构确定下来的时候就已知的，因此这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑回收的问题，以为方法结束或者线程结束时，内存自然就跟随着回收了。而Java堆区和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间才能知道会创建那些对象，这部分内存的分配和回收都是动态的，垃圾回收器关注的是这部分内存。</p>
<p>先讲述Java堆区中的对象回收。</p>
<h2 id="判断对象是否存活"><a href="#判断对象是否存活" class="headerlink" title="判断对象是否存活"></a>判断对象是否存活</h2><blockquote>
<ul>
<li>引用计数：通过判断对象被引用的次数(为0，则表示不可被使用)，但这很难解决对象相互循环引用的问题。</li>
<li>根搜索算法：即采用有向图的方式，判断从GC Roots到某个对象是否可达。</li>
</ul>
</blockquote>
<center><img src="http://upload-images.jianshu.io/upload_images/1319879-4f971e3cc1b0576c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="GC-可达性分析.png"></center>

<p>什么样的对象能作为GC的Root节点呢？</p>
<blockquote>
<ul>
<li>虚拟机栈中局部变量引用的对象</li>
<li>类静态属性引用的对象</li>
<li>常量引用的对象</li>
<li>JNI中引用的对象</li>
</ul>
</blockquote>
<h2 id="对象的回收"><a href="#对象的回收" class="headerlink" title="对象的回收"></a>对象的回收</h2><p>要宣告一个对象死亡，只少要经历两次标记过程：如果对象在进行可达行分析后发现没有与GC Roots相链接的引用链，那它将会被进行一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</p>
<center><img src="http://upload-images.jianshu.io/upload_images/1319879-aecbea806aeeedac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="对象回收.png"></center>

<h2 id="对象的引用类型"><a href="#对象的引用类型" class="headerlink" title="对象的引用类型"></a>对象的引用类型</h2><p>说起对象的回收我们就不能不说对象的引用了，因为无论【引用计数法】判断对象的引用数量，或者【根搜索算法】判断对象的应用链是否可达，判定对象是否存活都与引用有关。在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）与虚引用（Phantom Reference）四种，这四中引用程序依次逐渐减弱。</p>
<blockquote>
<ul>
<li>强引用就是指在程序代码之中普遍存在的，类似”Object obj = new Object()”这类的引用，只要有强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</li>
<li>软引用是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行二次回收。如果这次回收还没有足够的内存，才会抛出内存异常。在JDK1.2之后，提供了SoftReference类来实现软引用。</li>
<li>弱引用也是用来描述非必须对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存早下一次垃圾收集发生之前，当来及收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2之后，提供了WeakReference类来实现弱引用。</li>
<li>虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象实例，为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在JDK1.2之后，提供了PhantomReference类来实现虚引用。</li>
</ul>
</blockquote>
<h2 id="方法区的回收"><a href="#方法区的回收" class="headerlink" title="方法区的回收"></a>方法区的回收</h2><p>方法区或者是HotSpot虚拟机的永久代的垃圾回收主要回收的内容有两部分：废弃的常量和无用的类。</p>
<p>废弃的常量回收和Java堆中的对象回收时类似的。</p>
<p>判断一个类是否是【无用的类】却比判断一个对象是否被可以被回收苛刻的多，该类需要满足同时满足一下三个条件：</p>
<blockquote>
<ul>
<li>改类的所有实力都以及被回收，也就是说Java堆中存在改类的任何实力；</li>
<li>加载该类的ClassLoader都以及被回收。</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
</blockquote>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><blockquote>
<ul>
<li>标记-清除算法（Mark-Sweep）</li>
<li>复制算法（Copying）</li>
<li>标记-整理算法（Mark-Compact）</li>
</ul>
</blockquote>
<h1 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark-Sweep）"></a>标记-清除算法（Mark-Sweep）</h1><p>【标记-清除】是最基础的收集算法，算法分为“标记”和“清除”两个阶段，首先标记处所有需要回收的对象，在标记完成后统一回收所被标记的对象，它的标记过程就是上边讲的对象的回收中的标记。<br>特点：</p>
<blockquote>
<ul>
<li>标记和清除效率都不高 </li>
<li>标记清除后会产生大量内存碎片</li>
</ul>
</blockquote>
<center><img src="http://upload-images.jianshu.io/upload_images/1319879-9721d8b65befd938.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="标记-清除"></center>

<h1 id="复制算法（Copying）"><a href="#复制算法（Copying）" class="headerlink" title="复制算法（Copying）"></a>复制算法（Copying）</h1><p>为了解决效率问题，一种称为“复制”的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块的内存用完了，就将其存活着的对象复制到另外一块上面，然后再把已使用过的内存一次清理掉。</p>
<blockquote>
<ul>
<li>不会产生碎片</li>
<li>运行效率高</li>
<li>内存缩小了一半</li>
</ul>
</blockquote>
<center><img src="http://upload-images.jianshu.io/upload_images/1319879-884ab0c3cf30bb13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="复制算法"></center>

<h1 id="标记-整理算法（Mark-Compact）"><a href="#标记-整理算法（Mark-Compact）" class="headerlink" title="标记-整理算法（Mark Compact）"></a>标记-整理算法（Mark Compact）</h1><p>标记-整理算法是介于【标记-清除】和【复制】之间的收集算法，标记过程任然与【标记-清除】算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1319879-335a1d8911058ae5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="标记-整理"></p>
<h1 id="分代收集算法（Generational-Collection）"><a href="#分代收集算法（Generational-Collection）" class="headerlink" title="分代收集算法（Generational Collection）"></a>分代收集算法（Generational Collection）</h1><p>当前商业虚拟机的垃圾收集都是采用“分代收集”（Generational Collection）算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次来及收集时都发现有大批对象死去，只有少量存活，那就选用复制算犯法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高，没有额外控件对它进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收。</p>
<h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><p><img src="http://upload-images.jianshu.io/upload_images/1319879-3a598825ded15bd5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Java内存分配"></p>
<p>这里所说的内存分配，主要至的是在堆上的分配，一半的，对象的内存分配都是在堆上进行，但现代技术页支持将对象拆程标量类型（标量类型即原子类型，表示单个值，可以是基本类型或String类型），然后在栈上分配，在栈上分配很少见，我们这里不考虑。</p>
<p>Java内存分配和回收的机制概括的说，就是分代分配，分代回收。对象根据存活的时间被分为：年轻代（Young Generation）、老年代（Old Generation）、永久代（Permanent Generation，也就是方法区）。</p>
<blockquote>
<p>年轻代（Young Generation）：对象被创建时，内存的分配首先发生在年轻代（大对象可以直接 被创建在年老代），大部分的对象在创建后很快就不再使用，因此很快变得不可达，于是被年轻代的GC机制清理掉（IBM的研究表明，98%的对象都是很快消 亡的），这个GC机制被称为Minor GC或叫Young GC。注意，Minor GC并不代表年轻代内存不足，它事实上只表示在Eden区上的GC。</p>
</blockquote>
<p>Minor GC:采用复制算法（Copying）</p>
<blockquote>
<p>年老代（Old Generation）：对象如果在年轻代存活了足够长的时间而没有被清理掉（即在几次 Young GC后存活了下来），则会被复制到年老代，年老代的空间一般比年轻代大，能存放更多的对象，在年老代上发生的GC次数也比年轻代少。当年老代内存不足时， 将执行Major GC，也叫 Full GC。　</p>
</blockquote>
<p>Full GC:标记-整理算法(Mark-Compact)</p>
<center><img src="http://upload-images.jianshu.io/upload_images/1319879-64a5c67f7d05a058.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="GC.png"></center>

<blockquote>
<p>年轻代上的内存分配是这样的，年轻代可以分为3个区域：Eden区（伊甸园，亚当和夏娃偷吃禁果生娃娃的地方，用来表示内存首次分配的区域，再 贴切不过）和两个存活区（Survivor 0 、Survivor 1）。</p>
</blockquote>
<p>绝大多数刚创建的对象会被分配在Eden区，其中的大多数对象很快就会消亡。Eden区是连续的内存空间，因此在其上分配内存极快；</p>
<blockquote>
</blockquote>
<p>当Eden区满的时候，执行Minor GC，将消亡的对象清理掉，并将剩余的对象复制到一个存活区Survivor0（此时，Survivor1是空白的，两个Survivor总有一个是空白的）；</p>
<blockquote>
</blockquote>
<p>此后，每次Eden区满了，就执行一次Minor GC，并将剩余的对象都添加到Survivor0；</p>
<blockquote>
</blockquote>
<p>当Survivor0也满的时候，将其中仍然活着的对象直接复制到Survivor1，以后Eden区执行Minor GC后，就将剩余的对象添加Survivor1（此时，Survivor0是空白的）。</p>
<blockquote>
</blockquote>
<p>当两个存活区切换了几次（HotSpot虚拟机默认15次，用-XX:MaxTenuringThreshold控制，大于该值进入老年代）之后，仍然存活的对象（其实只有一小部分，比如，我们自己定义的对象），将被复制到老年代。</p>
<h1 id="对象优先在Eden区分配"><a href="#对象优先在Eden区分配" class="headerlink" title="对象优先在Eden区分配"></a>对象优先在Eden区分配</h1><h1 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h1><h1 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h1><p>第一次进入Survivor区域的时候对象年龄设置为1，对象在Survivor区域中每“熬过”一次MinorGC，年龄增加一岁，当它的年龄增加到一定程度（默认为15岁），将会被晋升到老年代中。</p>
<h1 id="动态对象年龄判断"><a href="#动态对象年龄判断" class="headerlink" title="动态对象年龄判断"></a>动态对象年龄判断</h1><p>为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</p>
<h1 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h1><p>在发生MinorGC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新手代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将会尝试着一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险（冒险：当出现大量对象在Minor GC后任然存活的情况，就需要老年代进行分配担保 ，把Survivor无法容纳的对象直接进入老年代），那这时改为进行一次Full GC。</p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM内存模型</title>
    <url>/2017/08/26/jvm-memory-model/</url>
    <content><![CDATA[<p>前一段时间写过一篇关于 <a href="http://dandanlove.com/2016/09/20/java-jvm-class-loading/" target="_blank" rel="noopener">JVM虚拟机之类加载的过程</a> 的文章，其中讲述了Java虚拟机对类的处理。最近听了一次部门内部有关JVM的分享，自己也顺便回顾了之前阅读《深入理解JVM虚拟机》一书中所讲述的Java虚拟机对内存的管理，再次将自己理解的JVM内存模型分享给大家。</p>
<h2 id="Java运行时数据区域"><a href="#Java运行时数据区域" class="headerlink" title="Java运行时数据区域"></a>Java运行时数据区域</h2><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区。这些区域都有各自的用途，一级创建和销毁的时间，有的区域随着虚拟机进程的启动而从在，有些区域则依赖用户线程的启动和结束而简历和销毁。</p>
<center><img src="http://upload-images.jianshu.io/upload_images/1319879-46f35743dbab107d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="JVM内存模型"></center>

<blockquote>
<ul>
<li>程序计数器</li>
<li>Java虚拟机栈</li>
<li>本地方法栈</li>
<li>Java堆</li>
<li>方法区</li>
<li>运行时常量池</li>
<li>直接内存</li>
</ul>
</blockquote>
<center><img src="http://upload-images.jianshu.io/upload_images/1319879-79c0858a44380293.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="java-memory-model"></center>

<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>当前线程所执行的字节码文件的行号指示器。</p>
<blockquote>
<ul>
<li>每个线程都有一个程序计数器</li>
<li>不会发生OOM</li>
</ul>
</blockquote>
<h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><p>虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。 </p>
<blockquote>
<ul>
<li>线程独有，生命周期与线程保持一致</li>
<li>StackOverflowError   （单线程，栈帧太大，还是虚拟机栈容量太小）</li>
<li>OutOfMemoryError  （创建线程太多）</li>
</ul>
</blockquote>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>同Java虚拟机栈类型，只不过是native方法执行的内存模型。</p>
<h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><p>所有的对象实例以及数组都要在堆上分配（除了Class对象）</p>
<blockquote>
<ul>
<li>所有线程共享的一块内存区域</li>
<li>OutOfMemoryError</li>
</ul>
</blockquote>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 </p>
<blockquote>
<ul>
<li>各个线程共享的内存区域</li>
<li>如果一个类被加载了，就会在方法区生成一个代表该类的Class对象，有了该对象的存在，才有了反射的实现。 </li>
<li>会出OOM</li>
</ul>
</blockquote>
<h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>运行时常量池中主要存放两大类常量：字面量和符号引用。字面量比较接近于Java语言层面的常量概念，如文本字符串、声明为final的常量值等。 </p>
<p>而符号引用则属于编译原理方面的概念，包括了下面三类常量：</p>
<blockquote>
<ul>
<li>类和接口的全限定名（包名+类名）</li>
<li>字段的名称和描述符 </li>
<li>方法的名称和描述符</li>
</ul>
</blockquote>
<p>时常量池在JDK1.6及之前版本的JVM中是方法区的一部分，而在JDK1.7及之后版本的JVM已经将运行时常量池从方法区中移了出来，在Java 堆（Heap）中开辟了一块区域存放运行时常量池。</p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA回忆录之泛型篇</title>
    <url>/2017/08/18/java-base-generic/</url>
    <content><![CDATA[<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzEzMTk4NzktMmE4YmE0MzlhMTczNDM2ZC5KUEc?x-oss-process=image/format,png#pic_center" alt=""></p>
<h1 id="泛型是什么"><a href="#泛型是什么" class="headerlink" title="泛型是什么"></a>泛型是什么</h1><p>泛型是JDK1.5版本中加入的，在没有泛型之前，从集合中读取到的每一个对象都必须进行转化。如果有人不小心插入了类型错误的对象，在运行时的转化处理就会出错。有了泛型之后，可以告诉变一起每个集合中接受那些对象类型。编译器自动地为你的插入进行转化，并在编译时告知是否插入了类型错误的对象。</p>
<p>泛型最精准的定义：参数化类型。具体点说就是处理的数据类型不是固定的，而是可以作为参数传入。定义泛型类、泛型接口、泛型方法，这样，同一套代码，可以用于多种数据类型。</p>
<blockquote>
<ul>
<li>K ——键，比如映射的键。</li>
<li>V ——值，比如 List 和 Set 的内容，或者 Map中的值。</li>
<li>E ——异常类。</li>
<li>T ——泛型。</li>
</ul>
</blockquote>
<p>数组是协变的（协变：其实只是表示如果Stub为Super的子类型，那么类型Stub[]就是Super[]的子类型），泛型不是协变的。因此数组和泛型不能好好地混合使用。</p>
<h1 id="泛型类、接口和泛型方法"><a href="#泛型类、接口和泛型方法" class="headerlink" title="泛型类、接口和泛型方法"></a>泛型类、接口和泛型方法</h1><h2 id="泛型类、接口"><a href="#泛型类、接口" class="headerlink" title="泛型类、接口"></a>泛型类、接口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">for</span> (T t : <span class="keyword">this</span>) &#123;</span><br><span class="line">            action.accept(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> Spliterator&lt;T&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Spliterators.spliteratorUnknownSize(iterator(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般而言，声明泛型接口的方式与声明泛型类相同。</p>
<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Collections</span> </span>&#123;</span><br><span class="line">    <span class="comment">/***其他代码省略***/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</span><br><span class="line">        list.sort(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***其他代码省略***/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Generic&lt;Integer&gt; generic = <span class="keyword">new</span> Generic&lt;&gt;();</span><br><span class="line">        generic.set(<span class="keyword">new</span> Integer(<span class="number">1</span>));</span><br><span class="line">        System.out.println(generic.get().intValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> T value;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个泛型使用的列子，我们反编译查看它的class文件：<br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Compiled from <span class="string">"Main.java"</span></span><br><span class="line">public class <span class="keyword">com</span>.loadclass.generic.Main$Generic&lt;T extends java.lang.Number&gt; &#123;</span><br><span class="line">  public com.loadclass.generic.Main$Generic();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  // Method java/lang/Object.<span class="string">"&lt;init&gt;"</span>:()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  public T get();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: getfield      #2                  // Field value:Ljava/lang/Number;</span><br><span class="line">       <span class="number">4</span>: areturn</span><br><span class="line"></span><br><span class="line">  public void set(T);</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: aload_1</span><br><span class="line">       2: putfield      #2                  // Field value:Ljava/lang/Number;</span><br><span class="line">       <span class="number">5</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class <span class="keyword">com</span>.loadclass.generic.Main &#123;</span><br><span class="line">  public com.loadclass.generic.Main();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  // Method java/lang/Object.<span class="string">"&lt;init&gt;"</span>:()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  // class <span class="keyword">com</span>/loadclass/generic/Main$Generic</span><br><span class="line">       <span class="number">3</span>: dup</span><br><span class="line">       <span class="number">4</span>: invokespecial #<span class="number">3</span>                  // Method <span class="keyword">com</span>/loadclass/generic/Main$Generic.<span class="string">"&lt;init&gt;"</span>:()V</span><br><span class="line">       <span class="number">7</span>: astore_1</span><br><span class="line">       <span class="number">8</span>: aload_1</span><br><span class="line">       <span class="number">9</span>: <span class="keyword">new</span>           #<span class="number">4</span>                  // class java/lang/Integer</span><br><span class="line">      <span class="number">12</span>: dup</span><br><span class="line">      <span class="number">13</span>: iconst_1</span><br><span class="line">      <span class="number">14</span>: invokespecial #<span class="number">5</span>                  // Method java/lang/Integer.<span class="string">"&lt;init&gt;"</span>:(I)V</span><br><span class="line">      17: invokevirtual #6                  // Method com/loadclass/generic/Main$Generic.set:(Ljava/lang/Number;)V</span><br><span class="line">      20: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      <span class="number">23</span>: aload_1</span><br><span class="line">      24: invokevirtual #8                  // Method com/loadclass/generic/Main$Generic.get:()Ljava/lang/Number;</span><br><span class="line">      <span class="number">27</span>: checkcast     #<span class="number">4</span>                  // class java/lang/Integer</span><br><span class="line">      <span class="number">30</span>: invokevirtual #<span class="number">9</span>                  // Method java/lang/Integer.intValue:()I</span><br><span class="line">      <span class="number">33</span>: invokevirtual #<span class="number">10</span>                 // Method java/io/PrintStream.println:(I)V</span><br><span class="line">      <span class="number">36</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从class文件中我们可以看出来，其实泛型在编译后都进行了擦除，类型T都转化为了它的超类Number，然后在需要使用的时候进行checkcast。当然在泛型没有做任何显示的时候比如Generic<t>，这样在编译生成的class文件中T都是转化为Object类型来处理的。</t></p>
<h1 id="有界泛型类型"><a href="#有界泛型类型" class="headerlink" title="有界泛型类型"></a>有界泛型类型<t extends="" superclass=""></t></h1><p>泛型参数类型可以使用任意参数类型替换。对于大多数情况这很好，但是限制能够传递给类型参数的类型是有时有用的。例如，假设希望创建一个泛型类，类中返回数据中数据平均值的方法（类型数字包括：整数、单精度和双精度）。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stats</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt; </span>&#123;</span><br><span class="line">    T[] nums;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stats</span><span class="params">(T[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nums = nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">average</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">            sum += nums[i].doubleValue();</span><br><span class="line">        <span class="keyword">return</span> sum / nums.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>向上边代码我们可以使用Number对T类型做限制，这样所有T类型对象都可以调用doubleValue()方法，因为该方法是由Number声明的。</p>
<h1 id="泛型通配符参数"><a href="#泛型通配符参数" class="headerlink" title="泛型通配符参数"></a>泛型通配符参数</h1><p>先看一段代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stats</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt; </span>&#123;</span><br><span class="line">    T[] nums;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stats</span><span class="params">(T[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nums = nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">average</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">            sum += nums[i].doubleValue();</span><br><span class="line">        <span class="keyword">return</span> sum / nums.length;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">boolean</span> <span class="title">sameAge</span><span class="params">(Stats&lt;T&gt; ob)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (average() == ob.average()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样的实现导致只有sameAge方法的参数类型和地啊用对象的类型相同时才能工作。</p>
<p>为了创建smaeAvg方法，必须使用Java泛型的另一个特性：通配符参数。通配符参数是由“？”指定的，表示未知类型。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stats</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt; </span>&#123;</span><br><span class="line">    T[] nums;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stats</span><span class="params">(T[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nums = nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">average</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">            sum += nums[i].doubleValue();</span><br><span class="line">        <span class="keyword">return</span> sum / nums.length;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">boolean</span> <span class="title">sameAge</span><span class="params">(Stats&lt;？&gt; ob)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (average() == ob.average()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此时，Stats&lt;?&gt;和所有的Stats对象匹配，允许任意两个Stats对象比较它们的平均值。</p>
<p>在讲述有界通配符之前我们先看一段代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Apple[] apples = <span class="keyword">new</span> Apple[<span class="number">1</span>];</span><br><span class="line">Fruit[] fruits = apples;</span><br><span class="line">fruits[<span class="number">0</span>] = <span class="keyword">new</span> Strawberry();</span><br></pre></td></tr></table></figure></p>
<p>因为数组可以协变的，所以Apple的数据applse可以赋值给子类数组fruits，但是在给数组中的某个Fruit对象赋值的时候假如不是Apple或者其子类类型，那么代码可以编译，但在允许时会抛出java.lang.ArrayStoreException的异常。</p>
<h2 id="有界通配符（上界）"><a href="#有界通配符（上界）" class="headerlink" title="有界通配符（上界）"></a>有界通配符（上界）</h2><p>向上造型一个泛型对象的引用&lt;? extends superclass&gt;</p>
<p>我们可以使用通配符把相关的代码转换程泛型：因为Apple是Fruit的一个子类，我们使用? extends 通配符，这样就能将一个List<apple>对象的定义赋到一个List&lt;? extends Fruit&gt;的声明上：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Apple&gt; apples = <span class="keyword">new</span> ArrayList&lt;Apple&gt;();</span><br><span class="line">List&lt;? extends Fruit&gt; fruits = apples;</span><br></pre></td></tr></table></figure></apple></p>
<p>这次，代码就编译不过去了！Java编译器会阻止你往一个Fruit list里加入strawberry。在编译时我们就能检测到错误，在运行时就不需要进行检查来确保往列表里加入不兼容的类型了。即使你往list里加入Fruit对象也不行：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fruits.add(<span class="keyword">new</span> Fruit());</span><br></pre></td></tr></table></figure></p>
<p>事实上你不能够往一个使用了? extends的数据结构里写入任何的值。</p>
<p>原因非常的简单，你可以这样想：这个? extends T 通配符告诉编译器我们在处理一个类型T的子类型，但我们不知道这个子类型究竟是什么。因为没法确定，为了保证类型安全，我们就不允许往里面加入任何这种类型的数据。另一方面，因为我们知道，不论它是什么类型，它总是类型T的子类型，当我们在读取数据时，能确保得到的数据是一个T类型的实例：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Fruit get = fruits.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="有界通配符（下界）"><a href="#有界通配符（下界）" class="headerlink" title="有界通配符（下界）"></a>有界通配符（下界）</h2><p>向下造型一个泛型对象的引用&lt;? super superclass&gt;</p>
<p>使用&lt;? super superclass&gt;通配符一般是什么情况？让我们先看看这个：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Fruit&gt; fruits = <span class="keyword">new</span> ArrayList&lt;Fruit&gt;();</span><br><span class="line">List&lt;? <span class="keyword">super</span> Apple&gt; = fruits;</span><br></pre></td></tr></table></figure></p>
<p>我们看到fruits指向的是一个装有Apple的某种超类(supertype)的List。同样的，我们不知道究竟是什么超类，但我们知道Apple和任何Apple的子类都跟它的类型兼容。既然这个未知的类型即是Apple，也是GreenApple的超类，我们就可以写入：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fruits.add(<span class="keyword">new</span> Apple());</span><br><span class="line">fruits.add(<span class="keyword">new</span> GreenApple());</span><br></pre></td></tr></table></figure></p>
<p>如果我们想往里面加入Apple的超类，编译器就会警告你：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fruits.add(<span class="keyword">new</span> Fruit());</span><br><span class="line">fruits.add(<span class="keyword">new</span> Object());</span><br></pre></td></tr></table></figure></p>
<p>因为我们不知道它是怎样的超类，所有这样的实例就不允许加入。</p>
<p>从这种形式的类型里获取数据又是怎么样的呢？结果表明，你只能取出Object实例：因为我们不知道超类究竟是什么，编译器唯一能保证的只是它是个Object，因为Object是任何Java类型的超类。</p>
<h1 id="存取原则和PECS法则"><a href="#存取原则和PECS法则" class="headerlink" title="存取原则和PECS法则"></a>存取原则和PECS法则</h1><p>请记住PECS法则：生产者(Producer)使用extends，消费者(Consumer)使用super。</p>
<ul>
<li>生产者使用extends</li>
</ul>
<blockquote>
<p>如果你需要一个列表提供T类型的元素（即你想从列表中读取T类型的元素），你需要把这个列表声明成&lt;? extends T&gt;，比如List&lt;? extends Integer&gt;，因此你不能往改列表中添加任何元素。</p>
</blockquote>
<ul>
<li>消费者使用super</li>
</ul>
<blockquote>
<p>如果需要一个列表使用T类型的元素（即你想把T类型的元素加入到列表中），你需要把这个列表声明成&lt;？ super T&gt;，比如List&lt;? super Integer&gt;，因此你不能保证从中读取到的元素的类型。</p>
</blockquote>
<ul>
<li>即是生产者，也是消费者</li>
</ul>
<blockquote>
<p>如果一个列表既要生成，又要消费，你不能使用泛型通配符声明列表，比如List<integer>。</integer></p>
</blockquote>
<h1 id="泛型类的层次问题"><a href="#泛型类的层次问题" class="headerlink" title="泛型类的层次问题"></a>泛型类的层次问题</h1><p>泛型类可以是类层次的一部分，就像非泛型类那样，因此，泛型类可以作为超类或子类。泛型和非泛型层次之间的关键区别是：在泛型层次中，类层次中的所有子类都必须向上传递超类所需要的所有类型参数。这与必须沿着类层次向上构造函数的参数类似。</p>
<h2 id="使用泛型超类"><a href="#使用泛型超类" class="headerlink" title="使用泛型超类"></a>使用泛型超类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gen</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T obj;</span><br><span class="line">    Gen(T object) &#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = object;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Generic继承Gen:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Gen</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    Generic(T object) &#123;</span><br><span class="line">        <span class="keyword">super</span>(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>继承泛型类的子类也可以拥有自己的泛型：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">V</span>,<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Gen</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> V value;</span><br><span class="line">    Generic(T object, V value) &#123;</span><br><span class="line">        <span class="keyword">super</span>(object);</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="使用泛型子类"><a href="#使用泛型子类" class="headerlink" title="使用泛型子类"></a>使用泛型子类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoGen</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    NoGen(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类继承NoGen并实现泛型：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gen</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">NoGen</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T obj;</span><br><span class="line">    Gen(T object, <span class="keyword">int</span> value) &#123;</span><br><span class="line">        <span class="keyword">super</span>(value);</span><br><span class="line">        <span class="keyword">this</span>.obj = object;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="强制转化"><a href="#强制转化" class="headerlink" title="强制转化"></a>强制转化</h2><p>只有当两个泛型类型实例的类型相互兼容并且他们的类型参数也是相同时，才能将其中的一个实例转化为另一个实例：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; listInteger = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();<span class="comment">//legal</span></span><br><span class="line">List&lt;Integer&gt; listLong = <span class="keyword">new</span> ArrayList&lt;Long&gt;();<span class="comment">//illegal</span></span><br></pre></td></tr></table></figure></p>
<h2 id="重写泛型类的方法"><a href="#重写泛型类的方法" class="headerlink" title="重写泛型类的方法"></a>重写泛型类的方法</h2><p>可以像重写其他任何方法那样重写泛型类的方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gen</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    T obj;</span><br><span class="line">    Gen(T object) &#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = object;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Gen</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    Generic(T object) &#123;</span><br><span class="line">        <span class="keyword">super</span>(object);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obj = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="泛型类型推断"><a href="#泛型类型推断" class="headerlink" title="泛型类型推断"></a>泛型类型推断</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();<span class="comment">//&lt;1.7</span></span><br><span class="line">List&lt;Integer&gt; integerList = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//1.7</span></span><br></pre></td></tr></table></figure>
<p>在JDK1.6的时候我们声明泛型和new一个泛型实例时必须制定相同的类型。而从<br>JDK1.7开始new的泛型实例不用制定类型，编译期会默认与声明的对象用于相同的泛型类型。</p>
<h2 id="擦除"><a href="#擦除" class="headerlink" title="擦除"></a>擦除</h2><p>前文中讲过泛型的擦除，为什么这里还需要再讲述呢？这里讲述在继承泛型时的擦除，仔细阅读会有不一样的发现哦~！<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gen</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    T obj;</span><br><span class="line">    Gen(T object) &#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = object;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span> <span class="keyword">extends</span> <span class="title">Gen</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    Generic(String object) &#123;</span><br><span class="line">        <span class="keyword">super</span>(object);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们分析编译后生成的Generic的class文件：<br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Compiled from <span class="string">"Generic.java"</span></span><br><span class="line">public class <span class="keyword">com</span>.genericity.Generic extends <span class="keyword">com</span>.genericity.Gen&lt;java.lang.String&gt; &#123;</span><br><span class="line">  com.genericity.Generic(java.lang.String);</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: aload_1</span><br><span class="line">       2: invokespecial #1                  // Method com/genericity/Gen."&lt;init&gt;":(Ljava/lang/Object;)V</span><br><span class="line">       <span class="number">5</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  public java.lang.String get();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: getfield      #2                  // Field obj:Ljava/lang/Object;</span><br><span class="line">       <span class="number">4</span>: checkcast     #<span class="number">3</span>                  // class java/lang/String</span><br><span class="line">       <span class="number">7</span>: areturn</span><br><span class="line"></span><br><span class="line">  public java.lang.Object get();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokevirtual #4                  // Method get:()Ljava/lang/String;</span><br><span class="line">       <span class="number">4</span>: areturn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看出Generic中有两个get方法，这是编译期偶尔需要为类添加桥接方法。</p>
<blockquote>
<p>桥接方法<br>子类中重写方法的类型擦除不能产生于超类中方法相同的擦除。对于这种情况，会生成使用超类类型擦除的方法，并且这个方法调用具有由子类指定的类型擦除的方法。当然桥接方法只会在字节码级别发生。</p>
</blockquote>
<h2 id="模糊性错误"><a href="#模糊性错误" class="headerlink" title="模糊性错误"></a>模糊性错误</h2><p>泛型的引入，增加了引起一种新类型错误——模糊性错误的可能，必须注意防范。当擦除导致两个看起来不同的泛型声明，在擦除后变成相同的类型而导致冲突时，就会发生模糊性错误。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gen</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = object;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">V</span>, <span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Gen</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    V value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V value)</span> </span>&#123;<span class="comment">//illegal</span></span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样进行重载防范的时候，如果进行泛型擦除那么两个方法一模一样。像这样的情况使用两个独立的方法名会更好一些，而不是试图重载set方法。</p>
<h1 id="泛型在使用过程中应该注意的问题"><a href="#泛型在使用过程中应该注意的问题" class="headerlink" title="泛型在使用过程中应该注意的问题"></a>泛型在使用过程中应该注意的问题</h1><h2 id="不能用基本类型实例化类型参数"><a href="#不能用基本类型实例化类型参数" class="headerlink" title="不能用基本类型实例化类型参数"></a>不能用基本类型实例化类型参数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pair = <span class="keyword">new</span> HashMap&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;();</span><br></pre></td></tr></table></figure>
<p>这样的语句是非法的。</p>
<h2 id="不能抛出也不能捕获泛型类实例"><a href="#不能抛出也不能捕获泛型类实例" class="headerlink" title="不能抛出也不能捕获泛型类实例"></a>不能抛出也不能捕获泛型类实例</h2><p>泛型类扩展Throwable即为不合法，因此无法抛出或捕获泛型类实例。但在异常声明中使用类型参数是合法的：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(T t)</span> <span class="keyword">throws</span> T </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable realCause) &#123;</span><br><span class="line">    t.initCause(realCause);</span><br><span class="line">    <span class="keyword">throw</span> t;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="数据不能结合泛型使用"><a href="#数据不能结合泛型使用" class="headerlink" title="数据不能结合泛型使用"></a>数据不能结合泛型使用</h2><p>在Java中数据是协变的，Object[]数组可以是任何数组的父类（因为任何一个数组都可以向上转型为它在定义时指定元素类型的父类的数组）。考虑以下代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] strs = <span class="keyword">new</span> String[<span class="number">10</span>];</span><br><span class="line">Object[] objs = strs;</span><br><span class="line">objs[<span class="number">0</span>] = <span class="keyword">new</span> Long(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<p>在上述代码中，我们将数组元素赋值为满足父类（Object）类型，但不同于原始类型Long的对象，在编译时能够通过，而在运行时会抛出ArrayStoreException异常。</p>
<h2 id="不能实例化类型变量"><a href="#不能实例化类型变量" class="headerlink" title="不能实例化类型变量"></a>不能实例化类型变量</h2><p>不能以诸如“new T(…)”, “new T[…]”, “T.class”的形式使用类型变量。Java禁止我们这样做的原因很简单，编译期不知道创建那种类型的对象。T只是一个占位符。</p>
<h2 id="对静态成员的一些限制"><a href="#对静态成员的一些限制" class="headerlink" title="对静态成员的一些限制"></a>对静态成员的一些限制</h2><p>注意，这里我们强调了泛型类。因为普通类中可以定义静态泛型方法，如上面我们提到的ArrayAlg类中的getMiddle方法。关于为什么有这样的规定，请考虑下面的代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span>&lt;<span class="title">T</span>&gt; </span>&#123; </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> T name; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">getName</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    ... </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们知道，在同一时刻，内存中可能存在不只一个People<t>类实例。假设现在内存中存在着一个People<string>对象和People<integer>对象，而类的静态变量与静态方法是所有类实例共享的。那么问题来了，name究竟是String类型还是Integer类型呢？基于这个原因，Java中不允许在泛型类的静态上下文中使用类型变量。</integer></string></t></p>
<p>泛型在我们编码的过程中，特别是写一些框架或者通用组件时是非常有帮助的。</p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Activity启动模式之大结局</title>
    <url>/2017/07/21/activity-launchmode-summary/</url>
    <content><![CDATA[<center><img src="http://upload-images.jianshu.io/upload_images/1319879-e481b89f30352afc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="lastday.jpg"></center>

<p>谈起Activity的启动模式必不可少的要是launchMode、Flags、taskAffinity这三块知识点，上一篇文章 <a href="http://www.jianshu.com/p/51a28a380c6a" target="_blank" rel="noopener">深入理解Activity启动模式之launchMode</a> 看过的同学都知道该文章对launchMode做了非常详细的讲解，所以本片文章承接上一篇文章对剩余的Flags、taskAffinity这两块做讲述，希望看完此片文章的同学们此后遇到Activity的启动模式相关问题或使用场景再也不用查资料^_^。<br>（PS：本篇文章的实验数据都基于Android7.0）</p>
<h2 id="Activity启动模式之Flags"><a href="#Activity启动模式之Flags" class="headerlink" title="Activity启动模式之Flags"></a>Activity启动模式之Flags</h2><p>先来看看常用Flags：</p>
<blockquote>
<ul>
<li>Intent.FLAG_ACTIVITY_SINGLE_TOP<br>  该标志位表示使用singleTop模式来启动一个Activity，与在清单文件指定android:launchMode=”singleTop”效果相同。</li>
<li>Intent.FLAG_ACTIVITY_CLEAR_TOP<br>  该标志位表示使用singleTask模式来启动一个Activity，与在清单文件指定android：launchMode=”singleTask”效果相同。</li>
<li>Intent.FLAG_ACTIVITY_NO_HISTORY<br>  使用该模式来启动Activity，当该Activity启动其他Activity后，该Activity就被销毁了，不会保留在任务栈中。如A-B,B中以这种模式启动C，C再启动D，则任务栈只有ABD。</li>
<li>Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS<br>  使用该标识位启动的Activity不添加到最近应用列表，也即我们从最近应用里面查看不到我们启动的这个activity。与属性android:excludeFromRecents=”true”效果相同。</li>
<li>Intent.FLAG_ACTIVITY_NEW_TASK<br>该标志位表示使用一个新的Task来启动一个Activity，相当于在清单文件中给Activity指定“singleTask”启动模式。通常我们在Service启动Activity时，由于Service中并没有Activity任务栈，所以必须使用该Flag来创建一个新的Task。</li>
</ul>
</blockquote>
<p>使用也非常简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(context, HomeActivity.class);</span><br><span class="line">    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">    context.startActivity(<span class="keyword">new</span> Intent(context, HomeActivity.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="android-taskAffinity"><a href="#android-taskAffinity" class="headerlink" title="android:taskAffinity"></a>android:taskAffinity</h2><p>我们重点来看看taskAffinity这个标签</p>
<blockquote>
<p><a href="https://developer.android.com/guide/topics/manifest/activity-element.html#reparent" target="_blank" rel="noopener">android:taskAffinity 官网解释</a><br>与 Activity 有着亲和关系的任务。从概念上讲，具有相同亲和关系的 Activity 归属同一任务（从用户的角度来看，则是归属同一“应用”）。 任务的亲和关系由其根 Activity 的亲和关系确定。<br>亲和关系确定两件事 - Activity 更改到的父项任务（请参阅 allowTaskReparenting 属性）和通过 FLAG_ACTIVITY_NEW_TASK 标志启动 Activity 时将用来容纳它的任务。</p>
</blockquote>
<blockquote>
<p>默认情况下，应用中的所有 Activity 都具有相同的亲和关系。您可以设置该属性来以不同方式组合它们，甚至可以将在不同应用中定义的 Activity 置于同一任务内。 要指定 Activity 与任何任务均无亲和关系，请将其设置为空字符串。</p>
</blockquote>
<blockquote>
<p>如果未设置该属性，则 Activity 继承为应用设置的亲和关系（请参阅 <application> 元素的 taskAffinity 属性）。 应用默认亲和关系的名称是 <manifest> 元素设置的软件包名称。</manifest></application></p>
</blockquote>
<p>我们来总结一下上边文字包含的信息：</p>
<ul>
<li>TASK的taskAffinity是有它的根Activity的taskAffinity决定的；</li>
<li>Activity的taskAffinity默认值为所在应用程序的包名；</li>
<li>taskAffinity影响Activity的任务（TASK）从属；<blockquote>
<p>我们先来看看截取的一段堆栈信息：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="function">Running <span class="title">activities</span> <span class="params">(most recent first)</span>:</span></span><br><span class="line">      TaskRecord&#123;f51ba40 #6608 A=com.tzx.launchmodel U=0 StackId=1 sz=2&#125;</span><br><span class="line">        Run #3: ActivityRecord&#123;6158b8a u0 com.tzx.launchmodel/.BActivity t6608&#125;</span><br><span class="line">      TaskRecord&#123;3e0d8d2 #6609 A=com.tzx.single U=0 StackId=1 sz=1&#125;</span><br><span class="line">        Run #2: ActivityRecord&#123;d387da3 u0 com.tzx.launchmodel/.CActivity t6609&#125;</span><br><span class="line">      TaskRecord&#123;f51ba40 #6608 A=com.tzx.launchmodel U=0 StackId=1 sz=2&#125;</span><br><span class="line">        Run #1: ActivityRecord&#123;a0bfd79 u0 com.tzx.launchmodel/.AActivity t6608&#125;</span><br><span class="line"><span class="comment">//该堆栈信息对应的AndroidManifest.xml:</span></span><br><span class="line">&lt;manifest xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="keyword">package</span>=<span class="string">"com.tzx.launchmodel"</span> &gt;</span><br><span class="line">    &lt;application</span><br><span class="line">        android:allowBackup=<span class="string">"true"</span></span><br><span class="line">        android:icon=<span class="string">"@mipmap/ic_launcher"</span></span><br><span class="line">        android:label=<span class="string">"@string/app_name"</span></span><br><span class="line">        android:supportsRtl=<span class="string">"true"</span></span><br><span class="line">        android:theme=<span class="string">"@style/AppTheme"</span> &gt;</span><br><span class="line">        &lt;activity android:name=<span class="string">".AActivity"</span>&gt;</span><br><span class="line">            &lt;intent-filter&gt;</span><br><span class="line">                &lt;action android:name=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span><br><span class="line">                &lt;category android:name=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span><br><span class="line">            &lt;/intent-filter&gt;</span><br><span class="line">        &lt;/activity&gt;</span><br><span class="line">        &lt;activity android:name=<span class="string">".BActivity"</span>/&gt;</span><br><span class="line">        &lt;activity android:name=<span class="string">".CActivity"</span></span><br><span class="line">                  android:taskAffinity=<span class="string">"com.tzx.single"</span></span><br><span class="line">            android:launchMode=<span class="string">"singleInstance"</span>/&gt;</span><br><span class="line">    &lt;/application&gt;</span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<blockquote>
<p>其中TaskRecord中的A的值就是taskAffinity。</p>
</blockquote>
<ul>
<li>taskAffinity一班与singleTask、singleInstance和allowTaskReparenting标签搭配使用。<blockquote>
<p>这句话又怎么理解呢？<br>在解释这句时我先想和大家先聊聊Android手机在使用过程中为了手机软件运行的更加流畅，我们一般都会清理后台任务。这个任务列表是我们最能直观的看到任务的存在痕迹。在这里我们会看到很多情况：一个应用程序的所有Activity一个任务，多个应用程序的不同Activity一个任务，一个应用程序不同Activity在不同任务中。此时是不是感觉很懵逼，没关系接下来我会讲述为什么会这样：</p>
</blockquote>
<center><img src="http://upload-images.jianshu.io/upload_images/1319879-0ea2325edccb02da.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="taskAffinity.jpg"></center><blockquote>
<ul>
<li>一个应用程序的所有Activity一个任务：一班情况下都这样（不设置taskAffinity）。</li>
<li>多个应用程序的不同Activity一个任务：一个应用程序启动另外一个应用程序的Activity并且这里只能是standard或者singleTop模式。因为我们得出的第三个结论taskAffinity只会对singleTask、singleInstance有影响，所以在启动standard或者singleTop模式的Activity时不会对比taskAffinity，会直接在启动它的TASK中启动。而启动singleTask、singleInstance模式的Activity只能在对应的taskAffinity的TASK中。</li>
<li>一个应用程序不同Activity在不同任务中：当在应用程序中我们启动singleTask模式的Activity时会寻找与该Activity的taskAffinity相同的TASK当中启动，如果没有则会新建一个TASK并且这个TASK在任务列表里展示。这时可能比较细心的同学会问singleInstance模式的Activity呢？它每次都会启动一个TASK，那么任务列表里面会展示这个TASK么？如果任务列表中不存在TASK与该singleInstance模式的Activity的taskAffinity<br>相同，那么该TASK出现中在任务列表。如果有那么不出现在任务列表。</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="android-allowTaskReparenting"><a href="#android-allowTaskReparenting" class="headerlink" title="android:allowTaskReparenting"></a>android:allowTaskReparenting</h2><p>android:allowTaskReparenting这个标签我们单独抽出来讲一下，为什么呢？因为我感觉android:allowTaskReparenting和taskAffinity没啥关系，至与launchMode有关！！！</p>
<blockquote>
<p> <a href="https://developer.android.com/guide/topics/manifest/activity-element.html#reparent" target="_blank" rel="noopener">android:allowTaskReparenting 官网解释</a><br>当启动 Activity 的任务接下来转至前台时，Activity 是否能从该任务转移至与其有亲和关系的任务 —“true”表示它可以转移，“false”表示它仍须留在启动它的任务处。<br>如果未设置该属性，则对 Activity 应用由 <application> 元素的相应 allowTaskReparenting 属性设置的值。 默认值为“false”。</application></p>
</blockquote>
<blockquote>
<p>正常情况下，当 Activity 启动时，会与启动它的任务关联，并在其整个生命周期中一直留在该任务处。您可以利用该属性强制 Activity 在其当前任务不再显示时将其父项更改为与其有亲和关系的任务。该属性通常用于使应用的 Activity 转移至与该应用关联的主任务。</p>
</blockquote>
<blockquote>
<p>例如，如果电子邮件包含网页链接，则点击链接会调出可显示网页的 Activity。 该 Activity 由浏览器应用定义，但作为电子邮件任务的一部分启动。 如果将其父项更改为浏览器任务，它会在浏览器下一次转至前台时显示，当电子邮件任务再次转至前台时则会消失。</p>
</blockquote>
<blockquote>
<p>Activity 的亲和关系由 taskAffinity 属性定义。 任务的亲和关系通过读取其根 Activity 的亲和关系来确定。因此，按照定义，根 Activity 始终位于具有相同亲和关系的任务之中。 由于具有“singleTask”或“singleInstance”启动模式的 Activity 只能位于任务的根，因此更改父项仅限于“standard”和“singleTop”模式。 （另请参阅 launchMode 属性。）</p>
</blockquote>
<p>上面文字叙述总结为一句话：android:allowTaskReparenting可以让Activity在TASK中转移，但该Activity时能是“standard”和“singleTop”模式。<br>至于为什么在讲taskAffinity的时候已经介绍清楚了。实用场景官网的描述中也有，大家可以参考使用。</p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>activity</tag>
        <tag>launchMode</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Activity启动模式之launchMode</title>
    <url>/2017/07/20/activity-launchmode/</url>
    <content><![CDATA[<p>Android每个Application都是由若干个四大组件组成的。每个页面都是一个Activity，当需要打开相应页面（Activity）时系统会创建他们的实例并把他们一一放入栈中进行管理。任务栈是一种“后进先出”的栈结构，通过back键，我们可以发现这些Activity会一一出栈（PS：不断返回上一页）。如果每次启动Activity都创建一个实例，会不会很浪费资源。能不能进行Activity的复用呢？Android系统在设计就考虑到这个问题，所以提供了同步的Activity启动模式，在不同条件下进行Activity的复用。其中都包括：Standard、SingleTop、SingleTask、SingleInstance。<br>（PS：本篇文章的实验数据都基于Android7.0）</p>
<p>在讲述Activity启动模式之前我们先了解一些基础概念：</p>
<blockquote>
<p>Application 是组件的集合。<br>Process 操作系统调度的单位。<br>Task是指在执行特定作业时与用户交互的一系列 Activity。Task以栈的形式管理Activity集合。</p>
<ul>
<li>一个应用中可以有多个Task</li>
<li>不同应用的Activity可以放在同一个Task中进行管理</li>
<li>一个应用中可以有多个Process</li>
<li>Task可以运行在不同进程</li>
</ul>
</blockquote>
<h1 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h1><blockquote>
<p>标准启动模式，也是activity的默认启动模式。在这种模式下启动的activity可以被多次实例化，即在同一个任务中可以存在多个activity的实例，每个实例都会处理一个Intent对象。</p>
</blockquote>
<center><img src="http://upload-images.jianshu.io/upload_images/1319879-23d7d680ef04ee97.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="standard.png"></center>

<ul>
<li>AndroidManifest.xml</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;application</span><br><span class="line">	android:allowBackup=<span class="string">"true"</span></span><br><span class="line">    android:icon=<span class="string">"@mipmap/ic_launcher"</span></span><br><span class="line">    android:label=<span class="string">"@string/app_name"</span></span><br><span class="line">    android:supportsRtl=<span class="string">"true"</span></span><br><span class="line">    android:theme=<span class="string">"@style/AppTheme"</span> &gt;</span><br><span class="line">    &lt;activity android:name=<span class="string">".AActivity"</span></span><br><span class="line">        android:launchMode=<span class="string">"standard"</span>&gt;</span><br><span class="line">        &lt;intent-filter&gt;</span><br><span class="line">            &lt;action android:name=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span><br><span class="line"></span><br><span class="line">            &lt;category android:name=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span><br><span class="line">        &lt;/intent-filter&gt;</span><br><span class="line">    &lt;/activity&gt;</span><br><span class="line">    &lt;activity android:name=<span class="string">".BActivity"</span></span><br><span class="line">              android:launchMode=<span class="string">"standard"</span>/&gt;</span><br><span class="line">&lt;/application&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>Logcat输出</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">3459</span>-<span class="number">3459</span> D/$$$AActivity: onCreate: currentActivityName:AActivity currentTaskID:<span class="number">6384</span></span><br><span class="line"><span class="number">3459</span>-<span class="number">3459</span> D/$$$AActivity: onClickBtn: AActivity start BActivity</span><br><span class="line"><span class="number">3459</span>-<span class="number">3459</span> D/$$$BActivity: onCreate: currentActivityName:BActivity currentTaskID:<span class="number">6384</span></span><br><span class="line"><span class="number">3459</span>-<span class="number">3459</span> D/$$$BActivity: onClickBtn: BActivity start AActivity</span><br><span class="line"><span class="number">3459</span>-<span class="number">3459</span> D/$$$AActivity: onCreate: currentActivityName:AActivity currentTaskID:<span class="number">6384</span></span><br><span class="line"><span class="number">3459</span>-<span class="number">3459</span> D/$$$AActivity: onClickBtn: AActivity start BActivity</span><br><span class="line"><span class="number">3459</span>-<span class="number">3459</span> D/$$$BActivity: onCreate: currentActivityName:BActivity currentTaskID:<span class="number">6384</span></span><br></pre></td></tr></table></figure>
<ul>
<li>当前任务栈</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="function">Running <span class="title">activities</span> <span class="params">(most recent first)</span>:</span></span><br><span class="line">     TaskRecord&#123;3efeab #6384 A=com.tzx.launchmodel U=0 StackId=1 sz=4&#125;</span><br><span class="line">       Run #4: ActivityRecord&#123;18878b0 u0 com.tzx.launchmodel/.BActivity t6384&#125;</span><br><span class="line">       Run #3: ActivityRecord&#123;5a7f957 u0 com.tzx.launchmodel/.AActivity t6384&#125;</span><br><span class="line">       Run #2: ActivityRecord&#123;559bd5f u0 com.tzx.launchmodel/.BActivity t6384&#125;</span><br><span class="line">       Run #1: ActivityRecord&#123;facb908 u0 com.tzx.launchmodel/.AActivity t6384&#125;</span><br></pre></td></tr></table></figure>
<h1 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h1><blockquote>
<p>启动的activity的实例已经存在于任务桟的桟顶，那么再启动这个Activity时，不会创建新的实例，而是重用位于栈顶的那个实例，并且会调用该实例的onNewIntent()方法将Intent对象传递到这个实例中。</p>
</blockquote>
<center><img src="http://upload-images.jianshu.io/upload_images/1319879-c7638e6221ef6e98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="singleTop.png"></center>

<ul>
<li>AndroidManifest.xml</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;application</span><br><span class="line">    android:allowBackup=<span class="string">"true"</span></span><br><span class="line">    android:icon=<span class="string">"@mipmap/ic_launcher"</span></span><br><span class="line">    android:label=<span class="string">"@string/app_name"</span></span><br><span class="line">    android:supportsRtl=<span class="string">"true"</span></span><br><span class="line">    android:theme=<span class="string">"@style/AppTheme"</span> &gt;</span><br><span class="line">    &lt;activity android:name=<span class="string">".AActivity"</span></span><br><span class="line">        android:launchMode=<span class="string">"standard"</span>&gt;</span><br><span class="line">        &lt;intent-filter&gt;</span><br><span class="line">            &lt;action android:name=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span><br><span class="line"></span><br><span class="line">            &lt;category android:name=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span><br><span class="line">        &lt;/intent-filter&gt;</span><br><span class="line">    &lt;/activity&gt;</span><br><span class="line">    &lt;activity android:name=<span class="string">".BActivity"</span></span><br><span class="line">              android:launchMode=<span class="string">"singleTop"</span>/&gt;</span><br><span class="line">&lt;/application&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>Logcat输出</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">14450</span>-<span class="number">14450</span> D/$$$AActivity: onCreate: currentActivityName:AActivity currentTaskID:<span class="number">6386</span></span><br><span class="line"><span class="number">14450</span>-<span class="number">14450</span> D/$$$AActivity: onClickBtn: AActivity start BActivity</span><br><span class="line"><span class="number">14450</span>-<span class="number">14450</span> D/$$$BActivity: onCreate: currentActivityName:BActivity currentTaskID:<span class="number">6386</span></span><br><span class="line"><span class="number">14450</span>-<span class="number">14450</span> D/$$$BActivity: onClickBtn: BActivity start AActivity</span><br><span class="line"><span class="number">14450</span>-<span class="number">14450</span> D/$$$AActivity: onCreate: currentActivityName:AActivity currentTaskID:<span class="number">6386</span></span><br><span class="line"><span class="number">14450</span>-<span class="number">14450</span> D/$$$AActivity: onClickBtn: AActivity start BActivity</span><br><span class="line"><span class="number">14450</span>-<span class="number">14450</span> D/$$$BActivity: onCreate: currentActivityName:BActivity currentTaskID:<span class="number">6386</span></span><br><span class="line"><span class="number">14450</span>-<span class="number">14450</span> D/$$$BActivity: onClickBtn: BActivity start BActivity</span><br><span class="line"><span class="number">14450</span>-<span class="number">14450</span> D/$$$BActivity: onNewIntent()</span><br><span class="line"><span class="number">14450</span>-<span class="number">14450</span> D/$$$BActivity: onClickBtn: BActivity start BActivity</span><br><span class="line"><span class="number">14450</span>-<span class="number">14450</span> D/$$$BActivity: onNewIntent()</span><br></pre></td></tr></table></figure>
<ul>
<li>当前任务栈</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="function">Running <span class="title">activities</span> <span class="params">(most recent first)</span>:</span></span><br><span class="line">      TaskRecord&#123;fba1a37 #6386 A=com.tzx.launchmodel U=0 StackId=1 sz=4&#125;</span><br><span class="line">        Run #5: ActivityRecord&#123;9609e73 u0 com.tzx.launchmodel/.BActivity t6386&#125;</span><br><span class="line">        Run #4: ActivityRecord&#123;50fff56 u0 com.tzx.launchmodel/.AActivity t6386&#125;</span><br><span class="line">        Run #3: ActivityRecord&#123;1c403e9 u0 com.tzx.launchmodel/.BActivity t6386&#125;</span><br><span class="line">        Run #2: ActivityRecord&#123;3c41ba4 u0 com.tzx.launchmodel/.AActivity t6386&#125;</span><br></pre></td></tr></table></figure>
<h1 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h1><blockquote>
<p>启动模式为singleTask，那么系统总会在一个新任务的最底部（root）启动这个activity，并且被这个activity启动的其他activity会和该activity同时存在于这个新任务中。如果系统中已经存在这样的一个activity则会重用这个实例，并且调用他的onNewIntent()方法。即，这样的一个activity在系统中只会存在一个实例。</p>
</blockquote>
<center><img src="http://upload-images.jianshu.io/upload_images/1319879-e3855b9fe746f456.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="singleTask.png"></center>

<ul>
<li>AndroidManifest.xml</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;application</span><br><span class="line">    android:allowBackup=<span class="string">"true"</span></span><br><span class="line">    android:icon=<span class="string">"@mipmap/ic_launcher"</span></span><br><span class="line">    android:label=<span class="string">"@string/app_name"</span></span><br><span class="line">    android:supportsRtl=<span class="string">"true"</span></span><br><span class="line">    android:theme=<span class="string">"@style/AppTheme"</span> &gt;</span><br><span class="line">    &lt;activity android:name=<span class="string">".AActivity"</span></span><br><span class="line">        android:launchMode=<span class="string">"standard"</span>&gt;</span><br><span class="line">        &lt;intent-filter&gt;</span><br><span class="line">            &lt;action android:name=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span><br><span class="line"></span><br><span class="line">            &lt;category android:name=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span><br><span class="line">        &lt;/intent-filter&gt;</span><br><span class="line">    &lt;/activity&gt;</span><br><span class="line">    &lt;activity android:name=<span class="string">".BActivity"</span></span><br><span class="line">              android:launchMode=<span class="string">"singleTask"</span>/&gt;</span><br><span class="line">    &lt;activity android:name=<span class="string">".CActivity"</span></span><br><span class="line">        android:process=<span class="string">":remote"</span>/&gt;</span><br><span class="line">&lt;/application&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>Logcat输出</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">19684</span>-<span class="number">19684</span> D/$$$AActivity: onCreate: currentActivityName:AActivity currentTaskID:<span class="number">6394</span></span><br><span class="line"><span class="number">19684</span>-<span class="number">19684</span> D/$$$AActivity: onClickBtn: AActivity start BActivity</span><br><span class="line"><span class="number">19684</span>-<span class="number">19684</span> D/$$$BActivity: onCreate: currentActivityName:BActivity currentTaskID:<span class="number">6394</span></span><br><span class="line"><span class="number">19684</span>-<span class="number">19684</span> D/$$$BActivity: onClickBtn: BActivity start AActivity</span><br><span class="line"><span class="number">19684</span>-<span class="number">19684</span> D/$$$AActivity: onCreate: currentActivityName:AActivity currentTaskID:<span class="number">6394</span></span><br><span class="line"><span class="number">19684</span>-<span class="number">19684</span> D/$$$AActivity: onClickBtn: AActivity start CActivity</span><br><span class="line"><span class="number">19921</span>-<span class="number">19921</span> D/$$$CActivity: onCreate: currentActivityName:CActivity currentTaskID:<span class="number">6394</span></span><br><span class="line"><span class="number">19921</span>-<span class="number">19921</span> D/$$$CActivity: onClickBtn: CActivity start AActivity</span><br><span class="line"><span class="number">19684</span>-<span class="number">19684</span> D/$$$AActivity: onCreate: currentActivityName:AActivity currentTaskID:<span class="number">6394</span></span><br><span class="line"><span class="number">19684</span>-<span class="number">19684</span> D/$$$AActivity: onClickBtn: AActivity start BActivity</span><br><span class="line"><span class="number">19684</span>-<span class="number">19684</span> D/$$$BActivity: onNewIntent()</span><br><span class="line"><span class="number">19684</span>-<span class="number">19684</span> D/$$$BActivity: onClickBtn: BActivity start BActivity</span><br><span class="line"><span class="number">19684</span>-<span class="number">19684</span> D/$$$BActivity: onNewIntent()</span><br></pre></td></tr></table></figure>
<ul>
<li>当前任务栈</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="function">Running <span class="title">activities</span> <span class="params">(most recent first)</span>:</span></span><br><span class="line">      TaskRecord&#123;8e8fb09 #6394 A=com.tzx.launchmodel U=0 StackId=1 sz=2&#125;</span><br><span class="line">        Run #7: ActivityRecord&#123;7489fc u0 com.tzx.launchmodel/.BActivity t6394&#125;</span><br><span class="line">        Run #6: ActivityRecord&#123;9a5d10e u0 com.tzx.launchmodel/.AActivity t6394&#125;</span><br></pre></td></tr></table></figure>
<h1 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h1><blockquote>
<p>总是在新的任务中开启，并且这个新的任务中有且只有这一个实例。</p>
</blockquote>
<center><img src="http://upload-images.jianshu.io/upload_images/1319879-4adba415bb2c3fdd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="singleInstance.png"></center>

<ul>
<li>AndroidManifest.xml</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;application</span><br><span class="line">    android:allowBackup=<span class="string">"true"</span></span><br><span class="line">    android:icon=<span class="string">"@mipmap/ic_launcher"</span></span><br><span class="line">    android:label=<span class="string">"@string/app_name"</span></span><br><span class="line">    android:supportsRtl=<span class="string">"true"</span></span><br><span class="line">    android:theme=<span class="string">"@style/AppTheme"</span> &gt;</span><br><span class="line">    &lt;activity android:name=<span class="string">".AActivity"</span></span><br><span class="line">        android:launchMode=<span class="string">"standard"</span>&gt;</span><br><span class="line">        &lt;intent-filter&gt;</span><br><span class="line">            &lt;action android:name=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span><br><span class="line"></span><br><span class="line">            &lt;category android:name=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span><br><span class="line">        &lt;/intent-filter&gt;</span><br><span class="line">    &lt;/activity&gt;</span><br><span class="line">    &lt;activity android:name=<span class="string">".BActivity"</span></span><br><span class="line">              android:launchMode=<span class="string">"singleInstance"</span>/&gt;</span><br><span class="line">    &lt;activity android:name=<span class="string">".CActivity"</span></span><br><span class="line">        android:process=<span class="string">":remote"</span>/&gt;</span><br><span class="line">&lt;/application&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>Logcat输出</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">25016</span>-<span class="number">25016</span> D/$$$AActivity: onCreate: currentActivityName:AActivity currentTaskID:<span class="number">6396</span></span><br><span class="line"><span class="number">25016</span>-<span class="number">25016</span> D/$$$AActivity: onClickBtn: AActivity start BActivity</span><br><span class="line"><span class="number">25016</span>-<span class="number">25016</span> D/$$$BActivity: onCreate: currentActivityName:BActivity currentTaskID:<span class="number">6397</span></span><br><span class="line"><span class="number">25016</span>-<span class="number">25016</span> D/$$$BActivity: onClickBtn: BActivity start AActivity</span><br><span class="line"><span class="number">25016</span>-<span class="number">25016</span> D/$$$AActivity: onCreate: currentActivityName:AActivity currentTaskID:<span class="number">6396</span></span><br><span class="line"><span class="number">25016</span>-<span class="number">25016</span> D/$$$AActivity: onClickBtn: AActivity start CActivity</span><br><span class="line"><span class="number">26003</span>-<span class="number">26003</span> D/$$$CActivity: onCreate: currentActivityName:CActivity currentTaskID:<span class="number">6396</span></span><br><span class="line"><span class="number">26003</span>-<span class="number">26003</span> D/$$$CActivity: onClickBtn: CActivity start BActivity</span><br><span class="line"><span class="number">25016</span>-<span class="number">25016</span> D/$$$BActivity: onNewIntent()</span><br></pre></td></tr></table></figure>
<ul>
<li>当前任务栈</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="function">Running <span class="title">activities</span> <span class="params">(most recent first)</span>:</span></span><br><span class="line">     TaskRecord&#123;d5934c9 #6397 A=com.tzx.launchmodel U=0 StackId=1 sz=1&#125;</span><br><span class="line">       Run #9: ActivityRecord&#123;986e7ce u0 com.tzx.launchmodel/.BActivity t6397&#125;</span><br><span class="line">     TaskRecord&#123;f282078 #6396 A=com.tzx.launchmodel U=0 StackId=1 sz=3&#125;</span><br><span class="line">       Run #8: ActivityRecord&#123;d2c75de u0 com.tzx.launchmodel/.CActivity t6396&#125;</span><br><span class="line">       Run #7: ActivityRecord&#123;2d3a2eb u0 com.tzx.launchmodel/.AActivity t6396&#125;</span><br><span class="line">       Run #6: ActivityRecord&#123;2ca9351 u0 com.tzx.launchmodel/.AActivity t6396&#125;</span><br></pre></td></tr></table></figure>
<p>本文叙述性的文字非常少，主要通过其代码和其运行结果然后得出我们需要的结论。每一种设计模式我都画了一副图，可以使大家理解记忆深刻。<br>Activity启动模式到这里就结束了么，然而并没有。之前看过其他类似文章或者书籍的同学都知道还有Activity的Flags和 <code>android:taskAffinity</code> 标签对Activity的启动有影响。这些内容我们放在下一张<a href="http://www.jianshu.com/p/8bc28d794e11" target="_blank" rel="noopener">深入理解Activity启动模式之大结局</a>中讲述，有兴趣的同学可以点击阅读～！</p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>activity</tag>
        <tag>launchMode</tag>
      </tags>
  </entry>
  <entry>
    <title>深入解析AIDL的实现：Messenger</title>
    <url>/2017/06/29/android-aidl-messenger/</url>
    <content><![CDATA[<p>Messenger可以翻译为信使，顾名思义，通过它可以在不同进程中传递Message对象，在Message中放入我们需要传递的数据，就可以轻松地实现数据的进程间传递了。Messenger是一种轻量级的IPC方案，它是AIDL在Android中的一种经典实践。</p>
<p>【本篇文章中讲述的都是跨进程通信，在相同进程中使用Messenger文章不做讲述~！~！】</p>
<p>文章主要讲述Messenger利用AIDL进行进程间通信，其中不免会涉及到AIDL的知识点。对ADIL不熟悉的同学可以阅读我之前写过的一篇<a href="http://www.jianshu.com/p/419cc7b95358" target="_blank" rel="noopener">Android：IPC之AIDL的学习和总结</a>。</p>
<p>本来想先通过Demo来引出Messenger，然后再根据Demo一步一步分析源码。但是最后还是觉得本次应该先讲述Messenger的基础知识，结合aidl的知识分析源码，然后再通过讲述Demo深入一些分析Android当时设计Messenger的心情。<br>先来看看Messenger的主要成员变量和成员方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Messenger</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IMessenger mTarget;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Messenger</span><span class="params">(Handler target)</span> </span>&#123;</span><br><span class="line">        mTarget = target.getIMessenger();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Message message)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        mTarget.send(message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">getBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mTarget.asBinder();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**其他代码省略**/</span></span><br><span class="line">	<span class="comment">//重点mTarget为IMessenger.Stub.asInterface</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Messenger</span><span class="params">(IBinder target)</span> </span>&#123;</span><br><span class="line">        mTarget = IMessenger.Stub.asInterface(target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Messenger一共有两个构造函数，一个通过IBinder构造，一个是通过Handler构造。<br>两种实现方式意义相同么（这是一个非常重要的问题）？<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Handler#getIMessenger</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> IMessenger <span class="title">getIMessenger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (mQueue) &#123;</span><br><span class="line">		<span class="keyword">if</span> (mMessenger != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> mMessenger;</span><br><span class="line">		&#125;</span><br><span class="line">		mMessenger = <span class="keyword">new</span> MessengerImpl();</span><br><span class="line">		<span class="keyword">return</span> mMessenger;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Handler#MessengerImpl</span></span><br><span class="line"><span class="comment">//重点MessengerImp是继承IMessenger.Stub</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerImpl</span> <span class="keyword">extends</span> <span class="title">IMessenger</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">		msg.sendingUid = Binder.getCallingUid();</span><br><span class="line">		Handler.<span class="keyword">this</span>.sendMessage(msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>IMessenger是一个aidl接口,MessengerImpl为它的实现类<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> android.os;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Message;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line">oneway <span class="class"><span class="keyword">interface</span> <span class="title">IMessenger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(in Message msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>之前介绍的<a href="http://www.jianshu.com/p/419cc7b95358" target="_blank" rel="noopener">Android：IPC之AIDL的学习和总结</a>文章中对aidl接口在编译后生成的Java类文件做了详细的分析和讲解。<br>这次我们再看一遍生成的IMessenger.java文件，对此熟悉的同学可以略过了。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This file is auto-generated.  DO NOT MODIFY.</span></span><br><span class="line"><span class="comment"> * Original file: frameworks/base/core/java/android/os/IMessenger.aidl</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> android.os;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMessenger</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">IInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(android.os.Message msg)</span> <span class="keyword">throws</span> android.os.RemoteException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Local-side IPC implementation stub class. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">IMessenger</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String DESCRIPTOR = <span class="string">"android.os.IMessenger"</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_send = (android.os.IBinder.FIRST_CALL_TRANSACTION +</span><br><span class="line">            <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Construct the stub at attach it to the interface. */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Stub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.attachInterface(<span class="keyword">this</span>, DESCRIPTOR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Cast an IBinder object into an android.os.IMessenger interface,</span></span><br><span class="line"><span class="comment">         * generating a proxy if needed.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> android.os.<span class="function">IMessenger <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> android.os.IMessenger))) &#123;</span><br><span class="line">                <span class="keyword">return</span> ((android.os.IMessenger) iin);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> android.os.IMessenger.Stub.Proxy(obj);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data,</span></span></span><br><span class="line"><span class="function"><span class="params">            android.os.Parcel reply, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">            <span class="keyword">case</span> INTERFACE_TRANSACTION: &#123;</span><br><span class="line">                reply.writeString(DESCRIPTOR);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TRANSACTION_send: &#123;</span><br><span class="line">                data.enforceInterface(DESCRIPTOR);</span><br><span class="line"></span><br><span class="line">                android.os.Message _arg0;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((<span class="number">0</span> != data.readInt())) &#123;</span><br><span class="line">                    _arg0 = android.os.Message.CREATOR.createFromParcel(data);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    _arg0 = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.send(_arg0);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//远端代理类</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">IMessenger</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line"></span><br><span class="line">            Proxy(android.os.IBinder remote) &#123;</span><br><span class="line">                mRemote = remote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mRemote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getInterfaceDescriptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> DESCRIPTOR;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(android.os.Message msg)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">                android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> ((msg != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                        _data.writeInt(<span class="number">1</span>);</span><br><span class="line">                        msg.writeToParcel(_data, <span class="number">0</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        _data.writeInt(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_send, _data, <span class="keyword">null</span>,</span><br><span class="line">                        android.os.IBinder.FLAG_ONEWAY);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看完这个IMessenger.java这个类，我们再回一下刚才Messenger的两个构造方法。</p>
<p>使用Handler构造：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Messenger#Messenger</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Messenger</span><span class="params">(Handler target)</span> </span>&#123;</span><br><span class="line">        mTarget = target.getIMessenger();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//Handler#getIMessenger</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> IMessenger <span class="title">getIMessenger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mQueue) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mMessenger != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> mMessenger;</span><br><span class="line">        &#125;</span><br><span class="line">        mMessenger = <span class="keyword">new</span> MessengerImpl();</span><br><span class="line">        <span class="keyword">return</span> mMessenger;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Handler#MessengerImpl</span></span><br><span class="line"><span class="comment">//重点MessengerImp是继承IMessenger.Stub</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerImpl</span> <span class="keyword">extends</span> <span class="title">IMessenger</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        msg.sendingUid = Binder.getCallingUid();</span><br><span class="line">        Handler.<span class="keyword">this</span>.sendMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用Handler构造出来的Messenger的mTarget成员变量类型为IMessenger.Stub即Binder的实现类。</p>
<p>使用IBinder构造：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**其他代码省略**/</span></span><br><span class="line"><span class="comment">//重点mTarget为IMessenger.Stub.asInterface</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Messenger</span><span class="params">(IBinder target)</span> </span>&#123;</span><br><span class="line">	mTarget = IMessenger.Stub.asInterface(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>IMessenger.java类中我们可以看到IMessenger.Stub.asInterface方法获得是IMessenger.Proxy类型对象，为Binder的代理类。这样构造出来的Messenger即为Binder的代理类。</p>
<p>通过源码的详细比较我们得出了结论：</p>
<blockquote>
<ul>
<li>使用Handler构造出来的Messenger为Binder的实现类；</li>
<li>使用使用IBinder构造构造出来的Messenger为Binder的代理类；</li>
</ul>
</blockquote>
<p>到这里我们队Messenger代码的研究就差不多结束了，接下来我们现在实现一个简单的利用Messenger在两个不同的进程进行简单通信的例子，希望通过这个Demo的讲解能将我们前面的知识消化吸收。<br>现在看看服务端的代码<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MessengerService"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">            String msgString = msg.getData().getString(<span class="string">"msg"</span>);</span><br><span class="line">            <span class="keyword">if</span> (!TextUtils.isEmpty(msgString)) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"handleMessage: msg = ["</span> + msgString + <span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建service端处理消息的Messenger</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Messenger mMessenger = <span class="keyword">new</span> Messenger(<span class="keyword">new</span> MessengerHandler());</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mMessenger.getBinder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>客户端代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MessengerActivity"</span>;</span><br><span class="line">    <span class="keyword">private</span> Messenger mService;</span><br><span class="line">    <span class="keyword">private</span> ServiceConnection mConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//构造客户端的Messenger往服务端发消息</span></span><br><span class="line">            mService = <span class="keyword">new</span> Messenger(service);</span><br><span class="line">            Message msg = Message.obtain();</span><br><span class="line">            Bundle data = <span class="keyword">new</span> Bundle();</span><br><span class="line">            String msgString = <span class="string">"hello ,this is client."</span>;</span><br><span class="line">            data.putString(<span class="string">"msg"</span>, msgString);</span><br><span class="line">            msg.setData(data);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mService.send(msg);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_messenger);</span><br><span class="line">        bindService(<span class="keyword">new</span> Intent(<span class="keyword">this</span>, MessengerService.class),mConnection,</span><br><span class="line">                Context.BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        unbindService(mConnection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将MessengerService在AndroidManifest.xml注册在另个一remote进程中：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;service android:name=<span class="string">".MessengerService"</span></span><br><span class="line">                 android:enabled=<span class="string">"true"</span></span><br><span class="line">                 android:exported=<span class="string">"true"</span></span><br><span class="line">                 android:process=<span class="string">":remote"</span> /&gt;</span><br></pre></td></tr></table></figure></p>
<p>在com.example.ybb.aidlexample:remote进程中的Logcat输出结果：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">06</span>-<span class="number">28</span> <span class="number">14</span>:<span class="number">55</span>:<span class="number">29.793</span> <span class="number">22206</span>-<span class="number">22206</span>/com.example.ybb.aidlexample:remote D/MessengerService: handleMessage() : msg = [hello ,<span class="keyword">this</span> is client.]</span><br></pre></td></tr></table></figure></p>
<p>是不是感觉很简单呢？那么如果在这个代码上修改一下：让客户端和服务端能互相发送和接受消息。</p>
<p>首相我们回想一下：</p>
<blockquote>
<ul>
<li>发送消息必须要得到远端的Binder对象来构造Messenger；</li>
<li>处理消息必须新建一个Handler来构造Messenger；</li>
</ul>
</blockquote>
<p>就以上这两点我们来重新写一下service端和Client端的代码：<br>Service端代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MessengerService"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> received = <span class="keyword">false</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">            String msgString = msg.getData().getString(<span class="string">"msg"</span>);</span><br><span class="line">            <span class="keyword">if</span> (!TextUtils.isEmpty(msgString)) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"handleMessage: msg = ["</span> + msgString + <span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!received) &#123;</span><br><span class="line">                <span class="comment">//利用Client端接受处理消息的Messenger来发送Message</span></span><br><span class="line">                Messenger client = msg.replyTo;</span><br><span class="line">                Message data = Message.obtain();</span><br><span class="line">                Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">                bundle.putString(<span class="string">"reply"</span>, <span class="string">"Your messages had received~!"</span>);</span><br><span class="line">                data.setData(bundle);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    client.send(data);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                received = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Messenger mMessenger = <span class="keyword">new</span> Messenger(<span class="keyword">new</span> MessengerHandler());</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mMessenger.getBinder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Client端代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MessengerActivity"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">            String replyString = msg.getData().getString(<span class="string">"reply"</span>);</span><br><span class="line">            <span class="keyword">if</span> (!TextUtils.isEmpty(replyString)) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"handleMessage() : reply = ["</span> + replyString + <span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Messenger clientHandler = <span class="keyword">new</span> Messenger(<span class="keyword">new</span> ClientHandler());</span><br><span class="line">    <span class="keyword">private</span> Messenger mService;</span><br><span class="line">    <span class="keyword">private</span> ServiceConnection mConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">            mService = <span class="keyword">new</span> Messenger(service);</span><br><span class="line">            Message msg = Message.obtain();</span><br><span class="line">            Bundle data = <span class="keyword">new</span> Bundle();</span><br><span class="line">            String msgString = <span class="string">"hello ,this is client."</span>;</span><br><span class="line">            data.putString(<span class="string">"msg"</span>, msgString);</span><br><span class="line">            msg.setData(data);</span><br><span class="line">            <span class="comment">//将处理消息的Messenger绑定到消息上带到服务端</span></span><br><span class="line">            msg.replyTo = clientHandler;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mService.send(msg);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_messenger);</span><br><span class="line">        bindService(<span class="keyword">new</span> Intent(<span class="keyword">this</span>, MessengerService.class),mConnection,</span><br><span class="line">                Context.BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        unbindService(mConnection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：</p>
<center><img src="http://upload-images.jianshu.io/upload_images/1319879-d5eb97beef5b0b79.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="messenger-logcat.jpg"></center>

<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>AIDL</tag>
        <tag>Android消息机制</tag>
        <tag>Messenger</tag>
      </tags>
  </entry>
  <entry>
    <title>又一年对Android消息机制（Handler和Looper）的思考</title>
    <url>/2017/06/25/android-handler-looper/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Android消息机制对于每一个Android开发者来说都不陌生，在日常的开发中我们不可避免的要经常涉及这部分的内容。从开发角度来说，Handler是Android消息机制的上层接口，这使得在开发过程中只需要和Handler交互即可。Handler的使用过程很简单，通过它可以轻松的将一个任务切换Handler所在的线程中去执行。很多人认为Handler的作用是更新UI，这的确没错，但是更新UI仅仅是Handler的一个特殊的使用场景。具体来说是这样的；有时候需要再子线程中进行耗时的I/O操作，可能是读取文件或访问网络等。。。。。</p>
<p>本文是是作者在【温故而知新】时，发现自己之前做的笔记再次完善后的，希望对各位读者都有所帮助~！</p>
<center>

<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzEzMTk4NzktYzk2YzAyMDk1OTUzNTI0Ni5qcGc?x-oss-process=image/format,png#pic_center" alt="handler.jpg"><br></p></center><br>思考上边这幅图，让我们带着自己的期待，开始从Handler的使用一步步探究到源代码的愉快之旅。<p></p>
<h1 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h1><h2 id="Handler的对象的创建"><a href="#Handler的对象的创建" class="headerlink" title="Handler的对象的创建"></a>Handler的对象的创建</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> Handler()&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="利用Handler发送消息"><a href="#利用Handler发送消息" class="headerlink" title="利用Handler发送消息"></a>利用Handler发送消息</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Message message = Message.obtain();</span><br><span class="line">message.setData(bundle);</span><br><span class="line">message.setTarget(mHandler);</span><br><span class="line">message.sendToTarget();</span><br><span class="line"><span class="comment">//或者mHandler.handleMessage(message);</span></span><br></pre></td></tr></table></figure>
<p>Handler的使用基本上就是上边所展示的【创建实例、处理消息、发送消息】这些内容。为什么这么简单的使用就能实现线程间的通信呢。。。</p>
<h2 id="Handler创建"><a href="#Handler创建" class="headerlink" title="Handler创建"></a>Handler创建</h2><p>上面我们介绍了Handler的使用，并且带着疑问【Handler使用的每一行代码我们都知道他的具体作用以及异步线程中是怎么传递消息的么】？</p>
<p>我们先从Handler的构造函数开始<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(callback, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(looper, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper, Callback callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(looper, callback, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">null</span>, async);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检测handler是否是静态的，否则会造成内存泄露；</span></span><br><span class="line">    <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">        <span class="keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class="line">        <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">"The following Handler class should be static or leaks might occur: "</span> +</span><br><span class="line">                klass.getCanonicalName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取当前线程的Looper否则抛异常</span></span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mQueue = mLooper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * looper:处理消息的装置</span></span><br><span class="line"><span class="comment"> * callback：处理消息回调，为空则调用handler的handleMessage方法</span></span><br><span class="line"><span class="comment"> * async：是否开启消息同步设置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper, Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    mLooper = looper;</span><br><span class="line">    mQueue = looper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以通过构造函数可以看出来，<code>Handler</code> 的构造函数实际的作用就是实例化内部的 <code>Looper</code> 类型的成员变量 <code>mLooper</code> ，和 <code>Looper</code> 内部的 <code>MessageQueue</code> 类型的变量 <code>mQueue</code>。`Handler 通过构造函数也能设置发送<strong>同步消息</strong> 和 <strong>异步消息</strong> 。</p>
<h2 id="Handler发送消息"><a href="#Handler发送消息" class="headerlink" title="Handler发送消息"></a>Handler发送消息</h2><p>发送消息有两种一种是利用Message，一种是调用Handler的sendMessage方法。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Message.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendToTarget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	target.sendMessage(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是很显然第一种方法内部还是调用Handler#sendMessage方法，接下来我们看看该方法的具体实现。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Handler.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(Message msg)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		delayMillis = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在这个时候delay已经变成when，时间有延迟变为执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">	MessageQueue queue = mQueue;</span><br><span class="line">	<span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">		RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">				<span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</span><br><span class="line">		Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将要发送的Message绑上该Handler的标签</span></span><br><span class="line">	msg.target = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">//如果构造设置了async，那么会为所有的消息打上异步的标签</span></span><br><span class="line">	<span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">		msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将消息将入Handler构造函数中初始化的MessageQueue队列</span></span><br><span class="line">	<span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用用 <code>Handler#sendMessage</code> 方法实际上是一步一步最终将消息与该 <code>Handler</code> 绑定，并放入 <code>Handler</code> 构造函数中初始化的 <code>MessageQueue</code> 队列中。消息队列有进就有出，<code>MessageQueue</code> 不断接受 <code>Handler</code> 发送过来的消息，那么 <code>MessageQueue</code> 是怎么处理这些消息的呢？因为<code>Handler</code> 是内的消息队列是引用的 <code>Looper</code> 中的成员变量，而消息的循环接受处理正式 <code>Looper</code> 的 <code>loop</code> 方法，接下来我们详细讲解并分析<code>Looper</code> 类在 <code>Android的消息机制</code> 中的所扮演的角色！</p>
<h2 id="同步屏障"><a href="#同步屏障" class="headerlink" title="同步屏障"></a>同步屏障</h2><p>在上面的讲述过程中我们了解到 <code>Handler</code> 可以发送 <strong>同步消息</strong> 和 <strong>异步消息</strong> ，那么两种消息有什么不一样呢，又有什么样的作用呢？</p>
<p>我们首先看看<strong>同步屏障</strong> 是怎么产生的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MessageQueue.java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Posts a synchronization barrier to the Looper's message queue.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//发送一个同步的屏障到Looper的消息队列中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> postSyncBarrier(SystemClock.uptimeMillis());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * when:消息的执行时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">(<span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Enqueue a new sync barrier token.</span></span><br><span class="line">    <span class="comment">// We don't need to wake the queue because the purpose of a barrier is to stall it.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> token = mNextBarrierToken++;</span><br><span class="line">        <span class="comment">//msg的target为空</span></span><br><span class="line">        <span class="keyword">final</span> Message msg = Message.obtain();</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        msg.arg1 = token;</span><br><span class="line">        Message prev = <span class="keyword">null</span>;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="comment">//找到一个执行时间比msg更晚或相同同时执行的消息</span></span><br><span class="line">        <span class="keyword">if</span> (when != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.when &lt;= when) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果有那么插入到这个消息的前面，否则这个消息就是连表头部的消息</span></span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>同步消息：Message的setAsynchronous(true)</li>
<li>异步消息：Message的setAsynchronous(false)</li>
<li>同步屏障：Message的target=null</li>
</ul>
<p>任何工作都需要有始有终，看完<strong>同步屏障</strong>的产生之后，可能接下来我们会思考<strong>同步屏障</strong>怎么移除。<br>虽然不同屏障是以同步消息的格式添加到消息队列中的，但是它不会像普通的消息一样被消费。一般都是谁插入的屏障谁负责移除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * when:消息的执行时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeSyncBarrier</span><span class="params">(<span class="keyword">int</span> token)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Remove a sync barrier token from the queue.</span></span><br><span class="line">    <span class="comment">// If the queue is no longer stalled by a barrier then wake it.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        Message prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//链表的头结点</span></span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="comment">//从头结点开始遍历，找到target=null，而且token相等的Message</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; (p.target != <span class="keyword">null</span> || p.arg1 != token)) &#123;</span><br><span class="line">            prev = p;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//指定的消息队列同步屏障令牌尚未发布或已被删除。</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The specified message queue synchronization "</span></span><br><span class="line">                    + <span class="string">" barrier token has not been posted or has already been removed."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> needWake;</span><br><span class="line">        <span class="comment">//如果获取的屏障不是头结点，那么删除该结点，此时不需要唤醒</span></span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">            prev.next = p.next;</span><br><span class="line">            needWake = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//获取的屏障是头结点，而且下一个结点不是屏障那么就需要唤醒</span></span><br><span class="line">            mMessages = p.next;</span><br><span class="line">            needWake = mMessages == <span class="keyword">null</span> || mMessages.target != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//回收这个消息</span></span><br><span class="line">        p.recycleUnchecked();</span><br><span class="line">        <span class="comment">// If the loop is quitting then it is already awake.</span></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 when mQuitting is false.</span></span><br><span class="line">        <span class="comment">// 如果需要唤醒而且没有退出消息的循环，那么执行唤醒</span></span><br><span class="line">        <span class="keyword">if</span> (needWake &amp;&amp; !mQuitting) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里先埋一个点，<strong>同步消息</strong> 、 <strong>异步消息</strong> 和 <strong>同步屏障</strong> 有什么用后面 <code>Looper</code> 中讲解。</p>
<h1 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h1><h2 id="Lopper简介"><a href="#Lopper简介" class="headerlink" title="Lopper简介"></a>Lopper简介</h2><p>Looper在Android的消息机制中扮演着消息循环的角色，具体来说就是它会不停地从MessageQueue中查看是否有新消息，如果有新消息就会立即处理，否则就一直阻塞在哪里。</p>
<h2 id="Looper的构造函数"><a href="#Looper的构造函数" class="headerlink" title="Looper的构造函数"></a>Looper的构造函数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">	mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">	mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过Looper的构造函数我们可以看出，Looper每个实例中都会有一个MessageQueue队列，用来循环读取消息。</p>
<h2 id="Looper的主要成员变量"><a href="#Looper的主要成员变量" class="headerlink" title="Looper的主要成员变量"></a>Looper的主要成员变量</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sThreadLocal.get() will return null unless you've called prepare().</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Looper sMainLooper;  <span class="comment">// guarded by Looper.class</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> MessageQueue mQueue;</span><br><span class="line"><span class="keyword">final</span> Thread mThread;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>sThreadLocal是一个ThreadLocal类型的变量，使用时可以得到当前线程的Looper实例。</li>
<li>sMainLooper表示主线程的Looper实例。</li>
<li>mQueue是Looper实例中的消息队列。</li>
<li>mThread线程类型的对象。</li>
</ul>
</blockquote>
<p><code>ThreadLocal</code> 相关知识可以阅读 <a href="https://dandanlove.blog.csdn.net/article/details/50791483" target="_blank" rel="noopener">Android与Java中的ThreadLocal</a> 。</p>
<p>通过Looper的成员变量我们可以看出来，每个线程只能有一个Loope实例。Looper是通过mQueue不断循环接受消息、分发消息的。</p>
<h2 id="Looper的获取"><a href="#Looper的获取" class="headerlink" title="Looper的获取"></a>Looper的获取</h2><p>为什么这里没有写Looper的创建而是Looper的获取呢？Looper的构造方法能为我们创建可用Looper实例么？仔细看上面的Looper的构造函数我们可以发现，构造函数中没有将Looper实例放入sThreadLocal中。我们看看下边 <figure class="highlight plain"><figcaption><span>```和 ```myLooper() ```方法的实现。</span></figcaption><table><tr><td class="code"><pre><span class="line">```java</span><br><span class="line">//Looper.java</span><br><span class="line">public static void prepare() &#123;</span><br><span class="line">	prepare(true);</span><br><span class="line">&#125;</span><br><span class="line">private static void prepare(boolean quitAllowed) &#123;</span><br><span class="line">	if (sThreadLocal.get() != null) &#123;</span><br><span class="line">		throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">     //Looper类会创建一个新的Looper对象,并放入全局的sThreadLocal中。</span><br><span class="line">	sThreadLocal.set(new Looper(quitAllowed));</span><br><span class="line">&#125;</span><br><span class="line">public static Looper myLooper() &#123;</span><br><span class="line">	return sThreadLocal.get();</span><br><span class="line">&#125;</span><br><span class="line">public static void prepareMainLooper() &#123;</span><br><span class="line">	prepare(false);</span><br><span class="line">	synchronized (Looper.class) &#123;</span><br><span class="line">		if (sMainLooper != null) &#123;</span><br><span class="line">			throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		sMainLooper = myLooper();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static Looper getMainLooper() &#123;</span><br><span class="line">	synchronized (Looper.class) &#123;</span><br><span class="line">		return sMainLooper;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在启动Activity的时候sMainLooper已经开始工作了（具体请看下边ActivityThread的main方法），所以我们要获取主线程的Looper实例，只需要调用<figure class="highlight plain"><figcaption><span>```。但在其他异步线程中我们要创建Looper通常我们通过以下方式获取Looper对象。</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line">Looper.prepare();</span><br><span class="line">Looper looper = Looper.myLooper();</span><br></pre></td></tr></table></figure></p>
<p>接下来我们看看在Framwork层中Looper是怎么使用的：ActivityThread#main</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"ActivityThreadMain"</span>);</span><br><span class="line">	SamplingProfilerIntegration.start();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// CloseGuard defaults to true and can be quite spammy.  We</span></span><br><span class="line">	<span class="comment">// disable it here, but selectively enable it later (via</span></span><br><span class="line">	<span class="comment">// StrictMode) on debug builds, but using DropBox, not logs.</span></span><br><span class="line">	CloseGuard.setEnabled(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">	Environment.initForCurrentUser();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set the reporter for event logging in libcore</span></span><br><span class="line">	EventLogger.setReporter(<span class="keyword">new</span> EventLoggingReporter());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Make sure TrustedCertificateStore looks in the right place for CA certificates</span></span><br><span class="line">	<span class="keyword">final</span> File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());</span><br><span class="line">	TrustedCertificateStore.setDefaultUserDirectory(configDir);</span><br><span class="line"></span><br><span class="line">	Process.setArgV0(<span class="string">"&lt;pre-initialized&gt;"</span>);</span><br><span class="line">    <span class="comment">//创建主线程的Looper对象</span></span><br><span class="line">	Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">	ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">	thread.attach(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">		sMainThreadHandler = thread.getHandler();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">		Looper.myLooper().setMessageLogging(<span class="keyword">new</span></span><br><span class="line">				LogPrinter(Log.DEBUG, <span class="string">"ActivityThread"</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// End of event ActivityThreadMain.</span></span><br><span class="line">	Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">	<span class="comment">//开启循坏队列监听并接受&amp;处理消息</span></span><br><span class="line">	Looper.loop();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看见main方法执行的时候主线程中的Looper就已经创建并循环等待处理消息了。</p>
<h2 id="Looper的loop"><a href="#Looper的loop" class="headerlink" title="Looper的loop"></a>Looper的loop</h2><p>上面我们讲述了Looper对象实例的获取，那么获取完后我们就需要开启循坏队列监听并接受&amp;处理消息，即执行<figure class="highlight plain"><figcaption><span>```方法。</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line">/**</span><br><span class="line"> * Run the message queue in this thread. Be sure to call</span><br><span class="line"> * &#123;@link #quit()&#125; to end the loop.</span><br><span class="line"> */</span><br><span class="line">public static void loop() &#123;</span><br><span class="line">    //获取当前线程的Looper对象实例</span><br><span class="line">    final Looper me = myLooper();</span><br><span class="line">    //调用loop()方法之前必须在当前线程通过Looper.prepare()方法创建Looper对象实例。</span><br><span class="line">    if (me == null) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //获取Looper实例的中的消息队列</span><br><span class="line">    final MessageQueue queue = me.mQueue;</span><br><span class="line">    // Make sure the identity of this thread is that of the local process,</span><br><span class="line">    // and keep track of what that identity token actually is.</span><br><span class="line">    Binder.clearCallingIdentity();</span><br><span class="line">    final long ident = Binder.clearCallingIdentity();</span><br><span class="line">    /***部分代码省略***/</span><br><span class="line">    //开启循环队列-不断</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        //从队列中取出消息，有可能产生阻塞</span><br><span class="line">        Message msg = queue.next(); // might block</span><br><span class="line">        //如果获取不到消息那么退出</span><br><span class="line">        if (msg == null) &#123;</span><br><span class="line">            // No message indicates that the message queue is quitting.</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        /***部分代码省略***/</span><br><span class="line">        //将消息分发给注册它的handler</span><br><span class="line">        try &#123;</span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">            dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (traceTag != 0) &#123;</span><br><span class="line">                Trace.traceEnd(traceTag);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        /***部分代码省略***/</span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到这里我们终于找到消息发送后的处理逻辑，实际上是通过每条消息传递给该消息所绑定的Handler的dispatchMessgage方法进行处理。</p>
<h2 id="Handler的消息处理"><a href="#Handler的消息处理" class="headerlink" title="Handler的消息处理"></a>Handler的消息处理</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Handler.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">		handleCallback(msg);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		handleMessage(msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个就是为什么我们在创建Handler对象的时候都需要复写它的handleMessage方法。</p>
<h2 id="MessageQueue-next"><a href="#MessageQueue-next" class="headerlink" title="MessageQueue.next"></a>MessageQueue.next</h2><p>从 <code>MessageQueue</code> 中获取消息，这个方法可能产生阻塞；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MessageQueue.java</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> mPtr; <span class="comment">// used by native code</span></span><br><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Return here if the message loop has already quit and been disposed.</span></span><br><span class="line">    <span class="comment">// This can happen if the application tries to restart a looper after quit</span></span><br><span class="line">    <span class="comment">// which is not supported.</span></span><br><span class="line">    <span class="comment">//如果消息循环已经退出并被处理，请返回此处。 </span></span><br><span class="line">    <span class="comment">//如果应用程序退出后不尝试重新启动循环程序，则可能会发生这种情况。</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//挂起空闲处理程序计数，一次next方法只设置一次；</span></span><br><span class="line">    <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//不断循环直到获取到Message为止；</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//唤醒消息队列；</span></span><br><span class="line">        <span class="comment">//nextPollTimeoutMillis=-1,表示等待；</span></span><br><span class="line">        <span class="comment">//nextPollTimeoutMillis=0,表示唤醒；</span></span><br><span class="line">        <span class="comment">////nextPollTimeoutMillis&gt;0,表示nextPollTimeoutMillis时间之后唤醒；</span></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">            Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">            Message msg = mMessages;</span><br><span class="line">            <span class="comment">//如果遇到同步屏障，那么找到离头部最近的异步消息；</span></span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果消息不为空，而且在当前时间之后执行那么设置下次唤醒时间为Math.min(msg.when - now, Integer.MAX_VALUE)；</span></span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Got a message.</span></span><br><span class="line">                    <span class="comment">//如果消息现在执行，那么消息队列设置不需要阻塞，并且设置改消息为已使用并在链表中删除；</span></span><br><span class="line">                    mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Returning message: "</span> + msg);</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="keyword">return</span> msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// No more messages.</span></span><br><span class="line">                <span class="comment">//获取不到消息那么nextPollTimeoutMillis = -1，将会进行空闲等待；</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//已经处理当前获取的消息是否进行退出，调用了MessageQueue的quit方法；</span></span><br><span class="line">            <span class="comment">// Process the quit message now that all pending messages have been handled.</span></span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                dispose();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">            <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">            <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line">            <span class="comment">//如果是第一次空闲，则获取发现线程何时阻塞的回调数量；</span></span><br><span class="line">            <span class="comment">//挂起空闲处理程序仅在队列为空或将来要处理队列中的第一条消息（可能是同步屏障）时才运行；</span></span><br><span class="line">            <span class="comment">//mIdleHandlers是添加了等待空闲的程序回调接口的列表；</span></span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//没有挂起空闲处理程序；</span></span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">                mBlocked = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//等待空闲的程序回调接口的数组如果为空，那么创建新的数组；</span></span><br><span class="line">            <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Run the idle handlers.</span></span><br><span class="line">        <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">        <span class="comment">//运行等待空闲时间的回调；</span></span><br><span class="line">        <span class="comment">//我们只会在第一次迭代时到达此代码块,因为后续的pendingIdleHandlerCount会置为0；</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">            <span class="comment">//释放mPendingIdleHandlers的引用对象；</span></span><br><span class="line">            mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line">            <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//进行接口回调，返回是否该回调要继续保持；</span></span><br><span class="line">                keep = idler.queueIdle();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">"IdleHandler threw exception"</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果不需要保持那么删除这个等待空闲程序；</span></span><br><span class="line">            <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将空闲处理程序计数重置为0，这样我们本地next方法就不再运行它们；</span></span><br><span class="line">        <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class="line">        pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// While calling an idle handler, a new message could have been delivered</span></span><br><span class="line">        <span class="comment">// so go back and look again for a pending message without waiting.</span></span><br><span class="line">        <span class="comment">//在调用空闲处理程序时，可能已经传递了一条新消息；</span></span><br><span class="line">        <span class="comment">//因此，请返回并再次查找未决的消息，而无需等待；</span></span><br><span class="line">        nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>nextPollTimeoutMillis=0</code> ，唤醒消息队列；</li>
<li>获取当前链表中的消息头 <code>mMessages</code> ;</li>
<li>如果头消息不为空，而且消息的 <code>target</code> 为空；<ol>
<li>那么这个是<code>屏障消息</code>，遇到消息屏障会从链表的顶端往下找一个<code>异步消息</code> ；<ol>
<li>如果找到异步消息那么这个异步消息将成为这次要处理的消息；</li>
<li>否则消息队列会进行等待，直到有异步消息到来。</li>
</ol>
</li>
</ol>
</li>
<li>如果消息不为空，判断当前消息的执行时间是否比现在晚；<ol>
<li>如果改消息的执行时间比现在晚，那么设置下次唤醒时间为当前消息的执行时间；</li>
<li>否则标记消息为已使用，并从链表当中删除该消息并进行返回，结束循环；</li>
</ol>
</li>
<li>如果消息为空那么 <code>nextPollTimeoutMillis=-1</code> ，那么消息队列进行等待；</li>
</ol>
<h2 id="同步屏障的使用"><a href="#同步屏障的使用" class="headerlink" title="同步屏障的使用"></a>同步屏障的使用</h2><p>在 <code>MessageQueue.next</code> 这个小结当中我们看到了 <code>屏障消息</code> 的出现，他的作用是：<strong>忽略所有的同步消息，返回异步消息。再换句话说，同步屏障为Handler消息机制增加了一种简单的优先级机制，异步消息的优先级要高于同步消息。</strong></p>
<p>同时我们也看到了 <code>MessageQueue.next</code> 的源代码中是不会删除同步 <code>屏障消息</code> 的，所以 <strong>同步屏障</strong> 出现后在不删除的情况下会一直保留。这个也解释为什么需要有删除<strong>同步屏障</strong>的消息方法。</p>
<p>之前在写 <a href="https://dandanlove.blog.csdn.net/article/details/78775166" target="_blank" rel="noopener">ViewRootImpl的独白，我不是一个View(布局篇)</a> 这篇文章的时候讲述过 <code>View绘制</code> 相关的知识点中就有<strong>同步屏障</strong> 的使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ViewRootImpl.java</span></span><br><span class="line"><span class="comment">//请求View开始进行布局</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">        <span class="comment">//检查是否是主线程让</span></span><br><span class="line">        checkThread();</span><br><span class="line">        mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//进行绘制的任务队列</span></span><br><span class="line">        scheduleTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//往handler的消息队列中插入同步屏障，并保存token</span></span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        <span class="comment">//添加异步消息任务mTraversalRunnable</span></span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (!mUnbufferedInputDispatch) &#123;</span><br><span class="line">            scheduleConsumeBatchedInput();</span><br><span class="line">        &#125;</span><br><span class="line">        notifyRendererOfFramePending();</span><br><span class="line">        pokeDrawLockIfNeeded();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> TraversalRunnable mTraversalRunnable = <span class="keyword">new</span> TraversalRunnable();</span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doTraversal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//移除同步屏障</span></span><br><span class="line">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line">        <span class="keyword">if</span> (mProfile) &#123;</span><br><span class="line">            Debug.startMethodTracing(<span class="string">"ViewAncestor"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始进行绘制</span></span><br><span class="line">        performTraversals();</span><br><span class="line">        <span class="keyword">if</span> (mProfile) &#123;</span><br><span class="line">            Debug.stopMethodTracing();</span><br><span class="line">            mProfile = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用<strong>同步屏障</strong>可以是绘制的任务提高优先级，同时也在绘制的时候取消的<strong>同步屏障</strong>这样也就不影响其他消息的执行。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>看完整篇文章我们就能理解Android中的消息机制了吧？可能有些同学还是有些小疑惑，我貌似看到了并理解了Handler对消息的处理【Handler发送消息并添加到队列中，Looper循环将队列里的消息发给Handler处理】，但是好像对Handler是怎么实现多线程异步通信还有些不清楚？</p>
<h2 id="多线程异步通信，Handler它到底是怎么实现的？"><a href="#多线程异步通信，Handler它到底是怎么实现的？" class="headerlink" title="多线程异步通信，Handler它到底是怎么实现的？"></a>多线程异步通信，Handler它到底是怎么实现的？</h2><p>首先我们需要明确三点：</p>
<blockquote>
<ul>
<li>线程之间内存是共享的；</li>
<li>每个线程最多只能有一个Looper对象实例；</li>
<li>Handler创建的时候必须绑定Looper对象（默认为当前线程的Looper实例对象）；</li>
</ul>
</blockquote>
<p>确定以上三点，我们就容易理解多了。多个线程编程中，当多个线程只拥有一个Handler实例时，无论消息在哪个线程里发送出来，消息都会在这个Handler的handleMessage方法中做处理（举例：若在主线程中创建一个Handler对象并且该Handler对象绑定的是主线程的Looper对象实例，那么我们在异步线程中使用该handler发送的消息，最终都会将在主线程中进行处理。eg：网络请求，文件读写。。）。</p>
<p>现在我们终于可以清空我们所有的疑问愉快的结束本文章的阅读啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android消息机制</tag>
        <tag>Handler</tag>
        <tag>Looper</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE的自动装箱和自动拆箱</title>
    <url>/2017/05/30/java-base-type/</url>
    <content><![CDATA[<h2 id="回顾一下Java基础数据类型："><a href="#回顾一下Java基础数据类型：" class="headerlink" title="回顾一下Java基础数据类型："></a>回顾一下Java基础数据类型：</h2><p><img src="http://upload-images.jianshu.io/upload_images/1319879-1b843fb53d98cace.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Java数据类型"></p>
<table>
<thead>
<tr>
<th>基础类型</th>
<th>字节</th>
<th>包装类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>int</td>
<td>4字节</td>
<td>Integer</td>
</tr>
<tr>
<td>byte</td>
<td>1字节</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>2字节</td>
<td>Short</td>
</tr>
<tr>
<td>long</td>
<td>8字节</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>4字节</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>8字节</td>
<td>Double</td>
</tr>
<tr>
<td>char</td>
<td>2字节</td>
<td>Character</td>
</tr>
<tr>
<td>boolean</td>
<td>未定</td>
<td>Boolean</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Java属于面向对象语言那么为什么会出现非对象类型数据（基础类型），因为基础数据类型是的虚拟机的运行速度更快而且占用内存更少。详情内容可以参见：<a href="http://www.importnew.com/11915.html" target="_blank" rel="noopener">Java为什么需要保留基本数据类型</a></p>
</blockquote>
<h2 id="为什么要有装箱-amp-拆箱"><a href="#为什么要有装箱-amp-拆箱" class="headerlink" title="为什么要有装箱&amp;拆箱"></a>为什么要有装箱&amp;拆箱</h2><p>在JavaSE5之前我们创建爱你Integer对象：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">10</span>);</span><br></pre></td></tr></table></figure></p>
<p>从JavaSE5提供了自动装箱的特性时，我们可以更简单的创建基础类型的对象：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = a;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>从上面的代码我们可以简单的看出装箱、拆箱的操作：<br>Integer a = 10;//我们将10【装箱】生成Integer对象。<br>int b = a;//我们将Integer【拆箱】转成int基础类型</p>
</blockquote>
<h2 id="装箱和拆箱是如何实现的"><a href="#装箱和拆箱是如何实现的" class="headerlink" title="装箱和拆箱是如何实现的"></a>装箱和拆箱是如何实现的</h2><p>我们这里先写一个简单的类，然后反编译看看它的字节码文件<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> b = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>反编译出来的字节码文件：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1319879-dc57d46990d3f88e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Main字节码.jpg"></p>
<h2 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h2><h1 id="装箱操作："><a href="#装箱操作：" class="headerlink" title="装箱操作："></a>装箱操作：</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//实际执行的是Integer a = Integer.valueOf(10);</span></span><br></pre></td></tr></table></figure>
<h1 id="拆箱操作："><a href="#拆箱操作：" class="headerlink" title="拆箱操作："></a>拆箱操作：</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> b = a;</span><br><span class="line"><span class="comment">//实际执行的是int b = a.intValue();</span></span><br></pre></td></tr></table></figure>
<h2 id="其他-amp-扩展"><a href="#其他-amp-扩展" class="headerlink" title="其他&amp;扩展"></a>其他&amp;扩展</h2><p>我们先来看一道面试题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer a = <span class="number">10</span>;</span><br><span class="line">        Integer b = <span class="number">10</span>;</span><br><span class="line">        Integer c = <span class="number">128</span>;</span><br><span class="line">        Integer d = <span class="number">128</span>;</span><br><span class="line">        System.out.println(a == b);</span><br><span class="line">        System.out.println(c == d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内心怀揣自己的真是答案，我们看看下边的源代码：<br>先看看Integer装箱和拆箱的函数源码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the value of this &#123;<span class="doctag">@code</span> Integer&#125; as an</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> int&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns an &#123;<span class="doctag">@code</span> Integer&#125; instance representing the specified</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> int&#125; value.  If a new &#123;<span class="doctag">@code</span> Integer&#125; instance is not</span></span><br><span class="line"><span class="comment"> * required, this method should generally be used in preference to</span></span><br><span class="line"><span class="comment"> * the constructor &#123;<span class="doctag">@link</span> #Integer(int)&#125;, as this method is likely</span></span><br><span class="line"><span class="comment"> * to yield significantly better space and time performance by</span></span><br><span class="line"><span class="comment"> * caching frequently requested values.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This method will always cache values in the range -128 to 127,</span></span><br><span class="line"><span class="comment"> * inclusive, and may cache other values outside of this range.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  i an &#123;<span class="doctag">@code</span> int&#125; value.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> an &#123;<span class="doctag">@code</span> Integer&#125; instance representing &#123;<span class="doctag">@code</span> i&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>  1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">		<span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<ul>
<li>拆箱操作：直接返回Integer内的数值</li>
<li>装箱操作：在i大于IntegerCache.low或者i小于IntegerCache.high时返回缓存的Integer对象，否则创建新的Integer对象。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Cache to support the object identity semantics of autoboxing for values between</span></span><br><span class="line"><span class="comment"> * -128 and 127 (inclusive) as required by JLS.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The cache is initialized on first usage.  The size of the cache</span></span><br><span class="line"><span class="comment"> * may be controlled by the &#123;<span class="doctag">@code</span> -XX:AutoBoxCacheMax=&lt;size&gt;&#125; option.</span></span><br><span class="line"><span class="comment"> * During VM initialization, java.lang.Integer.IntegerCache.high property</span></span><br><span class="line"><span class="comment"> * may be set and saved in the private system properties in the</span></span><br><span class="line"><span class="comment"> * sun.misc.VM class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*********/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过源码码我们可以发现，Integer在数据为[-128,127]之间时。使用了IntegerCache 返回缓存中对象的引用，否则new一个新的对象。</p>
<p>看到上面这个答案，有些同学就会想到：除过Integer之前还有其他的基础数据类型，那么其他的类型是否也是专业那个的呢？答案：是也不是。原理想想大家也都明白：</p>
<blockquote>
<ul>
<li>Boolean内部有true&amp;false两个静态变量，最后装箱得到的值都是这两个静态变量的引用。</li>
<li>Long&amp;Integer&amp;Short&amp;Byte在数值为[-128,127]之间都有Cache。</li>
<li>Double&amp;Float则都没有。</li>
</ul>
</blockquote>
<p>所以上面问题的正确答案分别是:true、false。</p>
<p>见识了”==”比较，现在看equals比较结果：<br>同样我们也先看一道题目：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer a = <span class="number">1</span>;</span><br><span class="line">        Integer b = <span class="number">2</span>;</span><br><span class="line">        Long c = <span class="number">3L</span>;</span><br><span class="line">        System.out.println(c == (a + b));</span><br><span class="line">        System.out.println(c.equals(a + b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后我们再看看源码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Compares this object to the specified object.  The result is</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> true&#125; if and only if the argument is not</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> null&#125; and is an &#123;<span class="doctag">@code</span> Integer&#125; object that</span></span><br><span class="line"><span class="comment"> * contains the same &#123;<span class="doctag">@code</span> int&#125; value as this object.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   obj   the object to compare with.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  &#123;<span class="doctag">@code</span> true&#125; if the objects are the same;</span></span><br><span class="line"><span class="comment"> *          &#123;<span class="doctag">@code</span> false&#125; otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">		<span class="keyword">return</span> value == ((Integer)obj).intValue();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在Java中我们知道操作”==”的两个数都是数据包装类型对象的引用的话，那么则是用来比较两个引用所指向的对象是不是同一个；而如果其中有一个操作数是表达式（即包含算术运算）则比较的是数值（即会触发自动拆箱的过程）。<em>为什么呢，因为”==”两边引用数据类型必须一致，要不然无语错误。</em></p>
<p>所以我们得到上边题目的答案是：true、false。<br>因为第一次比较实际是先对数据进行拆箱然后比较，所以得到的结果是true；第二次比较实际是先拆箱（两个Integer对象拆箱）后装箱（将拆箱且计算后的数据再装箱），然后同Long对象比较，显然不是同一类型所以得到false。</p>
<p>以上问题及答案都是作者亲自敲出来的，想实际操作同学也可以反编译class文件看看【真相】’。</p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>拆箱&amp;装箱</tag>
      </tags>
  </entry>
  <entry>
    <title>Android之NDK开发初体验</title>
    <url>/2017/03/24/android-ndk-init/</url>
    <content><![CDATA[<p>记得前年开始自己在项目中使用第三方so库的时候就接触NDK编程开发了，只不过哪个时候自己是输出了”Hello Wrold~!”。如今一年多的时间过去了，回头拾起之前的代码再次翻看。</p>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>在阅读文章之前我们首先了解几个概念</p>
<h2 id="JNI"><a href="#JNI" class="headerlink" title="JNI"></a>JNI</h2><blockquote>
<p>JNI是<a href="http://lib.csdn.net/base/javase" target="_blank" rel="noopener">Java</a>语言提供的Java和C/C++相互沟通的机制，Java可以通过JNI调用本地的C/C++代码，本地的C/C++的代码也可以调用java代码。JNI 是本地编程接口，Java和C/C++互相通过的接口。Java通过C/C++使用本地的代码的一个关键性原因在于C/C++代码的高效性。</p>
</blockquote>
<h2 id="NDK"><a href="#NDK" class="headerlink" title="NDK"></a>NDK</h2><blockquote>
<p>NDK是一系列工具的集合。它提供了一系列的工具，帮助开发者快速开发C（或C++）的动态库，并能自动将so和java应用一起打包成apk。这些工具对开发者的帮助是巨大的。它集成了交叉编译器，并提供了相应的mk文件隔离CPU、平台、ABI等差异，开发人员只需要简单修改mk文件（指出“哪些文件需要编译”、“编译特性要求”等），就可以创建出so。它可以自动地将so和Java应用一起打包，极大地减轻了开发人员的打包工作。</p>
</blockquote>
<h2 id="ARM"><a href="#ARM" class="headerlink" title="ARM"></a>ARM</h2><blockquote>
<p>早起Android只支持ARMv5的CPU架构，而发展到现在，支持一下7种架构：</p>
</blockquote>
<center><img src="http://upload-images.jianshu.io/upload_images/1319879-0b680fa969199ac1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="arm.jpg"></center><br>世界在进步，cup在arm基础上不断升级优化。每种架构关联着一种ABI（application binary interface应用程序二进制接口），所以每一种架构都对应一个.so文件，但都兼容arm。对于我们Android开发者来说，我们的app需要能在大多数手机上运行。所以要么我们所有arm类型都兼容，要么只兼容armeabi。兼容所有CPU架构类型是在性能上比较好，但是同时它也造成了apk体积的剧增（PS：我们之前的项目因为接入so库后导致apk体积剧增，最后只支持armeabi一种类型了）。<br><br># 搭建环境<br><br>## Java环境配置（略）<br>## AndroidSDK环境配置（略）<br>## NDK环境配置<br>&gt; 本文主要讲述NDK环境配置：<br>- <a href="https://developer.android.com/ndk/downloads/index.html" target="_blank" rel="noopener">下载对应操作系统的NDK</a><br>- 解压文件（windows随意解压，Ubuntu解压在bin目录下）<br>- windows环境下配置<br><center><img src="http://upload-images.jianshu.io/upload_images/1319879-4c5a46d281287332.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="windows-ndk.jpg"></center><br>- Ubuntu环境下配置<br>修改系统环境变量<br>sudo gedit /etc/profile<br>在profile文件下面添加,保存并退出<br>export ANDROID_NDK= ndk路径<br>export PATH=$ANDROID_NDK:$PATH<br>source  /etc/profile<br><br>查看是否配置成功<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">im@<span class="number">58</span>user:~/StudioProjects/NDKDemo/app/src/main/java$ ndk-build -v</span><br><span class="line">GNU Make <span class="number">3.81</span></span><br><span class="line">Copyright (C) <span class="number">2006</span>  Free Software Foundation, Inc.</span><br><span class="line">该程序为自由软件，详情可参阅版权条款。在法律允许的范围内</span><br><span class="line">我们不作任何担保，这包含但不限于任何商业适售性以及针对特</span><br><span class="line">定目的的适用性的担保。</span><br><span class="line"></span><br><span class="line"> 这个程序创建为 x86_64-pc-linux-gnu</span><br></pre></td></tr></table></figure><br><br>## Android studio环境配置<br><br><center><img src="http://upload-images.jianshu.io/upload_images/1319879-f1f46a7692aed25a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="android-ndk-env-config.jpg"></center>

<p>以上是下边使用Android studio 进行NDK开发的基础，下边我们进入真正的开发环节。</p>
<h1 id="NDK开发环节"><a href="#NDK开发环节" class="headerlink" title="NDK开发环节"></a>NDK开发环节</h1><h2 id="native方法的定义"><a href="#native方法的定义" class="headerlink" title="native方法的定义"></a>native方法的定义</h2><p>为了方便，我直接将native方法定义在了Activity当中<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">   <span class="comment">//加载so库，libjnilib.so文件</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">"jnilib"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义native方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> String <span class="title">getStringForNative</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        ((TextView) findViewById(R.id.text)).setText(getStringForNative());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="gradle配置"><a href="#gradle配置" class="headerlink" title="gradle配置"></a>gradle配置</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">	<span class="comment">/**略**/</span></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId <span class="string">"ndk.tzx.com.ndkdemo"</span></span><br><span class="line">        minSdkVersion <span class="number">19</span></span><br><span class="line">        targetSdkVersion <span class="number">23</span></span><br><span class="line">        versionCode <span class="number">1</span></span><br><span class="line">        versionName <span class="string">"1.0"</span></span><br><span class="line">        ndk &#123;</span><br><span class="line">			<span class="comment">//定义生成的mk文件中的model名称</span></span><br><span class="line">            moduleName <span class="string">"jnilib"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sourceSets &#123;</span><br><span class="line">        main &#123;</span><br><span class="line">			<span class="comment">//引入so路径</span></span><br><span class="line">            jni.srcDirs = [<span class="string">'src/main/jni'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">/**略**/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建jni目录"><a href="#创建jni目录" class="headerlink" title="创建jni目录"></a>创建jni目录</h2><center><img src="http://upload-images.jianshu.io/upload_images/1319879-956f3a2906c26310.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="new-jni.jpg"></center>

<h2 id="生成C-head文件"><a href="#生成C-head文件" class="headerlink" title="生成C++head文件"></a>生成C++head文件</h2><center><img src="http://upload-images.jianshu.io/upload_images/1319879-1db370f891c06e80.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="make-.c.jpg"></center>

<p>执行完改命令会在main/jni目录下生成对应的头文件</p>
<center><img src="http://upload-images.jianshu.io/upload_images/1319879-57305812fe749d22.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ndk-build.cpp.jpg"></center>


<h2 id="native方法的实现"><a href="#native方法的实现" class="headerlink" title="native方法的实现"></a>native方法的实现</h2><p>然后我们在main/jni目录下创建cpp文件并进行native方法的实现</p>
<blockquote>
<ul>
<li>include头问件</li>
<li>实现方法<br>这一步经常有好多人会遇到错误，只因方法名写错~！~！</li>
</ul>
</blockquote>
<center><img src="http://upload-images.jianshu.io/upload_images/1319879-22ab06e993f8c745.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="edit.cpp.jpg"></center>

<h2 id="构建并运行出结果"><a href="#构建并运行出结果" class="headerlink" title="构建并运行出结果"></a>构建并运行出结果</h2><center><img src="http://upload-images.jianshu.io/upload_images/1319879-b5d88ab642b4aef8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="arm-&amp;-mk.jpg"></center>

<blockquote>
<p>上图是项目build后的结果，在app/build/intermediates/ndk/debug目录下有lib文件夹，obj文件夹和Android.mk文件。<br>在Android.mk这个文件当中我们定义生成so的名称，生成so对应cpp文件的路径和so输出的路径。<br>lib目录下我们可以看到各种类型的CPU架构下的so文件。</p>
</blockquote>
<p>如果以上过程都没有问题的话，那么恭喜你整个项目就可以直接运行了。</p>
<h1 id="踩坑需要一步一步来"><a href="#踩坑需要一步一步来" class="headerlink" title="踩坑需要一步一步来"></a>踩坑需要一步一步来</h1><p>build项目的时候遇到下边问题：</p>
<h2 id="Android-mk生成问题"><a href="#Android-mk生成问题" class="headerlink" title="Android.mk生成问题"></a>Android.mk生成问题</h2><p>直接在gradle.properties文件尾部添加 <code>android.useDeprecatedNdk=true</code></p>
<center><img src="http://upload-images.jianshu.io/upload_images/1319879-14020e5546f73286.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ndk-intergration.jpg"></center>

<h2 id="生成so文件问题"><a href="#生成so文件问题" class="headerlink" title="生成so文件问题"></a>生成so文件问题</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Error:Execution failed <span class="keyword">for</span> task <span class="string">':app:compileDebugNdk'</span>.</span><br><span class="line">&gt; com.android.ide.common.process.ProcessException: org.gradle.process.internal.ExecException: Process <span class="string">'command '</span>/bin/android-ndk-r13b/ndk-build.cmd<span class="string">''</span> finished with non-zero exit value <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>使用Android.md文件生成so的时候可能会遇到这样的问题：<br>解决办法1:</p>
<blockquote>
<p>将Android.mk文件copy到jni目录下和.h与.cpp文件放在同一级目录，然后在该目录下执行<code>ndk-build</code>。 <center><img src="http://upload-images.jianshu.io/upload_images/1319879-6463def52a3229ec.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ndk-build.jpg"></center></p>
</blockquote>
<p>这种方法也肯能报错：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Error:(<span class="number">15</span>) *** Android NDK: Aborting.    .  Stop.</span><br><span class="line">Android NDK: /home/im/StudioProjects/NDKDemo/app/src/main/jni/Android.mk: Cannot find <span class="keyword">module</span> with tag <span class="string">'core'</span> in <span class="keyword">import</span> path    </span><br><span class="line">Android NDK: Are you sure your NDK_MODULE_PATH variable is properly defined ?    </span><br><span class="line">Android NDK: The following directories were searched:    </span><br><span class="line">Android NDK:         </span><br><span class="line">make: Entering directory `/home/im/StudioProjects/NDKDemo/app/src/main/jni<span class="string">'</span></span><br><span class="line"><span class="string">make: Leaving directory `/home/im/StudioProjects/NDKDemo/app/src/main/jni'</span></span><br><span class="line">:app:buildNative FAILED</span><br><span class="line">Error:Execution failed <span class="keyword">for</span> task <span class="string">':app:buildNative'</span>.</span><br><span class="line">&gt;Process <span class="string">'command '</span>/bin/android-ndk-r13b/ndk-build<span class="string">''</span> finished with non-zero exit value <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>遇到这种情况，偶查了很多资料最后才解决（参见解决方法2）</p>
<p>解决方法2：</p>
<blockquote>
<p>安装最新的ndk（^_^）</p>
</blockquote>
<h2 id="运行问题"><a href="#运行问题" class="headerlink" title="运行问题"></a>运行问题</h2><p>整个项目可以运行安装的时候是不是很爽，但是还可能遇到下边的问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ adb shell am start -n <span class="string">"ndk.tzx.com.ndkdemo/ndk.tzx.com.ndkdemo.MainActivity"</span> -a android.intent.action.MAIN -c android.intent.category.LAUNCHER</span><br><span class="line">Error <span class="keyword">while</span> executing: am start -n <span class="string">"ndk.tzx.com.ndkdemo/ndk.tzx.com.ndkdemo.MainActivity"</span> -a android.intent.action.MAIN -c android.intent.category.LAUNCHER</span><br><span class="line">Starting: Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=ndk.tzx.com.ndkdemo/.MainActivity &#125;</span><br><span class="line">Error type <span class="number">3</span></span><br><span class="line">Error: Activity <span class="class"><span class="keyword">class</span> </span>&#123;ndk.tzx.com.ndkdemo/ndk.tzx.com.ndkdemo.MainActivity&#125; does not exist.</span><br><span class="line"></span><br><span class="line">Error <span class="keyword">while</span> Launching activity</span><br></pre></td></tr></table></figure>
<p>这问题偶也整了好久，网上大多数解释为native方法名不匹配，最后重新写cpp文件也成功解决。</p>
<p>心好累~！~！~！复习之前的东西还是要当初做好笔记啊。</p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>JNI</tag>
        <tag>NDK</tag>
      </tags>
  </entry>
  <entry>
    <title>Android类加载之PathClassLoader和DexClassLoader</title>
    <url>/2017/02/23/pathclassloader-dexclassloader/</url>
    <content><![CDATA[<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzEzMTk4NzktMTBjNDA5NjhiNmM2ZWRjZi5qcGc?x-oss-process=image/format,png#pic_center =500x400" alt="北京的初雪.jpg"></p>
<h1 id="第二次修改"><a href="#第二次修改" class="headerlink" title="第二次修改"></a>第二次修改</h1><p>任何结论在没有经过实际检验之前都不能够确定一定没问题。三年前写的文章回过头来发现有些部分内容是有问题的（PS：这的确比较尴尬），再次对结果进行验证之后重新修改了之前的结论。幸亏文章阅读量不是很多，希望被误导的同学能够在其他地方得到正确结论。</p>
<hr>
<p>上一篇文章 <a href="http://www.jianshu.com/p/a8371d26f848" target="_blank" rel="noopener">自定义ClassLoader和双亲委派机制</a> 讲述了 <code>JVM</code> 中的类的加载机制，<code>Android</code> 也是类 <code>JVM</code> 虚拟机那么它的类加载机制是什么呢，我们来探究一下(PS：文章源码为 <code>Android5.1</code> )。</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Android</code> 的 <code>Dalvik</code> 虚拟机和 <code>Java</code> 虚拟机的运行原理相同都是将对应的 <code>java</code> 类加载在内存中运行。而 <code>Java</code> 虚拟机是加载 <code>class</code> 文件，也可以将一段二进制流通过 <code>defineClass</code> 方法生产 <code>Class</code> 进行加载（PS: <a href="http://www.jianshu.com/p/a8371d26f848" target="_blank" rel="noopener">自定义ClassLoader和双亲委派机制</a> 文章后面的自定义类加载器就是通过这种方式实现的）。<code>Dalvik</code> 虚拟机加载的 <code>dex</code> 文件。<code>dex</code> 文件是 <code>Android</code> 对与 <code>Class</code> 文件做的优化，以便于提高手机的性能。可以想象 <code>dex</code> 为 <code>class</code> 文件的一个压缩文件。<code>dex</code> 在 <code>Android</code> 中的加载和 <code>class</code> 在 <code>jvm</code> 中的相同都是基于双亲委派模型，都是调用<code>ClassLoader</code> 的 <code>loadClass</code> 方法加载类。</p>
<h1 id="Android系统中类加载的双亲委派机制"><a href="#Android系统中类加载的双亲委派机制" class="headerlink" title="Android系统中类加载的双亲委派机制"></a>Android系统中类加载的双亲委派机制</h1><ul>
<li><p><code>Android5.1</code> 源码中 <code>ClassLoader</code> 的 <code>loadClass</code> 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String className, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = findLoadedClass(className);</span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ClassNotFoundException suppressed = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//先让父类加载器加载</span></span><br><span class="line">                clazz = parent.loadClass(className, <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                suppressed = e;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当所有父类节点的类加载器都没有找到该类时，当前加载器调用findClass方法加载。</span></span><br><span class="line">            <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    clazz = findClass(className);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    e.addSuppressed(suppressed);</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>想要动态加载类，可以用 <a href="http://www.jianshu.com/p/a8371d26f848" target="_blank" rel="noopener">自定义ClassLoader和双亲委派机制</a> 中自定义 <code>ClassLoader</code> 的方法加载自己定义的 <code>class</code> 文件么？看看 <code>Android</code> 源码中的<code>ClassLoader</code> 的 <code>findClass</code> 方法：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String className) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(className);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法直接抛出了 <code>ClassNotFoundException</code> 异常，所以在 <code>Android</code> 中想通过这种方式实现类的加载时不行的。</p>
<h1 id="Android系统中的类加载器"><a href="#Android系统中的类加载器" class="headerlink" title="Android系统中的类加载器"></a>Android系统中的类加载器</h1><ul>
<li><code>Android</code> 系统屏蔽了 <code>ClassLoader</code> 的 <code>findClass</code> 加载方法，那么它自己的类加载时通过什么样的方式实现的呢？<ul>
<li><code>Android</code> 系统中有两个类加载器分别为 <code>PathClassLoader</code> 和 <code>DexclassLoader</code>。</li>
<li><code>PathClassLoader</code> 和 <code>DexClassLoader</code> 都是继承与<code>BaseDexClassLoader</code>，<code>BaseDexClassLoader</code> 继承与 <code>ClassLoader</code>。</li>
</ul>
</li>
</ul>
<h2 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h2><p>在这里我们先提一个问题 <code>Android</code> 为什么会将自己的类加载器派生出两个不同的子类，它们各自有什么用？</p>
<h2 id="BaseDexClassLoader类加载"><a href="#BaseDexClassLoader类加载" class="headerlink" title="BaseDexClassLoader类加载"></a>BaseDexClassLoader类加载</h2><ul>
<li><p>作为 <code>ClassLoader</code> 的子类，复写了父类的 <code>findClass</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        List&lt;Throwable&gt; suppressedExceptions = <span class="keyword">new</span> ArrayList&lt;Throwable&gt;();</span><br><span class="line">        <span class="comment">//在自己的成员变量DexPathList中寻找，找不到抛异常</span></span><br><span class="line">        Class c = pathList.findClass(name, suppressedExceptions);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ClassNotFoundException cnfe = <span class="keyword">new</span> ClassNotFoundException(<span class="string">"Didn't find class \""</span> + name + <span class="string">"\" on path: "</span> + pathList);</span><br><span class="line">            <span class="keyword">for</span> (Throwable t : suppressedExceptions) &#123;</span><br><span class="line">                cnfe.addSuppressed(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> cnfe;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>DexPathList</code> 的 <code>findClass</code> 方法</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Class <span class="title">findClass</span><span class="params">(String name, List&lt;Throwable&gt; suppressed)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//循环便利成员变量dexElements，调用DexFile.loadClassBinaryName加载class</span></span><br><span class="line">        <span class="keyword">for</span> (Element element : dexElements) &#123;</span><br><span class="line">            DexFile dex = element.dexFile;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dex != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Class clazz = dex.loadClassBinaryName(name, definingContext, suppressed);</span><br><span class="line">                <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> clazz;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dexElementsSuppressedExceptions != <span class="keyword">null</span>) &#123;</span><br><span class="line">            suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过以上两段代码我们可以看出，虽然 <code>Android</code> 中的 <code>ClassLoader</code> 的<code>findClass</code> 方法的实现被取消了，但是 <code>ClassLoader</code> 的基类 <code>BaseDexClassLoader</code> 实现了 <code>findClass</code> 方法取加载指定的 <code>Class</code>。</p>
<h2 id="PathClassLoader和DexClassLoader比较"><a href="#PathClassLoader和DexClassLoader比较" class="headerlink" title="PathClassLoader和DexClassLoader比较"></a>PathClassLoader和DexClassLoader比较</h2><ul>
<li><code>PathClassLoader</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(dexPath, <span class="keyword">null</span>, <span class="keyword">null</span>, parent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, String libraryPath,</span></span></span><br><span class="line"><span class="function"><span class="params">            ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(dexPath, <span class="keyword">null</span>, libraryPath, parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>DexClassLoader</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DexClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DexClassLoader</span><span class="params">(String dexPath, String optimizedDirectory,</span></span></span><br><span class="line"><span class="function"><span class="params">            String libraryPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(dexPath, <span class="keyword">new</span> File(optimizedDirectory), libraryPath, parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>BaseDexClassLoader</code> 的构造函数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dexPath 包含类和资源的jar/apk文件列表，Android中使用“:”拆分</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> optimizedDirectory 优化的dex文件所在的目录，可以为空；</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> libraryPath 动态库路径，可以为空；</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parent 父类加载器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BaseDexClassLoader</span><span class="params">(String dexPath, File optimizedDirectory,</span></span></span><br><span class="line"><span class="function"><span class="params">            String libraryPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="keyword">this</span>.pathList = <span class="keyword">new</span> DexPathList(<span class="keyword">this</span>, dexPath, libraryPath, optimizedDirectory);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>dexPath</code>：指定的是<code>dex</code>文件地址，多个地址可以用”:”进行分隔<ul>
<li><code>optimizedDirectory</code>：制定输出 <code>dex</code> 优化后的 <code>odex</code> 文件，可以为<code>null</code></li>
<li><code>libraryPath</code> ：动态库路径（将被添加到 <code>app</code> 动态库搜索路径列表中）</li>
<li><code>parent</code> ：制定父类加载器，以保证双亲委派机制从而实现每个类只加载一次。</li>
</ul>
</li>
</ul>
</blockquote>
<p>可以看出 <code>PathClassLoader</code> 和 <code>DexClassLoader</code> 的区别就在于构造函数中 <code>optimizedDirectory</code> 这个参数。<code>PathClassLoader</code> 中 <code>optimizedDirectory</code> 为 <code>null</code>，<code>DexClassLoader</code> 中为 <code>new File(optimizedDirectory)</code>。</p>
<h2 id="optimizedDirectory-的作用"><a href="#optimizedDirectory-的作用" class="headerlink" title="optimizedDirectory 的作用"></a>optimizedDirectory 的作用</h2><p> <code>BaseDexClassLoader</code> 的构造函数利用 <code>optimizedDirectory</code> 创建了一个<code>DexPathList</code>，看看 <code>DexPathList</code> 中 <code>optimizedDirectory</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DexPathList</span><span class="params">(ClassLoader definingContext, String dexPath,</span></span></span><br><span class="line"><span class="function"><span class="params">        String libraryPath, File optimizedDirectory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/******部分代码省略******/</span></span><br><span class="line">    <span class="keyword">this</span>.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory,</span><br><span class="line">                                       suppressedExceptions);</span><br><span class="line">    <span class="comment">/******部分代码省略******/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Element[] makeDexElements(ArrayList&lt;File&gt; files, File optimizedDirectory,</span><br><span class="line">                                         ArrayList&lt;IOException&gt; suppressedExceptions) &#123;</span><br><span class="line">   <span class="comment">/******部分代码省略******/</span></span><br><span class="line">    <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">        <span class="comment">/******部分代码省略******/</span></span><br><span class="line">        <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">           <span class="comment">/******部分代码省略******/</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (file.isFile())&#123;</span><br><span class="line">            <span class="keyword">if</span> (name.endsWith(DEX_SUFFIX)) &#123;</span><br><span class="line">                <span class="comment">// Raw dex file (not inside a zip/jar).</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    dex = loadDexFile(file, optimizedDirectory);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                    System.logE(<span class="string">"Unable to load dex file: "</span> + file, ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                zip = file;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    dex = loadDexFile(file, optimizedDirectory);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException suppressed) &#123;</span><br><span class="line">                    suppressedExceptions.add(suppressed);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.logW(<span class="string">"ClassLoader referenced unknown path: "</span> + file);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((zip != <span class="keyword">null</span>) || (dex != <span class="keyword">null</span>)) &#123;</span><br><span class="line">            elements.add(<span class="keyword">new</span> Element(file, <span class="keyword">false</span>, zip, dex));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> elements.toArray(<span class="keyword">new</span> Element[elements.size()]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> DexFile <span class="title">loadDexFile</span><span class="params">(File file, File optimizedDirectory)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (optimizedDirectory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DexFile(file);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        String optimizedPath = optimizedPathFor(file, optimizedDirectory);</span><br><span class="line">        <span class="keyword">return</span> DexFile.loadDex(file.getPath(), optimizedPath, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这里可以看出 <code>optimizedDirectory</code> 不同生产的 <code>DexFile</code> 对象不同，我们继续看看 <code>optimizedDirectory</code> 在 <code>DexFile</code> 中的作用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DexFile</span><span class="params">(File file)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(file.getPath());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从给定的File对象打开一个DEX文件。这通常是一个ZIP/JAR 文件，其中包含“classes.dex”。</span></span><br><span class="line"><span class="comment"> * VM将在/data/dalvik-cache中生成相应文件的名称，然后打开它，如果允许系统权限，可能会首先创建或更新它。不要在/data/dalvik-cache中传递文件名，因为预期该命名文件为原始状态（pre-dexopt）。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fileName 引用实际DEX文件的File对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException 找不到文件或*打开文件缺少访问权限，回抛出io异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DexFile</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    mCookie = openDexFile(fileName, <span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line">    mFileName = fileName;</span><br><span class="line">    guard.open(<span class="string">"close"</span>);</span><br><span class="line">    <span class="comment">//System.out.println("DEX FILE cookie is " + mCookie + " fileName=" + fileName);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打开一个DEX文件。返回的值是VM cookie</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceName Jar或APK文件包含“ classes.dex”。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> outputName 包含优化形式的DEX数据的文件。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> flags 启用可选功能。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">DexFile</span><span class="params">(String sourceName, String outputName, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (outputName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String parent = <span class="keyword">new</span> File(outputName).getParent();</span><br><span class="line">            <span class="keyword">if</span> (Libcore.os.getuid() != Libcore.os.stat(parent).st_uid) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Optimized data directory "</span> + parent</span><br><span class="line">                        + <span class="string">" is not owned by the current user. Shared storage cannot protect"</span></span><br><span class="line">                        + <span class="string">" your application from code injection attacks."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ErrnoException ignored) &#123;</span><br><span class="line">            <span class="comment">// assume we'll fail with a more contextual error later</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mCookie = openDexFile(sourceName, outputName, flags);</span><br><span class="line">    mFileName = sourceName;</span><br><span class="line">    guard.open(<span class="string">"close"</span>);</span><br><span class="line">    <span class="comment">//System.out.println("DEX FILE cookie is " + mCookie + " sourceName=" + sourceName + " outputName=" + outputName);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> DexFile <span class="title">loadDex</span><span class="params">(String sourcePathName, String outputPathName,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DexFile(sourcePathName, outputPathName, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打开dex的native方法，/art/runtime/native/dalvik_system_DexFile.cc</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">openDexFileNative</span><span class="params">(String sourceName, String outputName, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">//打开一个DEX文件。返回的值是VM cookie。 失败时，将引发IOException。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">openDexFile</span><span class="params">(String sourceName, String outputName, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Use absolute paths to enable the use of relative paths when testing on host.</span></span><br><span class="line">    <span class="keyword">return</span> openDexFileNative(<span class="keyword">new</span> File(sourceName).getAbsolutePath(),</span><br><span class="line">                                (outputName == <span class="keyword">null</span>) ? <span class="keyword">null</span> : <span class="keyword">new</span> File(outputName).getAbsolutePath(),</span><br><span class="line">                                flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从注释当中就可以看到 <code>new DexFile(file)</code> 的dex输出路径只能为 <code>/data/dalvik-cache</code>，而 <code>DexFile.loadDex()</code> 的 <code>dex</code> 输出路径为自己输入的<code>optimizedDirectory</code> 路径。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzEzMTk4NzktODk3NTY3NzQzZmMzMjVhZi5qcGc?x-oss-process=image/format,png#pic_center =300x500" alt="dalvik-cache.jpg"></p>
<h2 id="解决疑问"><a href="#解决疑问" class="headerlink" title="解决疑问"></a>解决疑问</h2><p>我们在文章开始提出的问题就这样一步步得到了答案。</p>
<blockquote>
<ul>
<li><code>DexClassLoader</code>：能够加载 <code>jar/apk/dex</code> ，也可以指定对 <code>dex</code> 优化后的 <code>odex</code> 的输出文件目录；</li>
<li><code>PathClassLoader</code>：只能够加载 <code>jar/apk/dex</code> ，但它的 <code>optimizedDirectory</code> 没法自己设定;</li>
</ul>
</blockquote>
<p>所以 <code>Android</code> 系统默认的类加载器为 <code>PathClassLoader</code>，而<code>DexClassLoader</code> 可以像 <code>JVM</code> 的 <code>ClassLoader</code> 一样提供动态加载。</p>
<h2 id="android-8-0上的修改"><a href="#android-8-0上的修改" class="headerlink" title="android 8.0上的修改"></a>android 8.0上的修改</h2><p><a href="https://www.androidos.net.cn/android/8.0.0_r4/xref/libcore/dalvik/src/main/java/dalvik/system/BaseDexClassLoader.java" target="_blank" rel="noopener">android-26版本的BaseDexClassLoader.java</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an instance.</span></span><br><span class="line"><span class="comment"> * Note that all the *.jar and *.apk files from &#123;<span class="doctag">@code</span> dexPath&#125; might be</span></span><br><span class="line"><span class="comment"> * first extracted in-memory before the code is loaded. This can be avoided</span></span><br><span class="line"><span class="comment"> * by passing raw dex files (*.dex) in the &#123;<span class="doctag">@code</span> dexPath&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dexPath the list of jar/apk files containing classes and</span></span><br><span class="line"><span class="comment"> * resources, delimited by &#123;<span class="doctag">@code</span> File.pathSeparator&#125;, which</span></span><br><span class="line"><span class="comment"> * defaults to &#123;<span class="doctag">@code</span> ":"&#125; on Android.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> optimizedDirectory this parameter is deprecated and has no effect</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> librarySearchPath the list of directories containing native</span></span><br><span class="line"><span class="comment"> * libraries, delimited by &#123;<span class="doctag">@code</span> File.pathSeparator&#125;; may be</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parent the parent class loader</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BaseDexClassLoader</span><span class="params">(String dexPath, File optimizedDirectory,</span></span></span><br><span class="line"><span class="function"><span class="params">        String librarySearchPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(parent);</span><br><span class="line">    <span class="keyword">this</span>.pathList = <span class="keyword">new</span> DexPathList(<span class="keyword">this</span>, dexPath, librarySearchPath, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (reporter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        reporter.report(<span class="keyword">this</span>.pathList.getDexPaths());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点关注 <code>@param optimizedDirectory this parameter is deprecated and has no effect</code> ，表明在 <code>Android26</code> 上 <code>optimizedDirectory</code> 已经被弃用。<br>所以在 <code>Android26</code> 之后 <code>PathClassLoader</code> 和 <code>DexClassLoader</code> 已经没有了区别。</p>
<p><a href="https://dandanlove.blog.csdn.net/article/details/102620708" target="_blank" rel="noopener">从JVM到Dalivk再到ART（class,dex,odex,vdex,ELF）</a> 这篇文章中讲述了 <code>Android26</code>  中其他 <code>dex</code> 相关的优化。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li><code>ClassLoader</code> 的 <code>loadClass</code> 方法保证了双亲委派机。</li>
<li><code>BaseDexClassLoader</code> 提供了两种派生类使我们可以加载自定义类。</li>
</ul>
<p>另外还有一个问题自己没太搞清楚，<strong>默认的optimizedDirectory</strong> 是哪个路径？<br><code>data/app</code> 和 <code>data/dalvik-cache</code> 下面都没有我加载的外部的 <code>dex</code> 文件，有谁找到了结果可以分享一下。</p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>PathClassLoader</tag>
        <tag>DexClassLoader</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义ClassLoader和双亲委派机制</title>
    <url>/2017/02/23/java-classloader/</url>
    <content><![CDATA[<p>博文主要讲classloader的模型、作用和使用，内容是作者学习java反射机制有关知识时记录的笔记。</p>
<h2 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h2><p>ClassLoad：类加载器（class loader）用来加载 Java 类到 Java 虚拟机中。Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。类加载器负责读取 Java 字节代码，并转换成 java.lang.Class 类的一个实例。 </p>
<h1 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h1><p>某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。</p>
<h1 id="自己对JVM中的ClassLoader和双亲委派机制的一些理解："><a href="#自己对JVM中的ClassLoader和双亲委派机制的一些理解：" class="headerlink" title="自己对JVM中的ClassLoader和双亲委派机制的一些理解："></a>自己对JVM中的ClassLoader和双亲委派机制的一些理解：</h1><ul>
<li>java虚拟机中的class其实都是通过classloader来装载的</li>
<li>只有当你使用该class的时候才会去装载，一个classloader只会装载同一个class一次。 </li>
<li>不同的类加载器的实例所加载的字节码文件，其通过反射获取的对象不是相同类型（相互赋值会抛出类型强转异常）。即：判断两个类是否为同一对象的标准里面有一条是类加载器必须为相同。</li>
<li>双亲委派机制能在很大程度上防止内存中出现多个相同的字节码文件。</li>
<li>在加载类的时候默认会使用当前类的ClassLoader进行加载（类A中引用了类B，JVM会用类A的类加载器加载类B）。</li>
<li>在线程中加载一个类的时候：当前线程的类加载器可以通过Thread类的getContextClassLoader()获得，也可以通过setContextClassLoader()自己设置类加载器（    PS：自己没有试验过）。</li>
</ul>
<h2 id="ClassLoader体系结构图"><a href="#ClassLoader体系结构图" class="headerlink" title="ClassLoader体系结构图"></a>ClassLoader体系结构图</h2><p><img src="http://upload-images.jianshu.io/upload_images/1319879-037f2e2c51de5bb5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ClassLoader体系结构图"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.tzx.reflection;</span><br><span class="line"></span><br><span class="line">public class MyClassLoader &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		System.out.println(Thread.currentThread().getContextClassLoader());</span><br><span class="line">		System.out.println(ClassLoaderTest.class.getClassLoader());</span><br><span class="line">		System.out.println(System.class.getClassLoader());</span><br><span class="line">		System.out.println(ClassLoader.getSystemClassLoader());</span><br><span class="line">		System.out.println(ClassLoader.getSystemClassLoader().getParent());</span><br><span class="line">		System.out.println(ClassLoader.getSystemClassLoader().getParent().getParent());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@4aa298b7</span><br><span class="line">sun.misc.Launcher$AppClassLoader@4aa298b7</span><br><span class="line">null</span><br><span class="line">sun.misc.Launcher$AppClassLoader@382f3bf0</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@25082661</span><br><span class="line">null</span><br></pre></td></tr></table></figure>
<p>按照双亲委派机制加载类，每当需要加载一个新的类时，当前的类加载器会先委托其父加载器，查询有没有加载该类。如果父类加载器已近加载该类，那么直接返回加载的class对象，如果没有那么继续向上寻找父类加载器，如果在祖宗类加载器Bootstrap都没有加载该类，那么需要当前的类加载器自己加载，如果当前的类加载器也不能加载则会跑出<code>ClassNotFoundException</code>异常 (PS:类加载器没有向下寻找，没有getChild只有getParent)。</p>
<p>用这种思想去解析上边代码：Thread.currentThread().getContextClassLoader()指出当前的类加载器是AppClassLoader，需要加载MyClassLoader.class先在父类加载器（ExtClassLoader）中寻找，没有再向祖宗类加载中寻找（Bootstrap ClassLoader），还没有找到那么AppClassLoader自己去加载。</p>
<h1 id="JVM中的类加载器类型："><a href="#JVM中的类加载器类型：" class="headerlink" title="JVM中的类加载器类型："></a>JVM中的类加载器类型：</h1><ul>
<li>(Bootstrap ClassLoader)启动类加载器:<br>负责加载java_home/jar/lib/rt.jar目录下的核心类或- Xbootclasspath指定目录下的类。由于引导类加载器全部是native代码来实现的并且涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作，从上面的ClassLoader体系结构图中可以看出在java代码中获取启动类加载器为null。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1319879-15a6783f4a84fe82.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="rt.jar.png"></p>
<p>像System.java这样的由系统提供的类都在rt.jar中，由Bootstrap ClassLoader加载，由于Bootstrap类加载器不是Java写的，所以打印出来的类名为null。</p>
<ul>
<li>(Extension)扩展类加载器：负责加载java_home/lib/ext目录下的扩展类或 -Djava.ext.dirs 指定目录下的类。 开发者可以直接使用标准扩展类加载器。</li>
</ul>
<p>我们将第一段代码生产的MyClassLoader.class文件打包成jar（<a href="http://www.jianshu.com/p/c23d26873ec3" target="_blank" rel="noopener">java打包成jar|执行jar包中的main方法</a>），放在java_home/jar/lib/ext目录下。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1319879-40d666ccd6046298.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ext.png"></p>
<p>再次执行该java程序<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">im@58user:/usr/lib/jvm/jdk1.8.0_101/jre/lib/ext$ java -cp MyClassLoader.jar com.loadclass.demo.ClassLoaderTest start</span><br><span class="line">sun.misc.Launcher$AppClassLoader@55f96302</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@70dea4e</span><br><span class="line">null</span><br><span class="line">sun.misc.Launcher$AppClassLoader@55f96302</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@70dea4e</span><br><span class="line">null</span><br></pre></td></tr></table></figure></p>
<p>通过终端输出结果我们可以看到执行ClassLoaderTest程序的类加载器是AppClassLoader，但加载ClassLoaderTest类的类加载器是ExtClassLoader。因为java_home/jar/lib/ext/<em>.jar在执行程序之前就被ExtClassLoader类加载器加载过了。**</em>这样避免了类的重复加载～！～！***</p>
<ul>
<li>(System)类加载器：负责加载-classpath/-Djava.class.path所指的目录下的类。开发者可以直接使用标准扩展类加载器。一般来说，Java应用的类都是由他来完成加载的。<br>除了以上三种类型的类加载器，还有一个中比较特殊的：线程上下文类加载器（PS:暂时没做这方面的记录）。</li>
</ul>
<h2 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h2><ul>
<li>定义</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.tzx.reflection;</span><br><span class="line"></span><br><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class MyClassLoader extends ClassLoader&#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;MyClassLoader&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static final String driver = &quot;/home/im/Desktop/&quot;;</span><br><span class="line">    public static final String fileTyep = &quot;.class&quot;;</span><br><span class="line"></span><br><span class="line">    public Class findClass(String name) &#123;</span><br><span class="line">        byte[] data = loadClassData(name);</span><br><span class="line">        return defineClass(data, 0, data.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public byte[] loadClassData(String name) &#123;</span><br><span class="line">        FileInputStream fis = null;</span><br><span class="line">        byte[] data = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            File file = new File(driver + name + fileTyep);</span><br><span class="line">            System.out.println(file.getAbsolutePath());</span><br><span class="line">            fis = new FileInputStream(file);</span><br><span class="line">            ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br><span class="line">            int ch = 0;</span><br><span class="line">            while ((ch = fis.read()) != -1) &#123;</span><br><span class="line">                baos.write(ch);</span><br><span class="line">            &#125;</span><br><span class="line">            data = baos.toByteArray();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(&quot;loadClassData-IOException&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ClassLoaderTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyClassLoader cl1 = new MyClassLoader();</span><br><span class="line">        //磁盘中/home/im/Desktop/Hello.class文件存在</span><br><span class="line">        try &#123;</span><br><span class="line">            Class c1 = cl1.loadClass(&quot;Hello&quot;);</span><br><span class="line">            Object object = c1.newInstance();</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(&quot;main-ClassNotFoundException&quot;);</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>ClassLoader</tag>
        <tag>双亲委派机制</tag>
      </tags>
  </entry>
  <entry>
    <title>java打包成jar|执行jar包中的main方法</title>
    <url>/2017/02/13/java-jar-run-main/</url>
    <content><![CDATA[<h1 id="java打包成jar"><a href="#java打包成jar" class="headerlink" title="java打包成jar"></a>java打包成jar</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jar -cvf [jar包的名字] [需要打包的文件]</span><br></pre></td></tr></table></figure>
<h1 id="执行jar包中的main方法"><a href="#执行jar包中的main方法" class="headerlink" title="执行jar包中的main方法"></a>执行jar包中的main方法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar ****.jar</span><br></pre></td></tr></table></figure>
<p>执行后总是运行指定的主方法，如果 jar 中有多个 main 方法，那么如何运行指定的 main 方法呢？<br>用下面的命令试试看：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -classpath ****.jar ****.****.className [args]</span><br><span class="line">“****.****”表示“包名”；</span><br><span class="line">“className”表示“类名”；</span><br><span class="line">“[args]”表示传入的参数；</span><br></pre></td></tr></table></figure></p>
<p>直接运行 MANIFEST.MF 中指定的 main 方法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar mplus-service-jar-with-dependencies.jar</span><br></pre></td></tr></table></figure></p>
<p>运行指定的 main 方法（MANIFEST.MF 中没有指定的main方法）：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -cp mplus-service-jar-with-dependencies.jar com.smbea.dubbo.bin.Console start</span><br></pre></td></tr></table></figure></p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu14.04创建Genymotion虚拟机</title>
    <url>/2017/02/13/ubuntu-create-genymotion/</url>
    <content><![CDATA[<p>最近工作开发环境有Windows切换到了Ubuntu，以前在Windows环境下使用Genymotion搞Android开发还蛮好用的。那么在Ubuntu环境下桌面创建Genymotion虚拟机呢，今天搞搞试试看～！～！</p>
<h2 id="Virtualbox"><a href="#Virtualbox" class="headerlink" title="Virtualbox"></a>Virtualbox</h2><p>先安装虚拟机软件Virtualbox，没有安装这个软件不能够使用Genymotion软件。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sudo apt-get install virtualbox</span><br></pre></td></tr></table></figure></p>
<h2 id="Genymotion"><a href="#Genymotion" class="headerlink" title="Genymotion"></a>Genymotion</h2><h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>先访问<a href="https://www.genymotion.com/" target="_blank" rel="noopener">Genymotion官网</a>，想要下载必须先注册Genymotion账号。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1319879-4eab5cbad0aac5eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="genymotion.png"></p>
<p>点击右上角的下载按钮，进入下载页面。Genymotion有好多版本，有些时收费的，作为开发者我们使用最基础的版本就够用的（PS:免费）。选择Get Genymotion personal version，进入personal Edit下载genymotion-2.8.1_x64.bin。</p>
<p>执行下边命令，生成名为genymotion的文件夹。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">chmod +x [InstallerPath]/genymotion.bin  </span><br><span class="line">[InstallerPath]/genymotion.bin</span><br></pre></td></tr></table></figure></p>
<h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><p>进入genymotion文件夹后，我们可以看到名为genymotion的可运行程序，双击或者在命令行当中运行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">im@<span class="number">58</span>user:/usr/lib/x86_64-linux-gnu$ sudo /home/im/program/genymotion/./genymotion</span><br><span class="line">Logging activities to file: /home/im/.Genymobile/genymotion.log</span><br><span class="line">Logging activities to file: /home/im/.Genymobile/genymotion.log</span><br><span class="line">Logging activities to file: /home/im/.Genymobile/Genymotion/deployed/Google Nexus <span class="number">5</span>X - <span class="number">6.0</span>.0 - API <span class="number">23</span> - <span class="number">1080</span>x1920/genymotion-player.log</span><br><span class="line">OpenGL connected to <span class="number">192.168</span>.56.101:<span class="number">25000</span></span><br><span class="line">Port <span class="number">22468</span> will be used <span class="keyword">for</span> OpenGL data connections</span><br></pre></td></tr></table></figure>
<p>如果没有问题那么则会像Windows环境下一样启动。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>自古好事多磨</p>
<h1 id="问题1："><a href="#问题1：" class="headerlink" title="问题1："></a>问题1：</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">im@<span class="number">58</span>user:/usr/lib/x86_64-linux-gnu$ sudo /home/im/program/genymotion/./genymotion</span><br><span class="line">/home/im/program/genymotion/./genymotion: /usr/lib/x86_64-linux-gnu/libstdc++.so.6: version `CXXABI_1.3.8<span class="string">' not found (required by /home/im/program/genymotion/libQt5Core.so.5)</span></span><br><span class="line"><span class="string">/home/im/program/genymotion/./genymotion: /usr/lib/x86_64-linux-gnu/libstdc++.so.6: version `GLIBCXX_3.4.20'</span> <span class="function">not <span class="title">found</span> <span class="params">(required by /home/im/program/genymotion/libQt5WebKit.so<span class="number">.5</span>)</span></span></span><br><span class="line"><span class="function">/home/im/program/genymotion/./genymotion: /usr/lib/x86_64-linux-gnu/libstdc++.so.6: version `CXXABI_1.3.8' not <span class="title">found</span> <span class="params">(required by /home/im/program/genymotion/libicui18n.so<span class="number">.52</span>)</span></span></span><br><span class="line"><span class="function">/home/im/program/genymotion/./genymotion: /usr/lib/x86_64-linux-gnu/libstdc++.so.6: version `CXXABI_1.3.8' not <span class="title">found</span> <span class="params">(required by /home/im/program/genymotion/libicuuc.so<span class="number">.52</span>)</span></span></span><br><span class="line"><span class="function">/home/im/program/genymotion/./genymotion: /usr/lib/x86_64-linux-gnu/libstdc++.so.6: version `GLIBCXX_3.4.20' not <span class="title">found</span> <span class="params">(required by /home/im/program/genymotion/libQt5Qml.so<span class="number">.5</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>执行genymotion程序时缺少相应的文件，上网找答案，提示更新gcc为4.9</p>
<p>下边为网络上的解决办法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:ubuntu-toolchain-r/test  </span><br><span class="line">sudo apt-get update  </span><br><span class="line">sudo apt-get install gcc-<span class="number">4.9</span> g++-<span class="number">4.9</span></span><br></pre></td></tr></table></figure></p>
<p>然而在我的电脑环境中执行却没有办法更新gcc。</p>
<p>日志信息：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">im@<span class="number">58</span>user:/usr/lib/x86_64-linux-gnu$ sudo apt-get install gcc-<span class="number">4.9</span> g++-<span class="number">4.9</span></span><br><span class="line">[sudo] password <span class="keyword">for</span> im: </span><br><span class="line">正在读取软件包列表... 完成</span><br><span class="line">正在分析软件包的依赖关系树       </span><br><span class="line">正在读取状态信息... 完成       </span><br><span class="line">有一些软件包无法被安装。如果您用的是 unstable 发行版，这也许是</span><br><span class="line">因为系统无法达到您要求的状态造成的。该版本中可能会有一些您需要的软件</span><br><span class="line">包尚未被创建或是它们已被从新到(Incoming)目录移出。</span><br><span class="line">下列信息可能会对解决问题有所帮助：</span><br><span class="line"></span><br><span class="line">下列软件包有未满足的依赖关系：</span><br><span class="line"> g++-<span class="number">4.9</span>:i386 : 依赖: gcc-<span class="number">4.9</span>-base:i386 (= <span class="number">4.9</span>.4-<span class="number">2</span>ubuntu1~<span class="number">14.04</span>.1) 但是 <span class="number">4.9</span>.3-<span class="number">0</span>ubuntu4 正要被安装</span><br><span class="line">                依赖: libstdc++-<span class="number">4.9</span>-dev:i386 (= <span class="number">4.9</span>.4-<span class="number">2</span>ubuntu1~<span class="number">14.04</span>.1) 但是它将不会被安装</span><br><span class="line">                依赖: libcloog-isl4:i386 (&gt;= <span class="number">0.17</span>) 但是它将不会被安装</span><br><span class="line">                依赖: libmpc3:i386 但是它将不会被安装</span><br><span class="line">                依赖: libmpfr4:i386 (&gt;= <span class="number">3.1</span>.3) 但是它将不会被安装</span><br><span class="line"> gcc-<span class="number">4.9</span>:i386 : 依赖: cpp-<span class="number">4.9</span>:i386 (= <span class="number">4.9</span>.4-<span class="number">2</span>ubuntu1~<span class="number">14.04</span>.1) 但是它将不会被安装</span><br><span class="line">                依赖: gcc-<span class="number">4.9</span>-base:i386 (= <span class="number">4.9</span>.4-<span class="number">2</span>ubuntu1~<span class="number">14.04</span>.1) 但是 <span class="number">4.9</span>.3-<span class="number">0</span>ubuntu4 正要被安装</span><br><span class="line">                依赖: binutils:i386 (&gt;= <span class="number">2.24</span>) 但是它将不会被安装</span><br><span class="line">                依赖: libgcc-<span class="number">4.9</span>-dev:i386 (= <span class="number">4.9</span>.4-<span class="number">2</span>ubuntu1~<span class="number">14.04</span>.1) 但是它将不会被安装</span><br><span class="line">                依赖: libcloog-isl4:i386 (&gt;= <span class="number">0.17</span>) 但是它将不会被安装</span><br><span class="line">                依赖: libmpc3:i386 但是它将不会被安装</span><br><span class="line">                依赖: libmpfr4:i386 (&gt;= <span class="number">3.1</span>.3) 但是它将不会被安装</span><br><span class="line">E: 无法修正错误，因为您要求某些软件包保持现状，就是它们破坏了软件包间的依赖关系。</span><br></pre></td></tr></table></figure></p>
<p>好无奈，没有办法解决这个问题。</p>
<p>再才执行运行genymotion的命令<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">im@<span class="number">58</span>user:/usr/lib/x86_64-linux-gnu$ sudo /home/im/program/genymotion/./genymotion</span><br></pre></td></tr></table></figure></p>
<p>查看输出的日志，有这么一段关键的信息 <figure class="highlight plain"><figcaption><span>version xxx not found```  ，查看了一下该路径下的文件：</span></figcaption><table><tr><td class="code"><pre><span class="line">```java</span><br><span class="line">im@58user:/usr/lib/x86_64-linux-gnu$ ls | grep &quot;libstdc&quot;</span><br><span class="line">libstdc++.so.6</span><br><span class="line">libstdc++.so.6.0.19</span><br><span class="line">im@58user:/usr/lib/x86_64-linux-gnu$ pwd</span><br><span class="line">/usr/lib/x86_64-linux-gnu</span><br></pre></td></tr></table></figure></p>
<p>有libstdc++.so.6这个文件啊！！！</p>
<p>问题二：<br>要升级gcc（PS:升级失败），会不会gcc4.9比gcc4.8的libstdc++.so.6文件版本高。先下载libstdc++看看。<br><a href="http://ftp.debian.org/debian/pool/main/g/gcc-4.9/libstdc++6-4.9-dbg_4.9.2-10_amd64.deb" target="_blank" rel="noopener">http://ftp.debian.org/debian/pool/main/g/gcc-4.9/libstdc++6-4.9-dbg_4.9.2-10_amd64.deb</a> 发现为.deb非常兴奋，是不是直接执行安装就行啦。结果依旧提示“依赖: gcc-4.9-base:i386 ”。</p>
<p>思考思考，先解压看看libstdc++6-4.9-dbg_4.9.2-10_amd64.deb文件里面都有什么：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1319879-7df3856a37aadea6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="libstdc++6-4.9-dbg_4.9.2-10_amd64.deb.png"></p>
<p>找到libstdc++.so.6.0.20并提取出来并修改为libstdc++.so.6，再与 <code>/usr/lib/x86_64-linux-gnu</code> 目录下的libstdc++.so.6替换。再次运行genymotion，成功启动～！～！</p>
<p>解决一个问题的方法有好多种，多尝试，总能找到答案。</p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu的MySQL中文乱码问题--自己躺坑</title>
    <url>/2017/02/08/Ubuntu-mysql-code-error/</url>
    <content><![CDATA[<p>最近一段时间学习Django，在进行与MySQL数据联合使用的插入数据的时候遇到下边的问题：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/usr/local/lib/python2.7/dist-packages/Django-<span class="number">1.11</span>.dev20170117002028-py2.7.egg/django/db/backends/mysql/base.py:<span class="number">109</span>: Warning: Incorrect string value: <span class="string">'\xE6\x88\x90\xE5\x8A\x9F...'</span> <span class="keyword">for</span> column <span class="string">'json'</span> at row <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> self.cursor.execute(query, args)</span><br><span class="line">[<span class="number">07</span>/Feb/<span class="number">2017</span> <span class="number">12</span>:<span class="number">15</span>:<span class="number">21</span>] <span class="string">"GET /index/ HTTP/1.1"</span> <span class="number">200</span> <span class="number">250</span></span><br></pre></td></tr></table></figure></p>
<p>中文无法插入MySQL数据库～！～！</p>
<h2 id="查看数据库编码"><a href="#查看数据库编码" class="headerlink" title="查看数据库编码"></a>查看数据库编码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt; show create database bangjob;</span><br><span class="line">+----------+--------------------------------------------------------------------+</span><br><span class="line">| Database | Create Database                                                    |</span><br><span class="line">+----------+--------------------------------------------------------------------+</span><br><span class="line">| bangjob  | CREATE DATABASE `bangjob` <span class="comment">/*!40100 DEFAULT CHARACTER SET latin1 */</span> |</span><br><span class="line">+----------+--------------------------------------------------------------------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like<span class="string">'%char%'</span>;</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| Variable_name            | Value                      |</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| character_set_client     | utf8                       |</span><br><span class="line">| character_set_connection | utf8                       |</span><br><span class="line">| character_set_database   | latin1                     |</span><br><span class="line">| character_set_filesystem | binary                     |</span><br><span class="line">| character_set_results    | utf8                       |</span><br><span class="line">| character_set_server     | latin1                     |</span><br><span class="line">| character_set_system     | utf8                       |</span><br><span class="line">| character_sets_dir       | /usr/share/mysql/charsets/ |</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line"><span class="number">8</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="修改数据库编码"><a href="#修改数据库编码" class="headerlink" title="修改数据库编码"></a>修改数据库编码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt; set character_set_database=utf8;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt; set character_set_server</span>=utf8;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="查看修改后的结果"><a href="#查看修改后的结果" class="headerlink" title="查看修改后的结果"></a>查看修改后的结果</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like<span class="string">'%char%'</span>;</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| Variable_name            | Value                      |</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| character_set_client     | utf8                       |</span><br><span class="line">| character_set_connection | utf8                       |</span><br><span class="line">| character_set_database   | utf8                       |</span><br><span class="line">| character_set_filesystem | binary                     |</span><br><span class="line">| character_set_results    | utf8                       |</span><br><span class="line">| character_set_server     | utf8                       |</span><br><span class="line">| character_set_system     | utf8                       |</span><br><span class="line">| character_sets_dir       | /usr/share/mysql/charsets/ |</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line"><span class="number">8</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure>
<p>这时候继续插入就没有任何问题了。<br>如果真的是这样简单就好了，因为这样的修改作者在重启MySQL的后<strong>设置失效！！！</strong></p>
<h1 id="继续寻找其它方法"><a href="#继续寻找其它方法" class="headerlink" title="继续寻找其它方法"></a>继续寻找其它方法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sudo gedit /etc/mysql/my.cnf</span><br></pre></td></tr></table></figure>
<p>在my.cnf文件的对应节点添加一下信息：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[client]</span><br><span class="line"><span class="keyword">default</span>-character-set=utf8</span><br><span class="line">[mysqld]</span><br><span class="line"><span class="keyword">default</span>-character-set=utf8</span><br><span class="line">[mysql]</span><br><span class="line"><span class="keyword">default</span>-character-set=utf8</span><br></pre></td></tr></table></figure></p>
<p>然后重启MySQL：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/etc/init.d/mysql start</span><br></pre></td></tr></table></figure></p>
<p>如果能重启那么再次查看数据库编码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="string">"%char%"</span>;</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| Variable_name            | Value                      |</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| character_set_client     | utf8                       |</span><br><span class="line">| character_set_connection | utf8                       |</span><br><span class="line">| character_set_database   | utf8                       |</span><br><span class="line">| character_set_filesystem | binary                     |</span><br><span class="line">| character_set_results    | utf8                       |</span><br><span class="line">| character_set_server     | utf8                       |</span><br><span class="line">| character_set_system     | utf8                       |</span><br><span class="line">| character_sets_dir       | /usr/share/mysql/charsets/ |</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line"><span class="number">8</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span><br></pre></td></tr></table></figure></p>
<p>如果真的时这样就好了，事情的发生总是不像想象的那么简单：<br>在重启MySQL服务的时候发现一直处于等待状态（PS：猜测发生了死锁什么的），这个时候执行 ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>
<p>则会抛出异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ERROR <span class="number">2002</span> (HY000): Can<span class="string">'t connect to local MySQL server through socket '</span>/var/run/mysqld/mysqld.sock<span class="string">' (2)</span></span><br></pre></td></tr></table></figure>
<p>我就是想修改一下编码而已，为什么这么苦-&gt;-&gt;-&gt;-&gt;-&gt;!!!</p>
<p>解决这个问题的时候试过好多方法（重启，恢复）。。。。。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sudo /etc/init.d/mysql status</span><br></pre></td></tr></table></figure></p>
<p>查看mysql的状态：<code>mysql respawn/post-start, (post-start) process 55665</code></p>
<p>这些方式不能解决问题，还是从日志开始吧…<br>找到日至文件 /var/log/mysql/error.log<br><img src="http://upload-images.jianshu.io/upload_images/1319879-1d95c8b3f32bb2c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="某一段日志内容.png"></p>
<p>继续找<code>ERROR 2002 (HY000): Can&#39;t connect to local MySQL server through socket &#39;/var/run/mysqld/mysqld.sock&#39; (2)</code>的解决办法。</p>
<p>答案：</p>
<hr>
<p>[ mysqld  ]  下的 default-character-set=utf8’  改成<br>character_set_server=utf8</p>
<hr>
<p>好了，终于可以重启MySQL了，并且重启后设置的编码依旧生效。</p>
<h1 id="当然之前创建的数据库需要重新创建T-T"><a href="#当然之前创建的数据库需要重新创建T-T" class="headerlink" title="当然之前创建的数据库需要重新创建T_T"></a>当然之前创建的数据库需要重新创建T_T</h1><p>因为 <code>show create database bangjob;</code>展示之前创建的数据编码依旧是<strong>latin1</strong>。。。。。</p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>utf8</tag>
      </tags>
  </entry>
  <entry>
    <title>python、main函数和argv参数</title>
    <url>/2017/02/08/python-main-argvs/</url>
    <content><![CDATA[<p>笔者学习和使用过的语言中：C语言，C++语言，C#语言，Java语言都时有main函数在的，main是程序执行的起点，Python中，也有类似的运行机制，但方式却截然不同：Python使用缩进对齐组织代码的执行，所有没有缩进的代码（非函数定义和类定义），都会在载入时自动执行，这些代码，可以认为是Python的main函数。</p>
<p>举个列子，我们可以清楚的了解：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">im@<span class="number">58</span>user:~/PythonProjects$ cat test.py </span><br><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">	print(<span class="string">'world~!'</span>)</span><br><span class="line">print(<span class="string">'hello'</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	main()</span><br><span class="line">im@<span class="number">58</span>user:~/PythonProjects$ python test.py </span><br><span class="line">hello</span><br><span class="line">world~!</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">&gt; 这样看来是否main函数没有多大的作用呢？</span><br><span class="line"></span><br><span class="line">每个文件（模块）都可以任意写一些没有缩进的代码，并且在载入时自动执行，为了区分主执行文件还是被调用的文件，Python引入了一个变量__name__，当文件是被调用时，__name__的值为模块名，当文件被执行时，__name__为<span class="string">'__main__'</span>。这个特性，我们可以在每个模块中写上测试代码，这些测试代码仅当模块被Python直接执行时才会运行，代码和测试完美的结合在一起。</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">im@<span class="number">58</span>user:~/PythonProjects$ cat test.py </span><br><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(argv)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> argv == <span class="keyword">None</span>:</span><br><span class="line">		print(<span class="string">'world~!'</span>)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		print(argv)</span><br><span class="line">print(<span class="string">'hello'</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	main(sys.argv)</span><br><span class="line">im@<span class="number">58</span>user:~/PythonProjects$ python test.py Tom</span><br><span class="line">hello</span><br><span class="line">[<span class="string">'test.py'</span>, <span class="string">'Tom'</span>]</span><br></pre></td></tr></table></figure></p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>mian</tag>
        <tag>argv</tag>
      </tags>
  </entry>
  <entry>
    <title>python2 import urllib2报错</title>
    <url>/2017/02/08/python2-import-urllib2-error/</url>
    <content><![CDATA[<p>这段时间想玩玩python网页信息爬取，在使用urllib2这个库的时候导入失败，提示信息为：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">im@<span class="number">58</span>user:~/PythonProjects/IOTest$ python</span><br><span class="line">Python <span class="number">2.7</span><span class="number">.6</span> (default, Oct <span class="number">26</span> <span class="number">2016</span>, <span class="number">20</span>:<span class="number">30</span>:<span class="number">19</span>) </span><br><span class="line">[GCC <span class="number">4.8</span><span class="number">.4</span>] on linux2</span><br><span class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> <span class="keyword">or</span> <span class="string">"license"</span> <span class="keyword">for</span> more information.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> urllib2</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"/usr/lib/python2.7/urllib2.py"</span>, line <span class="number">94</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">import</span> httplib</span><br><span class="line">  File <span class="string">"/usr/lib/python2.7/httplib.py"</span>, line <span class="number">80</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">import</span> mimetools</span><br><span class="line">  File <span class="string">"/usr/lib/python2.7/mimetools.py"</span>, line <span class="number">6</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">import</span> tempfile</span><br><span class="line">  File <span class="string">"/usr/lib/python2.7/tempfile.py"</span>, line <span class="number">32</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">import</span> io <span class="keyword">as</span> _io</span><br><span class="line">  File <span class="string">"io.py"</span>, line <span class="number">3</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    os.remove(f)</span><br><span class="line">NameError: name <span class="string">'f'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure></p>
<p>当然我仅仅时想在命令行测试一下是否能导入urllib2这个库，却报出这么一段错误日志。</p>
<p>猜想原因是：自己当前的执行目录中的io.py文件覆盖了python自带的io文件，并且io.py脚本自己没有写完语法有问题造成的。</p>
<p>记录这个错误，这让作者以后pyhon在命名文件时不是那么随意～！～！</p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python2</tag>
        <tag>urllib1L</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 14.04下Django和MySQL环境部署</title>
    <url>/2017/02/08/Ubuntu-django-and-mysql-ide/</url>
    <content><![CDATA[<p>##Python环境搭建##<br>操作系统Ubuntu14.04，自带Python2.7.6<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">im@<span class="number">58</span>user:/$ python</span><br><span class="line">Python <span class="number">2.7</span>.6 (<span class="keyword">default</span>, Oct <span class="number">26</span> <span class="number">2016</span>, <span class="number">20</span>:<span class="number">30</span>:<span class="number">19</span>) </span><br><span class="line">[GCC <span class="number">4.8</span>.4] on linux2</span><br><span class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> or <span class="string">"license"</span> <span class="keyword">for</span> more information.</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p>
<p>##Django环境搭建##<br>目前Django的版本已经到1.11了。先去官网下载Linux对应的文件，然后解压&amp;安装。（<a href="https://www.djangoproject.com/download/" target="_blank" rel="noopener">官网下载地址</a>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">tar xzvf Django-<span class="number">1.11</span>.x.tar.gz</span><br><span class="line">cd Django-<span class="number">1.11</span>.x</span><br><span class="line">sudo python setup.py install</span><br></pre></td></tr></table></figure>
<p>这时可能会提示<figure class="highlight plain"><figcaption><span>No module named setuptools```</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">执行``` sudo https://bootstrap.pypa.io/ez_setup.py -O - | sudo python</span><br></pre></td></tr></table></figure></p>
<p>然后执行<figure class="highlight plain"><figcaption><span>python setyp.py install```</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">到此Django安装成功～！</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##Mysql安装##</span><br><span class="line"></span><br><span class="line">执行一下命令，运行过程中可能需要输入root密码并进行确认。</span><br><span class="line">```java</span><br><span class="line">sudo apt-get install mysql-server mysql-client</span><br><span class="line">sudo apt-get install libmysqld-dev</span><br></pre></td></tr></table></figure></p>
<p>然后链接MySQL和Python<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line">sudo apt-get install python-dev</span><br><span class="line">sudo wget https:<span class="comment">//pypi.python.org/packages/source/M/MySQL-python/MySQL-python-1.2.5.zip</span></span><br><span class="line">unzip MySQL-python-<span class="number">1.2</span>.5.zip</span><br><span class="line">cd MySQL-python-<span class="number">1.2</span>.5/</span><br><span class="line">sudo python setup.py install</span><br></pre></td></tr></table></figure></p>
<p>进入mysql数据库的方式：</p>
<blockquote>
<ul>
<li>sudo mysql</li>
<li>mysql -u root -p<br>然后输入密码</li>
</ul>
</blockquote>
<p>####给mysql设置root密码：####<br>先以第一种方式进入mysql<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt; use mysql;</span><br><span class="line">Reading table information <span class="keyword">for</span> completion of table and column names</span><br><span class="line">You can turn off <span class="keyword">this</span> feature to get a quicker startup with -A</span><br><span class="line"></span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; update user set Password = PASSWORD(<span class="string">'root'</span>) where User =<span class="string">'root'</span>;</span><br><span class="line">Query OK, <span class="number">3</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function">Rows matched: 3  Changed: 3  Warnings: 0</span></span><br><span class="line"><span class="function">mysql&gt; exit</span></span><br><span class="line"><span class="function">括号里面的'root'就是新的密码</span></span><br></pre></td></tr></table></figure></p>
<p>##新建项目##<br>到了验证结果的时候了<br>将当前目录切换到Python的worspace下，输入新建的项目名称：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">im@<span class="number">58</span>user:~/PythonProjects$django-admin.py startproject Hello</span><br><span class="line">im@<span class="number">58</span>user:~/PythonProjects$ cd Hello/</span><br><span class="line">im@<span class="number">58</span>user:~/PythonProjects/Hello$ tree</span><br><span class="line">├── Hello</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── settings.py</span><br><span class="line">│   ├── urls.py</span><br><span class="line">│   └── wsgi.py</span><br><span class="line">└── manage.py</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>init</strong>.py：Python特性，可以是空文件，表明这个文件夹是一个可以导入的包。</li>
<li>settings.py：配置文件，本文主要修改数据库信息、模板目录、加载模块的信息。</li>
<li>url.py：URL配置文件，指定函数与URL的映射关系。</li>
<li>wsgi.py：本文中不会使用，nginx/apache+wsgi在生产环境中运行Django时使用</li>
</ul>
<p>接下来我们写一个HelloWorld页面。<br>在Hello文件下的一级目录创建views.py文件<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">im@<span class="number">58</span>user:~/PythonProjects/Hello$ touch views.py</span><br><span class="line">im@<span class="number">58</span>user:~/PythonProjects/Hello$ ls</span><br><span class="line">Hello  manage.py  views.py</span><br><span class="line">im@<span class="number">58</span>user:~/PythonProjects/Hello$ tree</span><br><span class="line">.</span><br><span class="line">├── Hello</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── settings.py</span><br><span class="line">│   ├── urls.py</span><br><span class="line">│   └── wsgi.py</span><br><span class="line">├── manage.py</span><br><span class="line">└── views.py</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> directory, <span class="number">6</span> files</span><br></pre></td></tr></table></figure></p>
<p>在views.py文件中写入下面代码<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">from django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">hello</span><span class="params">(request)</span>:</span></span><br><span class="line"><span class="function">	return <span class="title">HttpResponse</span><span class="params">(<span class="string">"Hello World~!~!"</span>)</span></span></span><br></pre></td></tr></table></figure></p>
<p>然后再将路径添加在urls.py文件中<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">from django.conf.urls <span class="keyword">import</span> url</span><br><span class="line">from django.contrib <span class="keyword">import</span> admin</span><br><span class="line">from views <span class="keyword">import</span> hello</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(r<span class="string">'^admin/'</span>, admin.site.urls),</span><br><span class="line">    url(r<span class="string">'^hello/'</span>, hello),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>然后在Hello目录下执行<code>python manage.py runserver 0.0.0.0:8080</code>启动服务器<br>打开浏览器访问<a href="http://127.0.0.1:8000/hello/" target="_blank" rel="noopener">http://127.0.0.1:8000/hello/</a> 可以看到展示结果。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1319879-a19f1df512b51616.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Hello world"></p>
<p>想阅读作者的更多文章，可以查看我的公共号：<br>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 14.04下Django项目链接MySQL数据库</title>
    <url>/2017/02/08/Ubuntu-django-connection-mysql/</url>
    <content><![CDATA[<p>在成功安装MySQL-python-1.2.5后，开始配置django的mysql连接配置。<br>打开django项目的二级目录/Hello/Hello/setting.py文件。<br>默认情况下Django数据为sqlite：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Database</span><br><span class="line"># https://docs.djangoproject.com/en/dev/ref/settings/#databases</span><br><span class="line"></span><br><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">'default'</span>: &#123;</span><br><span class="line">        <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.sqlite3'</span>,</span><br><span class="line">        <span class="string">'NAME'</span>: os.path.join(BASE_DIR, <span class="string">'db.sqlite3'</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在我们将它修改为mysql数据库<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Database</span><br><span class="line"># https://docs.djangoproject.com/en/dev/ref/settings/#databases</span><br><span class="line"></span><br><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">'default'</span>: &#123;</span><br><span class="line">        <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.mysql'</span>,</span><br><span class="line">        'NAME': 'mysite',	#数据库名称</span><br><span class="line">        'USER': 'root',		#数据库的用户名</span><br><span class="line">        'PASSWORD': '123',	#数据库对应用户的密码</span><br><span class="line">        'HOST': '127.0.0.1',	#数据库主机</span><br><span class="line">        'PORT': '3306',		#数据库默认端口号</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行数据库同步脚本：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">python mange.py  syncdb</span><br></pre></td></tr></table></figure></p>
<p>上面脚本可能在Django高版本执行报错，1.7及以上可以使用下边：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">python manage.py makemigrations</span><br><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure></p>
<p>执行结果<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">im@<span class="number">58</span>user:~/PythonProjects/Hello$ python manage.py migrate</span><br><span class="line">System check identified some issues:</span><br><span class="line">Operations to perform:</span><br><span class="line">  Apply all migrations: admin, auth, contenttypes, sessions</span><br><span class="line">Running migrations:</span><br><span class="line">  Applying contenttypes.0001_initial... OK</span><br><span class="line">  Applying auth.0001_initial... OK</span><br><span class="line">  Applying admin.0001_initial... OK</span><br><span class="line">  Applying admin.0002_logentry_remove_auto_add... OK</span><br><span class="line">  Applying contenttypes.0002_remove_content_type_name... OK</span><br><span class="line">  Applying auth.0002_alter_permission_name_max_length... OK</span><br><span class="line">  Applying auth.0003_alter_user_email_max_length... OK</span><br><span class="line">  Applying auth.0004_alter_user_username_opts... OK</span><br><span class="line">  Applying auth.0005_alter_user_last_login_null... OK</span><br><span class="line">  Applying auth.0006_require_contenttypes_0002... OK</span><br><span class="line">  Applying auth.0007_alter_validators_add_error_messages... OK</span><br><span class="line">  Applying auth.0008_alter_user_username_max_length... OK</span><br><span class="line">  Applying sessions.0001_initial... OK</span><br></pre></td></tr></table></figure></p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu14.04下如何开启Mysql远程访问</title>
    <url>/2017/02/08/Ubuntu-open-mysql-remote-access/</url>
    <content><![CDATA[<p>在目录/etc/mysql下找到my.cnf，用vim编辑，找到my.cnf里面的<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">#bind-address           = 127.0.0.1</span><br></pre></td></tr></table></figure></p>
<p>将其只能本地ip访问的代码进行注释</p>
<p>然后用root登陆Mysql数据库<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">im@<span class="number">58</span>user:~$ mysql -u root -p</span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is <span class="number">6</span></span><br><span class="line">Server version: <span class="number">5.5</span>.53-<span class="number">0</span>ubuntu0.14.04.1 (Ubuntu)</span><br><span class="line"></span><br><span class="line">Copyright (c) <span class="number">2000</span>, <span class="number">2016</span>, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type <span class="string">'help;'</span> or <span class="string">'\h'</span> <span class="keyword">for</span> help. Type <span class="string">'\c'</span> to clear the current input statement.</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure></p>
<p>然后在执行<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt; grant all on *.* to root@<span class="string">'%'</span> identified by <span class="string">'123'</span>;</span><br><span class="line">myslq&gt; flush privileges;</span><br></pre></td></tr></table></figure></p>
<p>最后就可以在远程用刚才创建的用户和密码登陆mysql。</p>
<p>在执行对用户授权密码的时候可能会遇到下面的错误：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ERROR <span class="number">1290</span> (HY000): The MySQL server is running with the --skip-grant-tables option so it cannot execute <span class="keyword">this</span> statement</span><br></pre></td></tr></table></figure></p>
<p>解决方法：</p>
<blockquote>
<p>先刷新一下权限表。<br>mysql&gt; flush privileges;<br>Query OK, 0 rows affected (0.01 sec)<br>mysql&gt; grant all on cactidb.* to dbuser@’localhost’ identified by ‘123’;<br>Query OK, 0 rows affected (0.00 sec)</p>
</blockquote>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu14.04反编译Apk[试试就知道]</title>
    <url>/2017/02/08/ubuntu-apk-dex2jar/</url>
    <content><![CDATA[<p>作为Android开发者反编译apk是我们需要掌握的技能，那么在Ubuntu环境下反编译怎么进行Apk的反编译呢？</p>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul>
<li><a href="https://sourceforge.net/projects/dex2jar/" target="_blank" rel="noopener">dex2jar</a></li>
<li><a href="http://jd.benow.ca/jd-gui/downloads/jd-gui-0.3.5.linux.i686.tar.gz" target="_blank" rel="noopener">jd-gui</a></li>
</ul>
<h2 id="dex2jar使用"><a href="#dex2jar使用" class="headerlink" title="dex2jar使用"></a>dex2jar使用</h2><ul>
<li>先参照上边提供的<a href="https://sourceforge.net/projects/dex2jar/" target="_blank" rel="noopener">地址</a>下载并解压dex2jar</li>
<li>然后再使用unzip命令解压apk，我们会在目录下边看到.dex文件</li>
<li>执行反编译命令</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh d2j-dex2jar.sh /home/im/Desktop/dex2jar/-debug-apk/classes.dex</span><br></pre></td></tr></table></figure>
<p>上述命令执行的过程中可能会遇到一些问题：</p>
<blockquote>
<ul>
<li>问题1：提示：[d2j-dex2jar.sh: 36: d2j-dex2jar.sh: ./d2j_invoke.sh: Permission denied]<br>原因：d2j_invoke.sh文件没有执行权限<br>解决：添加可执行权限：[sudo chmod +x d2j_invoke.sh]</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>问题2：生产的jar可能为空<br>原因：d2j-dex2jar.sh执行会依赖其它的脚本（单独拷贝出来执行会有问题）<br>解决：执行它的时候dex2jar的其它文件最好也在相同的目录</li>
</ul>
</blockquote>
<p>正确运行结果：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">im@<span class="number">58</span>user:~/Downloads/dex2jar-<span class="number">2.0</span>$ sudo chmod +x d2j_invoke.sh</span><br><span class="line">im@<span class="number">58</span>user:~/Downloads/dex2jar-<span class="number">2.0</span>$ sh d2j-dex2jar.sh /home/im/Desktop/dex2jar/bangjob-apk/classes.dex</span><br><span class="line">dex2jar /home/im/Desktop/dex2jar/bangjob-apk/classes.dex -&gt; ./classes-dex2jar.jar</span><br></pre></td></tr></table></figure></p>
<p>然后会在该目录生成classes-dex2jar.jar文件。</p>
<h2 id="jd-gui使用"><a href="#jd-gui使用" class="headerlink" title="jd-gui使用"></a>jd-gui使用</h2><ul>
<li>先参照上边提供的<a href="http://jd.benow.ca/jd-gui/downloads/jd-gui-0.3.5.linux.i686.tar.gz" target="_blank" rel="noopener">地址</a>下载文件</li>
<li>然后直接打开jd-gui</li>
</ul>
<p>可能遇到的问题：<br>jd-gui程序执行的时候可能没有任何反应，那是因为操作系统可能缺少某些环境。执行该命令：<code>sudo apt-get install gtk2-engines-murrine:i386 libgtk2.0-0:i386 libcanberra-gtk-module:i386 libgtk2.0-0:i386 libxxf86vm1:i386 libsm6:i386 lib32stdc++6 lib32ncurses5 lib32bz2-1.0 libgtk2.0-0:i386 libxxf86vm1:i386 libsm-dev:i386 libcanberra-gtk3-module:i386</code>后然再运行jd-gui程序，画面即将展现～！～！</p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>反编译</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>Android之Service学习笔记</title>
    <url>/2016/12/28/android-service-note/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本来想学习学习Binder通信机制，在学习的过程中又接触AIDL并开始学习，在AIDL学习过程中看到bindService，接着就想回顾一下Service的一些知识。希望温故可以知新，也算是年末最后一篇笔记，给自己明年有一个好的开头~！~！</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><a href="https://developer.android.com/reference/android/app/Service.html" target="_blank" rel="noopener">Service</a> 是一个可以在后台执行长时间运行操作而不提供用户界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。 此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信 (IPC)。 例如，服务可以处理网络事务、播放音乐，执行文件 I/O 或与内容提供程序交互，而所有这一切均可在后台进行。</p>
<h1 id="创建Service"><a href="#创建Service" class="headerlink" title="创建Service"></a>创建Service</h1><p>Service的创建可以分为两种分别是：启动和绑定。</p>
<p>启动：</p>
<blockquote>
<p>当应用组件（如 Activity）通过调用 <a href="https://developer.android.com/reference/android/content/Context.html#startService(android.content.Intent" target="_blank" rel="noopener">startService()</a>) 启动服务时，服务即处于“启动”状态。一旦启动，服务即可在后台无限期运行，即使启动服务的组件已被销毁也不受影响。 已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。例如，它可能通过网络下载或上传文件。 操作完成后，服务会自行停止运行。</p>
</blockquote>
<p>绑定：</p>
<blockquote>
<p>当应用组件通过调用 <a href="https://developer.android.com/reference/android/content/Context.html#bindService(android.content.Intent, android.content.ServiceConnection, int" target="_blank" rel="noopener">bindService()</a>) 绑定到服务时，服务即处于“绑定”状态。绑定服务提供了一个客户端-服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至是利用进程间通信 (IPC) 跨进程执行这些操作。 仅当与另一个应用组件绑定时，绑定服务才会运行。 多个组件可以同时绑定到该服务，但全部取消绑定后，该服务即会被销毁。</p>
</blockquote>
<p>同名的Service只能存在一个，但运行方式可以两种并存。也就是说，它既可以是启动服务（以无限期运行），也允许绑定。问题只是在于您是否实现了一组回调方法：<a href="https://developer.android.com/reference/android/app/Service.html#onStartCommand(android.content.Intent, int, int" target="_blank" rel="noopener">onStartCommand()</a>) （允许组件启动服务）和 <a href="https://developer.android.com/reference/android/app/Service.html#onBind(android.content.Intent" target="_blank" rel="noopener">onBind()</a>) （允许绑定服务）。</p>
<blockquote>
<p>需要注意的是Service它是运行在主线程中的，如果服务执行的CPU密集型或阻塞性质的操作，那么应该在服务内创建新的线程去工作。通过使用单独的线程，可以降低发生“应用无响应”(ANR) 错误的风险，而应用的主线程仍可继续专注于运行用户与 Activity 之间的交互。</p>
</blockquote>
<h1 id="Service之基础"><a href="#Service之基础" class="headerlink" title="Service之基础"></a>Service之基础</h1><p>下边主要介绍Service的一些方法以及其生命周期。</p>
<ul>
<li>onCreate()</li>
</ul>
<blockquote>
<p>首次创建服务时，系统将调用此方法来执行一次性设置程序（在调用 <a href="https://developer.android.com/reference/android/app/Service.html#onStartCommand(android.content.Intent, int, int" target="_blank" rel="noopener">onStartCommand()</a>) 或<a href="https://developer.android.com/reference/android/app/Service.html#onBind(android.content.Intent" target="_blank" rel="noopener">onBind()</a>) 之前）。如果服务已在运行，则不会调用此方法。</p>
</blockquote>
<ul>
<li>onStartCommand()</li>
</ul>
<blockquote>
<p>当另一个组件（如 Activity）通过调用 <a href="https://developer.android.com/reference/android/content/Context.html#startService(android.content.Intent" target="_blank" rel="noopener">startService()</a>) 请求启动服务时，系统将调用此方法。一旦执行此方法，服务即会启动并可在后台无限期运行。<br>关于onStartCommand返回值可以查看<a href="http://dandanlove.com/2016/12/28/onStartCommand/" target="_blank" rel="noopener">Service之onStartCommand剖析笔记</a></p>
</blockquote>
<ul>
<li>onBind()</li>
</ul>
<blockquote>
<p>当另一个组件想通过调用 <a href="https://developer.android.com/reference/android/content/Context.html#bindService(android.content.Intent, android.content.ServiceConnection, int" target="_blank" rel="noopener">bindService()</a>) 与服务绑定（例如执行 RPC）时，系统将调用此方法。在此方法的实现中，您必须通过返回 <a href="https://developer.android.com/reference/android/os/IBinder.html" target="_blank" rel="noopener">IBinder</a><br> 提供一个接口，供客户端用来与服务进行通信。请务必实现此方法，但如果您并不希望允许绑定，则应返回 null。</p>
</blockquote>
<ul>
<li>onRebind()</li>
</ul>
<blockquote>
<p>如果之前有断开连接的时候调用onUnbind方法，并且其返回值为ture。那么在新的客户端需要进行和服务进行连接的时候会调用该方法。</p>
</blockquote>
<ul>
<li>onUnbind()</li>
</ul>
<blockquote>
<p>和onRebind()对应，如果想在新的客户端连接的时候收到通知那么onUnbind()的返回值设置为ture，但改方法的默认返回值为false。</p>
</blockquote>
<ul>
<li>onDestroy()<blockquote>
<p>当服务不再使用且将被销毁时，系统将调用此方法。服务应该实现此方法来清理所有资源，如线程、注册的侦听器、接收器等。 这是服务接收的最后一个调用。</p>
</blockquote>
</li>
</ul>
<h1 id="Service的声明周期"><a href="#Service的声明周期" class="headerlink" title="Service的声明周期"></a>Service的声明周期</h1><p><img src="https://developer.android.com/images/service_lifecycle.png" alt="Service生命周期"></p>
<p>该图分别表示了startService和bindService的声明周期，那么当Service即有startService又有bindService时呢？</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1319879-75e2dd7f28a2ded2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Service的生命周期.png"></p>
<p>该图是作者使用同一个Service和多个不同的client去bindService和startService得出的结论。</p>
<blockquote>
<ul>
<li>Service类似于单例，无论启动多少次onCreate只执行一次，除非执行了onDestory或者stopSelf；</li>
<li>当client进行startService的时候，Service会调用onStartCommand方法。所以我们一般会在这个方法法中处理传递事件；</li>
<li>当client在进行stopService的时候，如果此时没有任何其他的client与其绑定（startService | bindService）那么Service才会执行onDestory方法；</li>
<li>当client在进行bindService的时候，如果Service没有被bind过那么Server会调用它的onBind方法。因为当Service的onBind方法被调用过后Ibinder已经被AMS获取到，那么在client进行bindService的时候会先判断是否Service的onUnbind方法已经被调用过，如果没有那么直接返回该Ibinder，否则根据onUnbind的返回值判断是否调用onRebind方法；</li>
<li>当client进行onbindService的时候，如果此时没有任何client在bind状态，那么就会调用Service的onUnbind，然后再判断是否有其他的client与Service绑定（startService），如果没有的话，那么Service就会调用onDestroy方法；</li>
</ul>
</blockquote>
<h1 id="下边是源码的方法执行流程："><a href="#下边是源码的方法执行流程：" class="headerlink" title="下边是源码的方法执行流程："></a>下边是源码的方法执行流程：</h1><p><img src="http://upload-images.jianshu.io/upload_images/1319879-7184a2c6402fe367.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="startService.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1319879-c7cb6e59eee2de3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="bindService.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1319879-57eda9c3c8bf69ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="unbindService.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1319879-a4e636e86d0134cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="stopService&amp;stopSelf.png"></p>
<p>上面流程图只是方法的调用，关于具体方法的实现还没有进行仔细的研究所以这里就不贴了。<br>看到这里关于Service的基础知识应该回顾的差不多，我们一起期待新的一年的开始吧~！~！~！</p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Service</tag>
      </tags>
  </entry>
  <entry>
    <title>Service之onStartCommand剖析笔记</title>
    <url>/2016/12/28/onStartCommand/</url>
    <content><![CDATA[<p>Service是我们学习Android的基石之一，它在移动应用程序中使用非常广泛。比如应用定位，push消息，内存流量监听等等。<br>记得大四那年在公司实习的时候，我做的第一个调研就是怎么让接受服务器push的Service不被kill掉（或kill后实现重新启动）。在调研的过程中就了解到如果Service的onStartCommand方法返回值为START_STICKY时，那么Service在不久后就会尝试重启。。。。现在自己重温Service知识点，想将其记录一下让自己对其印象更加深刻。</p>
<p>我们常用的onStartCommand返回值有START_STICKY、START_NOT_STICKY、START_REDELIVER_INTENT等等。</p>
<h1 id="START-STICKY："><a href="#START-STICKY：" class="headerlink" title="START_STICKY："></a>START_STICKY：</h1><blockquote>
<p>Constant to return from onStartCommand(Intent, int, int): if this service’s process is killed while it is started (after returning from onStartCommand(Intent, int, int)), then leave it in the started state but don’t retain this delivered intent. Later the system will try to re-create the service. Because it is in the started state, it will guarantee to call onStartCommand(Intent, int, int) after creating the new service instance; if there are not any pending start commands to be delivered to the service, it will be called with a null intent object, so you must take care to check for this.<br>This mode makes sense for things that will be explicitly started and stopped to run for arbitrary periods of time, such as a service performing background music playback.</p>
</blockquote>
<blockquote>
<ul>
<li>如果在onStartCommand(Intent, int, int)返回恒为START_STICKY。那么假设这个服务所在的进程被杀掉，那么开始在启动onStartCommand(Intent, int, int)方方法是传过来的Intent不会被保留。稍后系统会尝试重新创建这个service，并保证开始在创建新的service实例后调用onStartCommand(Intent, int, int)方法。如果这里没有任何挂起的服务调用service，那么系统会通过空Intent调用onStartCommand(Intent, int, int)方法。此模式对于明确启动和停止运行任意时间段（例如执行背景音乐播放的服务）的事物有意义。</li>
<li>getApplicationInfo().targetSdkVersion &gt;= Build.VERSION_CODES.ECLAIR时默认为START_STICKY</li>
</ul>
</blockquote>
<h1 id="START-STICKY-COMPATIBILITY："><a href="#START-STICKY-COMPATIBILITY：" class="headerlink" title="START_STICKY_COMPATIBILITY："></a>START_STICKY_COMPATIBILITY：</h1><blockquote>
<p>Constant to return from onStartCommand(Intent, int, int): compatibility version of START_STICKY that does not guarantee that onStartCommand(Intent, int, int) will be called again after being killed.</p>
<ul>
<li>对START_STICKY的兼容，不保证service杀掉后调用onStartCommand(Intent, int, int)。</li>
<li>getApplicationInfo().targetSdkVersion &lt; Build.VERSION_CODES.ECLAIR时默认为START_STICKY_COMPATIBILITY</li>
</ul>
</blockquote>
<h1 id="START-NOT-STICKY："><a href="#START-NOT-STICKY：" class="headerlink" title="START_NOT_STICKY："></a>START_NOT_STICKY：</h1><blockquote>
<p>Constant to return from onStartCommand(Intent, int, int): if this service’s process is killed while it is started (after returning from onStartCommand(Intent, int, int)), and there are no new start intents to deliver to it, then take the service out of the started state and don’t recreate until a future explicit call to Context.startService(Intent). The service will not receive a onStartCommand(Intent, int, int) call with a null Intent because it will not be re-started if there are no pending Intents to deliver.</p>
</blockquote>
<blockquote>
<p>如果在onStartCommand(Intent, int, int)返回恒为START_STICKY。那么假设这个服务所在的进程被杀掉，而且没有一个新的intent启动它。那么服务的状态将不会被保留，直到一个新的显示调用 Context.startService(Intent)。如果没有一个挂起的Intent要传递，否则系统不会重建服务。</p>
</blockquote>
<h1 id="START-REDELIVER-INTENT："><a href="#START-REDELIVER-INTENT：" class="headerlink" title="START_REDELIVER_INTENT："></a>START_REDELIVER_INTENT：</h1><blockquote>
<p>Constant to return from onStartCommand(Intent, int, int): if this service’s process is killed while it is started (after returning from onStartCommand(Intent, int, int)), then it will be scheduled for a restart and the last delivered Intent re-delivered to it again via onStartCommand(Intent, int, int). This Intent will remain scheduled for redelivery until the service calls stopSelf(int) with the start ID provided to onStartCommand(Intent, int, int). The service will not receive a onStartCommand(Intent, int, int) call with a null Intent because it will will only be re-started if it is not finished processing all Intents sent to it (and any such pending events will be delivered at the point of restart).</p>
</blockquote>
<blockquote>
<p>如果在onStartCommand(Intent, int, int)返回恒为START_STICKY。那么假设这个服务所在的进程被杀掉,那么这个服务将会重启并且将最后一个传递的Intent再次传递给onStartCommand(Intent, int, int)。这个Intent将会一直保留直到当前service调用stopSelf(int)</p>
</blockquote>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><ul>
<li>如果希望Service一直存活并且保留上次启动它的intent的数据，那么return START_REDELIVER_INTENT；</li>
<li>如果只希望Service一直存活不需要intent中的数据，那么return START_STICKY；</li>
<li>如果希望Service执行完指定的任务后销毁，那么return START_NOT_STICKY；</li>
<li>如果没有什么要求那么直接return super.onStartCommand；</li>
</ul>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Service</tag>
      </tags>
  </entry>
  <entry>
    <title>linkToDeath机制了解和使用</title>
    <url>/2016/12/21/link-to-death/</url>
    <content><![CDATA[<p>在学习 <code>Binder</code> 和 <code>AIDL</code> 的过程中遇到的一些有意思的事情~！<br><code>linkToDeath</code> 机制，我们先看看官网如何介绍：</p>
<blockquote>
<p>When working with remote objects, you often want to find out when they are no longer valid. There are three ways this can be determined:<br>The <a href="https://developer.android.com/reference/android/os/IBinder.html#transact(int, android.os.Parcel, android.os.Parcel, int" target="_blank" rel="noopener">transact()</a>)<br> method will throw a <a href="https://developer.android.com/reference/android/os/RemoteException.html" target="_blank" rel="noopener">RemoteException</a><br> exception if you try to call it on an IBinder whose process no longer exists.<br>The <a href="https://developer.android.com/reference/android/os/IBinder.html#pingBinder(" target="_blank" rel="noopener">pingBinder()</a>)<br> method can be called, and will return false if the remote process no longer exists.<br>The <a href="https://developer.android.com/reference/android/os/IBinder.html#linkToDeath(android.os.IBinder.DeathRecipient, int" target="_blank" rel="noopener">linkToDeath()</a>)<br> method can be used to register a <a href="https://developer.android.com/reference/android/os/IBinder.DeathRecipient.html" target="_blank" rel="noopener">IBinder.DeathRecipient</a><br> with the IBinder, which will be called when its containing process goes away.</p>
</blockquote>
<p>总结：我们可以通过三种方式来检测远程对象是否存活。</p>
<ul>
<li>调用远程方法的时候捕获 <code>RemoteException(DeadObjectException)</code>；</li>
<li>调用 <code>IBinder</code> 的 <code>pingBinder()</code> 进行检测；</li>
<li>实现 <code>IBinder.DeathRecipient</code> 接口回调；</li>
</ul>
<h1 id="Binder意外中断"><a href="#Binder意外中断" class="headerlink" title="Binder意外中断"></a>Binder意外中断</h1><p>往往是由于服务端进程意外停止了，这时我们需要重新连接服务。<br>那么我们可以使用 <code>linkToDeath</code> 机制，如果使用 <code>bindService</code> 那么还可以通过<code>ServiceConnection.onServiceDisconnected</code> 方法进行重连。</p>
<h2 id="捕获RemoteException"><a href="#捕获RemoteException" class="headerlink" title="捕获RemoteException"></a>捕获RemoteException</h2><p>在调用远程服务的时候，如果服务挂掉，那么我们客户端会接受到抛出的 <code>RemoteException</code> 异常，监听该异常进行处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">android.os.DeadObjectException</span><br><span class="line">	at android.os.BinderProxy.transact(Native Method)</span><br><span class="line">	at com.tzx.aidlinout.aidl.IBookManager$Stub$Proxy.addInBook(IBookManager.java:<span class="number">159</span>)</span><br><span class="line">	at com.tzx.aidlinout.MainActivity.onClick(MainActivity.java:<span class="number">117</span>)</span><br><span class="line">	at android.view.View.performClick(View.java:<span class="number">3514</span>)</span><br><span class="line">	at android.view.View$PerformClick.run(View.java:<span class="number">14125</span>)</span><br><span class="line">	at android.os.Handler.handleCallback(Handler.java:<span class="number">605</span>)</span><br><span class="line">	at android.os.Handler.dispatchMessage(Handler.java:<span class="number">92</span>)</span><br><span class="line">	at android.os.Looper.loop(Looper.java:<span class="number">137</span>)</span><br><span class="line">	at android.app.ActivityThread.main(ActivityThread.java:<span class="number">4439</span>)</span><br><span class="line">	at java.lang.reflect.Method.invokeNative(Native Method)</span><br><span class="line">	at java.lang.reflect.Method.invoke(Method.java:<span class="number">511</span>)</span><br><span class="line">	at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:<span class="number">787</span>)</span><br><span class="line">	at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:<span class="number">554</span>)</span><br><span class="line">	at dalvik.system.NativeStart.main(Native Method)</span><br></pre></td></tr></table></figure>
<h2 id="pingBinder进行检测"><a href="#pingBinder进行检测" class="headerlink" title="pingBinder进行检测"></a>pingBinder进行检测</h2><p><code>pingBinder()</code> 方法会返回当前远程服务的状态 <code>（true|false）</code></p>
<h2 id="IBinder-DeathRecipient"><a href="#IBinder-DeathRecipient" class="headerlink" title="IBinder.DeathRecipient"></a>IBinder.DeathRecipient</h2><p>实现了 <code>IBinder.DeathRecipient</code> 接口的参数调用 <code>linkToDeath()</code> 方法，可以在 <code>binderDied</code> 方法中处理中断逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">binder.linkToDeath(<span class="keyword">new</span> IBinder.DeathRecipient() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binderDied</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Log.d(<span class="string">"binder"</span>, <span class="string">"binderDied calling~!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>先看下边的 <code>log</code> ，从中我们可以总结出以上 <code>4</code> 中 <code>Binder</code> 中断处理方法的执行顺序：</p>
<blockquote>
<p>linkToDeath &gt; onServiceDisconnected &gt; pingBinder &gt; transact()</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用远程服务</span></span><br><span class="line">binder.pingBinder = <span class="keyword">true</span></span><br><span class="line">Binder Thread #2	//远程服务的当前线程名称</span><br><span class="line"><span class="comment">//kill远程服务存在的进程</span></span><br><span class="line">binderDied calling~!</span><br><span class="line">onServiceDisconnected</span><br><span class="line">binder.pingBinder = <span class="keyword">false</span></span><br><span class="line">android.os.DeadObjectException</span><br><span class="line">	at android.os.BinderProxy.transact(Native Method)</span><br><span class="line">	at com.tzx.aidlinout.aidl.IBookManager$Stub$Proxy.addInBook(IBookManager.java:<span class="number">159</span>)</span><br><span class="line">	at com.tzx.aidlinout.MainActivity.onClick(MainActivity.java:<span class="number">117</span>)</span><br><span class="line">	at android.view.View.performClick(View.java:<span class="number">3514</span>)</span><br><span class="line">	at android.view.View$PerformClick.run(View.java:<span class="number">14125</span>)</span><br><span class="line">	at android.os.Handler.handleCallback(Handler.java:<span class="number">605</span>)</span><br><span class="line">	at android.os.Handler.dispatchMessage(Handler.java:<span class="number">92</span>)</span><br><span class="line">	at android.os.Looper.loop(Looper.java:<span class="number">137</span>)</span><br><span class="line">	at android.app.ActivityThread.main(ActivityThread.java:<span class="number">4439</span>)</span><br><span class="line">	at java.lang.reflect.Method.invokeNative(Native Method)</span><br><span class="line">	at java.lang.reflect.Method.invoke(Method.java:<span class="number">511</span>)</span><br><span class="line">	at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:<span class="number">787</span>)</span><br><span class="line">	at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:<span class="number">554</span>)</span><br><span class="line">	at dalvik.system.NativeStart.main(Native Method)</span><br></pre></td></tr></table></figure>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>这里讲一个 <code>Android</code> 源码中的类：<code>RemoteCallbackList</code>。<br>它在内部对列表中的每一个数据实现了 <code>Callback</code>。而 <code>Callback</code> 实现了<code>IBinder.DeathRecipient</code> 接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteCallbackList</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">IInterface</span>&gt; </span>&#123;</span><br><span class="line">	ArrayMap&lt;IBinder, Callback&gt; mCallbacks</span><br><span class="line">            = <span class="keyword">new</span> ArrayMap&lt;IBinder, Callback&gt;();</span><br><span class="line">	<span class="keyword">private</span> Object[] mActiveBroadcast;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mBroadcastCount = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mKilled = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Callback</span> <span class="keyword">implements</span> <span class="title">IBinder</span>.<span class="title">DeathRecipient</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> E mCallback;</span><br><span class="line">        <span class="keyword">final</span> Object mCookie;</span><br><span class="line">        </span><br><span class="line">        Callback(E callback, Object cookie) &#123;</span><br><span class="line">            mCallback = callback;</span><br><span class="line">            mCookie = cookie;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binderDied</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mCallbacks) &#123;</span><br><span class="line">                mCallbacks.remove(mCallback.asBinder());</span><br><span class="line">            &#125;</span><br><span class="line">            onCallbackDied(mCallback, mCookie);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/******其他代码省略*******/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>AIDL</tag>
        <tag>Binder</tag>
      </tags>
  </entry>
  <entry>
    <title>AIDL源码解析in、out和inout</title>
    <url>/2016/10/27/aidl-tag-type/</url>
    <content><![CDATA[<p>为什么会想写这篇文章，只因为一个error。”aidl.exe E  4928  5836 type_namespace.cpp:130]     ‘Book’ can be an out type, so you must declare it as in, out or inout. “看过上一篇文章<a href="http://dandanlove.com/2016/10/27/aidl-study/" target="_blank" rel="noopener">Android：IPC之AIDL的学习和总结</a>的同学都知道这是因为在AIDL文件中使用非常规类型作为参数传递的时候没有标记指向tag，那么到底为什么会是这样子的呢，作为一个好奇宝宝我想好好看看。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><a href="https://developer.android.com/guide/components/aidl.html" target="_blank" rel="noopener">官网介绍AIDL</a>的时候上有这么一段话</p>
<blockquote>
<ul>
<li>All non-primitive parameters require a directional tag indicating which way the data goes. Either in, out, or inout (see the example below).</li>
<li>Primitives are in by default, and cannot be otherwise.</li>
<li>Caution: You should limit the direction to what is truly needed, because marshalling parameters is expensive.</li>
</ul>
</blockquote>
<p>大概意思是非默认类型的参数都需要添加指向标签in，out或inout。根据自己的需求去添加，因为实现是有代价的。</p>
<h2 id="已知结论"><a href="#已知结论" class="headerlink" title="已知结论"></a>已知结论</h2><p>看过我写的<a href="http://dandanlove.com/2016/10/27/aidl-study/" target="_blank" rel="noopener">Android：IPC之AIDL的学习和总结</a>的同学都知道：</p>
<blockquote>
<ul>
<li>in表示输入型参数（Server可以获取到Client传递过去的数据，但是不能对Client端的数据进行修改）</li>
<li>out表示输出型参数（Server获取不到Client传递过去的数据，但是能对Client端的数据进行修改）</li>
<li>inout表示输入输出型参数（Server可以获取到Client传递过去的数据，但是能对Client端的数据进行修改）。</li>
</ul>
</blockquote>
<h2 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h2><p>下边我们就研究一个in，out或inout为什么能代表不同的传输方式，为什么实现的代价不一样。</p>
<h2 id="过程验证"><a href="#过程验证" class="headerlink" title="过程验证"></a>过程验证</h2><p>创建Book.aidl文件<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzx.aidldemo.aidl;</span><br><span class="line">parcelable Book;</span><br></pre></td></tr></table></figure></p>
<p>创建Book.java文件<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzx.aidldemo.aidl;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> bookId;</span><br><span class="line">    <span class="keyword">public</span> String bookName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(<span class="keyword">int</span> bookId, String bookName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bookId = bookId;</span><br><span class="line">        <span class="keyword">this</span>.bookName = bookName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从序列化后的对象中创建原始对象</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Book</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">        bookId = in.readInt();</span><br><span class="line">        bookName = in.readString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Creator&lt;Book&gt; CREATOR = <span class="keyword">new</span> Creator&lt;Book&gt;() &#123;</span><br><span class="line">        <span class="comment">//从序列化后的对象中创建原始对象</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Book <span class="title">createFromParcel</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Book(in);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//指定长度的原始对象数组</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Book[] newArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Book[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//返回当前对象的内容描述。如果含有文件描述符，返回1，否则返回0，几乎所有情况都返回0</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将当前对象写入序列化结构中，其flags标识有两种（1|0）。</span></span><br><span class="line">    <span class="comment">//为1时标识当前对象需要作为返回值返回，不能立即释放资源，几乎所有情况下都为0.</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        dest.writeInt(bookId);</span><br><span class="line">        dest.writeString(bookName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"[bookId="</span> + bookId + <span class="string">",bookName='"</span> + bookName + <span class="string">"']"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建aidl接口文件IBookManager.aidl文件<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzx.aidlinout.aidl;</span><br><span class="line"><span class="keyword">import</span> com.tzx.aidlinout.aidl.Book;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IBookManager</span> </span>&#123;</span><br><span class="line">    <span class="function">Book <span class="title">addInBook</span><span class="params">(in Book book)</span></span>;</span><br><span class="line">    <span class="function">Book <span class="title">addOutBook</span><span class="params">(out Book book)</span></span>;</span><br><span class="line">    <span class="function">Book <span class="title">addInoutBook</span><span class="params">(inout Book book)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建远程服务<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将bookId都改为-1，在bookName后面都添加参数的tag标记</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookManagerService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CopyOnWriteArrayList list = <span class="keyword">new</span> CopyOnWriteArrayList();</span><br><span class="line">    <span class="keyword">private</span> IBinder mBinder = <span class="keyword">new</span> IBookManager.Stub()&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Book <span class="title">addInBook</span><span class="params">(Book book)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            book.bookId = -<span class="number">1</span>;</span><br><span class="line">            book.bookName = book.bookName + <span class="string">"-in"</span>;</span><br><span class="line">            list.add(book);</span><br><span class="line">            <span class="keyword">return</span> book;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Book <span class="title">addOutBook</span><span class="params">(Book book)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            book.bookId = -<span class="number">1</span>;</span><br><span class="line">            book.bookName = book.bookName + <span class="string">"-out"</span>;</span><br><span class="line">            list.add(book);</span><br><span class="line">            <span class="keyword">return</span> book;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Book <span class="title">addInoutBook</span><span class="params">(Book book)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            book.bookId = -<span class="number">1</span>;</span><br><span class="line">            book.bookName = book.bookName + <span class="string">"-inout"</span>;</span><br><span class="line">            list.add(book);</span><br><span class="line">            <span class="keyword">return</span> book;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">getBookList</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mBinder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在创建上面的文件的过程中，遇到不太清楚的或者编译出现Error的，可以参考上一篇文章<a href="http://dandanlove.com/2016/10/27/aidl-study/" target="_blank" rel="noopener">Android：IPC之AIDL的学习和总结</a>。</p>
<p>具体方法调用的Activity就不写全部代码了，我们看看三种方法的调用<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (v.getId()) &#123;</span><br><span class="line">            <span class="keyword">case</span> R.id.book_in:</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> bookId = Integer.parseInt(bookIdET.getText().toString());</span><br><span class="line">                    String bookName = bookNameET.getText().toString();</span><br><span class="line">                    <span class="keyword">if</span> (bookId &lt;= <span class="number">0</span> || TextUtils.isEmpty(bookName)) <span class="keyword">return</span>;</span><br><span class="line">                    StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                    <span class="comment">//LogUtils.d("-----------book_in-----------------");</span></span><br><span class="line">                    Book book0 = <span class="keyword">new</span> Book(bookId, bookName);</span><br><span class="line">                    String source = <span class="string">"source:"</span> + book0.toString();</span><br><span class="line">                    <span class="comment">//LogUtils.d(source);</span></span><br><span class="line">                    builder.append(source);</span><br><span class="line">                    builder.append(<span class="string">'\n'</span>);</span><br><span class="line">                    String result = <span class="string">"result:"</span> + bookManager.addInBook(book0).toString();</span><br><span class="line">                    <span class="comment">//LogUtils.d(result);</span></span><br><span class="line">                    builder.append(result);</span><br><span class="line">                    builder.append(<span class="string">'\n'</span>);</span><br><span class="line">                    source = <span class="string">"source"</span> + book0.toString();</span><br><span class="line">                    <span class="comment">//LogUtils.d(source);</span></span><br><span class="line">                    builder.append(source);</span><br><span class="line">                    <span class="comment">//LogUtils.d("**************book_in****************");</span></span><br><span class="line">                    bookinfoTV.setText(builder.toString());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> R.id.book_out:</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> bookId = Integer.parseInt(bookIdET.getText().toString());</span><br><span class="line">                    String bookName = bookNameET.getText().toString();</span><br><span class="line">                    <span class="keyword">if</span> (bookId &lt;= <span class="number">0</span> || TextUtils.isEmpty(bookName)) <span class="keyword">return</span>;</span><br><span class="line">                    StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                    <span class="comment">//LogUtils.d("-----------book_out-----------------");</span></span><br><span class="line">                    Book book0 = <span class="keyword">new</span> Book(bookId, bookName);</span><br><span class="line">                    String source = <span class="string">"source:"</span> + book0.toString();</span><br><span class="line">                    <span class="comment">//LogUtils.d(source);</span></span><br><span class="line">                    builder.append(source);</span><br><span class="line">                    builder.append(<span class="string">'\n'</span>);</span><br><span class="line">                    String result = <span class="string">"result:"</span> + bookManager.addOutBook(book0).toString();</span><br><span class="line">                    <span class="comment">//LogUtils.d(result);</span></span><br><span class="line">                    builder.append(result);</span><br><span class="line">                    builder.append(<span class="string">'\n'</span>);</span><br><span class="line">                    source = <span class="string">"source"</span> + book0.toString();</span><br><span class="line">                    <span class="comment">//LogUtils.d(source);</span></span><br><span class="line">                    builder.append(source);</span><br><span class="line">                    <span class="comment">//LogUtils.d("**************book_out****************");</span></span><br><span class="line">                    bookinfoTV.setText(builder.toString());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> R.id.book_inout:</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> bookId = Integer.parseInt(bookIdET.getText().toString());</span><br><span class="line">                    String bookName = bookNameET.getText().toString();</span><br><span class="line">                    <span class="keyword">if</span> (bookId &lt;= <span class="number">0</span> || TextUtils.isEmpty(bookName)) <span class="keyword">return</span>;</span><br><span class="line">                    StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                    <span class="comment">//LogUtils.d("-----------book_inout-----------------");</span></span><br><span class="line">                    Book book0 = <span class="keyword">new</span> Book(bookId, bookName);</span><br><span class="line">                    String source = <span class="string">"source:"</span> + book0.toString();</span><br><span class="line">                    <span class="comment">//LogUtils.d(source);</span></span><br><span class="line">                    builder.append(source);</span><br><span class="line">                    builder.append(<span class="string">'\n'</span>);</span><br><span class="line">                    String result = <span class="string">"result:"</span> + bookManager.addInoutBook(book0).toString();</span><br><span class="line">                    <span class="comment">//LogUtils.d(result);</span></span><br><span class="line">                    builder.append(result);</span><br><span class="line">                    builder.append(<span class="string">'\n'</span>);</span><br><span class="line">                    source = <span class="string">"source"</span> + book0.toString();</span><br><span class="line">                    <span class="comment">//LogUtils.d(source);</span></span><br><span class="line">                    builder.append(source);</span><br><span class="line">                    <span class="comment">//LogUtils.d("**************book_inout****************");</span></span><br><span class="line">                    bookinfoTV.setText(builder.toString());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>创建好上面三个文件后，我们编译整个项目工程（PS：生成aidl接口实现类）。</p>
<p>运行结果<br><img src="https://github.com/stven0king/aidl-study/raw/master/AIDLinout/aidlinout.gif" alt="AIDLinout运行结果"></p>
<p>下边是与结果相对应的Log输出<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">14962</span>-<span class="number">14962</span>/com.tzx.aidlinout D/xxx: -----------book_in-----------------</span><br><span class="line"><span class="number">14962</span>-<span class="number">14962</span>/com.tzx.aidlinout D/xxx: source:[bookId=<span class="number">1212</span>,bookName=C++]</span><br><span class="line"><span class="number">14962</span>-<span class="number">14962</span>/com.tzx.aidlinout D/xxx: result:[bookId=-<span class="number">1</span>,bookName=C++-in]</span><br><span class="line"><span class="number">14962</span>-<span class="number">14962</span>/com.tzx.aidlinout D/xxx: source[bookId=<span class="number">1212</span>,bookName=C++]</span><br><span class="line"><span class="number">14962</span>-<span class="number">14962</span>/com.tzx.aidlinout D/xxx: **************book_in****************</span><br><span class="line"><span class="number">14962</span>-<span class="number">14962</span>/com.tzx.aidlinout D/xxx: -----------book_out-----------------</span><br><span class="line"><span class="number">14962</span>-<span class="number">14962</span>/com.tzx.aidlinout D/xxx: source:[bookId=<span class="number">1212</span>,bookName=C++]</span><br><span class="line"><span class="number">14962</span>-<span class="number">14962</span>/com.tzx.aidlinout D/xxx: result:[bookId=-<span class="number">1</span>,bookName=<span class="keyword">null</span>-out]</span><br><span class="line"><span class="number">14962</span>-<span class="number">14962</span>/com.tzx.aidlinout D/xxx: source[bookId=-<span class="number">1</span>,bookName=<span class="keyword">null</span>-out]</span><br><span class="line"><span class="number">14962</span>-<span class="number">14962</span>/com.tzx.aidlinout D/xxx: **************book_out****************</span><br><span class="line"><span class="number">14962</span>-<span class="number">14962</span>/com.tzx.aidlinout D/xxx: -----------book_inout-----------------</span><br><span class="line"><span class="number">14962</span>-<span class="number">14962</span>/com.tzx.aidlinout D/xxx: source:[bookId=<span class="number">1212</span>,bookName=C++]</span><br><span class="line"><span class="number">14962</span>-<span class="number">14962</span>/com.tzx.aidlinout D/xxx: result:[bookId=-<span class="number">1</span>,bookName=C++-inout]</span><br><span class="line"><span class="number">14962</span>-<span class="number">14962</span>/com.tzx.aidlinout D/xxx: source[bookId=-<span class="number">1</span>,bookName=C++-inout]</span><br><span class="line"><span class="number">14962</span>-<span class="number">14962</span>/com.tzx.aidlinout D/xxx: **************book_inout****************</span><br></pre></td></tr></table></figure></p>
<p>实际结果与我们已知结论一致~！~！</p>
<p>但问题我们还没有解决，我们继续看代码，其实所有的实现都是在改接口实现类中IBookManager.java</p>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tzx.aidlinout.aidl;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBookManager</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">IInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> com.tzx.aidlinout.aidl.<span class="function">Book <span class="title">addInBook</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        com.tzx.aidlinout.aidl.Book book)</span> <span class="keyword">throws</span> android.os.RemoteException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> com.tzx.aidlinout.aidl.<span class="function">Book <span class="title">addOutBook</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        com.tzx.aidlinout.aidl.Book book)</span> <span class="keyword">throws</span> android.os.RemoteException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> com.tzx.aidlinout.aidl.<span class="function">Book <span class="title">addInoutBook</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        com.tzx.aidlinout.aidl.Book book)</span> <span class="keyword">throws</span> android.os.RemoteException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> java.util.List&lt;com.tzx.aidlinout.aidl.Book&gt; getBookList()</span><br><span class="line">        <span class="keyword">throws</span> android.os.RemoteException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Local-side IPC implementation stub class. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">tzx</span>.<span class="title">aidlinout</span>.<span class="title">aidl</span>.<span class="title">IBookManager</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String DESCRIPTOR = <span class="string">"com.tzx.aidlinout.aidl.IBookManager"</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_addInBook = (android.os.IBinder.FIRST_CALL_TRANSACTION +</span><br><span class="line">            <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_addOutBook = (android.os.IBinder.FIRST_CALL_TRANSACTION +</span><br><span class="line">            <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_addInoutBook = (android.os.IBinder.FIRST_CALL_TRANSACTION +</span><br><span class="line">            <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_getBookList = (android.os.IBinder.FIRST_CALL_TRANSACTION +</span><br><span class="line">            <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Construct the stub at attach it to the interface. */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Stub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.attachInterface(<span class="keyword">this</span>, DESCRIPTOR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Cast an IBinder object into an com.tzx.aidlinout.aidl.IBookManager interface,</span></span><br><span class="line"><span class="comment">         * generating a proxy if needed.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> com.tzx.aidlinout.aidl.<span class="function">IBookManager <span class="title">asInterface</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">                    (iin <span class="keyword">instanceof</span> com.tzx.aidlinout.aidl.IBookManager))) &#123;</span><br><span class="line">                <span class="keyword">return</span> ((com.tzx.aidlinout.aidl.IBookManager) iin);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> com.tzx.aidlinout.aidl.IBookManager.Stub.Proxy(obj);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data,</span></span></span><br><span class="line"><span class="function"><span class="params">            android.os.Parcel reply, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">            <span class="keyword">case</span> INTERFACE_TRANSACTION: &#123;</span><br><span class="line">                reply.writeString(DESCRIPTOR);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TRANSACTION_addInBook: &#123;</span><br><span class="line">                data.enforceInterface(DESCRIPTOR);</span><br><span class="line">				<span class="comment">//声明输入的参数_arg0的引用</span></span><br><span class="line">                com.tzx.aidlinout.aidl.Book _arg0;</span><br><span class="line">				<span class="comment">//并根据输入的数据为其创建对象</span></span><br><span class="line">                <span class="keyword">if</span> ((<span class="number">0</span> != data.readInt())) &#123;</span><br><span class="line">                    _arg0 = com.tzx.aidlinout.aidl.Book.CREATOR.createFromParcel(data);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    _arg0 = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">				<span class="comment">//获取调用this.addInBook方法返回的_result</span></span><br><span class="line">                com.tzx.aidlinout.aidl.Book _result = <span class="keyword">this</span>.addInBook(_arg0);</span><br><span class="line">                reply.writeNoException();</span><br><span class="line">				<span class="comment">//并向reply中写入返回值_result</span></span><br><span class="line">                <span class="keyword">if</span> ((_result != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    reply.writeInt(<span class="number">1</span>);</span><br><span class="line">                    _result.writeToParcel(reply,</span><br><span class="line">                        android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    reply.writeInt(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TRANSACTION_addOutBook: &#123;</span><br><span class="line">                data.enforceInterface(DESCRIPTOR);</span><br><span class="line">				<span class="comment">//声明输入的参数_arg0的引用</span></span><br><span class="line">                com.tzx.aidlinout.aidl.Book _arg0;</span><br><span class="line">				<span class="comment">//并为其创建新的对象</span></span><br><span class="line">                _arg0 = <span class="keyword">new</span> com.tzx.aidlinout.aidl.Book();</span><br><span class="line">				<span class="comment">//获取调用this.addOutBook方法返回的_result</span></span><br><span class="line">                com.tzx.aidlinout.aidl.Book _result = <span class="keyword">this</span>.addOutBook(_arg0);</span><br><span class="line">                reply.writeNoException();</span><br><span class="line">				<span class="comment">//并向reply中写入返回值_result</span></span><br><span class="line">                <span class="keyword">if</span> ((_result != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    reply.writeInt(<span class="number">1</span>);</span><br><span class="line">                    _result.writeToParcel(reply,</span><br><span class="line">                        android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    reply.writeInt(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">				<span class="comment">//再将参数_arg0写入reply中，至于为什么写入，我们看看客户端Proxy中的读取</span></span><br><span class="line">                <span class="keyword">if</span> ((_arg0 != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    reply.writeInt(<span class="number">1</span>);</span><br><span class="line">                    _arg0.writeToParcel(reply,</span><br><span class="line">                        android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    reply.writeInt(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TRANSACTION_addInoutBook: &#123;</span><br><span class="line">                data.enforceInterface(DESCRIPTOR);</span><br><span class="line">				<span class="comment">//声明输入的参数_arg0的引用</span></span><br><span class="line">                com.tzx.aidlinout.aidl.Book _arg0;</span><br><span class="line">				<span class="comment">//并根据输入的数据为其创建对象</span></span><br><span class="line">                <span class="keyword">if</span> ((<span class="number">0</span> != data.readInt())) &#123;</span><br><span class="line">                    _arg0 = com.tzx.aidlinout.aidl.Book.CREATOR.createFromParcel(data);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    _arg0 = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">				<span class="comment">//获取调用this.addInoutBook方法返回的_result</span></span><br><span class="line">                com.tzx.aidlinout.aidl.Book _result = <span class="keyword">this</span>.addInoutBook(_arg0);</span><br><span class="line">                reply.writeNoException();</span><br><span class="line">				<span class="comment">//并向reply中写入返回值_result</span></span><br><span class="line">                <span class="keyword">if</span> ((_result != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    reply.writeInt(<span class="number">1</span>);</span><br><span class="line">                    _result.writeToParcel(reply,</span><br><span class="line">                        android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    reply.writeInt(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">				<span class="comment">//再将参数_arg0写入reply中，至于为什么写入，我们看看客户端Proxy中的读取</span></span><br><span class="line">                <span class="keyword">if</span> ((_arg0 != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    reply.writeInt(<span class="number">1</span>);</span><br><span class="line">                    _arg0.writeToParcel(reply,</span><br><span class="line">                        android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    reply.writeInt(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TRANSACTION_getBookList: &#123;</span><br><span class="line">                data.enforceInterface(DESCRIPTOR);</span><br><span class="line"></span><br><span class="line">                java.util.List&lt;com.tzx.aidlinout.aidl.Book&gt; _result = <span class="keyword">this</span>.getBookList();</span><br><span class="line">                reply.writeNoException();</span><br><span class="line">                reply.writeTypedList(_result);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">tzx</span>.<span class="title">aidlinout</span>.<span class="title">aidl</span>.<span class="title">IBookManager</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line"></span><br><span class="line">            Proxy(android.os.IBinder remote) &#123;</span><br><span class="line">                mRemote = remote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mRemote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getInterfaceDescriptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> DESCRIPTOR;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> com.tzx.aidlinout.aidl.<span class="function">Book <span class="title">addInBook</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                com.tzx.aidlinout.aidl.Book book)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">                android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">                android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">                com.tzx.aidlinout.aidl.Book _result;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">					<span class="comment">//将客户端调用时传入的参数写入_data中</span></span><br><span class="line">                    <span class="keyword">if</span> ((book != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                        _data.writeInt(<span class="number">1</span>);</span><br><span class="line">                        book.writeToParcel(_data, <span class="number">0</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        _data.writeInt(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">					<span class="comment">//将_data、_reply序列化对象和Stub.TRANSACTION_addInBook指令传递到Server端</span></span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_addInBook, _data, _reply,</span><br><span class="line">                        <span class="number">0</span>);</span><br><span class="line">                    _reply.readException();</span><br><span class="line">					<span class="comment">//读取Server端返回的序列化_reply中的对象</span></span><br><span class="line">                    <span class="keyword">if</span> ((<span class="number">0</span> != _reply.readInt())) &#123;</span><br><span class="line">                        _result = com.tzx.aidlinout.aidl.Book.CREATOR.createFromParcel(_reply);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        _result = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">					<span class="comment">//然后直接将_result返回</span></span><br><span class="line">					<span class="comment">//我们发现整个方法调用期间传入的对象book只是将数据写入到Server，它的值进行并没有任何修改。</span></span><br><span class="line">					<span class="comment">//总结：in类型的参数，它向服务端传入数据，但是却不接受Server返回的值。</span></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> _result;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> com.tzx.aidlinout.aidl.<span class="function">Book <span class="title">addOutBook</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                com.tzx.aidlinout.aidl.Book book)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">                android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">                android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">                com.tzx.aidlinout.aidl.Book _result;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">					<span class="comment">//将_data、_reply序列化对象和Stub.TRANSACTION_addInBook指令传递到Server端</span></span><br><span class="line">					<span class="comment">//_data和_reply序列化对象并没有进行写入</span></span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_addOutBook, _data,</span><br><span class="line">                        _reply, <span class="number">0</span>);</span><br><span class="line">                    _reply.readException();</span><br><span class="line">					<span class="comment">//读取Server端返回的序列化_reply中的对象，写入到_result</span></span><br><span class="line">                    <span class="keyword">if</span> ((<span class="number">0</span> != _reply.readInt())) &#123;</span><br><span class="line">                        _result = com.tzx.aidlinout.aidl.Book.CREATOR.createFromParcel(_reply);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        _result = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">					<span class="comment">//读取Server端返回的序列化_reply中的对象，写入到传入的book对象中</span></span><br><span class="line">                    <span class="keyword">if</span> ((<span class="number">0</span> != _reply.readInt())) &#123;</span><br><span class="line">                        book.readFromParcel(_reply);</span><br><span class="line">                    &#125;</span><br><span class="line">					<span class="comment">//然后直接将_result返回</span></span><br><span class="line">					<span class="comment">//我们发现整个方法调用期间传入的对象book并没有将数据写入到Server，它的值确实是Server返回的。</span></span><br><span class="line">					<span class="comment">//总结：out类型的参数，它并不向服务端传入数据，但是却接受Server返回的值。</span></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> _result;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> com.tzx.aidlinout.aidl.<span class="function">Book <span class="title">addInoutBook</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                com.tzx.aidlinout.aidl.Book book)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">                android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">                android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">                com.tzx.aidlinout.aidl.Book _result;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">					<span class="comment">//将客户端调用时传入的参数写入_data中</span></span><br><span class="line">                    <span class="keyword">if</span> ((book != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                        _data.writeInt(<span class="number">1</span>);</span><br><span class="line">                        book.writeToParcel(_data, <span class="number">0</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        _data.writeInt(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">					<span class="comment">//将_data、_reply序列化对象和Stub.TRANSACTION_addInoutBook指令传递到Server端</span></span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_addInoutBook, _data,</span><br><span class="line">                        _reply, <span class="number">0</span>);</span><br><span class="line">                    _reply.readException();</span><br><span class="line">					<span class="comment">//读取Server端返回的序列化_reply中的对象，写入到_result</span></span><br><span class="line">                    <span class="keyword">if</span> ((<span class="number">0</span> != _reply.readInt())) &#123;</span><br><span class="line">                        _result = com.tzx.aidlinout.aidl.Book.CREATOR.createFromParcel(_reply);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        _result = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">					<span class="comment">//读取Server端返回的序列化_reply中的对象，写入到传入的book对象中</span></span><br><span class="line">                    <span class="keyword">if</span> ((<span class="number">0</span> != _reply.readInt())) &#123;</span><br><span class="line">                        book.readFromParcel(_reply);</span><br><span class="line">                    &#125;</span><br><span class="line">					<span class="comment">//然后直接将_result返回</span></span><br><span class="line">					<span class="comment">//我们发现整个方法调用期间传入的对象book将其数据写入到Server，并且它的值被Server返回的数据修改。</span></span><br><span class="line">					<span class="comment">//总结：inout类型的参数，它既向服务端传入数据，也却接受Server返回的值。</span></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> _result;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> java.util.List&lt;com.tzx.aidlinout.aidl.Book&gt; getBookList()</span><br><span class="line">                <span class="keyword">throws</span> android.os.RemoteException &#123;</span><br><span class="line">                android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">                android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">                java.util.List&lt;com.tzx.aidlinout.aidl.Book&gt; _result;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_getBookList, _data,</span><br><span class="line">                        _reply, <span class="number">0</span>);</span><br><span class="line">                    _reply.readException();</span><br><span class="line">                    _result = _reply.createTypedArrayList(com.tzx.aidlinout.aidl.Book.CREATOR);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> _result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看了这么多代码是不是感觉脑袋大了，没事接下来一张图帮你理的清清楚楚的：<br><img src="https://raw.githubusercontent.com/stven0king/aidl-study/master/AIDLinout/aidl-tag-type.jpg" alt="aidl-tag-type"></p>
<p>经过两篇文章对aidl的讲解，我想你已经把它理解的透透的了，如果还有什么问题可以给我留言哦~！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>IPC</tag>
        <tag>AIDL</tag>
      </tags>
  </entry>
  <entry>
    <title>Android：IPC之AIDL的学习和总结</title>
    <url>/2016/10/27/aidl-study/</url>
    <content><![CDATA[<p>为了使得一个程序能够在同一时间里处理许多用户的要求。即使用户可能发出一个要求，也肯能导致一个操作系统中多个进程的运行（PS:听音乐，看地图）。而且多个进程间需要相互交换、传递信息，IPC方法提供了这种可能。IPC方法包括管道（PIPE）、消息排队、旗语、共用内存以及套接字（Socket）。</p>
<p>Android中的IPC方式有Bundle、文件共享、Messager、AIDL、ContentProvider和Socket。<br>这次我们学习的是Android中的AIDL。</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>AIDL（Android接口描述语言）是一个IDL语言，它可以生成一段代码，可以是一个在Android设备上运行的两个进程使用内部通信进程进行交互。在Android上，一个进程通常无法访问另一个进程的内存。所以说，如果你想在一个进程中（例如在一个Activity中）访问另一个进程中（例如service）某个对象的方法，你就可以使用AIDL来生成这样的代码来伪装传递各种参数。</p>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p>AIDL它和Java基本上类似，只是有一些细微的差别（PS：可能Google为了方便Android程序猿使用）。AIDL使用简单的语法来声明接口，描述其方法以及方法的参数和返回值。这些参数和返回值可以是任何类型，甚至是其他AIDL生成的接口。重要的是必须导入所有非内置类型，哪怕是这些类型是在与接口相同的包中。</p>
<p>下边说说AIDL的一些特点：</p>
<blockquote>
<ul>
<li>通常引引用方式传递的其他AIDL生成的接口，必须要import 语句声明。</li>
<li>Java编程语言的主要类型 (int, boolean等) —不需要 import 语句。</li>
<li>在AIDL文件中，并不是所有的数据类型都是可以使用的，那么到底AIDL文件中支持哪些数据类型呢？<br>如下所示：<br>1、基本数据类型（int,long,char,boolean,float,double,byte,short八种基本类型）;<br>2、String和CharSequence;<br>3、List:只支持ArrayList,里面每个元素都必须能够被AIDL支持；<br>4、Map:只支持HashMap，里面的每个元素都必须被AIDL支持，包括key和value;<br>5、Parcelable:所有实现了Parcelable接口的对象；<br>6、AIDL：所有的AIDL接口本身也可以在AIDL文件中使用；<br>以上6中数据类型就是AIDL所支持的所有类型，其中自定义的Parcelable对象和AIDL对象必须要显式import进来，不管它们是否和当前的AIDL文件位于同一个包内。</li>
</ul>
</blockquote>
<hr>
<blockquote>
<p>需要注意的地方：<br>AIDL中除了基本数据类型，其他类型的参数必须标上方向：in、out或者inout；<br>(PS:假若传递一个Book对象且没有加指向tag时，则会抛出”aidl.exe E  4928  5836 type_namespace.cpp:130]     ‘Book’ can be an out type, so you must declare it as in, out or inout.”异常)</p>
<ul>
<li>in表示输入型参数（Server可以获取到Client传递过去的数据，但是不能对Client端的数据进行修改）</li>
<li>out表示输出型参数（Server获取不到Client传递过去的数据，但是能对Client端的数据进行修改）</li>
<li>inout表示输入输出型参数（Server可以获取到Client传递过去的数据，但是能对Client端的数据进行修改）。<br>更多tag相关的内容：<a href="http://dandanlove.com/2016/10/27/aidl-tag-type/" target="_blank" rel="noopener">AIDL源码解析in、out和inout</a></li>
</ul>
</blockquote>
<h1 id="使用AIDL实现IPC"><a href="#使用AIDL实现IPC" class="headerlink" title="使用AIDL实现IPC"></a>使用AIDL实现IPC</h1><h2 id="实现步骤-（官网AIDL样例）"><a href="#实现步骤-（官网AIDL样例）" class="headerlink" title="实现步骤 （官网AIDL样例）"></a>实现步骤 （<a href="https://developer.android.com/guide/components/aidl.html" target="_blank" rel="noopener">官网AIDL样例</a>）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IRemoteService.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.example.android;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Declare any non-default types here with import statements</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Example service interface */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IRemoteService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Request the process ID of this service, to do evil things with it. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPid</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Demonstrates some basic types that you can use as parameters</span></span><br><span class="line"><span class="comment">     * and return values in AIDL.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">basicTypes</span><span class="params">(<span class="keyword">int</span> anInt, <span class="keyword">long</span> aLong, <span class="keyword">boolean</span> aBoolean, <span class="keyword">float</span> aFloat,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">double</span> aDouble, String aString)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是官网创建的一个简单的AIDL文件。</p>
<p>这次我们自己声明一个包含非默认支持类型的AIDL文件。<br>AIDL要跨进程通信，其所携带的数据也需要跨进程传输。所以我们首先需要自定自己想要传输的数据类必须其必须实现Parcelable接口从而可以被序列化。<br>为什么需要序列化呢，为什么不适用Serializable，不知道的同学可以看下这篇文章：<a href="http://dandanlove.com/2016/10/18/Serializable-Parcelable/" target="_blank" rel="noopener"> Serializable和Parcelable的再次回忆</a><br>所以我们先创建需要传输的数据所对应的aidl文件，然后再相同目录下创建对应的Java类文件。这里可能有些同学会疑惑，不是直接创建Java类么。AIDL文件有两种类型，一种是我们上边定义的接口，而另外一种就是非常规类型的数据对象文件。即：如果AIDL文件中用到了自定义的Parcelable对象，那么必须新建一个和它同名的AIDL文件，并在其中声明它为Parcelable类型。详细的使用我们看下边例子：</p>
<h2 id="创建一个Book-aidl文件"><a href="#创建一个Book-aidl文件" class="headerlink" title="创建一个Book.aidl文件"></a>创建一个Book.aidl文件</h2><p>在Android Studio的项目中先创建对应的aidl包，然后右击选择创建aidl文件，so easy。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Book.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.tzx.aidldemo.aidl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Declare any non-default types here with import statements</span></span><br><span class="line"><span class="comment">//所有注释掉的内容都是Android Studio帮你写的，但是我们不需要。</span></span><br><span class="line"><span class="comment">//我们创建的是aidl数据对象，所以我们只需写出parcelable 后面跟对象名。</span></span><br><span class="line"><span class="comment">//parcelabe前的字母‘p’是小写的哦~</span></span><br><span class="line">parcelable Book;</span><br><span class="line"><span class="comment">//interface Book &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    /**</span></span><br><span class="line"><span class="comment">//     * Demonstrates some basic types that you can use as parameters</span></span><br><span class="line"><span class="comment">//     * and return values in AIDL.</span></span><br><span class="line"><span class="comment">//     */</span></span><br><span class="line"><span class="comment">//    void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat,</span></span><br><span class="line"><span class="comment">//            double aDouble, String aString);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="在Book-aidl的包下创建Book-java类文件"><a href="#在Book-aidl的包下创建Book-java类文件" class="headerlink" title="在Book.aidl的包下创建Book.java类文件"></a>在Book.aidl的包下创建Book.java类文件</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> bookId;</span><br><span class="line">    <span class="keyword">public</span> String bookName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(<span class="keyword">int</span> bookId, String bookName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bookId = bookId;</span><br><span class="line">        <span class="keyword">this</span>.bookName = bookName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从序列化后的对象中创建原始对象</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Book</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">        bookId = in.readInt();</span><br><span class="line">        bookName = in.readString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Creator&lt;Book&gt; CREATOR = <span class="keyword">new</span> Creator&lt;Book&gt;() &#123;</span><br><span class="line">        <span class="comment">//从序列化后的对象中创建原始对象</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Book <span class="title">createFromParcel</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Book(in);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//指定长度的原始对象数组</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Book[] newArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Book[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//返回当前对象的内容描述。如果含有文件描述符，返回1，否则返回0，几乎所有情况都返回0</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将当前对象写入序列化结构中，其flags标识有两种（1|0）。</span></span><br><span class="line">    <span class="comment">//为1时标识当前对象需要作为返回值返回，不能立即释放资源，几乎所有情况下都为0.</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        dest.writeInt(bookId);</span><br><span class="line">        dest.writeString(bookName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"[bookId="</span> + bookId + <span class="string">",bookName='"</span> + bookName + <span class="string">"']"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在Android Studio中如果先创建Java类文件，然后创建AIDL文件则会提示命名重复，但顺序反过来就可以。</p>
</blockquote>
<h2 id="创建aidl接口文件IBookManager-aidl"><a href="#创建aidl接口文件IBookManager-aidl" class="headerlink" title="创建aidl接口文件IBookManager.aidl"></a>创建aidl接口文件IBookManager.aidl</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IBookManager.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.tzx.aidldemo.aidl;</span><br><span class="line"><span class="comment">//通常引用方式传递自定义对象，必须要import语句声明</span></span><br><span class="line"><span class="keyword">import</span> com.tzx.aidldemo.aidl.Book;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IBookManager</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;Book&gt; <span class="title">getBookList</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addBook</span><span class="params">(in Book book)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样所有aidl相关的文件就定义完了，我们可以写客户端和服务端了么。然而实际结果表明我们还是无法在客户端或服务费使用aidl类。在这里说一下其实aidl方式只不过是为我们提供模板自动创建aidl对应的Java类文件，只有生成了对应的Java文件之后我们才可以在客户端或服务端使用。Android studio中make一下当前的project就会在项目的app/build/source/aidl/包名/debug这个目录下生成对应的aidl类文件（PS：只有aidl接口文件才会生成java类文件）。</p>
<p>make的时候可能提示找不到对应的Book.java文件，我们可以在build.gradle文件中的android{}标签里面添加：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sourceSets&#123;</span><br><span class="line">	main&#123;</span><br><span class="line">		aidl.srcDirs = [<span class="string">'src/main/java'</span>]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种情况只适合aidl类文件和对应的java类文件在同一个包下。</p>
<p>好了，现在所有的aidl文件都有了，我们开始写我们的服务交互了~！~！</p>
<h2 id="服务端："><a href="#服务端：" class="headerlink" title="服务端："></a>服务端：</h2><p>Service服务<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by tanzhenxing</span></span><br><span class="line"><span class="comment"> * Date: 2016/10/17.</span></span><br><span class="line"><span class="comment"> * Description:远程服务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookManagerService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="comment">//支持并发读写</span></span><br><span class="line">    <span class="keyword">private</span> CopyOnWriteArrayList&lt;Book&gt; mBookList = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">	<span class="comment">//服务端定义Binder类（IBookManager.Stub）</span></span><br><span class="line">    <span class="keyword">private</span> Binder mBinder = <span class="keyword">new</span> IBookManager.Stub() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">getBookList</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mBookList;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(Book book)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            mBookList.add(book);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mBinder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>并在Manifest文件中声明，将它放在一个新的进程中，这样方便我们演示跨进程通信。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;service android:name=&quot;.BookManagerService&quot;</span><br><span class="line">	android:process=&quot;:server&quot;/&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="客户端："><a href="#客户端：" class="headerlink" title="客户端："></a>客户端：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by tanzhenxing</span></span><br><span class="line"><span class="comment"> * Date: 2016/10/17.</span></span><br><span class="line"><span class="comment"> * Description:主界面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> EditText bookNameTV;</span><br><span class="line">    <span class="keyword">private</span> Button bookAddTV;</span><br><span class="line">    <span class="keyword">private</span> Button bookCountTV;</span><br><span class="line">    <span class="keyword">private</span> TextView bookInfoTV;</span><br><span class="line">    <span class="keyword">private</span> Intent bookManagerIntent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mBound = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> IBookManager bookManager;</span><br><span class="line">    <span class="keyword">private</span> ServiceConnection mConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">	        <span class="comment">//客户端获取代理对象</span></span><br><span class="line">            bookManager = IBookManager.Stub.asInterface(service);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        bookManagerIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, BookManagerService.class);</span><br><span class="line">        bindService(bookManagerIntent, mConnection, Context.BIND_AUTO_CREATE);</span><br><span class="line">        mBound = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        initView();</span><br><span class="line">        initListener();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        bookNameTV = (EditText) findViewById(R.id.book_name);</span><br><span class="line">        bookAddTV = (Button) findViewById(R.id.book_add);</span><br><span class="line">        bookCountTV = (Button) findViewById(R.id.book_count);</span><br><span class="line">        bookInfoTV = (TextView) findViewById(R.id.book_info);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        bookAddTV.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">        bookCountTV.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop();</span><br><span class="line">        <span class="keyword">if</span> (mBound) &#123;</span><br><span class="line">            mBound = <span class="keyword">false</span>;</span><br><span class="line">            unbindService(mConnection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (v.getId()) &#123;</span><br><span class="line">            <span class="keyword">case</span> R.id.book_add:</span><br><span class="line">                addBook();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> R.id.book_count:</span><br><span class="line">                getBookList();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bookManager != <span class="keyword">null</span> &amp;&amp; !TextUtils.isEmpty(bookNameTV.getText().toString())) &#123;</span><br><span class="line">            Book book = <span class="keyword">new</span> Book((<span class="keyword">int</span>) System.currentTimeMillis(), bookNameTV.getText().toString());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bookManager.addBook(book);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getBookList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (bookManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">                List&lt;Book&gt; list = bookManager.getBookList();</span><br><span class="line">                <span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                    <span class="keyword">for</span> (Book book : list) &#123;</span><br><span class="line">                        builder.append(book.toString());</span><br><span class="line">                        builder.append(<span class="string">'\n'</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    bookInfoTV.setText(builder.toString());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    bookInfoTV.setText(<span class="string">"Empty~!"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="https://raw.githubusercontent.com/stven0king/aidl-study/master/AIDLDemo/aidldemo.gif" alt="AIDLDEMO"></p>
<h2 id="解析aidl生成的java类"><a href="#解析aidl生成的java类" class="headerlink" title="解析aidl生成的java类"></a>解析aidl生成的java类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBookManager</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">IInterface</span> </span>&#123;</span><br><span class="line">	<span class="comment">//根据aidl文件中定义的方法，进行接口声明</span></span><br><span class="line">    <span class="keyword">public</span> java.util.List&lt;com.tzx.aidldemo.aidl.Book&gt; getBookList()</span><br><span class="line">        <span class="keyword">throws</span> android.os.RemoteException;</span><br><span class="line">	<span class="comment">//根据aidl文件中定义的方法，进行接口声明</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(com.tzx.aidldemo.aidl.Book book)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> android.os.RemoteException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Local-side IPC implementation stub class. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">tzx</span>.<span class="title">aidldemo</span>.<span class="title">aidl</span>.<span class="title">IBookManager</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String DESCRIPTOR = <span class="string">"com.tzx.aidldemo.aidl.IBookManager"</span>;</span><br><span class="line">		<span class="comment">//定义方法执行code，与客户端同步</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_getBookList = (android.os.IBinder.FIRST_CALL_TRANSACTION +</span><br><span class="line">            <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_addBook = (android.os.IBinder.FIRST_CALL_TRANSACTION +</span><br><span class="line">            <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Construct the stub at attach it to the interface. */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Stub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.attachInterface(<span class="keyword">this</span>, DESCRIPTOR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Cast an IBinder object into an com.tzx.aidldemo.aidl.IBookManager interface,</span></span><br><span class="line"><span class="comment">         * generating a proxy if needed.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> com.tzx.aidldemo.aidl.<span class="function">IBookManager <span class="title">asInterface</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">                    (iin <span class="keyword">instanceof</span> com.tzx.aidldemo.aidl.IBookManager))) &#123;</span><br><span class="line">                <span class="keyword">return</span> ((com.tzx.aidldemo.aidl.IBookManager) iin);</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//生成代理对象</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> com.tzx.aidldemo.aidl.IBookManager.Stub.Proxy(obj);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data,</span></span></span><br><span class="line"><span class="function"><span class="params">            android.os.Parcel reply, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">            <span class="keyword">case</span> INTERFACE_TRANSACTION: &#123;</span><br><span class="line">                reply.writeString(DESCRIPTOR);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TRANSACTION_getBookList: &#123;</span><br><span class="line">                data.enforceInterface(DESCRIPTOR);</span><br><span class="line">				<span class="comment">//调用服务端getBookList()</span></span><br><span class="line">                java.util.List&lt;com.tzx.aidldemo.aidl.Book&gt; _result = <span class="keyword">this</span>.getBookList();</span><br><span class="line">                reply.writeNoException();</span><br><span class="line">                reply.writeTypedList(_result);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TRANSACTION_addBook: &#123;</span><br><span class="line">                data.enforceInterface(DESCRIPTOR);</span><br><span class="line"></span><br><span class="line">                com.tzx.aidldemo.aidl.Book _arg0;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((<span class="number">0</span> != data.readInt())) &#123;</span><br><span class="line">                    _arg0 = com.tzx.aidldemo.aidl.Book.CREATOR.createFromParcel(data);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    _arg0 = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">				<span class="comment">//调用服务端addBook()</span></span><br><span class="line">                <span class="keyword">this</span>.addBook(_arg0);</span><br><span class="line">                reply.writeNoException();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">tzx</span>.<span class="title">aidldemo</span>.<span class="title">aidl</span>.<span class="title">IBookManager</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line"></span><br><span class="line">            Proxy(android.os.IBinder remote) &#123;</span><br><span class="line">                mRemote = remote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mRemote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getInterfaceDescriptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> DESCRIPTOR;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> java.util.List&lt;com.tzx.aidldemo.aidl.Book&gt; getBookList()</span><br><span class="line">                <span class="keyword">throws</span> android.os.RemoteException &#123;</span><br><span class="line">                android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">                android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">                java.util.List&lt;com.tzx.aidldemo.aidl.Book&gt; _result;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">					<span class="comment">//调用远程服务addBook()</span></span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_getBookList, _data,</span><br><span class="line">                        _reply, <span class="number">0</span>);</span><br><span class="line">                    _reply.readException();</span><br><span class="line">                    _result = _reply.createTypedArrayList(com.tzx.aidldemo.aidl.Book.CREATOR);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> _result;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(com.tzx.aidldemo.aidl.Book book)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">                android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">                android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> ((book != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                        _data.writeInt(<span class="number">1</span>);</span><br><span class="line">                        book.writeToParcel(_data, <span class="number">0</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        _data.writeInt(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">					<span class="comment">//调用远程服务addBook</span></span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, <span class="number">0</span>);</span><br><span class="line">                    _reply.readException();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用关系图表示比较清楚些。。</p>
<p><img src="https://raw.githubusercontent.com/stven0king/aidl-study/master/AIDLDemo/IBookManager.jpg" alt="IBookManager.java"></p>
<p>每个文件结构我们都解析完了，那么aidl到底是怎么实现通信的呢，要让我们自己写一套类似于aidl的那么应该怎么去设计呢？</p>
<p>我们仿aidl画一幅结构图：<br><img src="https://raw.githubusercontent.com/stven0king/aidl-study/master/AIDLDemo/ipc-aidl.jpg" alt="AIDL"></p>
<p>根据上面这个图，我们就可以写出自己的aidl。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBookManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> CAHAGE_MSG = <span class="number">1</span>;</span><br><span class="line">    <span class="function">Book <span class="title">change</span><span class="params">(Book book)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现方法的代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">IBookManager</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> IBinder mRemote;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Proxy <span class="title">asInterface</span><span class="params">(IBinder service)</span> </span>&#123;</span><br><span class="line">        mRemote = service;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Proxy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Book <span class="title">change</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">        Parcel data = Parcel.obtain();</span><br><span class="line">        Parcel reply = Parcel.obtain();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            data.writeInt(<span class="number">1</span>);</span><br><span class="line">            book.writeToParcel(data, <span class="number">0</span>);</span><br><span class="line">            mRemote.transact(IBookManager.CAHAGE_MSG, data, reply, <span class="number">0</span>);</span><br><span class="line">            reply.readException();</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0</span> != reply.readInt()) &#123;</span><br><span class="line">                <span class="keyword">return</span> Book.CREATOR.createFromParcel(reply);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            data.recycle();</span><br><span class="line">            reply.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Binder远端实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> <span class="keyword">extends</span> <span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">IBookManager</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Book <span class="title">change</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">        book.bookName = <span class="string">"Server"</span>;</span><br><span class="line">        <span class="keyword">return</span> book;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">            <span class="keyword">case</span> IBookManager.CAHAGE_MSG:</span><br><span class="line">                Book book = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> != data.readInt()) &#123;</span><br><span class="line">                    book = Book.CREATOR.createFromParcel(data);</span><br><span class="line">                &#125;</span><br><span class="line">                book = change(book);</span><br><span class="line">                reply.writeNoException();</span><br><span class="line">                reply.writeInt(<span class="number">1</span>);</span><br><span class="line">                book.writeToParcel(reply, Parcelable.PARCELABLE_WRITE_RETURN_VALUE);</span><br><span class="line">                reply.writeParcelable(book, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看完以上针对aidl的文字和图片结合方式讲解我想你应该能熟练的开发aidl了吧，如果还有问题可以给我留言哦~！</p>
<p><a href="https://github.com/stven0king/aidl-study" target="_blank" rel="noopener">GitHubDemo地址</a></p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>IPC</tag>
        <tag>AIDL</tag>
      </tags>
  </entry>
  <entry>
    <title>Serializable和Parcelable的再次回忆</title>
    <url>/2016/10/18/Serializable-Parcelable/</url>
    <content><![CDATA[<p>自己开发Android也有些时间了，Serializable和Parcelable遇到过不止一次了。但是每次别人问起具体的内容自己偏偏记得不是很清晰。因为某些原因再次梳理一下，以文章的形式给自己存储下来。温故而知新~！~！</p>
<p>序列化和反序列化几乎是工程师们每天都要面对的事情，但是要精确掌握这两个概念并不容易：一方面，它们往往作为框架的一部分出现而湮没在框架之中；另一方面，它们会以其他更容易理解的概念出现，例如加密、持久化。然而，序列化和反序列化的选型却是系统设计或重构一个重要的环节，在分布式、大数据量系统设计里面更为显著。恰当的序列化协议不仅可以提高系统的通用性、强健性、安全性、优化系统性能，而且会让系统更加易于调试、便于扩展。总而言之搞懂序列化是很重要滴。</p>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><blockquote>
<p>将对象的状态信息转换为可以存储或传输的形式的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区。</p>
</blockquote>
<h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><blockquote>
<p>就是读取序列化后保存在存储区的序列化信息或反序列化对象的状态，重新创建该对象。</p>
</blockquote>
<p>序列化和反序列化通常是并存的，他们的关系就像进行加密和解密操作一样。前者需要相同的序列化方式，后者需要知道秘钥。</p>
<p>Android中将对象序列化的方式有两种Serializable和Parcelable这两个接口都可以完成。Serializable是Java自带的序列化方法，而Android原生的序列化为Parcelable。这并不意味着在Android中可以抛弃Serialable，只能说在Android中Parcelable方法实现序列化更有优势。下边我们可以具体来看看这两个接口实现。（PS：对象参加序列化的时候其类的结构是不能发生变化的，以下Demo都是在此基础上演示）</p>
<h2 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h2><p>我们先看一个实现Serializable接口的类：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">4454266436543306544L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> userId;</span><br><span class="line">    <span class="keyword">public</span> String userName;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> userId, String userName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userId = userId;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Serializable是java提供的一个序列化接口，它是一个空接口，专门为对象提供标准的序列化和反序列化操作，使用Serializable来实现序列化相当简单，只需要在类的声明中指定一个类似下面的标示即可自动实现默认的序列化过程（serialVersionUID可自动生成也可自己写，如0L,1L,2L…）。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">4454266436543306544L</span>;</span><br></pre></td></tr></table></figure></p>
<p>通过Serializable方式来实现对象的序列化，实现起来非常简单，几乎素有工作都被系统自动完成。如果进行对象的序列化和反序列化也非常简单，只需要采用ObjectOutputStream和ObjectInputStream即可轻松实现。下面举个简单的列子：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//序列化过程</span></span><br><span class="line">User user = <span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">"Tom"</span>);</span><br><span class="line">ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"cache.txt"</span>));</span><br><span class="line">out.writeObject(user);</span><br><span class="line">out.close();</span><br><span class="line"><span class="comment">//反序列化过程</span></span><br><span class="line">ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"cache.txt"</span>));</span><br><span class="line">User newuser = (User) in.readObject();</span><br><span class="line">in.close();</span><br></pre></td></tr></table></figure></p>
<p>上述代码采用Serializable方式序列化对象的典型过程，只需要把实现Serializable接口的User对象写到文件中就可以快速恢复了，恢复后的对象newUser和User的内容完全一致，但是两个并不是同一个对象。</p>
<h2 id="serialVersionUID"><a href="#serialVersionUID" class="headerlink" title="serialVersionUID"></a>serialVersionUID</h2><p>上面提到，想让一个对象实现序列化，只需要这个类实现Serializable接口并声明一个serialVersionUID即可，实际上，甚至这个serialVersionUID也不是必需的，我们不声明这个serialVersionUID同样可以实现序列化，但是这将会对反序列化过程产生影响，具体会产生什么影响呢？</p>
<p>解决这个问题前我们先提一个问题，为什么需要serialVersionUID呢？</p>
<blockquote>
<p>因为静态成员变量属于类不属于对象，不会参与序列化过程，使用transient关键字标记的成员变量也不参与序列化过程。 （PS：关键字transient，这里简单说明一下，Java的serialization提供了一种持久化对象实例的机制。当持久化对象时，可能有一个特殊的对象数据成员，我们不想用serialization机制来保存它。为了在一个特定对象的一个域上关闭serialization，可以在这个域前加上关键字transient。当一个对象被序列化的时候，transient型变量的值不包括在序列化的表示中，然而非transient型的变量是被包括进去的）</p>
</blockquote>
<p>这个时候又有一个疑问serialVersionUID是静态成员变量不参与序列化过程，那么它的存在与否有什么影响呢？</p>
<blockquote>
<p>具体过程是这样的：序列化操作的时候系统会把当前类的serialVersionUID写入到序列化文件中，当反序列化时系统会去检测文件中的serialVersionUID，判断它是否与当前类的serialVersionUID一致，如果一致就说明序列化类的版本与当前类版本是一样的，可以反序列化成功，否则失败。</p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20161018095926141" alt="InvalidClassException"></p>
<p>接下来我们回答声明serialVersionUID对进行序列化有啥影响？</p>
<blockquote>
<p>如果不手动指定serialVersionUID的值，反序列化时当前类有所改变，比如增加或者删除了某些成员变量，那么系统就会重新计算当前类的hash值并且把它赋值给serialVersionUID，这个时候当前类的serialVersionUID就和序列化的数据中的serialVersionUID不一致，于是反序列化失败。所以我们手动指定serialVersionUID的值能很大程度上避免了反序列化失败。</p>
</blockquote>
<p>以上就是自己对Serializable的认识，下边来看看Parcelable相关的知识~！~！</p>
<h2 id="Parcelable"><a href="#Parcelable" class="headerlink" title="Parcelable"></a>Parcelable</h2><p>我们先看一个使用Parcelable进行序列化的例子：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> bookId;</span><br><span class="line">    <span class="keyword">public</span> String bookName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(<span class="keyword">int</span> bookId, String bookName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bookId = bookId;</span><br><span class="line">        <span class="keyword">this</span>.bookName = bookName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从序列化后的对象中创建原始对象</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Book</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">        bookId = in.readInt();</span><br><span class="line">        bookName = in.readString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Creator&lt;Book&gt; CREATOR = <span class="keyword">new</span> Creator&lt;Book&gt;() &#123;</span><br><span class="line">        <span class="comment">//从序列化后的对象中创建原始对象</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Book <span class="title">createFromParcel</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Book(in);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//指定长度的原始对象数组</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Book[] newArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Book[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//返回当前对象的内容描述。如果含有文件描述符，返回1，否则返回0，几乎所有情况都返回0</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将当前对象写入序列化结构中，其flags标识有两种（1|0）。</span></span><br><span class="line">    <span class="comment">//为1时标识当前对象需要作为返回值返回，不能立即释放资源，几乎所有情况下都为0.</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        dest.writeInt(bookId);</span><br><span class="line">        dest.writeString(bookName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"[bookId="</span> + bookId + <span class="string">",bookName='"</span> + bookName + <span class="string">"']"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>虽然Serializable可以将数据持久化在磁盘，但其在内存序列化上开销比较大（PS：Serializable在序列化的时候会产生大量的临时变量，从而引起频繁的GC），而内存资源属于android系统中的稀有资源（android系统分配给每个应用的内存开销都是有限的），为此android中提供了Parcelable接口来实现序列化操作，在使用内存的时候，Parcelable比Serializable性能高，所以推荐使用Parcelable。</p>
<p>Parcelable内部包装了可序列化的数据，可以在Biander中自由的传输，从代码中可以看出，在序列化过程中需要实现的功能有序列化，反序列化和内容描述。序列化功能是由writetoParcel方法来完成，最终是通过Parcel中的一系列write方法来完成的。反序列化功能是由CREATOR方法来完成，其内部标明了如何创建序列化对象和数组，并通过Parcel的一系列read方法来完成反序列化过程（PS：write和read的顺序必须一致~！）；内容描述功能是有describeContents方法来完成，几乎所有情况下这个方法都应该返回0，仅当当前对象中存在文件描述符时，此方法返回1.</p>
<p>系统已经给我们提供了许多实现了Parcelable接口类，他们都是可以直接序列化的，比如Intent，Bundle，Bitmap等，同事List和Map也支持序列化，提前是他们里面的每个元素都是可以序列化的。</p>
<p><font color="#0099ff" face="微软雅黑">总结</font></p>
<blockquote>
<p>既然Parcelable和Serializable都能实现序列化并且都可以用于Intent间传递数据，那么二者改如果选择呢？Serializable是Java中的序列化接口，其使用起来简单但是开销很大，序列化和反序列化过程需要大量的I/O操作。而Parcelable是Android中序列化方法，因为更适合于在Android平台上，它的缺点就是使用起来比较麻烦，但是它的效率很高，这是Android推荐的序列化方法，因为我们要首选Parcelable。Parcelable主要用于内存序列化上，通过Parcelable将对象序列化到存储设备中或者将对象序列化后通过网络传输也都是可以的，但是这个过程稍显复杂，因此在这两种情况下建议使用Serializable。</p>
</blockquote>
<p>文章部分摘自任玉刚的《Android开发艺术探索》</p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM虚拟机之类加载的过程</title>
    <url>/2016/09/20/java-jvm-class-loading/</url>
    <content><![CDATA[<p>我们都知道JVM虚拟机的可执行文件为.class文件，那么什么时候JVM虚拟机会加载自己所需要的类呢？之前自己一直有这样的问题，上网找过好多网友的解释，感觉好像理解但是自己却无法说清楚，今天看了《深入理解JVM虚拟机》一书的讲解感觉自己有些透了，在此记录下来自己的理解~！</p>
<p>我们都知道JVM虚拟机的可执行文件为.class文件，那么什么时候JVM虚拟机会加载自己所需要的类呢？之前自己一直有这样的问题，上网找过好多网友的解释，感觉好像理解但是自己却无法说清楚，今天看了《深入理解JVM虚拟机》一书的讲解感觉自己有些透了，在此记录下来自己的理解~！</p>
<h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/0b37595778ff0b42f7f66e448cb9230b.png#pic_center" alt="绘图1.png"></p>
<h2 id="类加载过程（主动-被动）"><a href="#类加载过程（主动-被动）" class="headerlink" title="类加载过程（主动|被动）"></a>类加载过程（主动|被动）</h2><blockquote>
<p>类的主动引用（一定会发生类的初始化）</p>
</blockquote>
<ul>
<li>new一个类的对象</li>
<li>调用类的静态成员（除了<code>final</code>常量）和静态方法</li>
<li>使用<code>java.lang.reflect</code>包的方法对类进行反射调用</li>
<li>当初始化一个类，如果其父类没有被初始化，则先初始化他的父类</li>
<li>当要执行某个程序时，一定先启动<code>main</code>方法所在的类</li>
</ul>
<blockquote>
<p>类的被动引用（不会发生类的初始化）</p>
</blockquote>
<ul>
<li>当访问一个静态变量时，只有真正声明这个静态变量的类才会被初始化（通过子类引用父类的静态变量，不会导致子类初始化）</li>
<li>通过数组定义类应用，不会触发此类的初始化  <code>A[] a = new A[10]</code>;</li>
<li>引用常量(<code>final</code>类型)不会触发此类的初始化（常量在编译阶段就存入调用类的常量池中了）</li>
</ul>
<h2 id="类加载的阶段之加载"><a href="#类加载的阶段之加载" class="headerlink" title="类加载的阶段之加载"></a>类加载的阶段之加载</h2><blockquote>
<ul>
<li>通过一个类的权限定名来获取定义此类的二进制字节流</li>
<li>将这些二进制流所代表的静态存储结构转化为方法去的运行时数据结构</li>
<li>在堆中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法去这个类的各种数据的访问入口</li>
</ul>
</blockquote>
<h2 id="类加载的阶段之验证"><a href="#类加载的阶段之验证" class="headerlink" title="类加载的阶段之验证"></a>类加载的阶段之验证</h2><blockquote>
<p>是否符合JVM规范，没有安全问题。大致分为四个阶段：文件格式验证、元数据验证、字节码验证、符号引用验证</p>
</blockquote>
<h2 id="类加载的阶段之准备"><a href="#类加载的阶段之准备" class="headerlink" title="类加载的阶段之准备"></a>类加载的阶段之准备</h2><blockquote>
<p>为类变量（仅包括被static修饰的变量）分配内容并设置类变量初始值的阶段，这些变量所使用的内存都将在方法去中进行分配。</p>
</blockquote>
<h2 id="类加载的阶段之解析"><a href="#类加载的阶段之解析" class="headerlink" title="类加载的阶段之解析"></a>类加载的阶段之解析</h2><blockquote>
<p>解析阶段是虚拟机将常量池的符号引用替换为直接引用的过程。（A.a = “Hello”替换为A.a指向“Hello”的地址）</p>
</blockquote>
<h2 id="类加载的阶段之初始化"><a href="#类加载的阶段之初始化" class="headerlink" title="类加载的阶段之初始化"></a>类加载的阶段之初始化</h2><blockquote>
<p>初始化阶段时执行类构造器<clinit>()方法的过程，<clinit>()方法是由变一起自动手机类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的。</clinit></clinit></p>
<ul>
<li>执行顺序为语句在源文件中出现的顺序（静态语句块只能访问定义在其之前的变量；定义在它之后的变量可以复制，但不能访问）</li>
<li>执行当前类的<clinit>()方法时，其父类的<clinit>方法已经执行完毕<br>父类的<clinit>方法先执行，也就意味着父类中定义的静态语句块要优于子类的变量赋值操作</clinit></clinit></clinit></li>
<li>虚拟机会保证一个类的构造器方法在多线程环境中被正确加锁和同步</li>
<li>接口与类的初始化不同的是，执行接口的<clinit>方法不需要先执行父类的<clinit>方法，只有当父类接口中定义的变量使用时，父类接口才会初始化</clinit></clinit></li>
</ul>
</blockquote>
<h2 id="类加载的阶段之类的使用过程"><a href="#类加载的阶段之类的使用过程" class="headerlink" title="类加载的阶段之类的使用过程"></a>类加载的阶段之类的使用过程</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//详情请见代码</span></span><br></pre></td></tr></table></figure>
<h2 id="类加载的阶段只类的卸载过程"><a href="#类加载的阶段只类的卸载过程" class="headerlink" title="类加载的阶段只类的卸载过程"></a>类加载的阶段只类的卸载过程</h2><blockquote>
<p>在Java虚拟机中类的生命周期和对象的生命周期很相似。虚拟机创建并初始化对象，使程序使用对象，然后在对象变得不再被引用后可选地进行垃圾收集。同样，虚拟机装载、连接并且初始化类，使程序能使用类，当程序不再引用他们的时候可选的卸载它们。如果程序不再引用某类型，那么这个类型就变成不可触及，所以可以被垃圾收集（俗称GC）。但需要注意的是JVM自带的类加载器（PS：<a href="http://www.jianshu.com/p/a8371d26f848" target="_blank" rel="noopener">Bootstrap、ExtClassLoader、AppClassLoader</a>）装载的类型永远是可触及的，所以永远不会被卸载。只有使用用户定义的类装载器装载的类型才会变成不可触及的，从而被虚拟机回收。</p>
</blockquote>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>JVM虚拟机</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>Class</tag>
      </tags>
  </entry>
  <entry>
    <title>Retrofit2.0+Okhttp不依赖服务端的数据缓存</title>
    <url>/2016/09/18/retrofit-okhttp-cache-offline/</url>
    <content><![CDATA[<p>随着Retrofit在项目中的使用，替换的以前使用的网络框架，相关的缓存机制也要进行替换，网络上大部分的Retrofit+okhttp缓存资料都是进行针对所有url的而且需要服务端的配合。有些时候是先有服务然后app去调用这些服务，所以这个时候没有服务端的配合我们在前端实现缓存比较空难但并不是很可以。（举个列子，有一个原来的服务更本不支持cache，但是我们在app中需要缓存这个服务的数据，这应该是前一段时间替换网络库时最后遇到的问题）。</p>
<h1 id="为什么要做缓存处理？"><a href="#为什么要做缓存处理？" class="headerlink" title="为什么要做缓存处理？"></a>为什么要做缓存处理？</h1><p>客观回答：</p>
<blockquote>
<p>减少服务器负荷，降低延迟提升用户体验。复杂的缓存策略会根据用户当前的网络情况采取不同的缓存策略，比如在2g网络很差的情况下，提高缓存使用的时间；不用的应用、业务需求、接口所需要的缓存策略也会不一样，有的要保证数据的实时性，所以不能有缓存，有的你可以缓存5分钟，等等。</p>
</blockquote>
<p>自己回答：</p>
<blockquote>
<p>在绝大部分的项目中我们前端开发人员只是考虑用户的流量，用户在产品性能上的体验。所以有时候服务端和前端没有依赖，即服务不支持缓存那么前端又需要缓存那么我们应该怎么做？普通的缓存模式已经很难适应这种需求了，下面将的就是利用Retrofit2.0+OkHttp3.0的缓存原理去实现我们的需求。</p>
</blockquote>
<h1 id="Retrofit-OkHttp的缓存机制："><a href="#Retrofit-OkHttp的缓存机制：" class="headerlink" title="Retrofit+OkHttp的缓存机制："></a>Retrofit+OkHttp的缓存机制：</h1><ul>
<li>在 data/data/&lt;包名&gt;/cache 下建立一个用来进行数据存储的文件夹，保持缓存数据。</li>
<li>这样我们就可以在请求的时候，根据业务逻辑，请求网络数据或者读取缓存的数据。</li>
</ul>
<h1 id="缓存使用情况："><a href="#缓存使用情况：" class="headerlink" title="缓存使用情况："></a>缓存使用情况：</h1><ul>
<li>一般情况下无网络，数据从缓存中读取；</li>
<li>有网络则根据请求头，判断是请求网络还是读取缓存。</li>
</ul>
<p>说到缓存，不是很了解的Http缓存的同学亦可以看一下<a href="http://blog.csdn.net/stven_king/article/details/51899865" target="_blank" rel="noopener">浏览器 HTTP 协议缓存机制详解</a> 这篇文章讲的很详细。</p>
<h1 id="Cache控制："><a href="#Cache控制：" class="headerlink" title="Cache控制："></a>Cache控制：</h1><p>该部分对理解怎么缓存很重要~！</p>
<p>1、用在request中的cache控制头</p>
<blockquote>
<p>Pragma: no-cache :兼容早起HTTP协议版本 如1.0+<br>Cache-Control: no-cache ，表示不希望得到一个缓存内容。只是希望，cache设备可能忽略。<br>Cache-Control: no-store，表示client与server之间的设备不能缓存响应内容，并应该删除已有缓存。<br>Cache-Control: only-if-cached，表示只接受是被缓存的内容</p>
</blockquote>
<p>2、用在response中控制cache的头</p>
<blockquote>
<p>Cache-Control: max-age=3600，用相对于接收到的时间开始可缓存多久<br>Cache-Control: s-maxage=3600，与上面类似，只是s-maxage一般用在cache服务器上，并只对public缓存有效<br>Expires: Fri, 05 Jul 2002, 05:00:00 GMT基于GMT的时间，绝对时间，但该头容易受到本地错误时间影响<br>Cache-Control: must-revalidate 该头表示内容可以被缓存但每次必须询问是否有更新。</p>
</blockquote>
<p><a href="https://cnbin.github.io/blog/2016/02/20/http-qing-qiu-,-xiang-ying-,-huan-cun/" target="_blank" rel="noopener">HTTP-请求、响应、缓存</a></p>
<h1 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h1><p>看到这里应该对缓存有一定的了解了，那么现在来看看怎么利用Retrofit2.0+Okhttp缓存的实现。</p>
<p>创建缓存文件，并对okhttp进行设置<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetrofitApiFactory</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> OkHttpClient okHttpClient = <span class="keyword">null</span> ;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> File cacheFile = <span class="keyword">new</span> File(ImageUtils.getAppCacheDir(), <span class="string">"xxxCache"</span>);</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Cache cache = <span class="keyword">new</span> Cache(cacheFile, <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">50</span>);</span><br><span class="line">    <span class="comment">/******中间代码省略*****/</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initOkHttpClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">		okHttpClient =</span><br><span class="line">				<span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">						.cache(cache)</span><br><span class="line">						.readTimeout(TIME_OUT, TimeUnit.SECONDS)</span><br><span class="line">						.writeTimeout(TIME_OUT, TimeUnit.SECONDS)</span><br><span class="line">						.addInterceptor(<span class="keyword">new</span> JobInterceptor(<span class="string">"Interceptor"</span>))  </span><br><span class="line">						<span class="comment">//only 有网情况下，一分钟内每次请求都会重新请求，不会走缓存</span></span><br><span class="line">						.addNetworkInterceptor(<span class="keyword">new</span> JobInterceptor(<span class="string">"NetworkInterceptor"</span>))    </span><br><span class="line">						<span class="comment">//only 如果超过1分钟，离线请求不成功</span></span><br><span class="line">						.build();</span><br><span class="line">		clearCacheMap() ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>控制Cache中最最最主要的部分：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JobInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">	<span class="comment">/******中间代码省略*****/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Request request = chain.request() ;</span><br><span class="line">        <span class="keyword">if</span> (!TextUtils.isEmpty(getCookie())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!NetworkDetection.getIsConnected()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    request = request</span><br><span class="line">                            .newBuilder()</span><br><span class="line">                            .addHeader(<span class="string">"Cookie"</span>, getCookie())</span><br><span class="line">                            .cacheControl(CacheControl.FORCE_CACHE)</span><br><span class="line">                            .build();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    request = request</span><br><span class="line">                            .newBuilder()</span><br><span class="line">                            .addHeader(<span class="string">"Cookie"</span>, getCookie())</span><br><span class="line">                            .build();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Response response = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            response = chain.proceed(request);</span><br><span class="line">            <span class="keyword">if</span>(!response.isSuccessful())&#123;</span><br><span class="line">                RetrofitApiFactory.initOkHttpClient();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果请求体有缓存数据的需要那么对响应体进行缓存</span></span><br><span class="line">                <span class="keyword">int</span> maxAge = request.cacheControl().maxAgeSeconds();</span><br><span class="line">                <span class="keyword">if</span> (request.cacheControl().isPublic() &amp;&amp; maxAge &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    response = response.newBuilder()</span><br><span class="line">                            .removeHeader(<span class="string">"Pragma"</span>)<span class="comment">//清楚响应体对Cache有影响的信息</span></span><br><span class="line">                            .removeHeader(<span class="string">"Cache-Control"</span>)<span class="comment">//清楚响应体对Cache有影响的信息</span></span><br><span class="line">                            .header(<span class="string">"Cache-Control"</span>, <span class="string">"public, max-age="</span> + maxAge)</span><br><span class="line">                            .build();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            RetrofitApiFactory.initOkHttpClient();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(e) ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接口使用：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Headers</span>(<span class="string">"Cache-Control: public, max-age=86400"</span>)</span><br><span class="line"><span class="meta">@GET</span></span><br><span class="line"><span class="function">Call&lt;ResponseBody&gt; <span class="title">getCacheData</span><span class="params">(@Url String url)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h1 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h1><p>上面的绝大部分内容大家都在类似的文章上看到的。这里主要讲一下几点：</p>
<blockquote>
<p>一、我们所用的接口服务不支持缓存，所以我不能只修改头信息而让服务端返回的response响应体去实现数据本地缓存。当然在没有网络的情况下我们可以尝试去读取缓存。</p>
</blockquote>
<blockquote>
<p>二、因为服务端没有提供response响应体的缓存，所以我们清除response响应体的Pragma、Cache-Control信息，然后根据自己设定的request请求体中的Cache信息去修改response响应体的Cache信息从而达到数据可以缓存。</p>
</blockquote>
<blockquote>
<p>三、在开发的过程中遇到如果一个接口在某次请求返回404，那么以后的结果总是请求失败的404页面。所以在请求失败的时候需要初始化OkHttpClient实例。</p>
</blockquote>
<p>如有问题，欢迎沟通指正~！~！<br>参考文章<a href="http://blog.csdn.net/qqyanjiang/article/details/51316116" target="_blank" rel="noopener">Retrofit-Cache</a></p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Retrofit2.0</tag>
        <tag>Android网络请求框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Android网络之HttpUrlConnection和Socket关系解析</title>
    <url>/2016/07/18/HttpUrlConnection-Socket-analysis/</url>
    <content><![CDATA[<p>多年以前Android的网络请求只有Apache开源的HttpClient和JDK的HttpUrlConnection，近几年随着OkHttp的流行Android在高版本的SDK中加入了OkHttp。但在Android官方文档中推荐使用HttpUrlConnection并且其会一直被维护，所以在学习Android网络相关的知识时我们队HttpUrlConnection要有足够的了解。。。。</p>
<p>前几天因为时间的关系只画了图 <a href="http://blog.csdn.net/stven_king/article/details/51913649" target="_blank" rel="noopener">HttpUrlConnection和Socket的关系图</a> ，本来说好的第二天续写，结果一直拖到了周末晚上。幸好时间还来的及，趁这短时间影响深刻，将自己解析代码过程记录下来。（PS：解析的过程有什么地方不明白的可以看看 <a href="http://blog.csdn.net/stven_king/article/details/51913649" target="_blank" rel="noopener">HttpUrlConnection和Socket的关系图</a> 图中讲出的过程和这次代码分析的过程是一样的，只不过代码讲述更加详细。<strong><em>所有源码都是来自Android4.0.4</em></strong>。有代码就有真相~！~！）</p>
<h2 id="类结构图"><a href="#类结构图" class="headerlink" title="类结构图"></a>类结构图</h2><p>先给大家展示一张相关类的结构图：<br><img src="http://img.blog.csdn.net/20160717213831370" alt="HttpUrlConnection和Socket关系类图"></p>
<h2 id="HttpUrlConnection-使用"><a href="#HttpUrlConnection-使用" class="headerlink" title="HttpUrlConnection 使用"></a>HttpUrlConnection 使用</h2><p>在分析代码的时候我希望首相脑海中要有一个URL的请求过程。<br>这是我在网上摘的一个HttpUrlConnection请求小Demo：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EsmTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过HttpURLConnection模拟post表单提交</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendEms</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String wen = <span class="string">"MS2201828"</span>;</span><br><span class="line">        String btnSearch = <span class="string">"EMS快递查询"</span>;</span><br><span class="line">        URL url = <span class="keyword">new</span> URL(<span class="string">"http://www.kd185.com/ems.php"</span>);</span><br><span class="line">        HttpURLConnection conn = (HttpURLConnection) url.openConnection();</span><br><span class="line">        conn.setRequestMethod(<span class="string">"POST"</span>);<span class="comment">// 提交模式</span></span><br><span class="line">        <span class="comment">// conn.setConnectTimeout(10000);//连接超时 单位毫秒</span></span><br><span class="line">        <span class="comment">// conn.setReadTimeout(2000);//读取超时 单位毫秒</span></span><br><span class="line">        conn.setDoOutput(<span class="keyword">true</span>);<span class="comment">// 是否输入参数</span></span><br><span class="line">        StringBuffer params = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="comment">// 表单参数与get形式一样</span></span><br><span class="line">        params.append(<span class="string">"wen"</span>).append(<span class="string">"="</span>).append(wen).append(<span class="string">"&amp;"</span>)</span><br><span class="line">              .append(<span class="string">"btnSearch"</span>).append(<span class="string">"="</span>).append(btnSearch);</span><br><span class="line">        <span class="keyword">byte</span>[] bypes = params.toString().getBytes();</span><br><span class="line">        conn.getOutputStream().write(bypes);<span class="comment">// 输入参数</span></span><br><span class="line">        InputStream inStream=conn.getInputStream();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(StreamTool.readInputStream(inStream), <span class="string">"gbk"</span>));</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendSms</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String message=<span class="string">"货已发到"</span>;</span><br><span class="line">        message=URLEncoder.encode(message, <span class="string">"UTF-8"</span>);</span><br><span class="line">        System.out.println(message);</span><br><span class="line">        String path =<span class="string">"http://localhost:8083/DS_Trade/mobile/sim!add.do?message="</span>+message;</span><br><span class="line">        URL url =<span class="keyword">new</span> URL(path);</span><br><span class="line">        HttpURLConnection conn = (HttpURLConnection)url.openConnection();</span><br><span class="line">        conn.setConnectTimeout(<span class="number">5</span>*<span class="number">1000</span>);</span><br><span class="line">        conn.setRequestMethod(<span class="string">"GET"</span>);</span><br><span class="line">        InputStream inStream = conn.getInputStream();    </span><br><span class="line">        <span class="keyword">byte</span>[] data = StreamTool.readInputStream(inStream);</span><br><span class="line">        String result=<span class="keyword">new</span> String(data, <span class="string">"UTF-8"</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="URL产生请求"><a href="#URL产生请求" class="headerlink" title="URL产生请求"></a>URL产生请求</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*****************URL.java************************/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个新的URL实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">URL</span><span class="params">(String spec)</span> <span class="keyword">throws</span> MalformedURLException </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>((URL) <span class="keyword">null</span>, spec, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">URL</span><span class="params">(URL context, String spec, URLStreamHandler handler)</span> <span class="keyword">throws</span> MalformedURLException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (spec == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> MalformedURLException();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">		streamHandler = handler;</span><br><span class="line">	&#125;</span><br><span class="line">	spec = spec.trim();</span><br><span class="line">	<span class="comment">//获取url的协议类型，http,https</span></span><br><span class="line">	protocol = UrlUtils.getSchemePrefix(spec);</span><br><span class="line">	<span class="comment">//请求开始部分的位置</span></span><br><span class="line">	<span class="keyword">int</span> schemeSpecificPartStart = protocol != <span class="keyword">null</span> ? (protocol.length() + <span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (protocol != <span class="keyword">null</span> &amp;&amp; context != <span class="keyword">null</span> &amp;&amp; !protocol.equals(context.protocol)) &#123;</span><br><span class="line">		context = <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">		set(context.protocol, context.getHost(), context.getPort(), context.getAuthority(),</span><br><span class="line">				context.getUserInfo(), context.getPath(), context.getQuery(),</span><br><span class="line">				context.getRef());</span><br><span class="line">		<span class="keyword">if</span> (streamHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">			streamHandler = context.streamHandler;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (protocol == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> MalformedURLException(<span class="string">"Protocol not found: "</span> + spec);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//这里为重点，获取StreamHandler</span></span><br><span class="line">	<span class="keyword">if</span> (streamHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">		setupStreamHandler();</span><br><span class="line">		<span class="keyword">if</span> (streamHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> MalformedURLException(<span class="string">"Unknown protocol: "</span> + protocol);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//对url的处理</span></span><br><span class="line">		streamHandler.parseURL(<span class="keyword">this</span>, spec, schemeSpecificPartStart, spec.length());</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> MalformedURLException(e.toString());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setupStreamHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//从缓存中获取</span></span><br><span class="line">	streamHandler = streamHandlers.get(protocol);</span><br><span class="line">	<span class="keyword">if</span> (streamHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//通过工厂方法创建</span></span><br><span class="line">	<span class="keyword">if</span> (streamHandlerFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">		streamHandler = streamHandlerFactory.createURLStreamHandler(protocol);</span><br><span class="line">		<span class="keyword">if</span> (streamHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">			streamHandlers.put(protocol, streamHandler);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//在同名包下检测一个可用的hadnler</span></span><br><span class="line">	String packageList = System.getProperty(<span class="string">"java.protocol.handler.pkgs"</span>);</span><br><span class="line">	ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">	<span class="keyword">if</span> (packageList != <span class="keyword">null</span> &amp;&amp; contextClassLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (String packageName : packageList.split(<span class="string">"\\|"</span>)) &#123;</span><br><span class="line">			String className = packageName + <span class="string">"."</span> + protocol + <span class="string">".Handler"</span>;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Class&lt;?&gt; c = contextClassLoader.loadClass(className);</span><br><span class="line">				streamHandler = (URLStreamHandler) c.newInstance();</span><br><span class="line">				<span class="keyword">if</span> (streamHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">					streamHandlers.put(protocol, streamHandler);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IllegalAccessException ignored) &#123;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InstantiationException ignored) &#123;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (ClassNotFoundException ignored) &#123;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果还是没有创建成功那么new一个handler</span></span><br><span class="line">	<span class="keyword">if</span> (protocol.equals(<span class="string">"file"</span>)) &#123;</span><br><span class="line">		streamHandler = <span class="keyword">new</span> FileHandler();</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (protocol.equals(<span class="string">"ftp"</span>)) &#123;</span><br><span class="line">		streamHandler = <span class="keyword">new</span> FtpHandler();</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (protocol.equals(<span class="string">"http"</span>)) &#123;</span><br><span class="line">		streamHandler = <span class="keyword">new</span> HttpHandler();</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (protocol.equals(<span class="string">"https"</span>)) &#123;</span><br><span class="line">		streamHandler = <span class="keyword">new</span> HttpsHandler();</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (protocol.equals(<span class="string">"jar"</span>)) &#123;</span><br><span class="line">		streamHandler = <span class="keyword">new</span> JarHandler();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (streamHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">		streamHandlers.put(protocol, streamHandler);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * streamHandler实现类为HttpURLConnectionImpl</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpHandler</span> <span class="keyword">extends</span> <span class="title">URLStreamHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> URLConnection <span class="title">openConnection</span><span class="params">(URL u)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HttpURLConnectionImpl(u, getDefaultPort());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> URLConnection <span class="title">openConnection</span><span class="params">(URL url, Proxy proxy)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span> || proxy == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null || proxy == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HttpURLConnectionImpl(url, getDefaultPort(), proxy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getDefaultPort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">80</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建连接请求准备"><a href="#创建连接请求准备" class="headerlink" title="创建连接请求准备"></a>创建连接请求准备</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*****************HttpURLConnectionImpl.java start************************/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无论是get还是post都需要建立连接</span></span><br><span class="line"><span class="comment"> * post</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> OutputStream <span class="title">getOutputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	connect();</span><br><span class="line">	OutputStream result = httpEngine.getRequestBody();</span><br><span class="line">	<span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">"method does not support a request body: "</span> + method);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (httpEngine.hasResponse()) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">"cannot write request body after response has been read"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无论是get还是post都需要建立连接</span></span><br><span class="line"><span class="comment"> * get</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> InputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!doInput) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">"This protocol does not support input"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取http响应</span></span><br><span class="line">	HttpEngine response = getResponse();</span><br><span class="line">	<span class="comment">//返回400抛异常</span></span><br><span class="line">	<span class="keyword">if</span> (getResponseCode() &gt;= HTTP_BAD_REQUEST) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(url.toString());</span><br><span class="line">	&#125;</span><br><span class="line">	InputStream result = response.getResponseBody();</span><br><span class="line">	<span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"No response body exists; responseCode="</span> + getResponseCode());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> HttpEngine <span class="title">getResponse</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	<span class="comment">//初始化http引擎</span></span><br><span class="line">	initHttpEngine();</span><br><span class="line">	<span class="comment">//是否有响应头信息</span></span><br><span class="line">	<span class="keyword">if</span> (httpEngine.hasResponse()) &#123;</span><br><span class="line">		<span class="keyword">return</span> httpEngine;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="comment">//发送请求</span></span><br><span class="line">			httpEngine.sendRequest();</span><br><span class="line">			httpEngine.readResponse();</span><br><span class="line">			<span class="comment">//为下次请求做准备</span></span><br><span class="line">			Retry retry = processResponseHeaders();</span><br><span class="line">			<span class="keyword">if</span> (retry == Retry.NONE) &#123;</span><br><span class="line">				httpEngine.automaticallyReleaseConnectionToPool();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//如果一个请求不能完成那么接下来为下次请求做准备</span></span><br><span class="line">			String retryMethod = method;</span><br><span class="line">			OutputStream requestBody = httpEngine.getRequestBody();</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM</span></span><br><span class="line"><span class="comment">			 * redirect should keep the same method, Chrome, Firefox and the</span></span><br><span class="line"><span class="comment">			 * RI all issue GETs when following any redirect.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">int</span> responseCode = getResponseCode();</span><br><span class="line">			<span class="keyword">if</span> (responseCode == HTTP_MULT_CHOICE || responseCode == HTTP_MOVED_PERM</span><br><span class="line">					|| responseCode == HTTP_MOVED_TEMP || responseCode == HTTP_SEE_OTHER) &#123;</span><br><span class="line">				retryMethod = HttpEngine.GET;</span><br><span class="line">				requestBody = <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (requestBody != <span class="keyword">null</span> &amp;&amp; !(requestBody <span class="keyword">instanceof</span> RetryableOutputStream)) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> HttpRetryException(<span class="string">"Cannot retry streamed HTTP body"</span>,</span><br><span class="line">						httpEngine.getResponseCode());</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (retry == Retry.DIFFERENT_CONNECTION) &#123;</span><br><span class="line">				httpEngine.automaticallyReleaseConnectionToPool();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			httpEngine.release(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">			httpEngine = newHttpEngine(retryMethod, rawRequestHeaders,</span><br><span class="line">					httpEngine.getConnection(), (RetryableOutputStream) requestBody);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> httpEngine;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">		httpEngineFailure = e;</span><br><span class="line">		<span class="keyword">throw</span> e;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	initHttpEngine();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		httpEngine.sendRequest();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">		httpEngineFailure = e;</span><br><span class="line">		<span class="keyword">throw</span> e;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无论是get还是post都需要初始化Http引擎</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initHttpEngine</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (httpEngineFailure != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> httpEngineFailure;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (httpEngine != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	connected = <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (doOutput) &#123;</span><br><span class="line">			<span class="keyword">if</span> (method == HttpEngine.GET) &#123;</span><br><span class="line">				<span class="comment">//如果要写入那么这就是一个post请求</span></span><br><span class="line">				method = HttpEngine.POST;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (method != HttpEngine.POST &amp;&amp; method != HttpEngine.PUT) &#123;</span><br><span class="line">				<span class="comment">//如果你要写入，那么不是post请求也不是put请求那就抛异常吧。</span></span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(method + <span class="string">" does not support writing"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		httpEngine = newHttpEngine(method, rawRequestHeaders, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">		httpEngineFailure = e;</span><br><span class="line">		<span class="keyword">throw</span> e;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建Socket连接"><a href="#创建Socket连接" class="headerlink" title="创建Socket连接"></a>创建Socket连接</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/********************HttpEngine.java**************/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Figures out what the response source will be, and opens a socket to that</span></span><br><span class="line"><span class="comment"> * source if necessary. Prepares the request headers and gets ready to start</span></span><br><span class="line"><span class="comment"> * writing the request body if it exists.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">sendRequest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (responseSource != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//填充请求头和cookies</span></span><br><span class="line">	prepareRawRequestHeaders();</span><br><span class="line">	<span class="comment">//初始化响应资源，计算缓存过期时间，判断是否读取缓冲中数据，或者进行网络请求</span></span><br><span class="line">	<span class="comment">//responseSource = ?</span></span><br><span class="line">	<span class="comment">//CACHE:返回缓存信息</span></span><br><span class="line">	<span class="comment">//CONDITIONAL_CACHE：进行网络请求如果网络请求结果无效则使用缓存</span></span><br><span class="line">	<span class="comment">//NETWORK:返回网络请求</span></span><br><span class="line">	initResponseSource();</span><br><span class="line">	<span class="comment">//请求行为记录</span></span><br><span class="line">	<span class="keyword">if</span> (responseCache <span class="keyword">instanceof</span> HttpResponseCache) &#123;</span><br><span class="line">		((HttpResponseCache) responseCache).trackResponse(responseSource);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//请求资源需要访问网络，但请求头部禁止请求。在这种情况下使用BAD_GATEWAY_RESPONSE替代</span></span><br><span class="line">	<span class="keyword">if</span> (requestHeaders.isOnlyIfCached() &amp;&amp; responseSource.requiresConnection()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (responseSource == ResponseSource.CONDITIONAL_CACHE) &#123;</span><br><span class="line">			IoUtils.closeQuietly(cachedResponseBody);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>.responseSource = ResponseSource.CACHE;</span><br><span class="line">		<span class="keyword">this</span>.cacheResponse = BAD_GATEWAY_RESPONSE;</span><br><span class="line">		RawHeaders rawResponseHeaders = RawHeaders.fromMultimap(cacheResponse.getHeaders());</span><br><span class="line">		setResponse(<span class="keyword">new</span> ResponseHeaders(uri, rawResponseHeaders), cacheResponse.getBody());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (responseSource.requiresConnection()) &#123;</span><br><span class="line">		<span class="comment">//socket网络连接</span></span><br><span class="line">		sendSocketRequest();</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">		HttpConnectionPool.INSTANCE.recycle(connection);</span><br><span class="line">		connection = <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendSocketRequest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (connection == <span class="keyword">null</span>) &#123;</span><br><span class="line">		connect();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (socketOut != <span class="keyword">null</span> || requestOut != <span class="keyword">null</span> || socketIn != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">	&#125;</span><br><span class="line">	socketOut = connection.getOutputStream();</span><br><span class="line">	requestOut = socketOut;</span><br><span class="line">	socketIn = connection.getInputStream();</span><br><span class="line">	<span class="keyword">if</span> (hasRequestBody()) &#123;</span><br><span class="line">		initRequestBodyOut();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打开Socket连接</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (connection == <span class="keyword">null</span>) &#123;</span><br><span class="line">		connection = openSocketConnection();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> HttpConnection <span class="title">openSocketConnection</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	HttpConnection result = HttpConnection.connect(</span><br><span class="line">			uri, policy.getProxy(), requiresTunnel(), policy.getConnectTimeout());</span><br><span class="line">	Proxy proxy = result.getAddress().getProxy();</span><br><span class="line">	<span class="keyword">if</span> (proxy != <span class="keyword">null</span>) &#123;</span><br><span class="line">		policy.setProxy(proxy);</span><br><span class="line">	&#125;</span><br><span class="line">	result.setSoTimeout(policy.getReadTimeout());</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/********************HttpConnection.java**************/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HttpConnection <span class="title">connect</span><span class="params">(URI uri, Proxy proxy, <span class="keyword">boolean</span> requiresTunnel,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">int</span> connectTimeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	<span class="comment">//代理直连</span></span><br><span class="line">	<span class="keyword">if</span> (proxy != <span class="keyword">null</span>) &#123;</span><br><span class="line">		Address address = (proxy.type() == Proxy.Type.DIRECT)</span><br><span class="line">				? <span class="keyword">new</span> Address(uri)</span><br><span class="line">				: <span class="keyword">new</span> Address(uri, proxy, requiresTunnel);</span><br><span class="line">		<span class="keyword">return</span> HttpConnectionPool.INSTANCE.get(address, connectTimeout);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//寻找代理直连</span></span><br><span class="line">	ProxySelector selector = ProxySelector.getDefault();</span><br><span class="line">	List&lt;Proxy&gt; proxyList = selector.select(uri);</span><br><span class="line">	<span class="keyword">if</span> (proxyList != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (Proxy selectedProxy : proxyList) &#123;</span><br><span class="line">			<span class="keyword">if</span> (selectedProxy.type() == Proxy.Type.DIRECT) &#123;</span><br><span class="line">				<span class="comment">// the same as NO_PROXY</span></span><br><span class="line">				<span class="comment">// <span class="doctag">TODO:</span> if the selector recommends a direct connection, attempt that?</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Address address = <span class="keyword">new</span> Address(uri, selectedProxy, requiresTunnel);</span><br><span class="line">				<span class="keyword">return</span> HttpConnectionPool.INSTANCE.get(address, connectTimeout);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				<span class="comment">// failed to connect, tell it to the selector</span></span><br><span class="line">				selector.connectFailed(uri, selectedProxy.address(), e);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//创建一个直连接</span></span><br><span class="line">	<span class="keyword">return</span> HttpConnectionPool.INSTANCE.get(<span class="keyword">new</span> Address(uri), connectTimeout);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">HttpConnection</span><span class="params">(Address config, <span class="keyword">int</span> connectTimeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.address = config;</span><br><span class="line">	Socket socketCandidate = <span class="keyword">null</span>;</span><br><span class="line">	InetAddress[] addresses = InetAddress.getAllByName(config.socketHost);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; addresses.length; i++) &#123;</span><br><span class="line">		socketCandidate = (config.proxy != <span class="keyword">null</span> &amp;&amp; config.proxy.type() != Proxy.Type.HTTP)</span><br><span class="line">				? <span class="keyword">new</span> Socket(config.proxy)</span><br><span class="line">				: <span class="keyword">new</span> Socket();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//DNS解析，socket连接（这块不做详细分析）</span></span><br><span class="line">			socketCandidate.connect(</span><br><span class="line">					<span class="keyword">new</span> InetSocketAddress(addresses[i], config.socketPort), connectTimeout);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i == addresses.length - <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">throw</span> e;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">this</span>.socket = socketCandidate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/********************HttpConnectionPool.java**************/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HttpConnection <span class="title">get</span><span class="params">(HttpConnection.Address address, <span class="keyword">int</span> connectTimeout)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	<span class="comment">//首先尝试重用现有的HTTP连接。</span></span><br><span class="line">	<span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">		List&lt;HttpConnection&gt; connections = connectionPool.get(address);</span><br><span class="line">		<span class="keyword">if</span> (connections != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">while</span> (!connections.isEmpty()) &#123;</span><br><span class="line">				HttpConnection connection = connections.remove(connections.size() - <span class="number">1</span>);</span><br><span class="line">				<span class="keyword">if</span> (!connection.isStale()) &#123; <span class="comment">// <span class="doctag">TODO:</span> this op does I/O!</span></span><br><span class="line">					<span class="comment">// Since Socket is recycled, re-tag before using</span></span><br><span class="line">					<span class="keyword">final</span> Socket socket = connection.getSocket();</span><br><span class="line">					SocketTagger.get().tag(socket);</span><br><span class="line">					<span class="keyword">return</span> connection;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			connectionPool.remove(address);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//无法找到可以复用的链接是，创建一个新的链接</span></span><br><span class="line">	<span class="keyword">return</span> address.connect(connectTimeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********************HttpConnection.Address.java**************/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HttpConnection <span class="title">connect</span><span class="params">(<span class="keyword">int</span> connectTimeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> HttpConnection(<span class="keyword">this</span>, connectTimeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="输出内容获取"><a href="#输出内容获取" class="headerlink" title="输出内容获取"></a>输出内容获取</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/********************HttpEngine.java**************/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">readResponse</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	<span class="comment">//如果有响应头</span></span><br><span class="line">	<span class="keyword">if</span> (hasResponse()) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//readResponse之前是否sendRequest</span></span><br><span class="line">	<span class="keyword">if</span> (responseSource == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"readResponse() without sendRequest()"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果不进行网络请求直接返回</span></span><br><span class="line">	<span class="keyword">if</span> (!responseSource.requiresConnection()) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//刷新请求头</span></span><br><span class="line">	<span class="keyword">if</span> (sentRequestMillis == -<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> contentLength = requestBodyOut <span class="keyword">instanceof</span> RetryableOutputStream</span><br><span class="line">				? ((RetryableOutputStream) requestBodyOut).contentLength()</span><br><span class="line">				: -<span class="number">1</span>;</span><br><span class="line">		writeRequestHeaders(contentLength);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//刷新请求体</span></span><br><span class="line">	<span class="keyword">if</span> (requestBodyOut != <span class="keyword">null</span>) &#123;</span><br><span class="line">		requestBodyOut.close();</span><br><span class="line">		<span class="keyword">if</span> (requestBodyOut <span class="keyword">instanceof</span> RetryableOutputStream) &#123;</span><br><span class="line">			((RetryableOutputStream) requestBodyOut).writeToSocket(requestOut);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	requestOut.flush();</span><br><span class="line">	requestOut = socketOut;</span><br><span class="line">	<span class="comment">//解析响应头</span></span><br><span class="line">	readResponseHeaders();</span><br><span class="line">	responseHeaders.setLocalTimestamps(sentRequestMillis, System.currentTimeMillis());</span><br><span class="line">	<span class="comment">//判断响应体类型</span></span><br><span class="line">	<span class="keyword">if</span> (responseSource == ResponseSource.CONDITIONAL_CACHE) &#123;</span><br><span class="line">		<span class="keyword">if</span> (cachedResponseHeaders.validate(responseHeaders)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (responseCache <span class="keyword">instanceof</span> HttpResponseCache) &#123;</span><br><span class="line">				((HttpResponseCache) responseCache).trackConditionalCacheHit();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//释放资源</span></span><br><span class="line">			release(<span class="keyword">true</span>);</span><br><span class="line">			<span class="comment">//返回缓存信息</span></span><br><span class="line">			setResponse(cachedResponseHeaders.combine(responseHeaders), cachedResponseBody);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			IoUtils.closeQuietly(cachedResponseBody);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (hasResponseBody()) &#123;</span><br><span class="line">		maybeCache(); <span class="comment">// reentrant. this calls into user code which may call back into this!</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	initContentStream(getTransferStream());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> InputStream <span class="title">getTransferStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!hasResponseBody()) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> FixedLengthInputStream(socketIn, cacheRequest, <span class="keyword">this</span>, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (responseHeaders.isChunked()) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ChunkedInputStream(socketIn, cacheRequest, <span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (responseHeaders.getContentLength() != -<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> FixedLengthInputStream(socketIn, cacheRequest, <span class="keyword">this</span>,</span><br><span class="line">				responseHeaders.getContentLength());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> UnknownLengthHttpInputStream(socketIn, cacheRequest, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initContentStream</span><span class="params">(InputStream transferStream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	<span class="comment">//是否gzip压缩</span></span><br><span class="line">	<span class="keyword">if</span> (transparentGzip &amp;&amp; responseHeaders.isContentEncodingGzip()) &#123;</span><br><span class="line">		responseHeaders.stripContentEncoding();</span><br><span class="line">		responseBodyIn = <span class="keyword">new</span> GZIPInputStream(transferStream);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		responseBodyIn = transferStream;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个请求的响应流程大概就是这样子的，其中的涉及的路由信息获取，DNS解析与缓存，请求的缓存过期等都还没有仔细研读。不过这些也够自己消化一段时间了^_^，相信自己现在回过头来看OkHttp的实现应该不是那么困难了。</p>
<p>默默肃立的路灯，像等待检阅的哨兵，站姿笔挺，瞪着炯炯有神的眼睛，时刻守护着这城市的安宁。一排排、一行行路灯不断向远方延伸，汇聚成了一支支流光溢彩的河流，偶尔有汽车疾驰而去，也是一尾尾鱼儿在河里游动。夜已深~！~！~！</p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>HttpUrlConnection</tag>
        <tag>Socket</tag>
        <tag>Android网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Android网络之HttpUrlConnection和Socket关系图解</title>
    <url>/2016/07/14/HttpUrlConnection-Socket-map/</url>
    <content><![CDATA[<p>最近在学习有关于网络方面的知识，研究Android网络请求框架。前几天阅读完Retrofit2.0源码写了一篇<a href="http://blog.csdn.net/stven_king/article/details/51839537" target="_blank" rel="noopener">Retrofit2.0使用和解析</a> 的文章，因为Retrofit2.0现在只支持OkHttp，OkHttp网络框架也在Android高版本的SDK中使用，自己为了能更好的优化Android中关于网络这个模块，然后又阅读了OkHttp3.0的源代码。OkHttp3.0的源码解析网上找的资料不很多，其中所用到的设计模式和网络相关的东西非常多。自己看的很懵逼，于是想先看看HttpUrlConnection的实现原理。</p>
<p>已经快23点了自己还在公司<br>先直接上图，明天再写源码分析吧<br><img src="http://img.blog.csdn.net/20160714225325530" alt="HttpUrlConnection和Socket关系图解"></p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>HttpUrlConnection</tag>
        <tag>Socket</tag>
        <tag>Android网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Android网络之Retrofit2.0使用和解析</title>
    <url>/2016/07/11/retrofit-note/</url>
    <content><![CDATA[<h1 id="Android网络之Retrofit2-0使用和解析"><a href="#Android网络之Retrofit2-0使用和解析" class="headerlink" title="Android网络之Retrofit2.0使用和解析"></a>Android网络之Retrofit2.0使用和解析</h1><h2 id="Retrofit2在项目中的使用"><a href="#Retrofit2在项目中的使用" class="headerlink" title="Retrofit2在项目中的使用"></a>Retrofit2在项目中的使用</h2><h3 id="Android-studio项目添加依赖"><a href="#Android-studio项目添加依赖" class="headerlink" title="Android studio项目添加依赖"></a>Android studio项目添加依赖</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">compile <span class="string">'com.squareup.retrofit2:retrofit:2.0.1'</span></span><br></pre></td></tr></table></figure>
<h3 id="项目中使用样例"><a href="#项目中使用样例" class="headerlink" title="项目中使用样例"></a>项目中使用样例</h3><h4 id="定义HTTP-API使用接口"><a href="#定义HTTP-API使用接口" class="headerlink" title="定义HTTP API使用接口"></a>定义HTTP API使用接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GitHubService</span> </span>&#123;</span><br><span class="line">	<span class="meta">@GET</span>(<span class="string">"users/&#123;user&#125;/repos"</span>)</span><br><span class="line">	 Call&lt;List&lt;Repo&gt;&gt; listRepos(<span class="meta">@Path</span>(<span class="string">"user"</span>) String user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>通过在接口上添加注解的方式来表示如何处理网络请求。</li>
<li>Retrofit支持5中类型的注解：GET,POST,PUT,DELETE和HEAD.</li>
<li>可以使用不带参数的url<code>@GET(&quot;users/list&quot;)</code>，也可以使用带参数的url<code>@GET(&quot;users/list?sort=desc&quot;)</code></li>
</ul>
</blockquote>
<h4 id="构造Retrofit实例"><a href="#构造Retrofit实例" class="headerlink" title="构造Retrofit实例"></a>构造Retrofit实例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">    .baseUrl(<span class="string">"https://api.github.com/"</span>)</span><br><span class="line">    .build();</span><br><span class="line">GitHubService service = retrofit.create(GitHubService.class);</span><br></pre></td></tr></table></figure>
<h4 id="创建同步或异步HTTP请求到远程网络服务器"><a href="#创建同步或异步HTTP请求到远程网络服务器" class="headerlink" title="创建同步或异步HTTP请求到远程网络服务器"></a>创建同步或异步HTTP请求到远程网络服务器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(<span class="string">"octocat"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="定制数据类型转换器"><a href="#定制数据类型转换器" class="headerlink" title="定制数据类型转换器"></a>定制数据类型转换器</h4><blockquote>
<ul>
<li>Gson: com.squareup.retrofit2:converter-gson</li>
<li>Jackson: com.squareup.retrofit2:converter-jackson</li>
<li>Moshi: com.squareup.retrofit2:converter-moshi</li>
<li>Protobuf: com.squareup.retrofit2:converter-protobuf</li>
<li>Wire: com.squareup.retrofit2:converter-wire</li>
<li>Simple XML: com.squareup.retrofit2:converter-simplexml</li>
<li>Scalars (primitives, boxed, and String): com.squareup.retrofit2:converter-scalars</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">    .baseUrl(<span class="string">"https://api.github.com"</span>)</span><br><span class="line">    .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">GitHubService service = retrofit.create(GitHubService.class);</span><br></pre></td></tr></table></figure>
<h3 id="Retrofit使用扩展"><a href="#Retrofit使用扩展" class="headerlink" title="Retrofit使用扩展"></a>Retrofit使用扩展</h3><h4 id="自定义Gson类型转换器"><a href="#自定义Gson类型转换器" class="headerlink" title="自定义Gson类型转换器"></a>自定义Gson类型转换器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	"resultcode":0,</span></span><br><span class="line"><span class="comment">	"resultmsg":"请求成功",</span></span><br><span class="line"><span class="comment">	"result":&#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> resultcode ;</span><br><span class="line">    <span class="keyword">public</span> String resultmsg ;</span><br><span class="line">    <span class="keyword">public</span> Object result ;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonAdapter</span> <span class="keyword">implements</span> <span class="title">JsonDeserializer</span>&lt;<span class="title">Wrapper02</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Wrapper <span class="title">deserialize</span><span class="params">(JsonElement json, Type typeOfT, JsonDeserializationContext context)</span> <span class="keyword">throws</span> JsonParseException </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String jsonRoot = json.getAsJsonObject().toString() ;</span><br><span class="line">                Wrapper wrapper = <span class="keyword">new</span> Wrapper() ;</span><br><span class="line">                JSONObject jsobRespData = <span class="keyword">new</span> JSONObject(jsonRoot) ;</span><br><span class="line">                wrapper.resultcode = jsobRespData.getInt(<span class="string">"resultcode"</span>) ;</span><br><span class="line">                wrapper.resultmsg = jsobRespData.getString(<span class="string">"resultmsg"</span>) ;</span><br><span class="line">                wrapper.result = jsobRespData.get(<span class="string">"result"</span>) ;</span><br><span class="line">                <span class="keyword">return</span> wrapper;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (JSONException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> JsonParseException(e) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加到Retrofit当中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Gson gson = <span class="keyword">new</span> GsonBuilder()</span><br><span class="line">            .registerTypeAdapter(Wrapper.class, <span class="keyword">new</span> Wrapper.JsonAdapter())</span><br><span class="line">            .create() ;</span><br><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">    .baseUrl(<span class="string">"https://api.github.com"</span>)</span><br><span class="line">    .addConverterFactory(GsonConverterFactory.create(gson))</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">GitHubService service = retrofit.create(GitHubService.class);</span><br></pre></td></tr></table></figure>
<h4 id="请求时添加head信息"><a href="#请求时添加head信息" class="headerlink" title="请求时添加head信息"></a>请求时添加head信息</h4><p>在定义请求接口时添加：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Headers</span>(<span class="string">"Cache-Control: max-age=640000"</span>)</span><br><span class="line"><span class="meta">@GET</span>(<span class="string">"widget/list"</span>)</span><br><span class="line">Call&lt;List&lt;Widget&gt;&gt; widgetList();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Headers</span>(&#123;</span><br><span class="line">    <span class="string">"Accept: application/vnd.github.v3.full+json"</span>,</span><br><span class="line">    <span class="string">"User-Agent: Retrofit-Sample-App"</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="meta">@GET</span>(<span class="string">"users/&#123;username&#125;"</span>)</span><br><span class="line"><span class="function">Call&lt;User&gt; <span class="title">getUser</span><span class="params">(@Path(<span class="string">"username"</span>)</span> String username)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GET</span>(<span class="string">"user"</span>)</span><br><span class="line"><span class="function">Call&lt;User&gt; <span class="title">getUser</span><span class="params">(@Header(<span class="string">"Authorization"</span>)</span> String authorization)</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdn.net/20160708104109016" alt="Retrofit依赖"><br>如果所示在Retrofit2.0中只支持okhttp，所以另一种方法是在okhttp的拦截器中addheader。</p>
<h2 id="Retrofit2源码解析"><a href="#Retrofit2源码解析" class="headerlink" title="Retrofit2源码解析"></a>Retrofit2源码解析</h2><blockquote>
<p>Retrofit请求框架实现了高度的解耦，通过解析注解的得到的代理类生成http请求，然后将请求交给OkHttp。通过在Retrofit创建时生成的Converter再将OkHttp返回的数据进行类型转换得到自己需要的数据。现在Rxjava响应式编程已经广泛应用，在使用Retrofit时也会结合RxJava使编码更加简单、高效。</p>
</blockquote>
<p>一张图简单描述一下Retrofit的工作原理：<br><img src="https://img-blog.csdn.net/20160708153944054" alt="Retrofit工作原理"></p>
<h3 id="定义网络请求接口"><a href="#定义网络请求接口" class="headerlink" title="定义网络请求接口"></a>定义网络请求接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GitHubService</span> </span>&#123;</span><br><span class="line">	 <span class="meta">@GET</span>(<span class="string">"users/&#123;user&#125;/repos"</span>)</span><br><span class="line">	 Call&lt;List&lt;Repo&gt;&gt; listRepos(<span class="meta">@Path</span>(<span class="string">"user"</span>) String user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建Retrofit实例"><a href="#创建Retrofit实例" class="headerlink" title="创建Retrofit实例"></a>创建Retrofit实例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">    .baseUrl(<span class="string">"https://api.github.com"</span>)</span><br><span class="line">    <span class="comment">//支持RxJava</span></span><br><span class="line">    .addCallAdapterFactory(RxJavaCallAdapterFactory.create())</span><br><span class="line">    .addConverterFactory(ByteArrayConverterFactory.create())</span><br><span class="line">    .addConverterFactory(JSONObjectResponseConverterFactory.create())</span><br><span class="line">    .addConverterFactory(StringResponseConverterFactory.create())</span><br><span class="line">    <span class="comment">//支持对象转json串</span></span><br><span class="line">    .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>设置BaseUrl</li>
<li>添加CallAdapterFactory</li>
<li>添加converterFactory</li>
<li>此时也可以设置自定义的okHttpclient</li>
</ul>
</blockquote>
<p>接下来我们看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GitHubService service = retrofit.create(GitHubService.class);</span><br></pre></td></tr></table></figure>
<h3 id="Retrofit-create方法的详细介绍"><a href="#Retrofit-create方法的详细介绍" class="headerlink" title="Retrofit.create方法的详细介绍"></a>Retrofit.create方法的详细介绍</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断定义的接口服务是否可用</span></span><br><span class="line">    Utils.validateServiceInterface(service);</span><br><span class="line">    <span class="keyword">if</span> (validateEagerly) &#123;</span><br><span class="line">      eagerlyValidateMethods(service);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">        <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">          <span class="comment">//判断Android，IOS，java8</span></span><br><span class="line">          <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object... args)</span></span></span><br><span class="line"><span class="function">              <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="comment">//如果是对象里的方法直接调用</span></span><br><span class="line">            <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">              <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 对java8做兼容，android和ios值恒为false</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span> (platform.isDefaultMethod(method)) &#123;</span><br><span class="line">              <span class="keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//主要看这三行代码</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 1、生成获取缓存中的method对应的ServiceMethod或者生产method对应的ServiceMethod</span></span><br><span class="line"><span class="comment">            * 2、生成OkHttpCall的实例</span></span><br><span class="line"><span class="comment">            * 3、根据生成的ServiceMethod实例中的callAdapter对象，调用callAdapter.adapt方法创建</span></span><br><span class="line"><span class="comment">            * 对应的Observable</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            ServiceMethod serviceMethod = loadServiceMethod(method);</span><br><span class="line">            OkHttpCall okHttpCall = <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</span><br><span class="line">            <span class="keyword">return</span> serviceMethod.callAdapter.adapt(okHttpCall);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Platfrom的获取"><a href="#Platfrom的获取" class="headerlink" title="Platfrom的获取"></a>Platfrom的获取</h3><p><img src="https://img-blog.csdn.net/20160902155113639" alt="Platfrom"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Platform</span> </span>&#123;</span><br><span class="line">	<span class="comment">//这个方法Android中为Plafrom默认的</span></span><br><span class="line">	<span class="comment">//Java8返回的是method.isDefault()，熟悉Java8的都知道这是Java8的新特性。。</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isDefaultMethod</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//这个方法Android中有自己默认的实现MainThreadExecutor</span></span><br><span class="line">	<span class="function">Executor <span class="title">defaultCallbackExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Android</span> <span class="keyword">extends</span> <span class="title">Platform</span> </span>&#123;</span><br><span class="line">		<span class="meta">@Override</span> </span><br><span class="line">		<span class="function"><span class="keyword">public</span> Executor <span class="title">defaultCallbackExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> MainThreadExecutor();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span> </span><br><span class="line">		CallAdapter.<span class="function">Factory <span class="title">defaultCallAdapterFactory</span><span class="params">(Executor callbackExecutor)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> ExecutorCallAdapterFactory(callbackExecutor);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//Rx默认请求方式都是同步请求，所以我们在发出请求和请求结果回来的时候切换线程</span></span><br><span class="line">		<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MainThreadExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">			<span class="keyword">private</span> <span class="keyword">final</span> Handler handler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line">			<span class="meta">@Override</span> </span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">				handler.post(r);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ServiceMethod对象的生成"><a href="#ServiceMethod对象的生成" class="headerlink" title="ServiceMethod对象的生成"></a>ServiceMethod对象的生成</h3><p>先看一张我debug时候的ServiceMethod的图<br><img src="https://img-blog.csdn.net/20160902161408563" alt="ServiceMethod"></p>
<h4 id="ServiceMethod的获取"><a href="#ServiceMethod的获取" class="headerlink" title="ServiceMethod的获取"></a>ServiceMethod的获取</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**Retrofit.java</span></span><br><span class="line"><span class="comment">* 首先从serviceMethodCache缓存中获取，如果为null则创建</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">ServiceMethod <span class="title">loadServiceMethod</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">    ServiceMethod result;</span><br><span class="line">    <span class="keyword">synchronized</span> (serviceMethodCache) &#123;</span><br><span class="line">      result = serviceMethodCache.get(method);</span><br><span class="line">      <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">        result = <span class="keyword">new</span> ServiceMethod.Builder(<span class="keyword">this</span>, method).build();</span><br><span class="line">        serviceMethodCache.put(method, result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="ServiceMethod的创建"><a href="#ServiceMethod的创建" class="headerlink" title="ServiceMethod的创建"></a>ServiceMethod的创建</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceMethod</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="comment">//部分代码省略</span></span><br><span class="line">	ServiceMethod(Builder&lt;T&gt; builder) &#123;</span><br><span class="line">	    <span class="keyword">this</span>.callFactory = builder.retrofit.callFactory();</span><br><span class="line">	    <span class="keyword">this</span>.callAdapter = builder.callAdapter;</span><br><span class="line">	    <span class="keyword">this</span>.baseUrl = builder.retrofit.baseUrl();</span><br><span class="line">	    <span class="keyword">this</span>.responseConverter = builder.responseConverter;</span><br><span class="line">	    <span class="keyword">this</span>.httpMethod = builder.httpMethod;</span><br><span class="line">	    <span class="keyword">this</span>.relativeUrl = builder.relativeUrl;</span><br><span class="line">	    <span class="keyword">this</span>.headers = builder.headers;</span><br><span class="line">	    <span class="keyword">this</span>.contentType = builder.contentType;</span><br><span class="line">	    <span class="keyword">this</span>.hasBody = builder.hasBody;</span><br><span class="line">	    <span class="keyword">this</span>.isFormEncoded = builder.isFormEncoded;</span><br><span class="line">	    <span class="keyword">this</span>.isMultipart = builder.isMultipart;</span><br><span class="line">	    <span class="keyword">this</span>.parameterHandlers = builder.parameterHandlers;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(Retrofit retrofit, Method method)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.retrofit = retrofit;</span><br><span class="line">		<span class="keyword">this</span>.method = method;</span><br><span class="line">		<span class="keyword">this</span>.methodAnnotations = method.getAnnotations();</span><br><span class="line">		<span class="keyword">this</span>.parameterTypes = method.getGenericParameterTypes();</span><br><span class="line">		<span class="keyword">this</span>.parameterAnnotationsArray = method.getParameterAnnotations();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> ServiceMethod <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">//创建CallAdapter&lt;?&gt;</span></span><br><span class="line">			callAdapter = createCallAdapter();</span><br><span class="line">			responseType = callAdapter.responseType();</span><br><span class="line">			<span class="keyword">if</span> (responseType == Response.class || responseType == okhttp3.Response.class) &#123;</span><br><span class="line">			 <span class="keyword">throw</span> methodError(<span class="string">"'"</span></span><br><span class="line">				 + Utils.getRawType(responseType).getName()</span><br><span class="line">				 + <span class="string">"' is not a valid response body type. Did you mean ResponseBody?"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//创建Converter&lt;ResponseBody, T&gt;</span></span><br><span class="line">			responseConverter = createResponseConverter();</span><br><span class="line">			<span class="keyword">for</span> (Annotation annotation : methodAnnotations) &#123;</span><br><span class="line">			 parseMethodAnnotation(annotation);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/********/</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> ServiceMethod&lt;&gt;(<span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">private</span> CallAdapter&lt;?&gt; createCallAdapter() &#123;</span><br><span class="line">			Type returnType = method.getGenericReturnType();</span><br><span class="line">			<span class="comment">/*******/</span></span><br><span class="line">			Annotation[] annotations = method.getAnnotations();</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">//调用retrofit中的方法进行创建</span></span><br><span class="line">				<span class="keyword">return</span> retrofit.callAdapter(returnType, annotations);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (RuntimeException e) &#123; <span class="comment">// Wide exception range because factories are user code.</span></span><br><span class="line">				<span class="keyword">throw</span> methodError(e, <span class="string">"Unable to create call adapter for %s"</span>, returnType);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">private</span> Converter&lt;ResponseBody, T&gt; <span class="title">createResponseConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			Annotation[] annotations = method.getAnnotations();</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">//调用retrofit中的方法进行创建</span></span><br><span class="line">				<span class="keyword">return</span> retrofit.responseBodyConverter(responseType, annotations);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (RuntimeException e) &#123; <span class="comment">// Wide exception range because factories are user code.</span></span><br><span class="line">				<span class="keyword">throw</span> methodError(e, <span class="string">"Unable to create converter for %s"</span>, responseType);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="CallAdapter的创建"><a href="#CallAdapter的创建" class="headerlink" title="CallAdapter的创建"></a>CallAdapter的创建</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> CallAdapter&lt;?&gt; callAdapter(Type returnType, Annotation[] annotations) &#123;</span><br><span class="line">	<span class="keyword">return</span> nextCallAdapter(<span class="keyword">null</span>, returnType, annotations);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> CallAdapter&lt;?&gt; nextCallAdapter(CallAdapter.Factory skipPast, Type returnType,</span><br><span class="line">  Annotation[] annotations) &#123;</span><br><span class="line">	checkNotNull(returnType, <span class="string">"returnType == null"</span>);</span><br><span class="line">	checkNotNull(annotations, <span class="string">"annotations == null"</span>);</span><br><span class="line">	<span class="keyword">int</span> start = adapterFactories.indexOf(skipPast) + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = start, count = adapterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">		CallAdapter&lt;?&gt; adapter = adapterFactories.get(i).get(returnType, annotations, <span class="keyword">this</span>);</span><br><span class="line">		<span class="keyword">if</span> (adapter != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> adapter;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/********************/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在创建Retrofit的时候我们添加过addCallAdapterFactory(RxJavaCallAdapterFactory.create()),这是我们会调用RxJavaCallAdapterFactory.get方法获取CallAdapter，通过源代码我们可以找到其返回的是new SimpleCallAdapter(observableType, scheduler)。</p>
<h5 id="Converter的创建"><a href="#Converter的创建" class="headerlink" title="Converter的创建"></a>Converter的创建</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Converter&lt;T, RequestBody&gt; <span class="title">requestBodyConverter</span><span class="params">(Type type,</span></span></span><br><span class="line"><span class="function"><span class="params">   Annotation[] parameterAnnotations, Annotation[] methodAnnotations)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> nextRequestBodyConverter(<span class="keyword">null</span>, type, parameterAnnotations, methodAnnotations);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Converter&lt;T, RequestBody&gt; <span class="title">nextRequestBodyConverter</span><span class="params">(Converter.Factory skipPast,</span></span></span><br><span class="line"><span class="function"><span class="params">	Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations)</span> </span>&#123;</span><br><span class="line">	checkNotNull(type, <span class="string">"type == null"</span>);</span><br><span class="line">    checkNotNull(parameterAnnotations, <span class="string">"parameterAnnotations == null"</span>);</span><br><span class="line">    checkNotNull(methodAnnotations, <span class="string">"methodAnnotations == null"</span>);</span><br><span class="line">    <span class="keyword">int</span> start = converterFactories.indexOf(skipPast) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start, count = converterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">		Converter.Factory factory = converterFactories.get(i);</span><br><span class="line">		Converter&lt;?, RequestBody&gt; converter =</span><br><span class="line">			factory.requestBodyConverter(type, parameterAnnotations, methodAnnotations, <span class="keyword">this</span>);</span><br><span class="line">		<span class="keyword">if</span> (converter != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">//noinspection unchecked</span></span><br><span class="line">			<span class="keyword">return</span> (Converter&lt;T, RequestBody&gt;) converter;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/******/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相同的在创建Retrofit的时候我们也添加过许多的ConverterFactory，在寻找相匹配的Converter时我们是通过遍历在寻找到第一个合适的Converter返回。什么叫做合适的Converter，即该ConverterFactory能产生出匹配服务接口注解和返回类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Platform platform;</span><br><span class="line">    <span class="keyword">private</span> okhttp3.Call.Factory callFactory;</span><br><span class="line">    <span class="keyword">private</span> HttpUrl baseUrl;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Converter.Factory&gt; converterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;CallAdapter.Factory&gt; adapterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Executor callbackExecutor;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> validateEagerly;</span><br><span class="line"></span><br><span class="line">    Builder(Platform platform) &#123;</span><br><span class="line">      <span class="keyword">this</span>.platform = platform;</span><br><span class="line">      <span class="comment">// Add the built-in converter factory first. This prevents overriding its behavior but also</span></span><br><span class="line">      <span class="comment">// ensures correct behavior when using converters that consume all types.</span></span><br><span class="line">      <span class="comment">//自动回添加加默认的转化器</span></span><br><span class="line">      converterFactories.add(<span class="keyword">new</span> BuiltInConverters());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/****************/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Retrofit <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (baseUrl == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Base URL required."</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      okhttp3.Call.Factory callFactory = <span class="keyword">this</span>.callFactory;</span><br><span class="line">      <span class="keyword">if</span> (callFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        callFactory = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Executor callbackExecutor = <span class="keyword">this</span>.callbackExecutor;</span><br><span class="line">      <span class="keyword">if</span> (callbackExecutor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        callbackExecutor = platform.defaultCallbackExecutor();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Make a defensive copy of the adapters and add the default Call adapter.</span></span><br><span class="line">      List&lt;CallAdapter.Factory&gt; adapterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.adapterFactories);</span><br><span class="line">      <span class="comment">//添加一个默认的适配器（Android、IOS、Java8）</span></span><br><span class="line">      adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Make a defensive copy of the converters.</span></span><br><span class="line">      List&lt;Converter.Factory&gt; converterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.converterFactories);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Retrofit(callFactory, baseUrl, converterFactories, adapterFactories,</span><br><span class="line">          callbackExecutor, validateEagerly);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="OkHttpCall的创建"><a href="#OkHttpCall的创建" class="headerlink" title="OkHttpCall的创建"></a>OkHttpCall的创建</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OkHttpCall(ServiceMethod&lt;T&gt; serviceMethod, Object[] args) &#123;</span><br><span class="line">   <span class="keyword">this</span>.serviceMethod = serviceMethod;</span><br><span class="line">   <span class="keyword">this</span>.args = args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h3><h4 id="请求的准备"><a href="#请求的准备" class="headerlink" title="请求的准备"></a>请求的准备</h4><p><code>serviceMethod.callAdapter.adapt(okHttpCall)</code> 对应SimpleCallAdapter.adapt</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleCallAdapter</span> <span class="keyword">implements</span> <span class="title">CallAdapter</span>&lt;<span class="title">Observable</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Type responseType;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Scheduler scheduler;</span><br><span class="line">    SimpleCallAdapter(Type responseType, Scheduler scheduler) &#123;</span><br><span class="line">		<span class="keyword">this</span>.responseType = responseType;</span><br><span class="line">		<span class="keyword">this</span>.scheduler = scheduler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Type <span class="title">responseType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> responseType;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> &lt;R&gt; <span class="function">Observable&lt;R&gt; <span class="title">adapt</span><span class="params">(Call&lt;R&gt; call)</span> </span>&#123;</span><br><span class="line">	    <span class="comment">//创建请求的观察者，返回我们需要的Ovservable</span></span><br><span class="line">		Observable&lt;R&gt; observable = Observable.create(<span class="keyword">new</span> CallOnSubscribe&lt;&gt;(call)) <span class="comment">//</span></span><br><span class="line">          .lift(OperatorMapResponseToBodyOrError.&lt;R&gt;instance());</span><br><span class="line">		<span class="keyword">if</span> (scheduler != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> observable.subscribeOn(scheduler);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> observable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Android</span> <span class="keyword">extends</span> <span class="title">Platform</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">defaultCallbackExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MainThreadExecutor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    CallAdapter.<span class="function">Factory <span class="title">defaultCallAdapterFactory</span><span class="params">(Executor callbackExecutor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ExecutorCallAdapterFactory(callbackExecutor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MainThreadExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Handler handler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">            handler.post(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 因为默认的执行线程为主线程，所以我们要切换到subscribeOn(Schedulers.io())线程从而达到异步的目的。</span></span><br><span class="line"><span class="comment">* 然后通过observeOn(AndroidSchedulers.mainThread())将线程切回UI线程。</span></span><br><span class="line"><span class="comment">* 当Okhttp请求完数据并进行相应的convert之后，就可以在UI处理相应的逻辑。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">service.listRepos(<span class="string">"octocat"</span>)</span><br><span class="line">.observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">.subscribeOn(Schedulers.io())</span><br><span class="line">.subscribe(list-&gt;&#123; </span><br><span class="line">	<span class="keyword">if</span>(list!=<span class="keyword">null</span>)&#123;      </span><br><span class="line">	<span class="comment">//TODO 取得数据后逻辑处理     </span></span><br><span class="line">	&#125;     </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="请求的发起"><a href="#请求的发起" class="headerlink" title="请求的发起"></a>请求的发起</h4><p>回到CallAdapt方法，创建Observable，而new CallOnSubscribe&lt;&gt;(call)生成了一个OnSubscribe（）的实例，而OnSubscribe继承自Action1，其只包含一个call()方法，而这个call是在CallOnSubscribe中实现： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CallOnSubscribe</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Observable</span>.<span class="title">OnSubscribe</span>&lt;<span class="title">Response</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Call&lt;T&gt; originalCall;</span><br><span class="line">    CallOnSubscribe(Call&lt;T&gt; originalCall) &#123;</span><br><span class="line">	<span class="keyword">this</span>.originalCall = originalCall;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(<span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> Response&lt;T&gt;&gt; subscriber)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// Since Call is a one-shot type, clone it for each new subscriber.</span></span><br><span class="line">		Call&lt;T&gt; call = originalCall.clone();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Wrap the call in a helper which handles both unsubscription and backpressure.</span></span><br><span class="line">		RequestArbiter&lt;T&gt; requestArbiter = <span class="keyword">new</span> RequestArbiter&lt;&gt;(call, subscriber);</span><br><span class="line">		subscriber.add(Subscriptions.create(requestArbiter));</span><br><span class="line">		subscriber.setProducer(requestArbiter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先clone了一份Call，然后生成了RequestArbiter，他继承自AtomicBoolean，实现了Subscription, Producer接口，Producer只有一个request方法；一般实现该接口的类，都会包含一个Subscriber对象和一个待处理的数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestArbiter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AtomicBoolean</span> <span class="keyword">implements</span> <span class="title">Action0</span>,</span></span><br><span class="line"><span class="class">    <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Call&lt;T&gt; call;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Subscriber&lt;?<span class="keyword">super</span> Response&lt;T&gt;&gt; subscriber;</span><br><span class="line">    RequestArbiter(Call&lt;T&gt; call, Subscriber&lt;?<span class="keyword">super</span> Response&lt;T&gt;&gt; subscriber) &#123;</span><br><span class="line">        <span class="keyword">this</span>.call = call;</span><br><span class="line">        <span class="keyword">this</span>.subscriber = subscriber;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"n &lt; 0: "</span> + n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// Nothing to do when requesting 0.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// Request was already triggered.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">	        <span class="comment">//进行网络请求</span></span><br><span class="line">            Response&lt;T&gt; response = call.execute();</span><br><span class="line">            <span class="keyword">if</span> (!subscriber.isUnsubscribed()) &#123;</span><br><span class="line">                subscriber.onNext(response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            Exceptions.throwIfFatal(t);</span><br><span class="line">            <span class="keyword">if</span> (!subscriber.isUnsubscribed()) &#123;</span><br><span class="line">                subscriber.onError(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!subscriber.isUnsubscribed()) &#123;</span><br><span class="line">            subscriber.onCompleted();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        call.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="请求的执行"><a href="#请求的执行" class="headerlink" title="请求的执行"></a>请求的执行</h4><p>回顾创建Retrofit.create()代码中<code>serviceMethod.callAdapter.adapt(okHttpCall)</code>，所以上面的<code>call.execute()</code> 就是OkHttpCall.execute</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Response&lt;T&gt; <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">	okhttp3.Call call;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( executed )</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException( <span class="string">"Already executed."</span> );</span><br><span class="line">		executed = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">if</span> ( creationFailure != <span class="keyword">null</span> )&#123;</span><br><span class="line">			<span class="keyword">if</span> ( creationFailure <span class="keyword">instanceof</span> IOException )&#123;</span><br><span class="line">				<span class="keyword">throw</span> (IOException) creationFailure;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">throw</span> (RuntimeException) creationFailure;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		call = rawCall;</span><br><span class="line">		<span class="keyword">if</span> ( call == <span class="keyword">null</span> )&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">//获取okhttp实例</span></span><br><span class="line">				call = rawCall = createRawCall();</span><br><span class="line">			&#125; <span class="keyword">catch</span> ( IOException | RuntimeException e ) &#123;</span><br><span class="line">				creationFailure = e;</span><br><span class="line">				<span class="keyword">throw</span> e;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ( canceled )&#123;</span><br><span class="line">		call.cancel();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//执行okhttp请求</span></span><br><span class="line">	<span class="keyword">return</span>(parseResponse( call.execute() ) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> okhttp3.<span class="function">Call <span class="title">createRawCall</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">	Request	request = serviceMethod.toRequest( args );</span><br><span class="line">	<span class="comment">//serviceMethod构造中this.callFactory = builder.retrofit.callFactory();</span></span><br><span class="line">	okhttp3.Call call = serviceMethod.callFactory.newCall( request );</span><br><span class="line">	<span class="keyword">if</span> ( call == <span class="keyword">null</span> )&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException( <span class="string">"Call.Factory returned null."</span> );</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>(call);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="请求的OkHttpClient实例获取"><a href="#请求的OkHttpClient实例获取" class="headerlink" title="请求的OkHttpClient实例获取"></a>请求的OkHttpClient实例获取</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> okhttp3.Call.<span class="function">Factory <span class="title">callFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> callFactory;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">callFactory</span><span class="params">(okhttp3.Call.Factory factory)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.callFactory = checkNotNull(factory, <span class="string">"factory == null"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用自定义OkHttpClient</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">client</span><span class="params">(OkHttpClient client)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> callFactory(checkNotNull(client, <span class="string">"client == null"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Retrofit <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ( baseUrl == <span class="keyword">null</span> )&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException( <span class="string">"Base URL required."</span> );</span><br><span class="line">	&#125;</span><br><span class="line">	okhttp3.Call.Factory callFactory = <span class="keyword">this</span>.callFactory;</span><br><span class="line">	<span class="comment">//没有自定义OkHttpClient，则会新创建一个</span></span><br><span class="line">	<span class="keyword">if</span> ( callFactory == <span class="keyword">null</span> )&#123;</span><br><span class="line">		callFactory = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">	&#125;</span><br><span class="line">	Executor callbackExecutor = <span class="keyword">this</span>.callbackExecutor;</span><br><span class="line">	<span class="keyword">if</span> ( callbackExecutor == <span class="keyword">null</span> )&#123;</span><br><span class="line">		callbackExecutor = platform.defaultCallbackExecutor();</span><br><span class="line">	&#125;</span><br><span class="line">	List&lt;CallAdapter.Factory&gt; adapterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;( <span class="keyword">this</span>.adapterFactories );</span><br><span class="line">	adapterFactories.add( platform.defaultCallAdapterFactory( callbackExecutor ) );</span><br><span class="line">	List&lt;Converter.Factory&gt; converterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;( <span class="keyword">this</span>.converterFactories );</span><br><span class="line">	<span class="keyword">return</span>(<span class="keyword">new</span> Retrofit( callFactory, baseUrl, converterFactories, adapterFactories,</span><br><span class="line">			     callbackExecutor, validateEagerly ) );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="请求结果的处理"><a href="#请求结果的处理" class="headerlink" title="请求结果的处理"></a>请求结果的处理</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Response&lt;T&gt; <span class="title">parseResponse</span><span class="params">( okhttp3.Response rawResponse )</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">	ResponseBody rawBody = rawResponse.body();</span><br><span class="line">	rawResponse = rawResponse.newBuilder()</span><br><span class="line">		      .body( <span class="keyword">new</span> NoContentResponseBody( rawBody.contentType(), rawBody.contentLength() ) )</span><br><span class="line">		      .build();</span><br><span class="line">	<span class="keyword">int</span> code = rawResponse.code();</span><br><span class="line">	<span class="keyword">if</span> ( code &lt; <span class="number">200</span> || code &gt;= <span class="number">300</span> )&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			ResponseBody bufferedBody = Utils.buffer( rawBody );</span><br><span class="line">			<span class="keyword">return</span>(Response.error( bufferedBody, rawResponse ) );</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			rawBody.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ( code == <span class="number">204</span> || code == <span class="number">205</span> )&#123;</span><br><span class="line">		<span class="keyword">return</span>(Response.success( <span class="keyword">null</span>, rawResponse ) );</span><br><span class="line">	&#125;</span><br><span class="line">	ExceptionCatchingRequestBody catchingBody = <span class="keyword">new</span> ExceptionCatchingRequestBody( rawBody );</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//使用Converter将返回结果转化为接口返回的数据格式类型</span></span><br><span class="line">		T body = serviceMethod.toResponse( catchingBody );</span><br><span class="line">		<span class="comment">//包装成Response并返回</span></span><br><span class="line">		<span class="keyword">return</span>(Response.success( body, rawResponse ) );</span><br><span class="line">	&#125; <span class="keyword">catch</span> ( RuntimeException e ) &#123;</span><br><span class="line">		catchingBody.throwIfCaught();</span><br><span class="line">		<span class="keyword">throw</span> e;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还记得创建Observable时 <code>Observable&lt;R&gt; observable = Observable.create(new CallOnSubscribe&lt;&gt;(call)).lift(OperatorMapResponseToBodyOrError.&lt;R&gt;instance());</code> ，OperatorMapResponseToBodyOrError将包装的Response中的body取出来并进行发射。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现在随着Rxjava响应式编程越来越多的程序猿使用，自己也开始接触和使用。Retrofit+Rxjava+okhttp是时下比较受欢迎的网络请求框架，其源代码并不是很多，其底层网络通信时交由 OkHttp来完成的，但是Retrofit运用了大量的设计模式，代码逻辑很清晰，笔者以前用的是AsyncHttpClient作为app的网络请求框架，其源码也没自己的研究过。但看完Retrofit代码之后觉得收获很大，建议如果感兴趣可以抽时间仔细的阅读。</p>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Retrofit2.0</tag>
        <tag>Android网络请求框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Retrofit2.0中注解使用套路</title>
    <url>/2016/07/11/retrofit-annotation/</url>
    <content><![CDATA[<p>之前有讲过Retrofit2.0的简单使用和解析。最近在做Retrofit替换之前使用的AsyncHttpClient，在替换的过程中遇到一些之前忽视的小细节。自己感觉知道这几点在开发中灵活使用Retrofit非常有好处。</p>
<p>#说说Retrofit中的注解</p>
<blockquote>
<p>@Query，@QueryMap，@Field，@FieldMap，@FormUrlEncoded，@Path，@Url<br>这七种注解应该是最常用的了。</p>
</blockquote>
<p>下边列举各种应用场景。</p>
<h1 id="一、get方式请求静态url地址"><a href="#一、get方式请求静态url地址" class="headerlink" title="一、get方式请求静态url地址"></a>一、get方式请求静态url地址</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Retrofit retrofit = new Retrofit.Builder()</span><br><span class="line">	.baseUrl(&quot;https://api.github.com/&quot;)</span><br><span class="line">    .build();</span><br><span class="line">public interface GitHubService &#123;</span><br><span class="line">	//无参数</span><br><span class="line">	@GET(&quot;users/stven0king/repos&quot;)</span><br><span class="line">	Call&lt;List&lt;Repo&gt;&gt; listRepos();</span><br><span class="line">	//少数参数</span><br><span class="line">	@GET(&quot;users/stven0king/repos&quot;)</span><br><span class="line">	Call&lt;List&lt;Repo&gt;&gt; listRepos(@Query(&quot;time&quot;) long time);</span><br><span class="line">	//参数较多</span><br><span class="line">	@GET(&quot;users/stven0king/repos&quot;)</span><br><span class="line">	Call&lt;List&lt;Repo&gt;&gt; listRepos(@QueryMap Map&lt;String, String&gt; params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@Query和@QueryMap也可以结合在一起使用。</p>
<blockquote>
<p>要是对应的url在服务端支持get/post两种类型的请求的话，那么上面的@GET变为@POST也可以执行，只不过post请求时所带的参数也会像get方式一样已？key=value&amp;key1=vaule2…的形式拼接在url的后边。</p>
</blockquote>
<h1 id="二、post方式请求静态url地址"><a href="#二、post方式请求静态url地址" class="headerlink" title="二、post方式请求静态url地址"></a>二、post方式请求静态url地址</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Retrofit retrofit = new Retrofit.Builder()</span><br><span class="line">    .baseUrl(&quot;https://api.github.com/&quot;)</span><br><span class="line">    .build()</span><br><span class="line">public interface GitHubService &#123;</span><br><span class="line">	//无参数</span><br><span class="line">	@POST(&quot;users/stven0king/repos&quot;)</span><br><span class="line">	Call&lt;List&lt;Repo&gt;&gt; listRepos();</span><br><span class="line">	//少数参数</span><br><span class="line">	@FormUrlEncoded</span><br><span class="line">	@POST(&quot;users/stven0king/repos&quot;)</span><br><span class="line">	Call&lt;List&lt;Repo&gt;&gt; listRepos(@Field(&quot;time&quot;) long time);</span><br><span class="line">	//参数较多</span><br><span class="line">	@FormUrlEncoded</span><br><span class="line">	@POST(&quot;users/stven0king/repos&quot;)</span><br><span class="line">	Call&lt;List&lt;Repo&gt;&gt; listRepos(@FieldMap Map&lt;String, String&gt; params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@Field和@FieldMap可以结合在一起使用。</p>
<blockquote>
<p>另外是不是发现了比起@GET多了一个@FromUrlEncoded的注解。如果去掉@FromUrlEncoded在post请求中使用@Field和@FieldMap，那么程序会抛出 [java.lang.IllegalArgumentException: @Field parameters can only be used with form encoding. (parameter #1)]的错误异常。如果将@FromUrlEncoded添加在@GET上面呢，同样的也会抛出 [java.lang.IllegalArgumentException:FormUrlEncoded can only be specified on HTTP methods with request body (e.g., @POST).] 的错误异常。</p>
</blockquote>
<h1 id="三、半静态的url地址请求"><a href="#三、半静态的url地址请求" class="headerlink" title="三、半静态的url地址请求"></a>三、半静态的url地址请求</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">    .baseUrl(<span class="string">"https://api.github.com/"</span>)</span><br><span class="line">    .build()</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GitHubService</span> </span>&#123;</span><br><span class="line">  <span class="meta">@GET</span>(<span class="string">"users/&#123;user&#125;/repos"</span>)</span><br><span class="line">  Call&lt;List&lt;Repo&gt;&gt; listRepos(<span class="meta">@Path</span>(<span class="string">"user"</span>) String user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="四、动态的url地址请求"><a href="#四、动态的url地址请求" class="headerlink" title="四、动态的url地址请求"></a>四、动态的url地址请求</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">    .baseUrl(<span class="string">"https://api.github.com/"</span>)</span><br><span class="line">    .build()</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GitHubService</span> </span>&#123;</span><br><span class="line">  <span class="meta">@GET</span></span><br><span class="line">  Call&lt;List&lt;Repo&gt;&gt; listRepos(<span class="meta">@Url</span> String user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="五、总结小细节"><a href="#五、总结小细节" class="headerlink" title="五、总结小细节"></a>五、总结小细节</h1><ul>
<li>当@GET或@POST注解的url为全路径时（可能和baseUrl不是一个域），会直接使用注解的url的域。</li>
<li>如果请求为post实现，那么最好传递参数时使用@Field、@FieldMap和@FormUrlEncoded。因为@Query和或QueryMap都是将参数拼接在url后面的，而@Field或@FieldMap传递的参数时放在请求体的。</li>
<li>使用@Path时，path对应的路径不能包含”/“，否则会将其转化为%2F。在遇到想动态的拼接多节url时，还是使用@Url吧。</li>
</ul>
<p>文章到这里就全部讲述完啦，若有其他需要交流的可以留言哦~！~！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Retrofit2.0</tag>
        <tag>Android网络请求框架</tag>
      </tags>
  </entry>
  <entry>
    <title>你要快乐</title>
    <url>/2016/06/07/%E4%BD%A0%E8%A6%81%E5%BF%AB%E4%B9%90/</url>
    <content><![CDATA[<p>又被爱伤了一遍</p>
<p>无所谓当作成长</p>
<p>刚刚走开的人</p>
<p>烟还点着味道却淡了</p>
<p>我并不是天生爱寂寞</p>
<p>却比任何人都多</p>
<p>就算把世界给我</p>
<p>我还是一无所有</p>
<p>我要快乐我要能睡的安稳</p>
<p>有些人不抱了才温暖</p>
<p>离开了才不恨我早应该割舍</p>
<p>我要快乐哪怕笑的再大声</p>
<p>心不是热的全都是假的</p>
<p>只有眼泪是真的</p>
<p>把从前想了一遍</p>
<p>谢谢了伤我的人</p>
<p>想做乐观的人</p>
<p>每种雨声听了都不冷</p>
<p>我并不是天生爱寂寞</p>
<p>却比任何人都多</p>
<p>就算把世界给我</p>
<p>我还是一无所有</p>
<p>我要快乐我要能睡的安稳</p>
<p>有些人不抱了才温暖</p>
<p>离开了才不恨我早应该割舍</p>
<p>我要快乐哪怕笑的再大声</p>
<p>心不是热的全都是假的</p>
<p>我的决定是对的</p>
]]></content>
      <tags>
        <tag>歌词</tag>
      </tags>
  </entry>
</search>
